var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// ../../node_modules/@cosmjs/encoding/build/ascii.js
var require_ascii = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/ascii.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromAscii = exports2.toAscii = void 0;
    function toAscii(input) {
      const toNums = (str) => str.split("").map((x) => {
        const charCode = x.charCodeAt(0);
        if (charCode < 32 || charCode > 126) {
          throw new Error("Cannot encode character that is out of printable ASCII range: " + charCode);
        }
        return charCode;
      });
      return Uint8Array.from(toNums(input));
    }
    exports2.toAscii = toAscii;
    function fromAscii(data) {
      const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {
        if (x < 32 || x > 126) {
          throw new Error("Cannot decode character that is out of printable ASCII range: " + x);
        }
        return String.fromCharCode(x);
      });
      return fromNums(Array.from(data)).join("");
    }
    exports2.fromAscii = fromAscii;
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/@cosmjs/encoding/build/base64.js
var require_base64 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/base64.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBase64 = exports2.toBase64 = void 0;
    var base64js = __importStar(require_base64_js());
    function toBase64(data) {
      return base64js.fromByteArray(data);
    }
    exports2.toBase64 = toBase64;
    function fromBase64(base64String) {
      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error("Invalid base64 string format");
      }
      return base64js.toByteArray(base64String);
    }
    exports2.fromBase64 = fromBase64;
  }
});

// ../../node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "../../node_modules/bech32/index.js"(exports2, module2) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0)
        throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i = 0; i < words.length; ++i) {
        var x2 = words[i];
        if (x2 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length)
          continue;
        words.push(v);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode,
      encode,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// ../../node_modules/@cosmjs/encoding/build/bech32.js
var require_bech322 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/bech32.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Bech32 = exports2.normalizeBech32 = exports2.fromBech32 = exports2.toBech32 = void 0;
    var bech32 = __importStar(require_bech32());
    function toBech32(prefix, data, limit) {
      const address = bech32.encode(prefix, bech32.toWords(data), limit);
      return address;
    }
    exports2.toBech32 = toBech32;
    function fromBech32(address, limit = Infinity) {
      const decodedAddress = bech32.decode(address, limit);
      return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(bech32.fromWords(decodedAddress.words))
      };
    }
    exports2.fromBech32 = fromBech32;
    function normalizeBech32(address) {
      const { prefix, data } = fromBech32(address);
      return toBech32(prefix, data);
    }
    exports2.normalizeBech32 = normalizeBech32;
    var Bech32 = class {
      /**
       * @deprecated This class is deprecated and will be removed soon. Please use fromBech32() and toBech32() instead. For more details please refer to https://github.com/cosmos/cosmjs/issues/1053.
       */
      static encode(prefix, data, limit) {
        return toBech32(prefix, data, limit);
      }
      /**
       * @deprecated This class is deprecated and will be removed soon. Please use fromBech32() and toBech32() instead. For more details please refer to https://github.com/cosmos/cosmjs/issues/1053.
       */
      static decode(address, limit = Infinity) {
        return fromBech32(address, limit);
      }
    };
    exports2.Bech32 = Bech32;
  }
});

// ../../node_modules/@cosmjs/encoding/build/hex.js
var require_hex = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/hex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromHex = exports2.toHex = void 0;
    function toHex(data) {
      let out = "";
      for (const byte of data) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    exports2.toHex = toHex;
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const out = new Uint8Array(hexstring.length / 2);
      for (let i = 0; i < out.length; i++) {
        const j = 2 * i;
        const hexByteAsString = hexstring.slice(j, j + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        out[i] = parseInt(hexByteAsString, 16);
      }
      return out;
    }
    exports2.fromHex = fromHex;
  }
});

// ../../node_modules/@cosmjs/encoding/build/rfc3339.js
var require_rfc3339 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/rfc3339.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toRfc3339 = exports2.fromRfc3339 = void 0;
    var rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
    function padded(integer, length = 2) {
      return integer.toString().padStart(length, "0");
    }
    function fromRfc3339(str) {
      const matches = rfc3339Matcher.exec(str);
      if (!matches) {
        throw new Error("Date string is not in RFC3339 format");
      }
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      const hour = +matches[4];
      const minute = +matches[5];
      const second = +matches[6];
      const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1e3) : 0;
      let tzOffsetSign;
      let tzOffsetHours;
      let tzOffsetMinutes;
      if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
      } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
      }
      const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60;
      const timestamp = Date.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1e3;
      return new Date(timestamp);
    }
    exports2.fromRfc3339 = fromRfc3339;
    function toRfc3339(date) {
      const year = date.getUTCFullYear();
      const month = padded(date.getUTCMonth() + 1);
      const day = padded(date.getUTCDate());
      const hour = padded(date.getUTCHours());
      const minute = padded(date.getUTCMinutes());
      const second = padded(date.getUTCSeconds());
      const ms = padded(date.getUTCMilliseconds(), 3);
      return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
    }
    exports2.toRfc3339 = toRfc3339;
  }
});

// ../../node_modules/@cosmjs/encoding/build/utf8.js
var require_utf8 = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromUtf8 = exports2.toUtf8 = void 0;
    function toUtf8(str) {
      return new TextEncoder().encode(str);
    }
    exports2.toUtf8 = toUtf8;
    function fromUtf8(data, lossy = false) {
      const fatal = !lossy;
      return new TextDecoder("utf-8", { fatal }).decode(data);
    }
    exports2.fromUtf8 = fromUtf8;
  }
});

// ../../node_modules/@cosmjs/encoding/build/index.js
var require_build = __commonJS({
  "../../node_modules/@cosmjs/encoding/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toUtf8 = exports2.fromUtf8 = exports2.toRfc3339 = exports2.fromRfc3339 = exports2.toHex = exports2.fromHex = exports2.toBech32 = exports2.normalizeBech32 = exports2.fromBech32 = exports2.Bech32 = exports2.toBase64 = exports2.fromBase64 = exports2.toAscii = exports2.fromAscii = void 0;
    var ascii_1 = require_ascii();
    Object.defineProperty(exports2, "fromAscii", { enumerable: true, get: function() {
      return ascii_1.fromAscii;
    } });
    Object.defineProperty(exports2, "toAscii", { enumerable: true, get: function() {
      return ascii_1.toAscii;
    } });
    var base64_1 = require_base64();
    Object.defineProperty(exports2, "fromBase64", { enumerable: true, get: function() {
      return base64_1.fromBase64;
    } });
    Object.defineProperty(exports2, "toBase64", { enumerable: true, get: function() {
      return base64_1.toBase64;
    } });
    var bech32_1 = require_bech322();
    Object.defineProperty(exports2, "Bech32", { enumerable: true, get: function() {
      return bech32_1.Bech32;
    } });
    Object.defineProperty(exports2, "fromBech32", { enumerable: true, get: function() {
      return bech32_1.fromBech32;
    } });
    Object.defineProperty(exports2, "normalizeBech32", { enumerable: true, get: function() {
      return bech32_1.normalizeBech32;
    } });
    Object.defineProperty(exports2, "toBech32", { enumerable: true, get: function() {
      return bech32_1.toBech32;
    } });
    var hex_1 = require_hex();
    Object.defineProperty(exports2, "fromHex", { enumerable: true, get: function() {
      return hex_1.fromHex;
    } });
    Object.defineProperty(exports2, "toHex", { enumerable: true, get: function() {
      return hex_1.toHex;
    } });
    var rfc3339_1 = require_rfc3339();
    Object.defineProperty(exports2, "fromRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.fromRfc3339;
    } });
    Object.defineProperty(exports2, "toRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.toRfc3339;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports2, "fromUtf8", { enumerable: true, get: function() {
      return utf8_1.fromUtf8;
    } });
    Object.defineProperty(exports2, "toUtf8", { enumerable: true, get: function() {
      return utf8_1.toUtf8;
    } });
  }
});

// ../../node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// ../../node_modules/@cosmjs/math/build/decimal.js
var require_decimal = __commonJS({
  "../../node_modules/@cosmjs/math/build/decimal.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decimal = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var maxFractionalDigits = 100;
    var Decimal = class {
      constructor(atomics, fractionalDigits) {
        if (!atomics.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        }
        this.data = {
          atomics: new bn_js_1.default(atomics),
          fractionalDigits
        };
      }
      static fromUserInput(input, fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
          throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === "") {
          whole = "0";
          fractional = "";
        } else if (input.search(/\./) === -1) {
          whole = input;
          fractional = "";
        } else {
          const parts = input.split(".");
          switch (parts.length) {
            case 0:
            case 1:
              throw new Error("Fewer than two elements in split result. This must not happen here.");
            case 2:
              if (!parts[1])
                throw new Error("Fractional part missing");
              whole = parts[0];
              fractional = parts[1].replace(/0+$/, "");
              break;
            default:
              throw new Error("More than one separator found");
          }
        }
        if (fractional.length > fractionalDigits) {
          throw new Error("Got more fractional digits than supported");
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new Decimal(quantity, fractionalDigits);
      }
      static fromAtomics(atomics, fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal(atomics, fractionalDigits);
      }
      /**
       * Creates a Decimal with value 0.0 and the given number of fractial digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static zero(fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal("0", fractionalDigits);
      }
      /**
       * Creates a Decimal with value 1.0 and the given number of fractial digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static one(fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
      }
      static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
          throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0)
          throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) {
          throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
      }
      static compare(a, b) {
        if (a.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));
      }
      get atomics() {
        return this.data.atomics.toString();
      }
      get fractionalDigits() {
        return this.data.fractionalDigits;
      }
      /** Creates a new instance with the same value */
      clone() {
        return new Decimal(this.atomics, this.fractionalDigits);
      }
      /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
      floor() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return this.clone();
        } else {
          return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);
        }
      }
      /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
      ceil() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return this.clone();
        } else {
          return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);
        }
      }
      toString() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return whole.toString();
        } else {
          const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
          const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
          return `${whole.toString()}.${trimmedFractionalPart}`;
        }
      }
      /**
       * Returns an approximation as a float type. Only use this if no
       * exact calculation is required.
       */
      toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out))
          throw new Error("Conversion to number failed");
        return out;
      }
      /**
       * a.plus(b) returns a+b.
       *
       * Both values need to have the same fractional digits.
       */
      plus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));
        return new Decimal(sum.toString(), this.fractionalDigits);
      }
      /**
       * a.minus(b) returns a-b.
       *
       * Both values need to have the same fractional digits.
       * The resulting difference needs to be non-negative.
       */
      minus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));
        if (difference.ltn(0))
          throw new Error("Difference must not be negative");
        return new Decimal(difference.toString(), this.fractionalDigits);
      }
      /**
       * a.multiply(b) returns a*b.
       *
       * We only allow multiplication by unsigned integers to avoid rounding errors.
       */
      multiply(b) {
        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));
        return new Decimal(product.toString(), this.fractionalDigits);
      }
      equals(b) {
        return Decimal.compare(this, b) === 0;
      }
      isLessThan(b) {
        return Decimal.compare(this, b) < 0;
      }
      isLessThanOrEqual(b) {
        return Decimal.compare(this, b) <= 0;
      }
      isGreaterThan(b) {
        return Decimal.compare(this, b) > 0;
      }
      isGreaterThanOrEqual(b) {
        return Decimal.compare(this, b) >= 0;
      }
    };
    exports2.Decimal = Decimal;
  }
});

// ../../node_modules/@cosmjs/math/build/integers.js
var require_integers = __commonJS({
  "../../node_modules/@cosmjs/math/build/integers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uint64 = exports2.Uint53 = exports2.Int53 = exports2.Uint32 = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var uint64MaxValue = new bn_js_1.default("18446744073709551615", 10, "be");
    var Uint32 = class {
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < 0 || input > 4294967295) {
          throw new Error("Input not in uint32 range: " + input.toString());
        }
        this.data = input;
      }
      /** @deprecated use Uint32.fromBytes */
      static fromBigEndianBytes(bytes) {
        return Uint32.fromBytes(bytes);
      }
      /**
       * Creates a Uint32 from a fixed length byte array.
       *
       * @param bytes a list of exactly 4 bytes
       * @param endianess defaults to big endian
       */
      static fromBytes(bytes, endianess = "be") {
        if (bytes.length !== 4) {
          throw new Error("Invalid input length. Expected 4 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error("Invalid value in byte. Found: " + bytes[i]);
          }
        }
        const beBytes = endianess === "be" ? bytes : Array.from(bytes).reverse();
        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new Uint32(Number.parseInt(str, 10));
      }
      toBytesBigEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 24) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 0) & 255
        ]);
      }
      toBytesLittleEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 0) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 24) & 255
        ]);
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports2.Uint32 = Uint32;
    var Int53 = class {
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
          throw new Error("Input not in int53 range: " + input.toString());
        }
        this.data = input;
      }
      static fromString(str) {
        if (!str.match(/^-?[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new Int53(Number.parseInt(str, 10));
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports2.Int53 = Int53;
    var Uint53 = class {
      constructor(input) {
        const signed = new Int53(input);
        if (signed.toNumber() < 0) {
          throw new Error("Input is negative");
        }
        this.data = signed;
      }
      static fromString(str) {
        const signed = Int53.fromString(str);
        return new Uint53(signed.toNumber());
      }
      toNumber() {
        return this.data.toNumber();
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports2.Uint53 = Uint53;
    var Uint64 = class {
      constructor(data) {
        if (data.isNeg()) {
          throw new Error("Input is negative");
        }
        if (data.gt(uint64MaxValue)) {
          throw new Error("Input exceeds uint64 range");
        }
        this.data = data;
      }
      /** @deprecated use Uint64.fromBytes */
      static fromBytesBigEndian(bytes) {
        return Uint64.fromBytes(bytes);
      }
      /**
       * Creates a Uint64 from a fixed length byte array.
       *
       * @param bytes a list of exactly 8 bytes
       * @param endianess defaults to big endian
       */
      static fromBytes(bytes, endianess = "be") {
        if (bytes.length !== 8) {
          throw new Error("Invalid input length. Expected 8 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error("Invalid value in byte. Found: " + bytes[i]);
          }
        }
        const beBytes = endianess === "be" ? Array.from(bytes) : Array.from(bytes).reverse();
        return new Uint64(new bn_js_1.default(beBytes));
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new Uint64(new bn_js_1.default(str, 10, "be"));
      }
      static fromNumber(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        let bigint;
        try {
          bigint = new bn_js_1.default(input);
        } catch (_a) {
          throw new Error("Input is not a safe integer");
        }
        return new Uint64(bigint);
      }
      toBytesBigEndian() {
        return Uint8Array.from(this.data.toArray("be", 8));
      }
      toBytesLittleEndian() {
        return Uint8Array.from(this.data.toArray("le", 8));
      }
      toString() {
        return this.data.toString(10);
      }
      toBigInt() {
        return BigInt(this.toString());
      }
      toNumber() {
        return this.data.toNumber();
      }
    };
    exports2.Uint64 = Uint64;
  }
});

// ../../node_modules/@cosmjs/math/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/@cosmjs/math/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uint64 = exports2.Uint53 = exports2.Uint32 = exports2.Int53 = exports2.Decimal = void 0;
    var decimal_1 = require_decimal();
    Object.defineProperty(exports2, "Decimal", { enumerable: true, get: function() {
      return decimal_1.Decimal;
    } });
    var integers_1 = require_integers();
    Object.defineProperty(exports2, "Int53", { enumerable: true, get: function() {
      return integers_1.Int53;
    } });
    Object.defineProperty(exports2, "Uint32", { enumerable: true, get: function() {
      return integers_1.Uint32;
    } });
    Object.defineProperty(exports2, "Uint53", { enumerable: true, get: function() {
      return integers_1.Uint53;
    } });
    Object.defineProperty(exports2, "Uint64", { enumerable: true, get: function() {
      return integers_1.Uint64;
    } });
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/coins.js
var require_coins = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/coins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseCoins = void 0;
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    exports2.parseCoins = parseCoins;
  }
});

// ../../node_modules/long/src/long.js
var require_long = __commonJS({
  "../../node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    var ONE = fromInt(1);
    Long.ONE = ONE;
    var UONE = fromInt(1, true);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base642 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf82 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base642();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf82();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/cosmjs-types/google/protobuf/any.js
var require_any = __commonJS({
  "../../node_modules/cosmjs-types/google/protobuf/any.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Any = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "google.protobuf";
    function createBaseAny() {
      return { typeUrl: "", value: new Uint8Array() };
    }
    exports2.Any = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : "",
          value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseAny();
        message.typeUrl = (_a = object.typeUrl) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js
var require_coin = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecProto = exports2.IntProto = exports2.DecCoin = exports2.Coin = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "cosmos.base.v1beta1";
    function createBaseCoin() {
      return { denom: "", amount: "" };
    }
    exports2.Coin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet(object.denom) ? String(object.denom) : "",
          amount: isSet(object.amount) ? String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCoin();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDecCoin() {
      return { denom: "", amount: "" };
    }
    exports2.DecCoin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet(object.denom) ? String(object.denom) : "",
          amount: isSet(object.amount) ? String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDecCoin();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseIntProto() {
      return { int: "" };
    }
    exports2.IntProto = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.int !== "") {
          writer.uint32(10).string(message.int);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { int: isSet(object.int) ? String(object.int) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.int !== void 0 && (obj.int = message.int);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseIntProto();
        message.int = (_a = object.int) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseDecProto() {
      return { dec: "" };
    }
    exports2.DecProto = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.dec = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { dec: isSet(object.dec) ? String(object.dec) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.dec !== void 0 && (obj.dec = message.dec);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDecProto();
        message.dec = (_a = object.dec) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactBitArray = exports2.MultiSignature = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return { signatures: [] };
    }
    exports2.MultiSignature = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signatures) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => bytesFromBase64(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMultiSignature();
        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompactBitArray() {
      return { extraBitsStored: 0, elems: new Uint8Array() };
    }
    exports2.CompactBitArray = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          extraBitsStored: isSet(object.extraBitsStored) ? Number(object.extraBitsStored) : 0,
          elems: isSet(object.elems) ? bytesFromBase64(object.elems) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = base64FromBytes(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCompactBitArray();
        message.extraBitsStored = (_a = object.extraBitsStored) !== null && _a !== void 0 ? _a : 0;
        message.elems = (_b = object.elems) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignatureDescriptor_Data_Multi = exports2.SignatureDescriptor_Data_Single = exports2.SignatureDescriptor_Data = exports2.SignatureDescriptor = exports2.SignatureDescriptors = exports2.signModeToJSON = exports2.signModeFromJSON = exports2.SignMode = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var multisig_1 = require_multisig();
    exports2.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode;
    (function(SignMode2) {
      SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode2[SignMode2["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
      SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode = exports2.SignMode || (exports2.SignMode = {}));
    function signModeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode.SIGN_MODE_TEXTUAL;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
          return SignMode.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode.UNRECOGNIZED;
      }
    }
    exports2.signModeFromJSON = signModeFromJSON;
    function signModeToJSON(object) {
      switch (object) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode.SIGN_MODE_EIP_191:
          return "SIGN_MODE_EIP_191";
        case SignMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.signModeToJSON = signModeToJSON;
    function createBaseSignatureDescriptors() {
      return { signatures: [] };
    }
    exports2.SignatureDescriptors = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signatures) {
          exports2.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports2.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => exports2.SignatureDescriptor.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.SignatureDescriptor.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSignatureDescriptors();
        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.SignatureDescriptor.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return { publicKey: void 0, data: void 0, sequence: long_1.default.UZERO };
    }
    exports2.SignatureDescriptor = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports2.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports2.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          publicKey: isSet(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : void 0,
          data: isSet(object.data) ? exports2.SignatureDescriptor_Data.fromJSON(object.data) : void 0,
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports2.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor();
        message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : void 0;
        message.data = object.data !== void 0 && object.data !== null ? exports2.SignatureDescriptor_Data.fromPartial(object.data) : void 0;
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return { single: void 0, multi: void 0 };
    }
    exports2.SignatureDescriptor_Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.single !== void 0) {
          exports2.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports2.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports2.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports2.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          single: isSet(object.single) ? exports2.SignatureDescriptor_Data_Single.fromJSON(object.single) : void 0,
          multi: isSet(object.multi) ? exports2.SignatureDescriptor_Data_Multi.fromJSON(object.multi) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports2.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports2.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data();
        message.single = object.single !== void 0 && object.single !== null ? exports2.SignatureDescriptor_Data_Single.fromPartial(object.single) : void 0;
        message.multi = object.multi !== void 0 && object.multi !== null ? exports2.SignatureDescriptor_Data_Multi.fromPartial(object.multi) : void 0;
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return { mode: 0, signature: new Uint8Array() };
    }
    exports2.SignatureDescriptor_Data_Single = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,
          signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;
        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return { bitarray: void 0, signatures: [] };
    }
    exports2.SignatureDescriptor_Data_Multi = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports2.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports2.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bitarray: isSet(object.bitarray) ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : void 0,
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => exports2.SignatureDescriptor_Data.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.SignatureDescriptor_Data.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSignatureDescriptor_Data_Multi();
        message.bitarray = object.bitarray !== void 0 && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : void 0;
        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.SignatureDescriptor_Data.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js
var require_tx = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Fee = exports2.ModeInfo_Multi = exports2.ModeInfo_Single = exports2.ModeInfo = exports2.SignerInfo = exports2.AuthInfo = exports2.TxBody = exports2.SignDoc = exports2.TxRaw = exports2.Tx = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var coin_1 = require_coin();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    exports2.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx() {
      return { body: void 0, authInfo: void 0, signatures: [] };
    }
    exports2.Tx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.body !== void 0) {
          exports2.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports2.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports2.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports2.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          body: isSet(object.body) ? exports2.TxBody.fromJSON(object.body) : void 0,
          authInfo: isSet(object.authInfo) ? exports2.AuthInfo.fromJSON(object.authInfo) : void 0,
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => bytesFromBase64(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports2.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports2.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseTx();
        message.body = object.body !== void 0 && object.body !== null ? exports2.TxBody.fromPartial(object.body) : void 0;
        message.authInfo = object.authInfo !== void 0 && object.authInfo !== null ? exports2.AuthInfo.fromPartial(object.authInfo) : void 0;
        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseTxRaw() {
      return { bodyBytes: new Uint8Array(), authInfoBytes: new Uint8Array(), signatures: [] };
    }
    exports2.TxRaw = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bodyBytes: isSet(object.bodyBytes) ? bytesFromBase64(object.bodyBytes) : new Uint8Array(),
          authInfoBytes: isSet(object.authInfoBytes) ? bytesFromBase64(object.authInfoBytes) : new Uint8Array(),
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => bytesFromBase64(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTxRaw();
        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: long_1.default.UZERO
      };
    }
    exports2.SignDoc = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (!message.accountNumber.isZero()) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bodyBytes: isSet(object.bodyBytes) ? bytesFromBase64(object.bodyBytes) : new Uint8Array(),
          authInfoBytes: isSet(object.authInfoBytes) ? bytesFromBase64(object.authInfoBytes) : new Uint8Array(),
          chainId: isSet(object.chainId) ? String(object.chainId) : "",
          accountNumber: isSet(object.accountNumber) ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSignDoc();
        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.chainId = (_c = object.chainId) !== null && _c !== void 0 ? _c : "";
        message.accountNumber = object.accountNumber !== void 0 && object.accountNumber !== null ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseTxBody() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: long_1.default.UZERO,
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports2.TxBody = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (!message.timeoutHeight.isZero()) {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v of message.extensionOptions) {
          any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
        }
        for (const v of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = reader.uint64();
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e) => any_1.Any.fromJSON(e)) : [],
          memo: isSet(object.memo) ? String(object.memo) : "",
          timeoutHeight: isSet(object.timeoutHeight) ? long_1.default.fromValue(object.timeoutHeight) : long_1.default.UZERO,
          extensionOptions: Array.isArray(object === null || object === void 0 ? void 0 : object.extensionOptions) ? object.extensionOptions.map((e) => any_1.Any.fromJSON(e)) : [],
          nonCriticalExtensionOptions: Array.isArray(object === null || object === void 0 ? void 0 : object.nonCriticalExtensionOptions) ? object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = (message.timeoutHeight || long_1.default.UZERO).toString());
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTxBody();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        message.memo = (_b = object.memo) !== null && _b !== void 0 ? _b : "";
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? long_1.default.fromValue(object.timeoutHeight) : long_1.default.UZERO;
        message.extensionOptions = ((_c = object.extensionOptions) === null || _c === void 0 ? void 0 : _c.map((e) => any_1.Any.fromPartial(e))) || [];
        message.nonCriticalExtensionOptions = ((_d = object.nonCriticalExtensionOptions) === null || _d === void 0 ? void 0 : _d.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAuthInfo() {
      return { signerInfos: [], fee: void 0 };
    }
    exports2.AuthInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signerInfos) {
          exports2.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports2.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports2.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports2.Fee.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signerInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.signerInfos) ? object.signerInfos.map((e) => exports2.SignerInfo.fromJSON(e)) : [],
          fee: isSet(object.fee) ? exports2.Fee.fromJSON(object.fee) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e) => e ? exports2.SignerInfo.toJSON(e) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports2.Fee.toJSON(message.fee) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseAuthInfo();
        message.signerInfos = ((_a = object.signerInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.SignerInfo.fromPartial(e))) || [];
        message.fee = object.fee !== void 0 && object.fee !== null ? exports2.Fee.fromPartial(object.fee) : void 0;
        return message;
      }
    };
    function createBaseSignerInfo() {
      return { publicKey: void 0, modeInfo: void 0, sequence: long_1.default.UZERO };
    }
    exports2.SignerInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports2.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports2.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          publicKey: isSet(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : void 0,
          modeInfo: isSet(object.modeInfo) ? exports2.ModeInfo.fromJSON(object.modeInfo) : void 0,
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports2.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignerInfo();
        message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : void 0;
        message.modeInfo = object.modeInfo !== void 0 && object.modeInfo !== null ? exports2.ModeInfo.fromPartial(object.modeInfo) : void 0;
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseModeInfo() {
      return { single: void 0, multi: void 0 };
    }
    exports2.ModeInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.single !== void 0) {
          exports2.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports2.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports2.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports2.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          single: isSet(object.single) ? exports2.ModeInfo_Single.fromJSON(object.single) : void 0,
          multi: isSet(object.multi) ? exports2.ModeInfo_Multi.fromJSON(object.multi) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports2.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports2.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo();
        message.single = object.single !== void 0 && object.single !== null ? exports2.ModeInfo_Single.fromPartial(object.single) : void 0;
        message.multi = object.multi !== void 0 && object.multi !== null ? exports2.ModeInfo_Multi.fromPartial(object.multi) : void 0;
        return message;
      }
    };
    function createBaseModeInfo_Single() {
      return { mode: 0 };
    }
    exports2.ModeInfo_Single = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { mode: isSet(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseModeInfo_Single();
        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi() {
      return { bitarray: void 0, modeInfos: [] };
    }
    exports2.ModeInfo_Multi = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.modeInfos) {
          exports2.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports2.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bitarray: isSet(object.bitarray) ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : void 0,
          modeInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.modeInfos) ? object.modeInfos.map((e) => exports2.ModeInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e) => e ? exports2.ModeInfo.toJSON(e) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseModeInfo_Multi();
        message.bitarray = object.bitarray !== void 0 && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : void 0;
        message.modeInfos = ((_a = object.modeInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.ModeInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFee() {
      return { amount: [], gasLimit: long_1.default.UZERO, payer: "", granter: "" };
    }
    exports2.Fee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (!message.gasLimit.isZero()) {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = reader.uint64();
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
          gasLimit: isSet(object.gasLimit) ? long_1.default.fromValue(object.gasLimit) : long_1.default.UZERO,
          payer: isSet(object.payer) ? String(object.payer) : "",
          granter: isSet(object.granter) ? String(object.granter) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = (message.gasLimit || long_1.default.UZERO).toString());
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseFee();
        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.gasLimit = object.gasLimit !== void 0 && object.gasLimit !== null ? long_1.default.fromValue(object.gasLimit) : long_1.default.UZERO;
        message.payer = (_b = object.payer) !== null && _b !== void 0 ? _b : "";
        message.granter = (_c = object.granter) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTxRaw = void 0;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
    exports2.decodeTxRaw = decodeTxRaw;
  }
});

// ../../node_modules/@cosmjs/utils/build/arrays.js
var require_arrays = __commonJS({
  "../../node_modules/@cosmjs/utils/build/arrays.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayContentStartsWith = exports2.arrayContentEquals = void 0;
    function arrayContentEquals(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    exports2.arrayContentEquals = arrayContentEquals;
    function arrayContentStartsWith(a, b) {
      if (a.length < b.length)
        return false;
      for (let i = 0; i < b.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    exports2.arrayContentStartsWith = arrayContentStartsWith;
  }
});

// ../../node_modules/@cosmjs/utils/build/assert.js
var require_assert = __commonJS({
  "../../node_modules/@cosmjs/utils/build/assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertDefinedAndNotNull = exports2.assertDefined = exports2.assert = void 0;
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || "condition is not truthy");
      }
    }
    exports2.assert = assert;
    function assertDefined(value, msg) {
      if (value === void 0) {
        throw new Error(msg !== null && msg !== void 0 ? msg : "value is undefined");
      }
    }
    exports2.assertDefined = assertDefined;
    function assertDefinedAndNotNull(value, msg) {
      if (value === void 0 || value === null) {
        throw new Error(msg !== null && msg !== void 0 ? msg : "value is undefined or null");
      }
    }
    exports2.assertDefinedAndNotNull = assertDefinedAndNotNull;
  }
});

// ../../node_modules/@cosmjs/utils/build/sleep.js
var require_sleep = __commonJS({
  "../../node_modules/@cosmjs/utils/build/sleep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sleep = void 0;
    async function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports2.sleep = sleep;
  }
});

// ../../node_modules/@cosmjs/utils/build/typechecks.js
var require_typechecks = __commonJS({
  "../../node_modules/@cosmjs/utils/build/typechecks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDefined = exports2.isUint8Array = exports2.isNonNullObject = void 0;
    function isNonNullObject(data) {
      return typeof data === "object" && data !== null;
    }
    exports2.isNonNullObject = isNonNullObject;
    function isUint8Array(data) {
      if (!isNonNullObject(data))
        return false;
      if (Object.prototype.toString.call(data) !== "[object Uint8Array]")
        return false;
      if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        if (Buffer.isBuffer(data))
          return false;
      }
      return true;
    }
    exports2.isUint8Array = isUint8Array;
    function isDefined(value) {
      return value !== void 0;
    }
    exports2.isDefined = isDefined;
  }
});

// ../../node_modules/@cosmjs/utils/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/@cosmjs/utils/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUint8Array = exports2.isNonNullObject = exports2.isDefined = exports2.sleep = exports2.assertDefinedAndNotNull = exports2.assertDefined = exports2.assert = exports2.arrayContentStartsWith = exports2.arrayContentEquals = void 0;
    var arrays_1 = require_arrays();
    Object.defineProperty(exports2, "arrayContentEquals", { enumerable: true, get: function() {
      return arrays_1.arrayContentEquals;
    } });
    Object.defineProperty(exports2, "arrayContentStartsWith", { enumerable: true, get: function() {
      return arrays_1.arrayContentStartsWith;
    } });
    var assert_1 = require_assert();
    Object.defineProperty(exports2, "assert", { enumerable: true, get: function() {
      return assert_1.assert;
    } });
    Object.defineProperty(exports2, "assertDefined", { enumerable: true, get: function() {
      return assert_1.assertDefined;
    } });
    Object.defineProperty(exports2, "assertDefinedAndNotNull", { enumerable: true, get: function() {
      return assert_1.assertDefinedAndNotNull;
    } });
    var sleep_1 = require_sleep();
    Object.defineProperty(exports2, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var typechecks_1 = require_typechecks();
    Object.defineProperty(exports2, "isDefined", { enumerable: true, get: function() {
      return typechecks_1.isDefined;
    } });
    Object.defineProperty(exports2, "isNonNullObject", { enumerable: true, get: function() {
      return typechecks_1.isNonNullObject;
    } });
    Object.defineProperty(exports2, "isUint8Array", { enumerable: true, get: function() {
      return typechecks_1.isUint8Array;
    } });
  }
});

// ../../node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "../../node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports2.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports2.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports2.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports2.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports2.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports2.output = output;
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports2.default = assert;
  }
});

// ../../node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "../../node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nodeCrypto = require("crypto");
    exports2.crypto = {
      node: nodeCrypto,
      web: void 0
    };
  }
});

// ../../node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "../../node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomBytes = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports2.rotr = rotr;
    exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports2.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports2.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    exports2.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports2.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports2.toBytes = toBytes;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports2.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports2.checkOpts = checkOpts;
    function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports2.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    }
    exports2.randomBytes = randomBytes;
  }
});

// ../../node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// ../../node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../../node_modules/@noble/hashes/pbkdf2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pbkdf2Async = exports2.pbkdf2 = void 0;
    var _assert_js_1 = require_assert2();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      _assert_js_1.default.hash(hash);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      _assert_js_1.default.number(c);
      _assert_js_1.default.number(dkLen);
      _assert_js_1.default.number(asyncTick);
      if (c < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u.fill(0);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports2.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i2 = 0; i2 < Ti.length; i2++)
            Ti[i2] ^= u[i2];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports2.pbkdf2Async = pbkdf2Async;
  }
});

// ../../node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/@noble/hashes/_sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA2 = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.SHA2 = SHA2;
  }
});

// ../../node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "../../node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.add = exports2.toBig = exports2.split = exports2.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports2.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports2.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports2.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig,
      split,
      toBig: exports2.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// ../../node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "../../node_modules/@noble/hashes/sha512.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n)));
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// ../../node_modules/@cosmjs/crypto/build/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/pbkdf2.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pbkdf2Sha512 = exports2.pbkdf2Sha512Noble = exports2.pbkdf2Sha512Crypto = exports2.pbkdf2Sha512Subtle = exports2.getSubtle = exports2.getCryptoModule = void 0;
    var utils_1 = require_build3();
    var pbkdf2_1 = require_pbkdf2();
    var sha512_1 = require_sha512();
    async function getCryptoModule() {
      try {
        const crypto = await Promise.resolve().then(() => __importStar(require("crypto")));
        if (typeof crypto === "object" && Object.keys(crypto).length <= 1) {
          return void 0;
        }
        return crypto;
      } catch (_a) {
        return void 0;
      }
    }
    exports2.getCryptoModule = getCryptoModule;
    async function getSubtle() {
      var _a, _b, _c;
      let subtle = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.subtle;
      if (!subtle)
        subtle = (_c = (_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _b === void 0 ? void 0 : _b.webcrypto) === null || _c === void 0 ? void 0 : _c.subtle;
      return subtle;
    }
    exports2.getSubtle = getSubtle;
    async function pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(subtle, "Argument subtle is falsy");
      (0, utils_1.assert)(typeof subtle === "object", "Argument subtle is not of type object");
      (0, utils_1.assert)(typeof subtle.importKey === "function", "subtle.importKey is not a function");
      (0, utils_1.assert)(typeof subtle.deriveBits === "function", "subtle.deriveBits is not a function");
      return subtle.importKey("raw", secret, { name: "PBKDF2" }, false, ["deriveBits"]).then((key) => subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: { name: "SHA-512" }
      }, key, keylen * 8).then((buffer) => new Uint8Array(buffer)));
    }
    exports2.pbkdf2Sha512Subtle = pbkdf2Sha512Subtle;
    async function pbkdf2Sha512Crypto(crypto, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(crypto, "Argument crypto is falsy");
      (0, utils_1.assert)(typeof crypto === "object", "Argument crypto is not of type object");
      (0, utils_1.assert)(typeof crypto.pbkdf2 === "function", "crypto.pbkdf2 is not a function");
      return new Promise((resolve, reject) => {
        crypto.pbkdf2(secret, salt, iterations, keylen, "sha512", (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(Uint8Array.from(result));
          }
        });
      });
    }
    exports2.pbkdf2Sha512Crypto = pbkdf2Sha512Crypto;
    async function pbkdf2Sha512Noble(secret, salt, iterations, keylen) {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, secret, salt, { c: iterations, dkLen: keylen });
    }
    exports2.pbkdf2Sha512Noble = pbkdf2Sha512Noble;
    async function pbkdf2Sha512(secret, salt, iterations, keylen) {
      const subtle = await getSubtle();
      if (subtle) {
        return pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen);
      } else {
        const crypto = await getCryptoModule();
        if (crypto) {
          return pbkdf2Sha512Crypto(crypto, secret, salt, iterations, keylen);
        } else {
          return pbkdf2Sha512Noble(secret, salt, iterations, keylen);
        }
      }
    }
    exports2.pbkdf2Sha512 = pbkdf2Sha512;
  }
});

// ../../node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "../../node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// ../../node_modules/@cosmjs/crypto/build/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toRealUint8Array = void 0;
    function toRealUint8Array(data) {
      if (data instanceof Uint8Array)
        return data;
      else
        return Uint8Array.from(data);
    }
    exports2.toRealUint8Array = toRealUint8Array;
  }
});

// ../../node_modules/@cosmjs/crypto/build/sha.js
var require_sha = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/sha.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512 = exports2.Sha512 = exports2.sha256 = exports2.Sha256 = void 0;
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils2();
    var Sha256 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = sha256_1.sha256.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports2.Sha256 = Sha256;
    function sha256(data) {
      return new Sha256(data).digest();
    }
    exports2.sha256 = sha256;
    var Sha512 = class {
      constructor(firstData) {
        this.blockSize = 1024 / 8;
        this.impl = sha512_1.sha512.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports2.Sha512 = Sha512;
    function sha512(data) {
      return new Sha512(data).digest();
    }
    exports2.sha512 = sha512;
  }
});

// ../../node_modules/@cosmjs/crypto/build/bip39.js
var require_bip39 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/bip39.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Bip39 = exports2.EnglishMnemonic = exports2.mnemonicToEntropy = exports2.entropyToMnemonic = void 0;
    var encoding_1 = require_build();
    var pbkdf2_1 = require_pbkdf22();
    var sha_1 = require_sha();
    var wordlist = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    function bytesToBitstring(bytes) {
      return Array.from(bytes).map((byte) => byte.toString(2).padStart(8, "0")).join("");
    }
    function deriveChecksumBits(entropy) {
      const entropyLengthBits = entropy.length * 8;
      const checksumLengthBits = entropyLengthBits / 32;
      const hash = (0, sha_1.sha256)(entropy);
      return bytesToBitstring(hash).slice(0, checksumLengthBits);
    }
    function bitstringToByte(bin) {
      return parseInt(bin, 2);
    }
    var allowedEntropyLengths = [16, 20, 24, 28, 32];
    var allowedWordLengths = [12, 15, 18, 21, 24];
    function entropyToMnemonic(entropy) {
      if (allowedEntropyLengths.indexOf(entropy.length) === -1) {
        throw new Error("invalid input length");
      }
      const entropyBits = bytesToBitstring(entropy);
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{11})/g);
      const words = chunks.map((binary) => {
        const index = bitstringToByte(binary);
        return wordlist[index];
      });
      return words.join(" ");
    }
    exports2.entropyToMnemonic = entropyToMnemonic;
    var invalidNumberOfWorks = "Invalid number of words";
    var wordNotInWordlist = "Found word that is not in the wordlist";
    var invalidEntropy = "Invalid entropy";
    var invalidChecksum = "Invalid mnemonic checksum";
    function normalize(str) {
      return str.normalize("NFKD");
    }
    function mnemonicToEntropy(mnemonic) {
      const words = normalize(mnemonic).split(" ");
      if (!allowedWordLengths.includes(words.length)) {
        throw new Error(invalidNumberOfWorks);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(wordNotInWordlist);
        }
        return index.toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(bitstringToByte);
      if (entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) {
        throw new Error(invalidEntropy);
      }
      const entropy = Uint8Array.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(invalidChecksum);
      }
      return entropy;
    }
    exports2.mnemonicToEntropy = mnemonicToEntropy;
    var EnglishMnemonic = class {
      constructor(mnemonic) {
        if (!EnglishMnemonic.mnemonicMatcher.test(mnemonic)) {
          throw new Error("Invalid mnemonic format");
        }
        const words = mnemonic.split(" ");
        const allowedWordsLengths = [12, 15, 18, 21, 24];
        if (allowedWordsLengths.indexOf(words.length) === -1) {
          throw new Error(`Invalid word count in mnemonic (allowed: ${allowedWordsLengths} got: ${words.length})`);
        }
        for (const word of words) {
          if (EnglishMnemonic.wordlist.indexOf(word) === -1) {
            throw new Error("Mnemonic contains invalid word");
          }
        }
        mnemonicToEntropy(mnemonic);
        this.data = mnemonic;
      }
      toString() {
        return this.data;
      }
    };
    exports2.EnglishMnemonic = EnglishMnemonic;
    EnglishMnemonic.wordlist = wordlist;
    EnglishMnemonic.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
    var Bip39 = class {
      /**
       * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
       *
       * | Entropy            | Words |
       * |--------------------|-------|
       * | 128 bit (16 bytes) |    12 |
       * | 160 bit (20 bytes) |    15 |
       * | 192 bit (24 bytes) |    18 |
       * | 224 bit (28 bytes) |    21 |
       * | 256 bit (32 bytes) |    24 |
       *
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
       * @param entropy The entropy to be encoded. This must be cryptographically secure.
       */
      static encode(entropy) {
        return new EnglishMnemonic(entropyToMnemonic(entropy));
      }
      static decode(mnemonic) {
        return mnemonicToEntropy(mnemonic.toString());
      }
      static async mnemonicToSeed(mnemonic, password) {
        const mnemonicBytes = (0, encoding_1.toUtf8)(normalize(mnemonic.toString()));
        const salt = "mnemonic" + (password ? normalize(password) : "");
        const saltBytes = (0, encoding_1.toUtf8)(salt);
        return (0, pbkdf2_1.pbkdf2Sha512)(mnemonicBytes, saltBytes, 2048, 64);
      }
    };
    exports2.Bip39 = Bip39;
  }
});

// ../../node_modules/@cosmjs/crypto/build/hmac.js
var require_hmac2 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hmac = void 0;
    var Hmac = class {
      constructor(hashFunctionConstructor, originalKey) {
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data) => new hashFunctionConstructor().update(data).digest();
        let key = originalKey;
        if (key.length > blockSize) {
          key = this.hash(key);
        }
        if (key.length < blockSize) {
          const zeroPadding = new Uint8Array(blockSize - key.length);
          key = new Uint8Array([...key, ...zeroPadding]);
        }
        this.oKeyPad = key.map((keyByte) => keyByte ^ 92);
        this.iKeyPad = key.map((keyByte) => keyByte ^ 54);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
      }
      update(data) {
        this.messageHasher.update(data);
        return this;
      }
      digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));
      }
    };
    exports2.Hmac = Hmac;
  }
});

// ../../node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "../../node_modules/@noble/hashes/sha3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shake256 = exports2.shake128 = exports2.keccak_512 = exports2.keccak_384 = exports2.keccak_256 = exports2.keccak_224 = exports2.sha3_512 = exports2.sha3_384 = exports2.sha3_256 = exports2.sha3_224 = exports2.Keccak = exports2.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports2.keccakP = keccakP;
    var Keccak = class extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports2.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports2.sha3_224 = gen(6, 144, 224 / 8);
    exports2.sha3_256 = gen(6, 136, 256 / 8);
    exports2.sha3_384 = gen(6, 104, 384 / 8);
    exports2.sha3_512 = gen(6, 72, 512 / 8);
    exports2.keccak_224 = gen(1, 144, 224 / 8);
    exports2.keccak_256 = gen(1, 136, 256 / 8);
    exports2.keccak_384 = gen(1, 104, 384 / 8);
    exports2.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports2.shake128 = genShake(31, 168, 128 / 8);
    exports2.shake256 = genShake(31, 136, 256 / 8);
  }
});

// ../../node_modules/@cosmjs/crypto/build/keccak.js
var require_keccak = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/keccak.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.keccak256 = exports2.Keccak256 = void 0;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils2();
    var Keccak256 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = sha3_1.keccak_256.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports2.Keccak256 = Keccak256;
    function keccak256(data) {
      return new Keccak256(data).digest();
    }
    exports2.keccak256 = keccak256;
  }
});

// ../../node_modules/libsodium/dist/modules/libsodium.js
var require_libsodium = __commonJS({
  "../../node_modules/libsodium/dist/modules/libsodium.js"(exports2, module2) {
    !function(A) {
      function I(A2) {
        "use strict";
        var I2;
        void 0 === (I2 = A2) && (I2 = {});
        var g = I2;
        "object" != typeof g.sodium && ("object" == typeof global ? g = global : "object" == typeof window && (g = window));
        var C = I2;
        return I2.ready = new Promise(function(A3, I3) {
          (i = C).onAbort = I3, i.print = function(A4) {
          }, i.printErr = function(A4) {
          }, i.onRuntimeInitialized = function() {
            try {
              i._crypto_secretbox_keybytes(), A3();
            } catch (A4) {
              I3(A4);
            }
          }, i.useBackupModule = function() {
            return new Promise(function(A4, I4) {
              (i2 = {}).onAbort = I4, i2.onRuntimeInitialized = function() {
                Object.keys(C).forEach(function(A5) {
                  "getRandomValue" !== A5 && delete C[A5];
                }), Object.keys(i2).forEach(function(A5) {
                  C[A5] = i2[A5];
                }), A4();
              };
              var g3, B2, Q2, i2 = void 0 !== i2 ? i2 : {}, E2 = Object.assign({}, i2), o2 = "object" == typeof window, a2 = "function" == typeof importScripts, n2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, r2 = "";
              if (n2) {
                var f2 = require("fs"), t2 = require("path");
                r2 = a2 ? t2.dirname(r2) + "/" : __dirname + "/", g3 = (A5, I5) => {
                  var g4 = T2(A5);
                  return g4 ? I5 ? g4 : g4.toString() : (A5 = x2(A5) ? new URL(A5) : t2.normalize(A5), f2.readFileSync(A5, I5 ? void 0 : "utf8"));
                }, Q2 = (A5) => {
                  var I5 = g3(A5, true);
                  return I5.buffer || (I5 = new Uint8Array(I5)), I5;
                }, B2 = (A5, I5, g4) => {
                  var C2 = T2(A5);
                  C2 && I5(C2), A5 = x2(A5) ? new URL(A5) : t2.normalize(A5), f2.readFile(A5, function(A6, C3) {
                    A6 ? g4(A6) : I5(C3.buffer);
                  });
                }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), "undefined" != typeof module2 && (module2.exports = i2), i2.inspect = function() {
                  return "[Emscripten Module object]";
                };
              } else
                (o2 || a2) && (a2 ? r2 = self.location.href : "undefined" != typeof document && document.currentScript && (r2 = document.currentScript.src), r2 = 0 !== r2.indexOf("blob:") ? r2.substr(0, r2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", g3 = (A5) => {
                  try {
                    var I5 = new XMLHttpRequest();
                    return I5.open("GET", A5, false), I5.send(null), I5.responseText;
                  } catch (I6) {
                    var g4 = T2(A5);
                    if (g4)
                      return function(A6) {
                        for (var I7 = [], g5 = 0; g5 < A6.length; g5++) {
                          var C2 = A6[g5];
                          C2 > 255 && (C2 &= 255), I7.push(String.fromCharCode(C2));
                        }
                        return I7.join("");
                      }(g4);
                    throw I6;
                  }
                }, a2 && (Q2 = (A5) => {
                  try {
                    var I5 = new XMLHttpRequest();
                    return I5.open("GET", A5, false), I5.responseType = "arraybuffer", I5.send(null), new Uint8Array(I5.response);
                  } catch (I6) {
                    var g4 = T2(A5);
                    if (g4)
                      return g4;
                    throw I6;
                  }
                }), B2 = (A5, I5, g4) => {
                  var C2 = new XMLHttpRequest();
                  C2.open("GET", A5, true), C2.responseType = "arraybuffer", C2.onload = () => {
                    if (200 == C2.status || 0 == C2.status && C2.response)
                      I5(C2.response);
                    else {
                      var B3 = T2(A5);
                      B3 ? I5(B3.buffer) : g4();
                    }
                  }, C2.onerror = g4, C2.send(null);
                });
              i2.print;
              var e2, c2 = i2.printErr || void 0;
              Object.assign(i2, E2), E2 = null, i2.arguments && i2.arguments, i2.thisProgram && i2.thisProgram, i2.quit && i2.quit, i2.wasmBinary && (e2 = i2.wasmBinary), i2.noExitRuntime;
              var y2, D2 = { Memory: function(A5) {
                this.buffer = new ArrayBuffer(65536 * A5.initial);
              }, Module: function(A5) {
              }, Instance: function(A5, I5) {
                this.exports = function(A6) {
                  for (var I6, g4 = new Uint8Array(123), C2 = 25; C2 >= 0; --C2)
                    g4[48 + C2] = 52 + C2, g4[65 + C2] = C2, g4[97 + C2] = 26 + C2;
                  function B3(A7, I7, C3) {
                    for (var B4, Q4, i3 = 0, E3 = I7, o3 = C3.length, a3 = I7 + (3 * o3 >> 2) - ("=" == C3[o3 - 2]) - ("=" == C3[o3 - 1]); i3 < o3; i3 += 4)
                      B4 = g4[C3.charCodeAt(i3 + 1)], Q4 = g4[C3.charCodeAt(i3 + 2)], A7[E3++] = g4[C3.charCodeAt(i3)] << 2 | B4 >> 4, E3 < a3 && (A7[E3++] = B4 << 4 | Q4 >> 2), E3 < a3 && (A7[E3++] = Q4 << 6 | g4[C3.charCodeAt(i3 + 3)]);
                  }
                  function Q3() {
                    throw new Error("abort");
                  }
                  return g4[43] = 62, g4[47] = 63, function(A7) {
                    var g5 = A7.a, C3 = g5.a, i3 = C3.buffer;
                    C3.grow = function(A8) {
                      A8 |= 0;
                      var g6 = 0 | rI(), B4 = g6 + A8 | 0;
                      if (g6 < B4 && B4 < 65536) {
                        var Q4 = new ArrayBuffer(r3(B4, 65536));
                        new Int8Array(Q4).set(E3), E3 = new Int8Array(Q4), new Int16Array(Q4), o3 = new Int32Array(Q4), a3 = new Uint8Array(Q4), new Uint16Array(Q4), n3 = new Uint32Array(Q4), new Float32Array(Q4), new Float64Array(Q4), i3 = Q4, C3.buffer = i3, I6 = a3;
                      }
                      return g6;
                    };
                    var E3 = new Int8Array(i3), o3 = (new Int16Array(i3), new Int32Array(i3)), a3 = new Uint8Array(i3), n3 = (new Uint16Array(i3), new Uint32Array(i3)), r3 = (new Float32Array(i3), new Float64Array(i3), Math.imul), f3 = (Math.fround, Math.abs, Math.clz32), t3 = (Math.min, Math.max, Math.floor, Math.ceil, Math.trunc, Math.sqrt, g5.b), e3 = g5.c, c3 = g5.d, y3 = g5.e, D3 = 101744, w3 = 0;
                    function h3(A8, I7) {
                      var g6, C4, B4, Q4, i4, o4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0, P4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, X4 = 0, q4 = 0, z4 = 0, V4 = 0, O4 = 0, T4 = 0, W4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0, BA2 = 0, QA2 = 0, iA2 = 0, EA2 = 0, oA2 = 0, aA2 = 0, rA2 = 0, fA2 = 0, tA2 = 0, eA2 = 0, cA2 = 0, yA2 = 0, DA2 = 0, wA2 = 0, hA2 = 0, sA2 = 0, pA2 = 0, uA2 = 0, kA2 = 0, FA2 = 0, lA2 = 0, SA2 = 0, HA2 = 0, MA2 = 0, GA2 = 0, UA2 = 0;
                      eA2 = a3[I7 + 40 | 0] | a3[I7 + 41 | 0] << 8 | a3[I7 + 42 | 0] << 16 | a3[I7 + 43 | 0] << 24, yA2 = o4 = a3[I7 + 44 | 0] | a3[I7 + 45 | 0] << 8 | a3[I7 + 46 | 0] << 16 | a3[I7 + 47 | 0] << 24, gA2 = a3[I7 + 104 | 0] | a3[I7 + 105 | 0] << 8 | a3[I7 + 106 | 0] << 16 | a3[I7 + 107 | 0] << 24, DA2 = o4 = a3[I7 + 108 | 0] | a3[I7 + 109 | 0] << 8 | a3[I7 + 110 | 0] << 16 | a3[I7 + 111 | 0] << 24, o4 = a3[I7 + 68 | 0] | a3[I7 + 69 | 0] << 8 | a3[I7 + 70 | 0] << 16 | a3[I7 + 71 | 0] << 24, q4 = a3[I7 + 64 | 0] | a3[I7 + 65 | 0] << 8 | a3[I7 + 66 | 0] << 16 | a3[I7 + 67 | 0] << 24, BA2 = o4, HA2 = o4 = a3[I7 + 36 | 0] | a3[I7 + 37 | 0] << 8 | a3[I7 + 38 | 0] << 16 | a3[I7 + 39 | 0] << 24, S4 = o4, oA2 = a3[I7 + 120 | 0] | a3[I7 + 121 | 0] << 8 | a3[I7 + 122 | 0] << 16 | a3[I7 + 123 | 0] << 24, pA2 = o4 = a3[I7 + 124 | 0] | a3[I7 + 125 | 0] << 8 | a3[I7 + 126 | 0] << 16 | a3[I7 + 127 | 0] << 24, B4 = o4 = a3[I7 + 92 | 0] | a3[I7 + 93 | 0] << 8 | a3[I7 + 94 | 0] << 16 | a3[I7 + 95 | 0] << 24, g6 = a3[I7 + 88 | 0] | a3[I7 + 89 | 0] << 8 | a3[I7 + 90 | 0] << 16 | a3[I7 + 91 | 0] << 24, X4 = o4, EA2 = a3[I7 + 80 | 0] | a3[I7 + 81 | 0] << 8 | a3[I7 + 82 | 0] << 16 | a3[I7 + 83 | 0] << 24, hA2 = o4 = a3[I7 + 84 | 0] | a3[I7 + 85 | 0] << 8 | a3[I7 + 86 | 0] << 16 | a3[I7 + 87 | 0] << 24, z4 = o4, QA2 = a3[A8 + 16 | 0] | a3[A8 + 17 | 0] << 8 | a3[A8 + 18 | 0] << 16 | a3[A8 + 19 | 0] << 24, o4 = (rA2 = a3[A8 + 52 | 0] | a3[A8 + 53 | 0] << 8 | a3[A8 + 54 | 0] << 16 | a3[A8 + 55 | 0] << 24) + S4 | 0, x4 = (aA2 = a3[A8 + 48 | 0] | a3[A8 + 49 | 0] << 8 | a3[A8 + 50 | 0] << 16 | a3[A8 + 51 | 0] << 24) + (fA2 = a3[I7 + 32 | 0] | a3[I7 + 33 | 0] << 8 | a3[I7 + 34 | 0] << 16 | a3[I7 + 35 | 0] << 24) | 0, o4 = (a3[A8 + 20 | 0] | a3[A8 + 21 | 0] << 8 | a3[A8 + 22 | 0] << 16 | a3[A8 + 23 | 0] << 24) + (aA2 >>> 0 > x4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (QA2 = (n4 = x4) >>> 0 > (x4 = x4 + QA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + yA2 | 0, iA2 = cA2 = x4 + eA2 | 0, cA2 = o4 = cA2 >>> 0 < x4 >>> 0 ? o4 + 1 | 0 : o4, x4 = nA(x4 ^ (a3[A8 + 80 | 0] | a3[A8 + 81 | 0] << 8 | a3[A8 + 82 | 0] << 16 | a3[A8 + 83 | 0] << 24) ^ -79577749, QA2 ^ (a3[A8 + 84 | 0] | a3[A8 + 85 | 0] << 8 | a3[A8 + 86 | 0] << 16 | a3[A8 + 87 | 0] << 24) ^ 528734635, 32), FA2 = o4 = w3, o4 = o4 + 1013904242 | 0, QA2 = x4, T4 = o4 = (x4 = x4 - 23791573 | 0) >>> 0 < 4271175723 ? o4 + 1 | 0 : o4, rA2 = nA(x4 ^ aA2, o4 ^ rA2, 40), o4 = (o4 = cA2) + (cA2 = w3) | 0, aA2 = nA(QA2 ^ (D4 = aA2 = rA2 + iA2 | 0), FA2 ^ (h4 = D4 >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = T4 + (L4 = w3) | 0, k4 = o4 = (aA2 = x4 + (s4 = aA2) | 0) >>> 0 < x4 >>> 0 ? o4 + 1 | 0 : o4, aA2 = o4 = nA(rA2 ^ (u4 = aA2), cA2 ^ o4, 1), T4 = x4 = w3, cA2 = a3[I7 + 24 | 0] | a3[I7 + 25 | 0] << 8 | a3[I7 + 26 | 0] << 16 | a3[I7 + 27 | 0] << 24, FA2 = o4 = a3[I7 + 28 | 0] | a3[I7 + 29 | 0] << 8 | a3[I7 + 30 | 0] << 16 | a3[I7 + 31 | 0] << 24, tA2 = a3[A8 + 8 | 0] | a3[A8 + 9 | 0] << 8 | a3[A8 + 10 | 0] << 16 | a3[A8 + 11 | 0] << 24, x4 = (rA2 = a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24) + (QA2 = a3[A8 + 40 | 0] | a3[A8 + 41 | 0] << 8 | a3[A8 + 42 | 0] << 16 | a3[A8 + 43 | 0] << 24) | 0, o4 = (MA2 = a3[I7 + 20 | 0] | a3[I7 + 21 | 0] << 8 | a3[I7 + 22 | 0] << 16 | a3[I7 + 23 | 0] << 24) + (UA2 = a3[A8 + 44 | 0] | a3[A8 + 45 | 0] << 8 | a3[A8 + 46 | 0] << 16 | a3[A8 + 47 | 0] << 24) | 0, o4 = (a3[A8 + 12 | 0] | a3[A8 + 13 | 0] << 8 | a3[A8 + 14 | 0] << 16 | a3[A8 + 15 | 0] << 24) + (x4 >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = FA2 + (iA2 = (n4 = x4) >>> 0 > (x4 = x4 + tA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (tA2 = x4 + cA2 | 0) >>> 0 < x4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(x4 ^ (a3[A8 + 72 | 0] | a3[A8 + 73 | 0] << 8 | a3[A8 + 74 | 0] << 16 | a3[A8 + 75 | 0] << 24) ^ 725511199, iA2 ^ (a3[A8 + 76 | 0] | a3[A8 + 77 | 0] << 8 | a3[A8 + 78 | 0] << 16 | a3[A8 + 79 | 0] << 24) ^ -1694144372, 32), e4 = nA(QA2 ^ (r4 = n4 - 2067093701 | 0), UA2 ^ (m4 = (b4 = x4 = w3) - ((n4 >>> 0 < 2067093701) + 1150833018 | 0) | 0), 40), o4 = (R4 = w3) + o4 | 0, o4 = (Y4 = (F4 = x4 = e4 + tA2 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4) + T4 | 0, o4 = (F4 >>> 0 > (x4 = F4 + aA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + z4 | 0, o4 = (QA2 = (f4 = x4) >>> 0 > (x4 = x4 + EA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + X4 | 0, P4 = X4 = x4 + g6 | 0, y4 = o4 = X4 >>> 0 < x4 >>> 0 ? o4 + 1 | 0 : o4, p4 = aA2, uA2 = T4, T4 = x4, iA2 = QA2, aA2 = a3[I7 + 8 | 0] | a3[I7 + 9 | 0] << 8 | a3[I7 + 10 | 0] << 16 | a3[I7 + 11 | 0] << 24, x4 = o4 = a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24, UA2 = o4 = a3[0 | A8] | a3[A8 + 1 | 0] << 8 | a3[A8 + 2 | 0] << 16 | a3[A8 + 3 | 0] << 24, Q4 = QA2 = a3[A8 + 4 | 0] | a3[A8 + 5 | 0] << 8 | a3[A8 + 6 | 0] << 16 | a3[A8 + 7 | 0] << 24, z4 = o4, o4 = (lA2 = a3[I7 + 4 | 0] | a3[I7 + 5 | 0] << 8 | a3[I7 + 6 | 0] << 16 | a3[I7 + 7 | 0] << 24) + (t4 = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24) | 0, o4 = Q4 + ((X4 = a3[A8 + 32 | 0] | a3[A8 + 33 | 0] << 8 | a3[A8 + 34 | 0] << 16 | a3[A8 + 35 | 0] << 24) >>> 0 > (f4 = X4 + (QA2 = a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24) | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (tA2 = (z4 = f4 + z4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) + x4 | 0, sA2 = f4 = z4 + aA2 | 0, f4 = o4 = f4 >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4, c4 = X4, X4 = nA(z4 ^ (a3[0 | (o4 = A8 - -64 | 0)] | a3[o4 + 1 | 0] << 8 | a3[o4 + 2 | 0] << 16 | a3[o4 + 3 | 0] << 24) ^ -1377402159, tA2 ^ (a3[o4 + 4 | 0] | a3[o4 + 5 | 0] << 8 | a3[o4 + 6 | 0] << 16 | a3[o4 + 7 | 0] << 24) ^ 1359893119, 32), tA2 = o4 = w3, o4 = o4 + 1779033703 | 0, z4 = X4, U4 = o4 = (X4 = X4 - 205731576 | 0) >>> 0 < 4089235720 ? o4 + 1 | 0 : o4, t4 = nA(c4 ^ (l4 = X4), o4 ^ t4, 40), o4 = (K4 = w3) + f4 | 0, c4 = nA(z4 ^ (f4 = X4 = t4 + sA2 | 0), tA2 ^ (H4 = t4 >>> 0 > f4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(c4 ^ T4, (Z3 = w3) ^ iA2, 32), O4 = X4 = w3, v4 = o4, C4 = o4 = a3[I7 + 60 | 0] | a3[I7 + 61 | 0] << 8 | a3[I7 + 62 | 0] << 16 | a3[I7 + 63 | 0] << 24, tA2 = sA2 = a3[I7 + 56 | 0] | a3[I7 + 57 | 0] << 8 | a3[I7 + 58 | 0] << 16 | a3[I7 + 59 | 0] << 24, G4 = a3[A8 + 24 | 0] | a3[A8 + 25 | 0] << 8 | a3[A8 + 26 | 0] << 16 | a3[A8 + 27 | 0] << 24, X4 = (iA2 = a3[I7 + 48 | 0] | a3[I7 + 49 | 0] << 8 | a3[I7 + 50 | 0] << 16 | a3[I7 + 51 | 0] << 24) + (z4 = a3[A8 + 56 | 0] | a3[A8 + 57 | 0] << 8 | a3[A8 + 58 | 0] << 16 | a3[A8 + 59 | 0] << 24) | 0, o4 = (SA2 = a3[I7 + 52 | 0] | a3[I7 + 53 | 0] << 8 | a3[I7 + 54 | 0] << 16 | a3[I7 + 55 | 0] << 24) + (_4 = a3[A8 + 60 | 0] | a3[A8 + 61 | 0] << 8 | a3[A8 + 62 | 0] << 16 | a3[A8 + 63 | 0] << 24) | 0, o4 = (a3[A8 + 28 | 0] | a3[A8 + 29 | 0] << 8 | a3[A8 + 30 | 0] << 16 | a3[A8 + 31 | 0] << 24) + (X4 >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = C4 + (T4 = (M4 = X4) >>> 0 > (X4 = G4 + X4 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (G4 = X4 + tA2 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4, T4 = nA(X4 ^ (a3[A8 + 88 | 0] | a3[A8 + 89 | 0] << 8 | a3[A8 + 90 | 0] << 16 | a3[A8 + 91 | 0] << 24) ^ 327033209, T4 ^ (a3[A8 + 92 | 0] | a3[A8 + 93 | 0] << 8 | a3[A8 + 94 | 0] << 16 | a3[A8 + 95 | 0] << 24) ^ 1541459225, 32), z4 = nA(z4 ^ (tA2 = T4 + 1595750129 | 0), (M4 = _4) ^ (_4 = (J4 = X4 = w3) - ((T4 >>> 0 < 2699217167) + 1521486533 | 0) | 0), 40), o4 = (IA2 = w3) + o4 | 0, X4 = nA((G4 = X4 = z4 + G4 | 0) ^ T4, J4 ^ (M4 = G4 >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = _4 + ($3 = w3) | 0, N4 = o4 = (X4 = tA2 + (_4 = X4) | 0) >>> 0 < tA2 >>> 0 ? o4 + 1 | 0 : o4, o4 = O4 + o4 | 0, V4 = p4 ^ (T4 = v4 + (J4 = X4) | 0), p4 = o4 = T4 >>> 0 < J4 >>> 0 ? o4 + 1 | 0 : o4, tA2 = nA(V4, o4 ^ uA2, 40), o4 = (uA2 = w3) + y4 | 0, X4 = nA(P4 = v4 ^ (y4 = X4 = tA2 + P4 | 0), O4 ^ (v4 = y4 >>> 0 < tA2 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = p4 + (CA2 = w3) | 0, O4 = o4 = (p4 = T4 + (P4 = X4) | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4, X4 = (d4 = nA(p4 ^ tA2, uA2 ^ o4, 1)) + (T4 = a3[I7 + 72 | 0] | a3[I7 + 73 | 0] << 8 | a3[I7 + 74 | 0] << 16 | a3[I7 + 75 | 0] << 24) | 0, o4 = (wA2 = w3) + (uA2 = a3[I7 + 76 | 0] | a3[I7 + 77 | 0] << 8 | a3[I7 + 78 | 0] << 16 | a3[I7 + 79 | 0] << 24) | 0, kA2 = X4, j4 = X4 >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4, W4 = DA2, X4 = a3[I7 + 96 | 0] | a3[I7 + 97 | 0] << 8 | a3[I7 + 98 | 0] << 16 | a3[I7 + 99 | 0] << 24, tA2 = o4 = a3[I7 + 100 | 0] | a3[I7 + 101 | 0] << 8 | a3[I7 + 102 | 0] << 16 | a3[I7 + 103 | 0] << 24, z4 = (o4 = D4) + (D4 = nA(J4 ^ z4, N4 ^ IA2, 1)) | 0, o4 = (J4 = w3) + h4 | 0, o4 = (D4 >>> 0 > z4 >>> 0 ? o4 + 1 | 0 : o4) + tA2 | 0, o4 = (h4 = (h4 = z4) >>> 0 > (z4 = X4 + z4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + W4 | 0, V4 = N4 = z4 + gA2 | 0, N4 = o4 = N4 >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4, F4 = nA(n4 ^ F4, Y4 ^ b4, 48), Y4 = o4 = nA(F4 ^ z4, (b4 = w3) ^ h4, 32), o4 = U4 + Z3 | 0, o4 = (IA2 = z4 = w3) + (l4 = (z4 = c4 + l4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, U4 = o4 = (h4 = z4) >>> 0 > (c4 = h4 + Y4 | 0) >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(c4 ^ D4, J4 ^ o4, 40), o4 = (Z3 = w3) + N4 | 0, o4 = (J4 = D4 >>> 0 > (N4 = z4 = D4 + V4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + j4 | 0, o4 = (n4 = N4 >>> 0 > (z4 = N4 + kA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + pA2 | 0, kA2 = j4 = z4 + oA2 | 0, j4 = o4 = j4 >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4, V4 = z4, W4 = n4, z4 = a3[I7 + 116 | 0] | a3[I7 + 117 | 0] << 8 | a3[I7 + 118 | 0] << 16 | a3[I7 + 119 | 0] << 24, I7 = a3[I7 + 112 | 0] | a3[I7 + 113 | 0] << 8 | a3[I7 + 114 | 0] << 16 | a3[I7 + 115 | 0] << 24, t4 = nA(t4 ^ h4, l4 ^ K4, 1), o4 = (K4 = w3) + M4 | 0, o4 = ((n4 = t4 + G4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) + z4 | 0, o4 = (h4 = (l4 = n4) >>> 0 > (n4 = I7 + n4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + pA2 | 0, GA2 = l4 = n4 + oA2 | 0, l4 = o4 = l4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(n4 ^ s4, h4 ^ L4, 32), AA2 = n4 = w3, s4 = o4, h4 = n4, o4 = b4 + m4 | 0, F4 = n4 = r4 + F4 | 0, G4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + h4 | 0, M4 = n4 = n4 + s4 | 0, L4 = o4 = F4 >>> 0 > n4 >>> 0 ? o4 + 1 | 0 : o4, h4 = nA(n4 ^ t4, K4 ^ o4, 40), o4 = (K4 = w3) + l4 | 0, s4 = nA((n4 = h4 + GA2 | 0) ^ s4, AA2 ^ (r4 = n4 >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(s4 ^ V4, (GA2 = w3) ^ W4, 32), AA2 = t4 = w3, l4 = o4, V4 = t4, e4 = nA(e4 ^ F4, G4 ^ R4, 1), o4 = H4 + (F4 = w3) | 0, o4 = ((t4 = f4) >>> 0 > (f4 = f4 + e4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + BA2 | 0, o4 = (f4 = (t4 = f4 + q4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) + uA2 | 0, W4 = H4 = t4 + T4 | 0, H4 = o4 = H4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, G4 = e4, t4 = nA(t4 ^ _4, f4 ^ $3, 32), o4 = (_4 = w3) + k4 | 0, u4 = nA(G4 ^ (f4 = e4 = t4 + u4 | 0), (k4 = t4 >>> 0 > f4 >>> 0 ? o4 + 1 | 0 : o4) ^ F4, 40), o4 = ($3 = w3) + H4 | 0, F4 = e4 = u4 + W4 | 0, e4 = nA(t4 ^ e4, _4 ^ (H4 = e4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = k4 + (i4 = w3) | 0, k4 = e4, _4 = o4 = (e4 = f4 + e4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + V4 | 0, o4 = (G4 = e4) >>> 0 > (e4 = e4 + l4 | 0) >>> 0 ? o4 + 1 | 0 : o4, V4 = e4, e4 ^= d4, d4 = o4, t4 = nA(e4, wA2 ^ o4, 40), o4 = (wA2 = w3) + j4 | 0, j4 = e4 = t4 + kA2 | 0, o4 = B4 + (W4 = t4 >>> 0 > e4 >>> 0 ? o4 + 1 | 0 : o4) | 0, kA2 = e4 = e4 + g6 | 0, b4 = o4 = e4 >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4, e4 = n4, m4 = gA2, R4 = DA2, n4 = nA(Y4 ^ N4, J4 ^ IA2, 48), o4 = U4 + (IA2 = w3) | 0, Y4 = n4, U4 = o4 = (f4 = c4 + n4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(f4 ^ D4, Z3 ^ o4, 1), o4 = (c4 = w3) + R4 | 0, o4 = ((D4 = n4 + m4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, o4 = SA2 + (e4 = (r4 = e4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4) | 0, N4 = D4 = r4 + iA2 | 0, D4 = o4 = D4 >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(r4 ^ k4, e4 ^ i4, 32), o4 = O4 + (J4 = w3) | 0, k4 = r4, p4 = o4 = (r4 = p4 + r4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(n4 ^ r4, o4 ^ c4, 40), o4 = (o4 = D4) + (D4 = w3) | 0, c4 = n4 = e4 + N4 | 0, n4 = nA(n4 ^ k4, J4 ^ (N4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = p4 + (Z3 = w3) | 0, J4 = n4, O4 = o4 = (p4 = r4 + n4 | 0) >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(e4 ^ p4, D4 ^ o4, 1), o4 = (D4 = w3) + b4 | 0, o4 = C4 + (e4 = (r4 = n4 + kA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, kA2 = k4 = r4 + sA2 | 0, k4 = o4 = k4 >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4, b4 = n4, m4 = D4, o4 = L4 + GA2 | 0, o4 = (n4 = s4 + M4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, s4 = n4, M4 = o4, o4 = nA(n4 ^ h4, K4 ^ o4, 1), h4 = D4 = w3, n4 = o4, o4 = H4 + z4 | 0, o4 = ((F4 = I7 + F4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4) + D4 | 0, o4 = hA2 + (F4 = (D4 = n4 + F4 | 0) >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4) | 0, L4 = H4 = D4 + EA2 | 0, H4 = o4 = H4 >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(D4 ^ P4, F4 ^ CA2, 32), o4 = U4 + (P4 = w3) | 0, F4 = D4, U4 = o4 = (U4 = f4) >>> 0 > (f4 = f4 + D4 | 0) >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(n4 ^ f4, o4 ^ h4, 40), o4 = (K4 = w3) + H4 | 0, h4 = n4 = D4 + L4 | 0, n4 = nA(H4 = n4 ^ F4, P4 ^ (F4 = n4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = U4 + (CA2 = w3) | 0, U4 = n4, H4 = n4 = f4 + n4 | 0, P4 = o4 = n4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, L4 = r4, R4 = e4, n4 = nA(u4 ^ G4, _4 ^ $3, 1), o4 = (f4 = w3) + S4 | 0, o4 = v4 + ((r4 = n4 + fA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = BA2 + (e4 = (r4 = r4 + y4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4) | 0, v4 = y4 = r4 + q4 | 0, y4 = o4 = y4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, u4 = n4, n4 = (r4 = nA(r4 ^ Y4, e4 ^ IA2, 32)) + s4 | 0, o4 = (s4 = w3) + M4 | 0, e4 = n4, f4 = nA(n4 ^ u4, (Y4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4) ^ f4, 40), o4 = (IA2 = w3) + y4 | 0, y4 = n4 = f4 + v4 | 0, G4 = nA(n4 ^ r4, s4 ^ (v4 = n4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4), 48), r4 = nA(G4 ^ L4, (o4 = R4) ^ (R4 = w3), 32), o4 = (L4 = w3) + P4 | 0, s4 = n4 = r4 + H4 | 0, u4 = nA(n4 ^ b4, (M4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4) ^ m4, 40), o4 = (b4 = w3) + k4 | 0, k4 = n4 = u4 + kA2 | 0, n4 = nA(n4 ^ r4, L4 ^ (_4 = n4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = M4 + ($3 = w3) | 0, M4 = n4, L4 = o4 = (r4 = s4) >>> 0 > (s4 = s4 + n4 | 0) >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(s4 ^ u4, b4 ^ o4, 1), o4 = pA2 + (kA2 = w3) | 0, b4 = n4, GA2 = n4 = oA2 + n4 | 0, u4 = o4 = n4 >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4, r4 = eA2, n4 = nA(D4 ^ H4, K4 ^ P4, 1), o4 = N4 + (D4 = w3) | 0, o4 = ((H4 = c4) >>> 0 > (c4 = n4 + c4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + yA2 | 0, o4 = (H4 = (r4 = r4 + c4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) + FA2 | 0, m4 = c4 = r4 + cA2 | 0, N4 = o4 = c4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, P4 = n4, c4 = nA(l4 ^ j4, W4 ^ AA2, 48), o4 = nA(c4 ^ r4, (K4 = w3) ^ H4, 32), AA2 = n4 = w3, l4 = o4, r4 = n4, o4 = Y4 + R4 | 0, o4 = (n4 = e4 + G4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = n4, Y4 = o4, o4 = o4 + r4 | 0, H4 = n4 = n4 + l4 | 0, G4 = o4 = e4 >>> 0 > n4 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(n4 ^ P4, o4 ^ D4, 40), o4 = (o4 = N4) + (N4 = w3) | 0, P4 = n4 = r4 + m4 | 0, j4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + u4 | 0, W4 = o4 = (D4 = n4 + GA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, u4 = o4, n4 = nA(f4 ^ e4, Y4 ^ IA2, 1), o4 = x4 + (f4 = w3) | 0, o4 = F4 + ((e4 = n4 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = tA2 + (h4 = (e4 = e4 + h4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4) | 0, m4 = F4 = e4 + X4 | 0, F4 = o4 = F4 >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4, Y4 = n4, o4 = nA(e4 ^ J4, h4 ^ Z3, 32), R4 = n4 = w3, e4 = o4, h4 = n4, o4 = K4 + d4 | 0, J4 = n4 = c4 + V4 | 0, d4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + h4 | 0, o4 = (c4 = n4 + e4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = c4 ^ Y4, Y4 = o4, h4 = nA(n4, o4 ^ f4, 40), o4 = (Z3 = w3) + F4 | 0, f4 = n4 = h4 + m4 | 0, V4 = nA(n4 ^ e4, R4 ^ (F4 = n4 >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(V4 ^ D4, (IA2 = w3) ^ u4, 32), GA2 = n4 = w3, m4 = o4, u4 = n4, n4 = nA(t4 ^ J4, d4 ^ wA2, 1), o4 = v4 + (t4 = w3) | 0, o4 = lA2 + ((e4 = n4 + y4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (y4 = (e4 = e4 + QA2 | 0) >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4) + MA2 | 0, J4 = v4 = e4 + rA2 | 0, v4 = o4 = v4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(e4 ^ U4, y4 ^ CA2, 32), o4 = O4 + (d4 = w3) | 0, U4 = e4, y4 = t4, t4 = o4 = (e4 = p4 + e4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(n4 ^ e4, y4 ^ o4, 40), o4 = (CA2 = w3) + v4 | 0, p4 = n4 = y4 + J4 | 0, n4 = nA(J4 = n4 ^ U4, d4 ^ (U4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = t4 + (K4 = w3) | 0, t4 = n4, v4 = n4 = e4 + n4 | 0, J4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + u4 | 0, O4 = o4 = (u4 = n4 + m4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(u4 ^ b4, kA2 ^ o4, 40), o4 = W4 + (d4 = w3) | 0, o4 = ((n4 = e4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4) + DA2 | 0, D4 = n4, W4 = n4 = n4 + gA2 | 0, b4 = o4 = D4 >>> 0 > n4 >>> 0 ? o4 + 1 | 0 : o4, R4 = BA2, D4 = nA(l4 ^ P4, j4 ^ AA2, 48), o4 = (wA2 = w3) + G4 | 0, l4 = n4 = D4 + H4 | 0, o4 = nA(n4 ^ r4, (H4 = n4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4) ^ N4, 1), N4 = r4 = w3, n4 = o4, o4 = F4 + B4 | 0, o4 = ((f4 = f4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, o4 = (f4 = (r4 = n4 + f4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) + R4 | 0, G4 = F4 = r4 + q4 | 0, F4 = o4 = F4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(r4 ^ t4, f4 ^ K4, 32), o4 = L4 + (P4 = w3) | 0, s4 = o4 = (t4 = r4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ t4, o4 ^ N4, 40), o4 = (j4 = w3) + F4 | 0, F4 = n4 = f4 + G4 | 0, r4 = nA(n4 ^ r4, P4 ^ (N4 = n4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = s4 + (G4 = w3) | 0, P4 = o4 = (s4 = r4 + t4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(f4 ^ s4, j4 ^ o4, 1), o4 = (j4 = w3) + b4 | 0, o4 = uA2 + ((t4 = n4 + W4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (f4 = (t4 = t4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) + S4 | 0, kA2 = S4 = t4 + fA2 | 0, S4 = o4 = S4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, L4 = n4, R4 = t4, K4 = f4, t4 = eA2, n4 = nA(y4 ^ v4, J4 ^ CA2, 1), o4 = _4 + (y4 = w3) | 0, o4 = ((f4 = k4) >>> 0 > (k4 = n4 + k4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + yA2 | 0, o4 = MA2 + (f4 = (t4 = t4 + k4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4) | 0, _4 = k4 = t4 + rA2 | 0, v4 = o4 = k4 >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4, k4 = n4, f4 = o4 = nA(t4 ^ D4, f4 ^ wA2, 32), o4 = Y4 + IA2 | 0, o4 = (J4 = n4 = w3) + (c4 = (n4 = c4 + V4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, Y4 = o4 = (D4 = n4 + f4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, k4 = nA(D4 ^ k4, o4 ^ y4, 40), o4 = (IA2 = w3) + v4 | 0, v4 = nA(_4 = (t4 = k4 + _4 | 0) ^ f4, J4 ^ (f4 = t4 >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(v4 ^ R4, (CA2 = w3) ^ K4, 32), wA2 = y4 = w3, _4 = o4, J4 = y4, n4 = nA(n4 ^ h4, c4 ^ Z3, 1), o4 = tA2 + (y4 = w3) | 0, o4 = U4 + ((c4 = n4 + X4 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = lA2 + (p4 = (c4 = c4 + p4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4) | 0, R4 = h4 = c4 + QA2 | 0, h4 = o4 = h4 >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4, U4 = n4, V4 = y4, c4 = nA(c4 ^ M4, p4 ^ $3, 32), o4 = (M4 = w3) + H4 | 0, y4 = n4 = c4 + l4 | 0, p4 = nA(n4 ^ U4, (l4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) ^ V4, 40), o4 = (Z3 = w3) + h4 | 0, U4 = n4 = p4 + R4 | 0, n4 = nA(n4 ^ c4, M4 ^ (H4 = n4 >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = l4 + (R4 = w3) | 0, h4 = n4, l4 = n4 = y4 + n4 | 0, M4 = o4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + J4 | 0, J4 = n4 = n4 + _4 | 0, c4 = j4, j4 = o4 = l4 >>> 0 > n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ L4, c4 ^ o4, 40), o4 = (o4 = S4) + (S4 = w3) | 0, V4 = n4 = c4 + kA2 | 0, L4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = f4, n4 = nA(m4 ^ W4, b4 ^ GA2, 48), o4 = O4 + ($3 = w3) | 0, O4 = n4, f4 = (n4 = u4 + n4 | 0) ^ e4, e4 = o4 = n4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(f4, o4 ^ d4, 1), o4 = (d4 = w3) + y4 | 0, o4 = C4 + ((t4 = f4 + t4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (y4 = (t4 = t4 + sA2 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) + x4 | 0, W4 = u4 = t4 + aA2 | 0, u4 = o4 = u4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = nA(t4 ^ h4, y4 ^ R4, 32), o4 = P4 + (b4 = w3) | 0, P4 = t4, s4 = o4 = (y4 = s4 + t4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(f4 ^ y4, d4 ^ o4, 40), o4 = (o4 = u4) + (u4 = w3) | 0, h4 = t4 = f4 + W4 | 0, t4 = nA(m4 = t4 ^ P4, b4 ^ (P4 = t4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = s4 + (kA2 = w3) | 0, d4 = t4, W4 = o4 = (s4 = y4 + t4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, t4 = nA(f4 ^ s4, u4 ^ o4, 1), o4 = (u4 = w3) + L4 | 0, o4 = B4 + ((f4 = t4 + V4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = z4 + (y4 = (f4 = f4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) | 0, GA2 = b4 = I7 + f4 | 0, b4 = o4 = b4 >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4, m4 = t4, R4 = u4, u4 = f4, K4 = y4, t4 = nA(p4 ^ l4, M4 ^ Z3, 1), o4 = (y4 = w3) + N4 | 0, o4 = hA2 + ((f4 = t4 + F4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (p4 = (f4 = f4 + EA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) + z4 | 0, N4 = F4 = I7 + f4 | 0, F4 = o4 = F4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, l4 = t4, f4 = o4 = nA(f4 ^ O4, p4 ^ $3, 32), p4 = t4 = w3, o4 = Y4 + CA2 | 0, Y4 = o4 = (t4 = D4 + v4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + p4 | 0, o4 = (D4 = t4) >>> 0 > (t4 = t4 + f4 | 0) >>> 0 ? o4 + 1 | 0 : o4, v4 = t4, t4 ^= l4, l4 = o4, y4 = nA(t4, o4 ^ y4, 40), o4 = (Z3 = w3) + F4 | 0, p4 = nA(F4 = (t4 = y4 + N4 | 0) ^ f4, p4 ^ (f4 = t4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(p4 ^ u4, (o4 = K4) ^ (K4 = w3), 32), $3 = u4 = w3, F4 = o4, N4 = e4, e4 = r4, o4 = nA(D4 ^ k4, Y4 ^ IA2, 1), M4 = r4 = w3, D4 = o4, o4 = H4 + FA2 | 0, o4 = ((k4 = U4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, k4 = o4 = (r4 = D4 + k4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(r4 ^ e4, o4 ^ G4, 32), o4 = (o4 = N4) + (N4 = w3) | 0, D4 = nA((n4 = e4 + n4 | 0) ^ D4, M4 ^ (Y4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = k4 + (IA2 = w3) | 0, U4 = D4, o4 = SA2 + ((H4 = r4) >>> 0 > (r4 = r4 + D4 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, H4 = o4 = (D4 = r4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(e4 ^ D4, N4 ^ o4, 48), o4 = Y4 + (CA2 = w3) | 0, G4 = n4, e4 = r4, Y4 = n4 = n4 + r4 | 0, N4 = o4 = G4 >>> 0 > n4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + u4 | 0, G4 = o4 = (u4 = n4 + F4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = (k4 = nA(u4 ^ m4, o4 ^ R4, 40)) + GA2 | 0, o4 = (GA2 = w3) + b4 | 0, M4 = n4, O4 = n4 >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(_4 ^ V4, L4 ^ wA2, 48), o4 = (_4 = w3) + j4 | 0, J4 = r4 = n4 + J4 | 0, m4 = S4, S4 = o4 = r4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(r4 ^ c4, m4 ^ o4, 1), V4 = r4 = w3, c4 = o4, o4 = f4 + C4 | 0, o4 = ((t4 = t4 + sA2 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, o4 = uA2 + (t4 = (r4 = t4 + c4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) | 0, L4 = f4 = r4 + T4 | 0, f4 = o4 = f4 >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(r4 ^ e4, t4 ^ CA2, 32), o4 = W4 + (b4 = w3) | 0, j4 = r4, r4 = (e4 = s4 + r4 | 0) ^ c4, c4 = o4 = e4 >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, t4 = nA(r4, V4 ^ o4, 40), o4 = (o4 = f4) + (f4 = w3) | 0, V4 = r4 = t4 + L4 | 0, r4 = nA(s4 = r4 ^ j4, b4 ^ (j4 = r4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = c4 + (CA2 = w3) | 0, W4 = r4, e4 = o4 = (r4 = e4 + r4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, t4 = nA(r4 ^ t4, f4 ^ o4, 1), o4 = (s4 = w3) + O4 | 0, o4 = pA2 + ((f4 = t4 + M4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (c4 = (f4 = f4 + oA2 | 0) >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4) + BA2 | 0, AA2 = L4 = f4 + q4 | 0, L4 = o4 = L4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, b4 = t4, m4 = f4, R4 = c4, t4 = nA(U4 ^ Y4, N4 ^ IA2, 1), o4 = (N4 = w3) + DA2 | 0, o4 = P4 + (t4 >>> 0 > (f4 = t4 + gA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, c4 = o4 = (f4 = f4 + h4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(n4 ^ f4, o4 ^ _4, 32), _4 = n4 = w3, h4 = o4, o4 = l4 + K4 | 0, o4 = (n4 = p4 + v4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, p4 = n4, Y4 = o4, o4 = _4 + o4 | 0, l4 = n4 = n4 + h4 | 0, U4 = o4 = p4 >>> 0 > n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(n4 ^ t4, N4 ^ o4, 40), o4 = c4 + (K4 = w3) | 0, v4 = n4, o4 = tA2 + ((n4 = f4 + n4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (n4 = n4 + X4 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4, N4 = n4, n4 ^= h4, h4 = o4, c4 = nA(n4, _4 ^ o4, 48), o4 = nA(c4 ^ m4, (o4 = R4) ^ (R4 = w3), 32), IA2 = n4 = w3, _4 = o4, P4 = n4, n4 = nA(y4 ^ p4, Y4 ^ Z3, 1), o4 = FA2 + (f4 = w3) | 0, o4 = H4 + ((t4 = n4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (y4 = (t4 = t4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4) + x4 | 0, H4 = p4 = t4 + aA2 | 0, p4 = o4 = p4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, D4 = n4, Y4 = f4, n4 = (t4 = nA(t4 ^ d4, y4 ^ kA2, 32)) + J4 | 0, o4 = (J4 = w3) + S4 | 0, f4 = n4, y4 = nA(y4 = n4 ^ D4, (D4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) ^ Y4, 40), o4 = (Z3 = w3) + p4 | 0, p4 = n4 = y4 + H4 | 0, t4 = nA(n4 ^ t4, J4 ^ (S4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = D4 + (Y4 = w3) | 0, H4 = n4 = t4 + f4 | 0, J4 = o4 = n4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + P4 | 0, P4 = o4 = (D4 = n4 + _4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(D4 ^ b4, o4 ^ s4, 40), o4 = (d4 = w3) + L4 | 0, L4 = n4 = f4 + AA2 | 0, b4 = o4 = n4 >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, n4 = r4, s4 = e4, e4 = t4, r4 = nA(F4 ^ M4, O4 ^ $3, 48), o4 = G4 + (AA2 = w3) | 0, F4 = r4, u4 = o4 = (t4 = u4 + r4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(t4 ^ k4, GA2 ^ o4, 1), G4 = r4 = w3, k4 = o4, o4 = h4 + HA2 | 0, o4 = ((h4 = N4 + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, h4 = o4 = (r4 = h4 + k4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(r4 ^ e4, o4 ^ Y4, 32), o4 = (N4 = w3) + s4 | 0, k4 = nA((n4 = e4 + n4 | 0) ^ k4, G4 ^ (s4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = h4 + (M4 = w3) | 0, o4 = lA2 + ((h4 = r4) >>> 0 > (r4 = r4 + k4 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, Y4 = o4 = (h4 = r4 + QA2 | 0) >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(e4 ^ h4, N4 ^ o4, 48), o4 = s4 + ($3 = w3) | 0, N4 = r4, G4 = o4 = (s4 = n4 + r4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(s4 ^ k4, M4 ^ o4, 1), o4 = (k4 = w3) + b4 | 0, o4 = hA2 + ((r4 = n4 + L4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = pA2 + (e4 = (r4 = r4 + EA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, wA2 = M4 = r4 + oA2 | 0, M4 = o4 = M4 >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4, O4 = n4, m4 = r4, n4 = nA(y4 ^ H4, J4 ^ Z3, 1), o4 = (y4 = w3) + j4 | 0, o4 = MA2 + ((r4 = n4 + V4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = SA2 + (H4 = (r4 = r4 + rA2 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, V4 = J4 = r4 + iA2 | 0, J4 = o4 = J4 >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4, j4 = n4, o4 = nA(r4 ^ F4, H4 ^ AA2, 32), AA2 = n4 = w3, r4 = o4, o4 = U4 + R4 | 0, l4 = n4 = c4 + l4 | 0, F4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, o4 = AA2 + o4 | 0, U4 = o4 = (c4 = n4 + r4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(c4 ^ j4, o4 ^ y4, 40), o4 = (R4 = w3) + J4 | 0, H4 = n4 = y4 + V4 | 0, j4 = nA(n4 ^ r4, AA2 ^ (J4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(j4 ^ m4, (AA2 = w3) ^ e4, 32), Z3 = n4 = w3, V4 = o4, e4 = n4, r4 = eA2, n4 = nA(l4 ^ v4, F4 ^ K4, 1), o4 = S4 + (F4 = w3) | 0, o4 = ((l4 = p4) >>> 0 > (p4 = n4 + p4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + yA2 | 0, o4 = hA2 + (p4 = (r4 = r4 + p4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4) | 0, l4 = S4 = r4 + EA2 | 0, S4 = o4 = S4 >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(r4 ^ W4, p4 ^ CA2, 32), o4 = u4 + (v4 = w3) | 0, u4 = r4, o4 = (r4 = t4 + r4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = F4, F4 = o4, t4 = nA(n4 ^ r4, t4 ^ o4, 40), o4 = (K4 = w3) + S4 | 0, p4 = n4 = t4 + l4 | 0, n4 = nA(n4 ^ u4, v4 ^ (S4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = F4 + (m4 = w3) | 0, F4 = n4, l4 = n4 = r4 + n4 | 0, v4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + e4 | 0, o4 = (u4 = n4 + V4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = u4 ^ O4, O4 = o4, k4 = nA(n4, o4 ^ k4, 40), o4 = (CA2 = w3) + M4 | 0, M4 = n4 = k4 + wA2 | 0, W4 = n4 >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(_4 ^ L4, b4 ^ IA2, 48), o4 = P4 + (IA2 = w3) | 0, _4 = n4, o4 = (n4 = D4 + n4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, D4 = n4, P4 = o4, o4 = nA(n4 ^ f4, o4 ^ d4, 1), d4 = n4 = w3, e4 = o4, o4 = J4 + uA2 | 0, o4 = ((r4 = H4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) + n4 | 0, o4 = lA2 + (r4 = (n4 = r4 + e4 | 0) >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4) | 0, H4 = f4 = n4 + QA2 | 0, f4 = o4 = f4 >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(n4 ^ F4, r4 ^ m4, 32), o4 = G4 + (J4 = w3) | 0, F4 = n4, s4 = o4 = (r4 = s4 + n4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(r4 ^ e4, d4 ^ o4, 40), o4 = (d4 = w3) + f4 | 0, H4 = n4 = e4 + H4 | 0, n4 = nA(f4 = n4 ^ F4, J4 ^ (F4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = s4 + (wA2 = w3) | 0, s4 = n4, G4 = o4 = (f4 = r4 + n4 | 0) >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(f4 ^ e4, d4 ^ o4, 1), o4 = (J4 = w3) + W4 | 0, o4 = FA2 + ((r4 = n4 + M4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (e4 = (r4 = r4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) + DA2 | 0, kA2 = d4 = r4 + gA2 | 0, d4 = o4 = d4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, L4 = n4, b4 = r4, m4 = e4, n4 = nA(t4 ^ l4, K4 ^ v4, 1), o4 = MA2 + (e4 = w3) | 0, o4 = Y4 + ((r4 = n4 + rA2 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = HA2 + (t4 = (r4 = r4 + h4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4) | 0, v4 = h4 = r4 + fA2 | 0, h4 = o4 = h4 >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4, Y4 = n4, l4 = e4, o4 = nA(r4 ^ _4, t4 ^ IA2, 32), _4 = n4 = w3, t4 = o4, r4 = n4, o4 = U4 + AA2 | 0, o4 = (n4 = c4 + j4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, c4 = n4, U4 = o4, o4 = o4 + r4 | 0, o4 = (e4 = n4 + t4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = e4 ^ Y4, Y4 = o4, n4 = nA(n4, o4 ^ l4, 40), o4 = (o4 = h4) + (h4 = w3) | 0, l4 = r4 = n4 + v4 | 0, v4 = o4 = r4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, _4 = nA(r4 ^ t4, _4 ^ o4, 48), o4 = nA(_4 ^ b4, (o4 = m4) ^ (m4 = w3), 32), K4 = r4 = w3, j4 = o4, r4 = nA(c4 ^ y4, U4 ^ R4, 1), o4 = (c4 = w3) + yA2 | 0, o4 = S4 + ((t4 = r4 + eA2 | 0) >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = C4 + (y4 = (t4 = t4 + p4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4) | 0, R4 = p4 = t4 + sA2 | 0, p4 = o4 = p4 >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4, S4 = r4, U4 = c4, t4 = nA(t4 ^ N4, y4 ^ $3, 32), o4 = (N4 = w3) + P4 | 0, c4 = r4 = t4 + D4 | 0, r4 = (y4 = nA(r4 ^ S4, (D4 = r4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4) ^ U4, 40)) + R4 | 0, o4 = (R4 = w3) + p4 | 0, S4 = r4, r4 = nA(r4 ^ t4, N4 ^ (U4 = r4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = D4 + (AA2 = w3) | 0, N4 = r4, P4 = r4 = c4 + r4 | 0, b4 = o4 = r4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, o4 = K4 + o4 | 0, o4 = (t4 = r4 + j4 | 0) >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, r4 = J4, J4 = o4, c4 = nA(t4 ^ L4, r4 ^ o4, 40), o4 = (IA2 = w3) + d4 | 0, p4 = r4 = c4 + kA2 | 0, o4 = nA(r4 ^ j4, K4 ^ (d4 = r4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4), 48), K4 = r4 = w3, j4 = o4, r4 = n4, o4 = Y4 + m4 | 0, Y4 = n4 = e4 + _4 | 0, _4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(n4 ^ r4, o4 ^ h4, 1), e4 = r4 = w3, n4 = o4, o4 = U4 + B4 | 0, o4 = ((D4 = S4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, o4 = tA2 + (D4 = (r4 = n4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4) | 0, m4 = h4 = r4 + X4 | 0, h4 = o4 = h4 >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4, S4 = n4, U4 = e4, n4 = nA(M4 ^ V4, W4 ^ Z3, 48), o4 = O4 + (Z3 = w3) | 0, M4 = n4, o4 = (n4 = u4 + n4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, u4 = n4, r4 = nA(r4 ^ s4, D4 ^ wA2, 32), O4 = o4, o4 = o4 + (V4 = w3) | 0, e4 = n4 = r4 + n4 | 0, D4 = nA(n4 ^ S4, (s4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4) ^ U4, 40), o4 = (W4 = w3) + h4 | 0, h4 = n4 = D4 + m4 | 0, n4 = nA(n4 ^ r4, V4 ^ (S4 = n4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = s4 + ($3 = w3) | 0, U4 = n4, V4 = o4 = (s4 = e4 + n4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(D4 ^ s4, W4 ^ o4, 1), o4 = lA2 + (m4 = w3) | 0, W4 = n4, wA2 = n4 = QA2 + n4 | 0, e4 = o4 = n4 >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(k4 ^ u4, O4 ^ CA2, 1), o4 = (D4 = w3) + v4 | 0, o4 = SA2 + ((r4 = n4 + l4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = BA2 + (u4 = (r4 = r4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, O4 = k4 = r4 + q4 | 0, k4 = o4 = k4 >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4, l4 = D4, r4 = nA(r4 ^ N4, u4 ^ AA2, 32), o4 = G4 + (AA2 = w3) | 0, v4 = r4, o4 = (D4 = f4 + r4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, f4 = l4, l4 = o4, u4 = nA(n4 ^ D4, f4 ^ o4, 40), o4 = (CA2 = w3) + k4 | 0, N4 = n4 = u4 + O4 | 0, o4 = (G4 = n4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4) + e4 | 0, k4 = o4 = (e4 = n4 + wA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, O4 = o4 = nA(e4 ^ j4, o4 ^ K4, 32), L4 = n4 = w3, n4 = nA(y4 ^ P4, b4 ^ R4, 1), o4 = (f4 = w3) + F4 | 0, o4 = z4 + ((r4 = n4 + H4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (y4 = (r4 = I7 + r4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4) + x4 | 0, b4 = F4 = r4 + aA2 | 0, F4 = o4 = F4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, H4 = n4, P4 = f4, r4 = nA(r4 ^ M4, y4 ^ Z3, 32), o4 = (M4 = w3) + _4 | 0, f4 = n4 = r4 + Y4 | 0, n4 = (y4 = nA(n4 ^ H4, (Y4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4) ^ P4, 40)) + b4 | 0, o4 = (b4 = w3) + F4 | 0, F4 = n4, n4 = nA(n4 ^ r4, M4 ^ (H4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = Y4 + (Z3 = w3) | 0, Y4 = n4, M4 = o4 = (n4 = f4 + n4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + L4 | 0, _4 = o4 = (f4 = n4) >>> 0 > (n4 = n4 + O4 | 0) >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(n4 ^ W4, m4 ^ o4, 40), o4 = k4 + (m4 = w3) | 0, P4 = r4, o4 = B4 + ((r4 = e4 + r4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4) | 0, W4 = r4 = r4 + g6 | 0, e4 = r4 ^ O4, O4 = o4 = r4 >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4, r4 = nA(e4, L4 ^ o4, 48), o4 = _4 + (L4 = w3) | 0, _4 = o4 = (k4 = n4 + r4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = o4 = nA(k4 ^ P4, m4 ^ o4, 1), P4 = e4 = w3, e4 = nA(f4 ^ y4, M4 ^ b4, 1), o4 = S4 + (y4 = w3) | 0, o4 = SA2 + ((f4 = e4 + h4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = hA2 + (h4 = (f4 = f4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, m4 = S4 = f4 + EA2 | 0, S4 = o4 = S4 >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4, M4 = e4, b4 = y4, o4 = J4 + K4 | 0, o4 = (e4 = t4 + j4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, J4 = e4, v4 = nA(N4 ^ v4, G4 ^ AA2, 48), y4 = nA(f4 ^ v4, h4 ^ (AA2 = w3), 32), N4 = o4, o4 = o4 + (wA2 = w3) | 0, h4 = e4 = y4 + e4 | 0, e4 = nA(e4 ^ M4, (G4 = e4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4) ^ b4, 40), o4 = (M4 = w3) + S4 | 0, b4 = o4 = (t4 = e4 + m4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + P4 | 0, o4 = C4 + ((j4 = t4) >>> 0 > (t4 = n4 + t4 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (f4 = (t4 = t4 + sA2 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) + yA2 | 0, kA2 = S4 = t4 + eA2 | 0, m4 = o4 = S4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, R4 = n4, K4 = t4, o4 = nA(c4 ^ J4, N4 ^ IA2, 1), c4 = t4 = w3, n4 = o4, o4 = H4 + MA2 | 0, o4 = ((S4 = F4 + rA2 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, o4 = tA2 + (S4 = (t4 = n4 + S4 | 0) >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4) | 0, N4 = F4 = t4 + X4 | 0, F4 = o4 = F4 >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4, H4 = n4, o4 = nA(t4 ^ U4, S4 ^ $3, 32), J4 = n4 = w3, t4 = o4, S4 = n4, o4 = l4 + AA2 | 0, l4 = n4 = D4 + v4 | 0, U4 = o4 = n4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + S4 | 0, o4 = (D4 = n4 + t4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4;
                      n4 = D4 ^ H4, H4 = o4, S4 = nA(n4, o4 ^ c4, 40), o4 = (AA2 = w3) + F4 | 0, v4 = nA(F4 = (n4 = S4 + N4 | 0) ^ t4, J4 ^ (t4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = nA(o4 = v4 ^ K4, (K4 = w3) ^ f4, 32), IA2 = f4 = w3, N4 = o4, F4 = f4, f4 = nA(u4 ^ l4, U4 ^ CA2, 1), o4 = BA2 + (u4 = w3) | 0, o4 = d4 + ((c4 = f4 + q4 | 0) >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = FA2 + (p4 = (c4 = c4 + p4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4) | 0, U4 = l4 = c4 + cA2 | 0, l4 = o4 = l4 >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ Y4, p4 ^ Z3, 32), o4 = V4 + (J4 = w3) | 0, Y4 = c4, s4 = o4 = (c4 = s4 + c4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, p4 = nA(f4 ^ c4, o4 ^ u4, 40), o4 = (Z3 = w3) + l4 | 0, u4 = f4 = p4 + U4 | 0, f4 = nA(l4 = f4 ^ Y4, J4 ^ (Y4 = f4 >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = s4 + ($3 = w3) | 0, l4 = f4, U4 = f4 = c4 + f4 | 0, J4 = o4 = f4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, o4 = o4 + F4 | 0, o4 = (c4 = f4 + N4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4, f4 = P4, P4 = o4, s4 = nA(c4 ^ R4, f4 ^ o4, 40), o4 = (d4 = w3) + m4 | 0, F4 = f4 = s4 + kA2 | 0, f4 = nA(m4 = f4 ^ N4, IA2 ^ (N4 = f4 >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = P4 + (IA2 = w3) | 0, P4 = f4, c4 = o4 = (f4 = c4 + f4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, d4 = o4 = nA(f4 ^ s4, d4 ^ o4, 1), CA2 = o4, V4 = s4 = w3, s4 = t4, t4 = e4, e4 = nA(y4 ^ j4, b4 ^ wA2, 48), o4 = G4 + (wA2 = w3) | 0, G4 = e4, o4 = (e4 = h4 + e4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, h4 = n4, n4 = t4 ^ e4, t4 = o4, n4 = nA(n4, o4 ^ M4, 1), o4 = (M4 = w3) + s4 | 0, o4 = HA2 + (n4 >>> 0 > (y4 = h4 + n4 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = DA2 + (h4 = (y4 = y4 + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, j4 = s4 = y4 + gA2 | 0, s4 = o4 = s4 >>> 0 < gA2 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(y4 ^ l4, h4 ^ $3, 32), o4 = _4 + (b4 = w3) | 0, l4 = o4 = (h4 = y4 + k4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, k4 = nA(n4 ^ h4, M4 ^ o4, 40), o4 = ($3 = w3) + s4 | 0, M4 = n4 = k4 + j4 | 0, y4 = nA(n4 ^ y4, b4 ^ (_4 = n4 >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4), 48), o4 = l4 + (j4 = w3) | 0, b4 = n4 = y4 + h4 | 0, l4 = n4, m4 = o4 = n4 >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, h4 = e4, s4 = t4, o4 = H4 + K4 | 0, o4 = (n4 = D4 + v4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, D4 = n4, n4 ^= S4, S4 = o4, o4 = nA(n4, AA2 ^ o4, 1), R4 = n4 = w3, H4 = o4, t4 = o4, o4 = Y4 + x4 | 0, o4 = ((e4 = u4 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) + n4 | 0, u4 = o4 = (n4 = e4) >>> 0 > (e4 = t4 + e4 | 0) >>> 0 ? o4 + 1 | 0 : o4, t4 = nA(r4 ^ e4, o4 ^ L4, 32), o4 = (o4 = s4) + (s4 = w3) | 0, v4 = n4 = t4 + h4 | 0, r4 = nA(r4 = n4 ^ H4, R4 ^ (H4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = u4 + (L4 = w3) | 0, o4 = uA2 + ((n4 = r4 + e4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4) | 0, R4 = o4 = (h4 = n4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4, s4 = nA(t4 ^ h4, s4 ^ o4, 48), kA2 = o4 = w3, n4 = nA(p4 ^ U4, J4 ^ Z3, 1), o4 = (t4 = w3) + O4 | 0, o4 = pA2 + ((e4 = n4 + W4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = z4 + (p4 = (e4 = e4 + oA2 | 0) >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, O4 = u4 = I7 + e4 | 0, U4 = o4 = u4 >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4, J4 = n4, u4 = nA(e4 ^ G4, p4 ^ wA2, 32), o4 = (Z3 = w3) + S4 | 0, S4 = n4 = u4 + D4 | 0, e4 = nA(n4 ^ J4, (G4 = n4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4) ^ t4, 40), o4 = (o4 = U4) + (U4 = w3) | 0, J4 = n4 = e4 + O4 | 0, O4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, t4 = o4, o4 = z4 + V4 | 0, o4 = ((p4 = I7 + d4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, Y4 = o4 = (t4 = n4 + p4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(t4 ^ s4, kA2 ^ o4, 32), o4 = (d4 = w3) + m4 | 0, D4 = nA((p4 = n4 + l4 | 0) ^ CA2, (o4 = p4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ V4, 40), V4 = o4, o4 = DA2 + (l4 = w3) | 0, o4 = Y4 + ((W4 = D4 + gA2 | 0) >>> 0 < gA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (Y4 = t4 + W4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = d4, d4 = o4, t4 = nA(n4 ^ Y4, t4 ^ o4, 48), o4 = (o4 = V4) + (V4 = w3) | 0, n4 = D4 ^ (p4 = t4 + p4 | 0), D4 = o4 = p4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, W4 = o4 = nA(n4, o4 ^ l4, 1), CA2 = o4, K4 = n4 = w3, l4 = f4, AA2 = c4, f4 = e4, e4 = nA(u4 ^ J4, O4 ^ Z3, 48), o4 = G4 + (J4 = w3) | 0, u4 = n4 = e4 + S4 | 0, S4 = o4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ U4, 1), o4 = (O4 = w3) + HA2 | 0, o4 = R4 + ((n4 = f4 + fA2 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, h4 = o4 = (c4 = n4 + h4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(c4 ^ y4, o4 ^ j4, 32), o4 = (U4 = w3) + AA2 | 0, l4 = y4 = n4 + l4 | 0, G4 = o4 = y4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(f4 ^ y4, o4 ^ O4, 40), o4 = hA2 + (wA2 = w3) | 0, O4 = f4, o4 = h4 + ((f4 = EA2 + f4 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, c4 = o4 = (f4 = f4 + c4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(n4 ^ f4, o4 ^ U4, 48), o4 = (o4 = G4) + (G4 = w3) | 0, j4 = n4 = y4 + l4 | 0, U4 = n4, R4 = o4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, o4 = H4 + kA2 | 0, l4 = (n4 = s4 + v4 | 0) ^ r4, r4 = o4 = n4 >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(l4, o4 ^ L4, 1), L4 = h4 = w3, l4 = o4, o4 = _4 + tA2 | 0, o4 = ((s4 = M4 + X4 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4) + h4 | 0, H4 = o4 = (H4 = s4) >>> 0 > (s4 = s4 + l4 | 0) >>> 0 ? o4 + 1 | 0 : o4, v4 = h4 = nA(s4 ^ P4, IA2 ^ o4, 32), M4 = o4 = w3, o4 = o4 + S4 | 0, _4 = h4 = h4 + u4 | 0, P4 = o4 = v4 >>> 0 > h4 >>> 0 ? o4 + 1 | 0 : o4, h4 = nA(h4 ^ l4, L4 ^ o4, 40), o4 = yA2 + (L4 = w3) | 0, o4 = H4 + ((u4 = h4 + eA2 | 0) >>> 0 < eA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (l4 = s4) >>> 0 > (s4 = s4 + u4 | 0) >>> 0 ? o4 + 1 | 0 : o4, l4 = nA(s4 ^ v4, o4 ^ M4, 48), IA2 = o4 = w3, S4 = o4, k4 = nA(k4 ^ b4, m4 ^ $3, 1), H4 = o4 = w3, v4 = e4, o4 = o4 + x4 | 0, o4 = N4 + ((e4 = k4 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (e4 = e4 + F4 | 0) >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4, F4 = e4 ^ v4, v4 = o4, F4 = nA(F4, o4 ^ J4, 32), o4 = ($3 = w3) + r4 | 0, N4 = n4 = F4 + n4 | 0, r4 = nA(n4 ^ k4, (r4 = H4) ^ (H4 = n4 >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = pA2 + (M4 = w3) | 0, o4 = v4 + ((n4 = r4 + oA2 | 0) >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, v4 = n4 = n4 + e4 | 0, J4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = o4, o4 = K4 + SA2 | 0, o4 = ((k4 = W4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4) + e4 | 0, W4 = o4 = (e4 = n4 + k4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(e4 ^ l4, o4 ^ S4, 32), o4 = (b4 = w3) + R4 | 0, S4 = nA((k4 = n4 + U4 | 0) ^ CA2, (o4 = k4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), m4 = U4 = w3, K4 = o4, o4 = U4 + FA2 | 0, o4 = W4 + ((U4 = S4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, W4 = o4 = (U4 = e4 + U4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = nA(n4 ^ U4, o4 ^ b4, 48), o4 = (b4 = w3) + K4 | 0, n4 = (k4 = e4 + k4 | 0) ^ S4, S4 = o4 = k4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, m4 = o4 = nA(n4, o4 ^ m4, 1), K4 = n4 = w3, AA2 = p4, Z3 = y4, y4 = r4, r4 = nA(F4 ^ v4, J4 ^ $3, 48), o4 = (F4 = w3) + H4 | 0, H4 = n4 = r4 + N4 | 0, v4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(n4 ^ y4, o4 ^ M4, 1), o4 = (M4 = w3) + lA2 | 0, o4 = ((n4 = y4 + QA2 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4) + u4 | 0, s4 = o4 = (p4 = n4 + s4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(p4 ^ Z3, o4 ^ G4, 32), o4 = (u4 = w3) + D4 | 0, N4 = D4 = n4 + AA2 | 0, G4 = o4 = D4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(y4 ^ D4, o4 ^ M4, 40), o4 = C4 + (Z3 = w3) | 0, M4 = y4, o4 = s4 + ((y4 = sA2 + y4 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, J4 = o4 = (D4 = y4 + p4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(n4 ^ D4, o4 ^ u4, 48), o4 = (o4 = G4) + (G4 = w3) | 0, N4 = n4 = y4 + N4 | 0, AA2 = o4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, s4 = t4, p4 = f4, o4 = P4 + IA2 | 0, t4 = o4 = (n4 = l4 + _4 | 0) >>> 0 < l4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ h4, o4 ^ L4, 1), o4 = (h4 = w3) + BA2 | 0, o4 = ((u4 = f4 + q4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) + c4 | 0, c4 = nA(s4 ^ (p4 = p4 + u4 | 0), (o4 = p4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4) ^ V4, 32), u4 = o4, l4 = f4, o4 = (s4 = w3) + v4 | 0, o4 = (f4 = c4 + H4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, H4 = f4, f4 ^= l4, l4 = o4, f4 = nA(f4, o4 ^ h4, 40), o4 = B4 + (v4 = w3) | 0, o4 = ((h4 = f4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) + u4 | 0, _4 = o4 = (u4 = h4) >>> 0 > (h4 = h4 + p4 | 0) >>> 0 ? o4 + 1 | 0 : o4, s4 = nA(c4 ^ h4, o4 ^ s4, 48), IA2 = o4 = w3, p4 = o4, c4 = nA(j4 ^ O4, R4 ^ wA2, 1), P4 = o4 = w3, O4 = t4, o4 = o4 + uA2 | 0, o4 = d4 + ((t4 = c4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = F4, F4 = o4 = (t4 = t4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? o4 + 1 | 0 : o4, u4 = nA(r4 ^ t4, u4 ^ o4, 32), o4 = ($3 = w3) + O4 | 0, Y4 = n4 = u4 + n4 | 0, r4 = nA(n4 ^ c4, (r4 = P4) ^ (P4 = n4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = MA2 + (O4 = w3) | 0, o4 = F4 + ((n4 = r4 + rA2 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, d4 = n4 = n4 + t4 | 0, j4 = o4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = o4, o4 = K4 + tA2 | 0, o4 = ((c4 = X4 + m4 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, F4 = o4 = (t4 = n4 + c4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(t4 ^ s4, o4 ^ p4, 32), o4 = (V4 = w3) + AA2 | 0, p4 = nA((c4 = n4 + N4 | 0) ^ m4, (o4 = c4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), m4 = o4, o4 = x4 + (L4 = w3) | 0, o4 = F4 + ((R4 = p4 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (F4 = t4 + R4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = V4, V4 = o4, t4 = nA(n4 ^ F4, t4 ^ o4, 48), o4 = (o4 = m4) + (m4 = w3) | 0, n4 = (c4 = t4 + c4 | 0) ^ p4, p4 = o4 = c4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, L4 = o4 = nA(n4, o4 ^ L4, 1), R4 = n4 = w3, K4 = y4, y4 = r4, r4 = nA(u4 ^ d4, j4 ^ $3, 48), o4 = (o4 = P4) + (P4 = w3) | 0, Y4 = n4 = r4 + Y4 | 0, u4 = O4, O4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(n4 ^ y4, u4 ^ o4, 1), o4 = (d4 = w3) + FA2 | 0, o4 = _4 + ((n4 = y4 + cA2 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = h4, h4 = n4 + h4 | 0, n4 = G4, G4 = o4 = u4 >>> 0 > h4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(h4 ^ K4, n4 ^ o4, 32), o4 = (o4 = S4) + (S4 = w3) | 0, _4 = o4 = (u4 = n4 + k4 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, k4 = u4, y4 = nA(y4 ^ u4, o4 ^ d4, 40), o4 = uA2 + ($3 = w3) | 0, d4 = y4, o4 = G4 + ((y4 = T4 + y4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) | 0, G4 = o4 = (u4 = y4 + h4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(n4 ^ u4, o4 ^ S4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, j4 = n4 = y4 + k4 | 0, K4 = o4 = n4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, k4 = e4, o4 = l4 + IA2 | 0, e4 = o4 = (n4 = s4 + H4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ v4, 1), o4 = DA2 + (s4 = w3) | 0, o4 = J4 + ((h4 = f4 + gA2 | 0) >>> 0 < gA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, l4 = (h4 = D4 + h4 | 0) ^ k4, k4 = o4 = h4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(l4, o4 ^ b4, 32), S4 = o4 = w3, l4 = f4, o4 = o4 + O4 | 0, o4 = (f4 = D4 + Y4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, H4 = f4, f4 ^= l4, l4 = o4, f4 = nA(f4, o4 ^ s4, 40), o4 = B4 + (v4 = w3) | 0, o4 = k4 + ((s4 = f4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) | 0, J4 = o4 = (s4 = h4 + s4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, k4 = nA(D4 ^ s4, o4 ^ S4, 48), IA2 = o4 = w3, h4 = o4, D4 = nA(M4 ^ N4, Z3 ^ AA2, 1), Y4 = o4 = w3, N4 = e4, o4 = o4 + C4 | 0, o4 = W4 + ((e4 = D4 + sA2 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, U4 = o4 = (e4 = e4 + U4 | 0) >>> 0 < U4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ e4, o4 ^ P4, 32), o4 = (CA2 = w3) + N4 | 0, N4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ D4, (M4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4) ^ Y4, 40), o4 = z4 + (P4 = w3) | 0, o4 = U4 + ((n4 = I7 + r4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4) | 0, U4 = n4 = n4 + e4 | 0, O4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = o4, o4 = R4 + pA2 | 0, o4 = ((D4 = L4 + oA2 | 0) >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4) + e4 | 0, Y4 = o4 = (e4 = n4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(e4 ^ k4, o4 ^ h4, 32), o4 = (W4 = w3) + K4 | 0, h4 = nA((D4 = n4 + j4 | 0) ^ L4, (o4 = D4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ R4, 40), b4 = o4, o4 = HA2 + (L4 = w3) | 0, o4 = Y4 + ((R4 = h4 + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (Y4 = e4 + R4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = W4, W4 = o4, e4 = nA(n4 ^ Y4, e4 ^ o4, 48), o4 = (o4 = b4) + (b4 = w3) | 0, n4 = (D4 = e4 + D4 | 0) ^ h4, h4 = o4 = D4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, L4 = o4 = nA(n4, o4 ^ L4, 1), wA2 = o4, R4 = n4 = w3, AA2 = c4, Z3 = y4, c4 = r4, r4 = nA(S4 ^ U4, O4 ^ CA2, 48), o4 = (S4 = w3) + M4 | 0, U4 = n4 = r4 + N4 | 0, N4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ P4, 1), o4 = (P4 = w3) + yA2 | 0, o4 = J4 + ((n4 = c4 + eA2 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (y4 = n4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(y4 ^ Z3, o4 ^ _4, 32), o4 = (M4 = w3) + p4 | 0, _4 = o4 = (p4 = n4 + AA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ p4, o4 ^ P4, 40), o4 = lA2 + (CA2 = w3) | 0, J4 = c4, o4 = s4 + ((c4 = QA2 + c4 | 0) >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = c4 + y4 | 0, c4 = M4, M4 = o4 = s4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ s4, c4 ^ o4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, P4 = n4 = c4 + p4 | 0, O4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = t4, o4 = l4 + IA2 | 0, t4 = o4 = (n4 = k4 + H4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ v4, 1), o4 = (k4 = w3) + MA2 | 0, o4 = G4 + ((p4 = f4 + rA2 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, y4 = nA(y4 ^ (p4 = p4 + u4 | 0), (o4 = p4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4) ^ m4, 32), l4 = u4 = w3, u4 = o4, H4 = f4, o4 = l4 + N4 | 0, o4 = (f4 = y4 + U4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, U4 = f4, f4 ^= H4, H4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = hA2 + (v4 = w3) | 0, o4 = ((k4 = f4 + EA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) + u4 | 0, G4 = l4, l4 = o4 = (u4 = p4 + k4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, k4 = nA(y4 ^ u4, G4 ^ o4, 48), IA2 = o4 = w3, p4 = o4, y4 = nA(j4 ^ d4, K4 ^ $3, 1), N4 = o4 = w3, G4 = t4, o4 = o4 + BA2 | 0, o4 = V4 + ((t4 = y4 + q4 | 0) >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4) | 0, F4 = o4 = (t4 = t4 + F4 | 0) >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ t4, o4 ^ S4, 32), o4 = ($3 = w3) + G4 | 0, G4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ y4, (r4 = N4) ^ (N4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = SA2 + (d4 = w3) | 0, o4 = F4 + ((n4 = r4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, j4 = n4 = n4 + t4 | 0, V4 = o4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = o4, o4 = R4 + B4 | 0, o4 = ((y4 = L4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, F4 = o4 = (t4 = n4 + y4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(t4 ^ k4, o4 ^ p4, 32), o4 = (L4 = w3) + O4 | 0, p4 = nA((y4 = n4 + P4 | 0) ^ wA2, (o4 = y4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ R4, 40), R4 = o4, o4 = FA2 + (m4 = w3) | 0, o4 = F4 + ((K4 = p4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (F4 = t4 + K4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = L4, L4 = o4, t4 = nA(n4 ^ F4, t4 ^ o4, 48), o4 = (o4 = R4) + (R4 = w3) | 0, n4 = (y4 = t4 + y4 | 0) ^ p4, p4 = o4 = y4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, m4 = o4 = nA(n4, o4 ^ m4, 1), K4 = n4 = w3, AA2 = D4, Z3 = c4, c4 = r4, r4 = nA(S4 ^ j4, V4 ^ $3, 48), o4 = (S4 = w3) + N4 | 0, N4 = n4 = r4 + G4 | 0, G4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ d4, 1), o4 = (d4 = w3) + lA2 | 0, o4 = l4 + ((n4 = c4 + QA2 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (D4 = n4 + u4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(D4 ^ Z3, o4 ^ _4, 32), o4 = (l4 = w3) + h4 | 0, _4 = o4 = (h4 = n4 + AA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ h4, o4 ^ d4, 40), o4 = BA2 + ($3 = w3) | 0, d4 = c4, o4 = u4 + ((c4 = q4 + c4 | 0) >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = c4 + D4 | 0, c4 = l4, l4 = o4 = u4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ u4, c4 ^ o4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, j4 = n4 = c4 + h4 | 0, V4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, D4 = e4, o4 = H4 + IA2 | 0, e4 = o4 = (n4 = k4 + U4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ v4, 1), o4 = SA2 + (k4 = w3) | 0, o4 = M4 + ((h4 = f4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (h4 = h4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(D4 ^ h4, o4 ^ b4, 32), U4 = o4 = w3, H4 = f4, o4 = o4 + G4 | 0, o4 = (f4 = D4 + N4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, v4 = f4, f4 ^= H4, H4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = pA2 + (N4 = w3) | 0, o4 = s4 + ((k4 = f4 + oA2 | 0) >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (s4 = h4 + k4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, h4 = U4, U4 = o4, k4 = nA(D4 ^ s4, h4 ^ o4, 48), IA2 = o4 = w3, h4 = o4, D4 = nA(J4 ^ P4, O4 ^ CA2, 1), G4 = o4 = w3, M4 = e4, o4 = o4 + z4 | 0, o4 = W4 + ((e4 = I7 + D4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4) | 0, Y4 = o4 = (e4 = e4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ e4, o4 ^ S4, 32), o4 = (CA2 = w3) + M4 | 0, M4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ D4, (r4 = G4) ^ (G4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = uA2 + (J4 = w3) | 0, o4 = Y4 + ((n4 = r4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) | 0, P4 = n4 = n4 + e4 | 0, O4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = o4, o4 = K4 + DA2 | 0, o4 = ((D4 = m4 + gA2 | 0) >>> 0 < gA2 >>> 0 ? o4 + 1 | 0 : o4) + e4 | 0, Y4 = o4 = (e4 = n4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(e4 ^ k4, o4 ^ h4, 32), o4 = (W4 = w3) + V4 | 0, h4 = nA((D4 = n4 + j4 | 0) ^ m4, (o4 = D4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), m4 = o4, o4 = C4 + (b4 = w3) | 0, o4 = Y4 + ((K4 = h4 + sA2 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (Y4 = e4 + K4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = W4, W4 = o4, e4 = nA(n4 ^ Y4, e4 ^ o4, 48), o4 = (o4 = m4) + (m4 = w3) | 0, n4 = (D4 = e4 + D4 | 0) ^ h4, h4 = o4 = D4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, b4 = o4 = nA(n4, o4 ^ b4, 1), K4 = n4 = w3, AA2 = y4, Z3 = c4, c4 = r4, r4 = nA(S4 ^ P4, O4 ^ CA2, 48), o4 = (S4 = w3) + G4 | 0, G4 = n4 = r4 + M4 | 0, M4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ J4, 1), o4 = (J4 = w3) + tA2 | 0, o4 = U4 + ((n4 = c4 + X4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (y4 = n4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(y4 ^ Z3, o4 ^ _4, 32), o4 = (U4 = w3) + p4 | 0, _4 = o4 = (p4 = n4 + AA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ p4, o4 ^ J4, 40), o4 = MA2 + (CA2 = w3) | 0, J4 = c4, o4 = s4 + ((c4 = rA2 + c4 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = c4 + y4 | 0, c4 = U4, U4 = o4 = s4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ s4, c4 ^ o4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, P4 = n4 = c4 + p4 | 0, O4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = t4, o4 = H4 + IA2 | 0, t4 = o4 = (n4 = k4 + v4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ N4, 1), o4 = (k4 = w3) + hA2 | 0, o4 = l4 + ((p4 = f4 + EA2 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (p4 = p4 + u4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(y4 ^ p4, o4 ^ R4, 32), l4 = o4 = w3, H4 = f4, o4 = o4 + M4 | 0, o4 = (f4 = y4 + G4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, v4 = f4, f4 ^= H4, H4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = yA2 + (N4 = w3) | 0, o4 = u4 + ((k4 = f4 + eA2 | 0) >>> 0 < eA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, G4 = l4, l4 = o4 = (u4 = p4 + k4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, k4 = nA(y4 ^ u4, G4 ^ o4, 48), IA2 = o4 = w3, p4 = o4, y4 = nA(j4 ^ d4, V4 ^ $3, 1), G4 = o4 = w3, M4 = t4, o4 = o4 + x4 | 0, o4 = L4 + ((t4 = y4 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, F4 = o4 = (t4 = t4 + F4 | 0) >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ t4, o4 ^ S4, 32), o4 = ($3 = w3) + M4 | 0, M4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ y4, (r4 = G4) ^ (G4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = HA2 + (d4 = w3) | 0, o4 = F4 + ((n4 = r4 + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, j4 = n4 = n4 + t4 | 0, V4 = o4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = o4, o4 = K4 + C4 | 0, o4 = ((y4 = b4 + sA2 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, F4 = o4 = (t4 = n4 + y4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(t4 ^ k4, o4 ^ p4, 32), o4 = (L4 = w3) + O4 | 0, p4 = nA((y4 = n4 + P4 | 0) ^ b4, (o4 = y4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), R4 = o4, o4 = SA2 + (b4 = w3) | 0, o4 = F4 + ((K4 = p4 + iA2 | 0) >>> 0 < iA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (F4 = t4 + K4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = L4, L4 = o4, t4 = nA(n4 ^ F4, t4 ^ o4, 48), o4 = (o4 = R4) + (R4 = w3) | 0, n4 = (y4 = t4 + y4 | 0) ^ p4, p4 = o4 = y4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, b4 = o4 = nA(n4, o4 ^ b4, 1), K4 = n4 = w3, AA2 = D4, Z3 = c4, c4 = r4, r4 = nA(S4 ^ j4, V4 ^ $3, 48), o4 = (S4 = w3) + G4 | 0, G4 = n4 = r4 + M4 | 0, M4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ d4, 1), o4 = (d4 = w3) + x4 | 0, o4 = l4 + ((n4 = c4 + aA2 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (D4 = n4 + u4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(D4 ^ Z3, o4 ^ _4, 32), o4 = (l4 = w3) + h4 | 0, _4 = o4 = (h4 = n4 + AA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ h4, o4 ^ d4, 40), o4 = yA2 + ($3 = w3) | 0, d4 = c4, o4 = u4 + ((c4 = eA2 + c4 | 0) >>> 0 < eA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = c4 + D4 | 0, c4 = l4, l4 = o4 = u4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ u4, c4 ^ o4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, j4 = n4 = c4 + h4 | 0, V4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, D4 = e4, o4 = H4 + IA2 | 0, e4 = o4 = (n4 = k4 + v4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ N4, 1), o4 = hA2 + (k4 = w3) | 0, o4 = U4 + ((h4 = f4 + EA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (h4 = h4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(D4 ^ h4, o4 ^ m4, 32), U4 = o4 = w3, H4 = f4, o4 = o4 + M4 | 0, o4 = (f4 = D4 + G4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, v4 = f4, f4 ^= H4, H4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = MA2 + (N4 = w3) | 0, o4 = s4 + ((k4 = f4 + rA2 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (s4 = h4 + k4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, h4 = U4, U4 = o4, k4 = nA(D4 ^ s4, h4 ^ o4, 48), IA2 = o4 = w3, h4 = o4, D4 = nA(J4 ^ P4, O4 ^ CA2, 1), G4 = o4 = w3, M4 = e4, o4 = o4 + BA2 | 0, o4 = W4 + ((e4 = D4 + q4 | 0) >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4) | 0, Y4 = o4 = (e4 = e4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ e4, o4 ^ S4, 32), o4 = (CA2 = w3) + M4 | 0, M4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ D4, (r4 = G4) ^ (G4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = HA2 + (J4 = w3) | 0, o4 = Y4 + ((n4 = r4 + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, P4 = n4 = n4 + e4 | 0, O4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = o4, o4 = K4 + uA2 | 0, o4 = ((D4 = b4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) + e4 | 0, Y4 = o4 = (e4 = n4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(e4 ^ k4, o4 ^ h4, 32), o4 = (W4 = w3) + V4 | 0, h4 = nA((D4 = n4 + j4 | 0) ^ b4, (o4 = D4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), m4 = o4, o4 = z4 + (b4 = w3) | 0, o4 = Y4 + ((K4 = I7 + h4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (Y4 = e4 + K4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = W4, W4 = o4, e4 = nA(n4 ^ Y4, e4 ^ o4, 48), o4 = (o4 = m4) + (m4 = w3) | 0, n4 = (D4 = e4 + D4 | 0) ^ h4, h4 = o4 = D4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, b4 = o4 = nA(n4, o4 ^ b4, 1), K4 = n4 = w3, AA2 = y4, Z3 = c4, c4 = r4, r4 = nA(S4 ^ P4, O4 ^ CA2, 48), o4 = (S4 = w3) + G4 | 0, G4 = n4 = r4 + M4 | 0, M4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ J4, 1), o4 = (J4 = w3) + pA2 | 0, o4 = U4 + ((n4 = c4 + oA2 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (y4 = n4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(y4 ^ Z3, o4 ^ _4, 32), o4 = (U4 = w3) + p4 | 0, _4 = o4 = (p4 = n4 + AA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ p4, o4 ^ J4, 40), o4 = B4 + (CA2 = w3) | 0, J4 = c4, o4 = s4 + ((c4 = g6 + c4 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = c4 + y4 | 0, c4 = U4, U4 = o4 = s4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ s4, c4 ^ o4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, P4 = n4 = c4 + p4 | 0, O4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = t4, o4 = H4 + IA2 | 0, t4 = o4 = (n4 = k4 + v4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ N4, 1), o4 = (k4 = w3) + DA2 | 0, o4 = l4 + ((p4 = f4 + gA2 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (p4 = p4 + u4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(y4 ^ p4, o4 ^ R4, 32), l4 = o4 = w3, H4 = f4, o4 = o4 + M4 | 0, o4 = (f4 = y4 + G4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, v4 = f4, f4 ^= H4, H4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = lA2 + (N4 = w3) | 0, o4 = u4 + ((k4 = f4 + QA2 | 0) >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, G4 = l4, l4 = o4 = (u4 = p4 + k4 | 0) >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4, k4 = nA(y4 ^ u4, G4 ^ o4, 48), IA2 = o4 = w3, p4 = o4, y4 = nA(j4 ^ d4, V4 ^ $3, 1), G4 = o4 = w3, M4 = t4, o4 = o4 + FA2 | 0, o4 = L4 + ((t4 = y4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, F4 = o4 = (t4 = t4 + F4 | 0) >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ t4, o4 ^ S4, 32), o4 = ($3 = w3) + M4 | 0, M4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ y4, (r4 = G4) ^ (G4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = tA2 + (d4 = w3) | 0, o4 = F4 + ((n4 = r4 + X4 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4) | 0, j4 = n4 = n4 + t4 | 0, V4 = o4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = o4, o4 = K4 + HA2 | 0, o4 = ((y4 = b4 + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, F4 = o4 = (t4 = n4 + y4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(t4 ^ k4, o4 ^ p4, 32), o4 = (L4 = w3) + O4 | 0, p4 = nA((y4 = n4 + P4 | 0) ^ b4, (o4 = y4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), R4 = o4, o4 = yA2 + (b4 = w3) | 0, o4 = F4 + ((K4 = p4 + eA2 | 0) >>> 0 < eA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (F4 = t4 + K4 | 0) >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = L4, L4 = o4, t4 = nA(n4 ^ F4, t4 ^ o4, 48), o4 = (o4 = R4) + (R4 = w3) | 0, n4 = (y4 = t4 + y4 | 0) ^ p4, p4 = o4 = y4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, b4 = o4 = nA(n4, o4 ^ b4, 1), K4 = n4 = w3, AA2 = D4, Z3 = c4, c4 = r4, r4 = nA(S4 ^ j4, V4 ^ $3, 48), o4 = (S4 = w3) + G4 | 0, G4 = n4 = r4 + M4 | 0, M4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ d4, 1), o4 = (d4 = w3) + SA2 | 0, o4 = l4 + ((n4 = c4 + iA2 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (D4 = n4 + u4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(D4 ^ Z3, o4 ^ _4, 32), o4 = (l4 = w3) + h4 | 0, _4 = o4 = (h4 = n4 + AA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ h4, o4 ^ d4, 40), o4 = C4 + ($3 = w3) | 0, d4 = c4, o4 = u4 + ((c4 = sA2 + c4 | 0) >>> 0 < sA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = c4 + D4 | 0, c4 = l4, l4 = o4 = u4 >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ u4, c4 ^ o4, 48), o4 = (o4 = _4) + (_4 = w3) | 0, j4 = n4 = c4 + h4 | 0, V4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, D4 = e4, o4 = H4 + IA2 | 0, e4 = o4 = (n4 = k4 + v4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ N4, 1), o4 = lA2 + (k4 = w3) | 0, o4 = U4 + ((h4 = f4 + QA2 | 0) >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (h4 = h4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(D4 ^ h4, o4 ^ m4, 32), U4 = o4 = w3, H4 = f4, o4 = o4 + M4 | 0, o4 = (f4 = D4 + G4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, v4 = f4, f4 ^= H4, H4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = x4 + (N4 = w3) | 0, o4 = s4 + ((k4 = f4 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (s4 = h4 + k4 | 0) >>> 0 < h4 >>> 0 ? o4 + 1 | 0 : o4, h4 = U4, U4 = o4, k4 = nA(D4 ^ s4, h4 ^ o4, 48), IA2 = o4 = w3, h4 = o4, D4 = nA(J4 ^ P4, O4 ^ CA2, 1), G4 = o4 = w3, M4 = e4, o4 = o4 + MA2 | 0, o4 = W4 + ((e4 = D4 + rA2 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, Y4 = o4 = (e4 = e4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? o4 + 1 | 0 : o4, S4 = nA(r4 ^ e4, o4 ^ S4, 32), o4 = (CA2 = w3) + M4 | 0, M4 = n4 = S4 + n4 | 0, r4 = nA(n4 ^ D4, (r4 = G4) ^ (G4 = n4 >>> 0 < S4 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = FA2 + (J4 = w3) | 0, o4 = Y4 + ((n4 = r4 + cA2 | 0) >>> 0 < cA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, P4 = n4 = n4 + e4 | 0, O4 = o4 = n4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = o4, o4 = K4 + hA2 | 0, o4 = ((D4 = b4 + EA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) + e4 | 0, Y4 = o4 = (e4 = n4 + D4 | 0) >>> 0 < D4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(e4 ^ k4, o4 ^ h4, 32), o4 = (W4 = w3) + V4 | 0, h4 = nA((D4 = n4 + j4 | 0) ^ b4, (o4 = D4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), m4 = o4, o4 = B4 + (b4 = w3) | 0, o4 = Y4 + ((K4 = h4 + g6 | 0) >>> 0 < g6 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (Y4 = e4 + K4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, e4 = W4, W4 = o4, e4 = nA(n4 ^ Y4, e4 ^ o4, 48), o4 = (o4 = m4) + (m4 = w3) | 0, n4 = (D4 = e4 + D4 | 0) ^ h4, h4 = o4 = D4 >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, b4 = o4 = nA(n4, o4 ^ b4, 1), K4 = n4 = w3, AA2 = y4, Z3 = c4, c4 = r4, r4 = nA(S4 ^ P4, O4 ^ CA2, 48), o4 = (S4 = w3) + G4 | 0, G4 = n4 = r4 + M4 | 0, M4 = o4 = n4 >>> 0 < r4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ c4, o4 ^ J4, 1), o4 = (P4 = w3) + BA2 | 0, o4 = U4 + ((n4 = c4 + q4 | 0) >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4) | 0, s4 = o4 = (y4 = n4 + s4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, n4 = nA(y4 ^ Z3, o4 ^ _4, 32), o4 = (U4 = w3) + p4 | 0, _4 = p4 = n4 + AA2 | 0, J4 = o4 = p4 >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ p4, o4 ^ P4, 40), o4 = uA2 + (AA2 = w3) | 0, P4 = c4, o4 = s4 + ((c4 = T4 + c4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) | 0, p4 = c4 + y4 | 0, c4 = U4, U4 = o4 = p4 >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(n4 ^ p4, c4 ^ o4, 48), o4 = (o4 = J4) + (J4 = w3) | 0, _4 = n4 = c4 + _4 | 0, O4 = o4 = n4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = t4, o4 = H4 + IA2 | 0, t4 = o4 = (n4 = k4 + v4 | 0) >>> 0 < k4 >>> 0 ? o4 + 1 | 0 : o4, f4 = nA(n4 ^ f4, o4 ^ N4, 1), o4 = (k4 = w3) + z4 | 0, o4 = l4 + ((s4 = I7 + f4 | 0) >>> 0 < f4 >>> 0 ? o4 + 1 | 0 : o4) | 0, u4 = o4 = (s4 = s4 + u4 | 0) >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4, l4 = y4 = nA(y4 ^ s4, o4 ^ R4, 32), H4 = o4 = w3, v4 = f4, o4 = o4 + M4 | 0, o4 = (f4 = y4 + G4 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, N4 = f4, f4 ^= v4, v4 = o4, f4 = nA(f4, o4 ^ k4, 40), o4 = pA2 + (G4 = w3) | 0, o4 = u4 + ((y4 = f4 + oA2 | 0) >>> 0 < oA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, M4 = (y4 = y4 + s4 | 0) ^ l4, l4 = o4 = y4 >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, s4 = nA(M4, o4 ^ H4, 48), R4 = o4 = w3, k4 = o4, H4 = u4 = nA(j4 ^ d4, V4 ^ $3, 1), M4 = o4 = w3, d4 = t4, o4 = o4 + tA2 | 0, o4 = L4 + ((t4 = u4 + X4 | 0) >>> 0 < X4 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (t4 = t4 + F4 | 0) >>> 0 < F4 >>> 0 ? o4 + 1 | 0 : o4, F4 = S4, S4 = o4, u4 = nA(r4 ^ t4, F4 ^ o4, 32), o4 = (Z3 = w3) + d4 | 0, F4 = n4 = u4 + n4 | 0, r4 = nA(r4 = n4 ^ H4, (H4 = n4 >>> 0 < u4 >>> 0 ? o4 + 1 | 0 : o4) ^ M4, 40), o4 = DA2 + (M4 = w3) | 0, o4 = S4 + ((n4 = r4 + gA2 | 0) >>> 0 < gA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, S4 = n4 = n4 + t4 | 0, d4 = o4 = n4 >>> 0 < t4 >>> 0 ? o4 + 1 | 0 : o4, t4 = o4, o4 = K4 + uA2 | 0, o4 = ((L4 = T4) >>> 0 > (T4 = b4 + T4 | 0) >>> 0 ? o4 + 1 | 0 : o4) + t4 | 0, uA2 = o4 = (n4 = n4 + T4 | 0) >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4, T4 = nA(n4 ^ s4, o4 ^ k4, 32), o4 = (j4 = w3) + O4 | 0, k4 = nA((t4 = _4 + T4 | 0) ^ b4, (o4 = t4 >>> 0 < T4 >>> 0 ? o4 + 1 | 0 : o4) ^ K4, 40), L4 = o4, o4 = pA2 + (V4 = w3) | 0, o4 = uA2 + ((b4 = oA2) >>> 0 > (oA2 = k4 + oA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (oA2 = n4 + oA2 | 0) >>> 0 < n4 >>> 0 ? o4 + 1 | 0 : o4, n4 = T4 ^ oA2, T4 = o4;
                      pA2 = nA(n4, o4 ^ j4, 48), o4 = (uA2 = w3) + L4 | 0, t4 = o4 = (n4 = t4 + pA2 | 0) >>> 0 < pA2 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(n4 ^ k4, o4 ^ V4, 1), k4 = w3, j4 = o4, V4 = D4, D4 = gA2, L4 = DA2, DA2 = nA(u4 ^ S4, d4 ^ Z3, 48), o4 = (u4 = w3) + H4 | 0, H4 = D4, F4 = o4 = (gA2 = F4 + DA2 | 0) >>> 0 < DA2 >>> 0 ? o4 + 1 | 0 : o4, D4 = nA(r4 ^ (S4 = gA2), o4 ^ M4, 1), o4 = (M4 = w3) + L4 | 0, o4 = l4 + (D4 >>> 0 > (gA2 = H4 + D4 | 0) >>> 0 ? o4 + 1 | 0 : o4) | 0, r4 = o4 = (gA2 = y4 + gA2 | 0) >>> 0 < y4 >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ gA2, o4 ^ J4, 32), o4 = (o4 = h4) + (h4 = w3) | 0, l4 = y4 = c4 + V4 | 0, H4 = o4 = y4 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, y4 = nA(y4 ^ D4, o4 ^ M4, 40), o4 = (M4 = w3) + SA2 | 0, o4 = (y4 >>> 0 > (iA2 = y4 + iA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, r4 = o4 = (r4 = iA2) >>> 0 > (iA2 = gA2 + iA2 | 0) >>> 0 ? o4 + 1 | 0 : o4, c4 = nA(c4 ^ iA2, o4 ^ h4, 48), o4 = (D4 = w3) + H4 | 0, h4 = gA2 = c4 + l4 | 0, SA2 = o4 = gA2 >>> 0 < c4 >>> 0 ? o4 + 1 | 0 : o4, l4 = I7, H4 = z4, o4 = v4 + R4 | 0, gA2 = o4 = (I7 = s4 + N4 | 0) >>> 0 < s4 >>> 0 ? o4 + 1 | 0 : o4, z4 = nA(I7 ^ f4, o4 ^ G4, 1), o4 = (s4 = w3) + H4 | 0, o4 = U4 + ((f4 = l4 + z4 | 0) >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4) | 0, e4 = nA((f4 = f4 + p4 | 0) ^ e4, (o4 = f4 >>> 0 < p4 >>> 0 ? o4 + 1 | 0 : o4) ^ m4, 32), l4 = o4, U4 = EA2, EA2 = z4, o4 = (p4 = w3) + F4 | 0, F4 = s4, s4 = o4 = (z4 = e4 + S4 | 0) >>> 0 < e4 >>> 0 ? o4 + 1 | 0 : o4, EA2 = nA(z4 ^ EA2, F4 ^ o4, 40), o4 = (S4 = w3) + hA2 | 0, o4 = ((hA2 = U4 + EA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) + l4 | 0, l4 = hA2, f4 = e4 ^ (hA2 = f4 + hA2 | 0), e4 = o4 = l4 >>> 0 > hA2 >>> 0 ? o4 + 1 | 0 : o4, o4 = nA(f4, o4 ^ p4, 48), v4 = f4 = w3, p4 = o4, F4 = q4, l4 = BA2, q4 = nA(_4 ^ P4, O4 ^ AA2, 1), H4 = o4 = w3, o4 = o4 + HA2 | 0, o4 = W4 + ((q4 = (U4 = q4) + fA2 | 0) >>> 0 < fA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, fA2 = o4 = (q4 = Y4 + q4 | 0) >>> 0 < Y4 >>> 0 ? o4 + 1 | 0 : o4, BA2 = nA(q4 ^ DA2, o4 ^ u4, 32), o4 = (Y4 = w3) + gA2 | 0, gA2 = I7 = BA2 + I7 | 0, DA2 = nA(I7 ^ U4, (u4 = I7 >>> 0 < BA2 >>> 0 ? o4 + 1 | 0 : o4) ^ H4, 40), o4 = (o4 = l4) + (l4 = w3) | 0, o4 = fA2 + ((I7 = DA2 + F4 | 0) >>> 0 < DA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, fA2 = I7 = I7 + q4 | 0, HA2 = o4 = I7 >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4, q4 = o4, o4 = k4 + lA2 | 0, o4 = ((U4 = QA2) >>> 0 > (QA2 = j4 + QA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + q4 | 0, lA2 = o4 = (q4 = I7 + QA2 | 0) >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4, QA2 = nA(p4 ^ q4, o4 ^ f4, 32), o4 = (U4 = w3) + SA2 | 0, f4 = I7 = QA2 + h4 | 0, I7 = nA(I7 ^ j4, (F4 = k4) ^ (k4 = I7 >>> 0 < QA2 >>> 0 ? o4 + 1 | 0 : o4), 40), o4 = MA2 + (H4 = w3) | 0, MA2 = I7, o4 = lA2 + ((I7 = rA2 + I7 | 0) >>> 0 < rA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (I7 = I7 + q4 | 0) >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4, lA2 = I7, N4 = (a3[A8 + 8 | 0] | a3[A8 + 9 | 0] << 8 | a3[A8 + 10 | 0] << 16 | a3[A8 + 11 | 0] << 24) ^ I7, F4 = o4, G4 = o4 ^ (a3[A8 + 12 | 0] | a3[A8 + 13 | 0] << 8 | a3[A8 + 14 | 0] << 16 | a3[A8 + 15 | 0] << 24), q4 = nA(BA2 ^ fA2, Y4 ^ HA2, 48), o4 = (fA2 = w3) + u4 | 0, u4 = I7 = q4 + gA2 | 0, HA2 = o4 = I7 >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4, BA2 = eA2, o4 = s4 + v4 | 0, eA2 = o4 = (I7 = p4 + z4 | 0) >>> 0 < z4 >>> 0 ? o4 + 1 | 0 : o4, EA2 = nA(I7 ^ EA2, o4 ^ S4, 1), o4 = (p4 = w3) + yA2 | 0, o4 = ((BA2 = EA2 + BA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4) + r4 | 0, BA2 = o4 = (yA2 = BA2 + iA2 | 0) >>> 0 < BA2 >>> 0 ? o4 + 1 | 0 : o4, gA2 = nA(yA2 ^ pA2, o4 ^ uA2, 32), o4 = (z4 = w3) + HA2 | 0, iA2 = o4 = (rA2 = gA2 + u4 | 0) >>> 0 < gA2 >>> 0 ? o4 + 1 | 0 : o4, pA2 = gA2, gA2 = nA(EA2 ^ rA2, o4 ^ p4, 40), o4 = (r4 = w3) + FA2 | 0, o4 = (gA2 >>> 0 > (EA2 = gA2 + cA2 | 0) >>> 0 ? o4 + 1 | 0 : o4) + BA2 | 0, s4 = z4, z4 = o4 = (yA2 = EA2 + yA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4, EA2 = nA(pA2 ^ (cA2 = yA2), s4 ^ o4, 48), o4 = (p4 = w3) + iA2 | 0, o4 = (BA2 = EA2 + rA2 | 0) >>> 0 < EA2 >>> 0 ? o4 + 1 | 0 : o4, rA2 = BA2, BA2 ^= N4, E3[A8 + 8 | 0] = BA2, E3[A8 + 9 | 0] = BA2 >>> 8, E3[A8 + 10 | 0] = BA2 >>> 16, E3[A8 + 11 | 0] = BA2 >>> 24, iA2 = o4, o4 ^= G4, E3[A8 + 12 | 0] = o4, E3[A8 + 13 | 0] = o4 >>> 8, E3[A8 + 14 | 0] = o4 >>> 16, E3[A8 + 15 | 0] = o4 >>> 24, yA2 = I7, BA2 = eA2, I7 = q4, q4 = nA(y4 ^ h4, M4 ^ SA2, 1), o4 = (FA2 = w3) + B4 | 0, o4 = (q4 >>> 0 > (eA2 = q4 + g6 | 0) >>> 0 ? o4 + 1 | 0 : o4) + T4 | 0, oA2 = o4 = (h4 = eA2) >>> 0 > (eA2 = oA2 + eA2 | 0) >>> 0 ? o4 + 1 | 0 : o4, I7 = nA(I7 ^ eA2, o4 ^ fA2, 32), o4 = (o4 = BA2) + (BA2 = w3) | 0, fA2 = o4 = (yA2 = I7 + yA2 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4, pA2 = I7, yA2 = nA(q4 ^ (T4 = yA2), o4 ^ FA2, 40), o4 = (y4 = w3) + C4 | 0, o4 = oA2 + ((I7 = yA2 + sA2 | 0) >>> 0 < yA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (I7 = I7 + eA2 | 0) >>> 0 < eA2 >>> 0 ? o4 + 1 | 0 : o4, oA2 = I7, I7 ^= pA2, pA2 = o4, eA2 = nA(I7, o4 ^ BA2, 48), o4 = (h4 = w3) + fA2 | 0, T4 = I7 = eA2 + T4 | 0, fA2 = I7 >>> 0 < eA2 >>> 0 ? o4 + 1 | 0 : o4, DA2 = I7 = nA(u4 ^ DA2, l4 ^ HA2, 1), FA2 = o4 = w3, o4 = o4 + x4 | 0, o4 = e4 + ((I7 = I7 + aA2 | 0) >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, x4 = o4 = (q4 = I7 + hA2 | 0) >>> 0 < hA2 >>> 0 ? o4 + 1 | 0 : o4, I7 = (BA2 = nA(c4 ^ q4, o4 ^ D4, 32)) + n4 | 0, o4 = (n4 = w3) + t4 | 0, hA2 = I7, I7 = (aA2 = nA(e4 = I7 ^ DA2, (DA2 = I7 >>> 0 < BA2 >>> 0 ? o4 + 1 | 0 : o4) ^ FA2, 40)) + X4 | 0, o4 = (X4 = w3) + tA2 | 0, o4 = x4 + (I7 >>> 0 < aA2 >>> 0 ? o4 + 1 | 0 : o4) | 0, o4 = (x4 = I7 + q4 | 0) >>> 0 < q4 >>> 0 ? o4 + 1 | 0 : o4, q4 = x4 ^ UA2 ^ T4, E3[0 | (I7 = A8)] = q4, E3[I7 + 1 | 0] = q4 >>> 8, E3[I7 + 2 | 0] = q4 >>> 16, E3[I7 + 3 | 0] = q4 >>> 24, q4 = o4 ^ Q4 ^ fA2, E3[I7 + 4 | 0] = q4, E3[I7 + 5 | 0] = q4 >>> 8, E3[I7 + 6 | 0] = q4 >>> 16, E3[I7 + 7 | 0] = q4 >>> 24, q4 = (BA2 = nA(x4 ^ BA2, o4 ^ n4, 48)) + hA2 | 0, o4 = (hA2 = w3) + DA2 | 0, o4 = (DA2 = q4 >>> 0 < BA2 >>> 0 ? o4 + 1 | 0 : o4) ^ (a3[I7 + 20 | 0] | a3[I7 + 21 | 0] << 8 | a3[I7 + 22 | 0] << 16 | a3[I7 + 23 | 0] << 24) ^ pA2, x4 = (a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24) ^ oA2 ^ q4, E3[I7 + 16 | 0] = x4, E3[I7 + 17 | 0] = x4 >>> 8, E3[I7 + 18 | 0] = x4 >>> 16, E3[I7 + 19 | 0] = x4 >>> 24, E3[I7 + 20 | 0] = o4, E3[I7 + 21 | 0] = o4 >>> 8, E3[I7 + 22 | 0] = o4 >>> 16, E3[I7 + 23 | 0] = o4 >>> 24, I7 = nA(QA2 ^ lA2, F4 ^ U4, 48), x4 = w3, oA2 = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24, o4 = (a3[A8 + 32 | 0] | a3[A8 + 33 | 0] << 8 | a3[A8 + 34 | 0] << 16 | a3[A8 + 35 | 0] << 24) ^ nA(gA2 ^ rA2, r4 ^ iA2, 1) ^ I7, E3[A8 + 32 | 0] = o4, E3[A8 + 33 | 0] = o4 >>> 8, E3[A8 + 34 | 0] = o4 >>> 16, E3[A8 + 35 | 0] = o4 >>> 24, o4 = w3 ^ oA2 ^ x4, E3[A8 + 36 | 0] = o4, E3[A8 + 37 | 0] = o4 >>> 8, E3[A8 + 38 | 0] = o4 >>> 16, E3[A8 + 39 | 0] = o4 >>> 24, o4 = k4 + x4 | 0, o4 = (oA2 = I7 + f4 | 0) >>> 0 < I7 >>> 0 ? o4 + 1 | 0 : o4, gA2 = (a3[(I7 = A8) + 28 | 0] | a3[I7 + 29 | 0] << 8 | a3[I7 + 30 | 0] << 16 | a3[I7 + 31 | 0] << 24) ^ z4 ^ o4, x4 = (a3[I7 + 24 | 0] | a3[I7 + 25 | 0] << 8 | a3[I7 + 26 | 0] << 16 | a3[I7 + 27 | 0] << 24) ^ cA2 ^ oA2, E3[I7 + 24 | 0] = x4, E3[I7 + 25 | 0] = x4 >>> 8, E3[I7 + 26 | 0] = x4 >>> 16, E3[I7 + 27 | 0] = x4 >>> 24, E3[I7 + 28 | 0] = gA2, E3[I7 + 29 | 0] = gA2 >>> 8, E3[I7 + 30 | 0] = gA2 >>> 16, E3[I7 + 31 | 0] = gA2 >>> 24, gA2 = a3[I7 + 44 | 0] | a3[I7 + 45 | 0] << 8 | a3[I7 + 46 | 0] << 16 | a3[I7 + 47 | 0] << 24, I7 = eA2 ^ (a3[I7 + 40 | 0] | a3[I7 + 41 | 0] << 8 | a3[I7 + 42 | 0] << 16 | a3[I7 + 43 | 0] << 24) ^ nA(q4 ^ aA2, X4 ^ DA2, 1), E3[A8 + 40 | 0] = I7, E3[A8 + 41 | 0] = I7 >>> 8, E3[A8 + 42 | 0] = I7 >>> 16, E3[A8 + 43 | 0] = I7 >>> 24, I7 = h4 ^ w3 ^ gA2, E3[A8 + 44 | 0] = I7, E3[A8 + 45 | 0] = I7 >>> 8, E3[A8 + 46 | 0] = I7 >>> 16, E3[A8 + 47 | 0] = I7 >>> 24, q4 = a3[A8 + 60 | 0] | a3[A8 + 61 | 0] << 8 | a3[A8 + 62 | 0] << 16 | a3[A8 + 63 | 0] << 24, I7 = BA2 ^ (a3[A8 + 56 | 0] | a3[A8 + 57 | 0] << 8 | a3[A8 + 58 | 0] << 16 | a3[A8 + 59 | 0] << 24) ^ nA(T4 ^ yA2, y4 ^ fA2, 1), E3[A8 + 56 | 0] = I7, E3[A8 + 57 | 0] = I7 >>> 8, E3[A8 + 58 | 0] = I7 >>> 16, E3[A8 + 59 | 0] = I7 >>> 24, I7 = hA2 ^ w3 ^ q4, E3[A8 + 60 | 0] = I7, E3[A8 + 61 | 0] = I7 >>> 8, E3[A8 + 62 | 0] = I7 >>> 16, E3[A8 + 63 | 0] = I7 >>> 24, q4 = a3[A8 + 52 | 0] | a3[A8 + 53 | 0] << 8 | a3[A8 + 54 | 0] << 16 | a3[A8 + 55 | 0] << 24, I7 = EA2 ^ (a3[A8 + 48 | 0] | a3[A8 + 49 | 0] << 8 | a3[A8 + 50 | 0] << 16 | a3[A8 + 51 | 0] << 24) ^ nA(oA2 ^ MA2, o4 ^ H4, 1), E3[A8 + 48 | 0] = I7, E3[A8 + 49 | 0] = I7 >>> 8, E3[A8 + 50 | 0] = I7 >>> 16, E3[A8 + 51 | 0] = I7 >>> 24, I7 = p4 ^ w3 ^ q4, E3[A8 + 52 | 0] = I7, E3[A8 + 53 | 0] = I7 >>> 8, E3[A8 + 54 | 0] = I7 >>> 16, E3[A8 + 55 | 0] = I7 >>> 24;
                    }
                    function s3(A8, I7, g6, C4, B4, Q4, i4) {
                      var n4, r4, f4, t4, e4, c4, y4, h4, s4, p4, k4, F4, l4, S4, H4, G4, U4, J4, N4, Y4, b4, _4, K4, P4, d4, L4, R4, x4, j4, X4, q4, z4, V4, O4, T4, W4, Z3, $3, AA2, IA2, gA2, CA2, BA2, iA2, oA2, aA2, nA2, rA2, fA2 = 0, tA2 = 0, eA2 = 0, cA2 = 0, yA2 = 0, wA2 = 0, hA2 = 0, sA2 = 0, pA2 = 0, kA2 = 0, FA2 = 0, lA2 = 0, SA2 = 0, HA2 = 0, MA2 = 0, GA2 = 0, UA2 = 0, JA2 = 0, NA2 = 0, YA2 = 0, bA2 = 0, _A2 = 0, KA2 = 0, PA2 = 0, vA2 = 0, mA2 = 0, dA2 = 0, LA2 = 0, RA2 = 0, xA2 = 0, jA2 = 0, XA2 = 0, qA2 = 0, zA2 = 0, VA2 = 0, OA2 = 0, TA2 = 0, WA2 = 0, ZA2 = 0, AI2 = 0, II2 = 0, gI2 = 0, CI2 = 0, BI2 = 0, QI2 = 0, iI2 = 0;
                      return D3 = f4 = D3 - 560 | 0, EA(f4 + 352 | 0), i4 && m3(f4 + 352 | 0, 34768, 34, 0), QA(f4 + 288 | 0, Q4, 32, 0), m3(wA2 = f4 + 352 | 0, f4 + 320 | 0, 32, 0), m3(wA2, g6, C4, B4), M3(wA2, sA2 = f4 + 224 | 0), pA2 = a3[(tA2 = Q4) + 32 | 0] | a3[tA2 + 33 | 0] << 8 | a3[tA2 + 34 | 0] << 16 | a3[tA2 + 35 | 0] << 24, FA2 = a3[tA2 + 36 | 0] | a3[tA2 + 37 | 0] << 8 | a3[tA2 + 38 | 0] << 16 | a3[tA2 + 39 | 0] << 24, cA2 = a3[tA2 + 40 | 0] | a3[tA2 + 41 | 0] << 8 | a3[tA2 + 42 | 0] << 16 | a3[tA2 + 43 | 0] << 24, fA2 = a3[tA2 + 44 | 0] | a3[tA2 + 45 | 0] << 8 | a3[tA2 + 46 | 0] << 16 | a3[tA2 + 47 | 0] << 24, eA2 = a3[tA2 + 48 | 0] | a3[tA2 + 49 | 0] << 8 | a3[tA2 + 50 | 0] << 16 | a3[tA2 + 51 | 0] << 24, Q4 = a3[tA2 + 52 | 0] | a3[tA2 + 53 | 0] << 8 | a3[tA2 + 54 | 0] << 16 | a3[tA2 + 55 | 0] << 24, yA2 = a3[tA2 + 60 | 0] | a3[tA2 + 61 | 0] << 8 | a3[tA2 + 62 | 0] << 16 | a3[tA2 + 63 | 0] << 24, tA2 = a3[tA2 + 56 | 0] | a3[tA2 + 57 | 0] << 8 | a3[tA2 + 58 | 0] << 16 | a3[tA2 + 59 | 0] << 24, E3[A8 + 56 | 0] = tA2, E3[A8 + 57 | 0] = tA2 >>> 8, E3[A8 + 58 | 0] = tA2 >>> 16, E3[A8 + 59 | 0] = tA2 >>> 24, E3[A8 + 60 | 0] = yA2, E3[A8 + 61 | 0] = yA2 >>> 8, E3[A8 + 62 | 0] = yA2 >>> 16, E3[A8 + 63 | 0] = yA2 >>> 24, E3[A8 + 48 | 0] = eA2, E3[A8 + 49 | 0] = eA2 >>> 8, E3[A8 + 50 | 0] = eA2 >>> 16, E3[A8 + 51 | 0] = eA2 >>> 24, E3[A8 + 52 | 0] = Q4, E3[A8 + 53 | 0] = Q4 >>> 8, E3[A8 + 54 | 0] = Q4 >>> 16, E3[A8 + 55 | 0] = Q4 >>> 24, E3[A8 + 40 | 0] = cA2, E3[A8 + 41 | 0] = cA2 >>> 8, E3[A8 + 42 | 0] = cA2 >>> 16, E3[A8 + 43 | 0] = cA2 >>> 24, E3[A8 + 44 | 0] = fA2, E3[A8 + 45 | 0] = fA2 >>> 8, E3[A8 + 46 | 0] = fA2 >>> 16, E3[A8 + 47 | 0] = fA2 >>> 24, E3[0 | (Q4 = A8 + 32 | 0)] = pA2, E3[Q4 + 1 | 0] = pA2 >>> 8, E3[Q4 + 2 | 0] = pA2 >>> 16, E3[Q4 + 3 | 0] = pA2 >>> 24, E3[Q4 + 4 | 0] = FA2, E3[Q4 + 5 | 0] = FA2 >>> 8, E3[Q4 + 6 | 0] = FA2 >>> 16, E3[Q4 + 7 | 0] = FA2 >>> 24, u3(sA2), v3(f4, sA2), uA(A8, f4), EA(wA2), i4 && m3(f4 + 352 | 0, 34768, 34, 0), m3(i4 = f4 + 352 | 0, A8, 64, 0), m3(i4, g6, C4, B4), M3(i4, hA2 = f4 + 160 | 0), u3(hA2), E3[f4 + 288 | 0] = 248 & a3[f4 + 288 | 0], E3[f4 + 319 | 0] = 63 & a3[f4 + 319 | 0] | 64, g6 = a3[23 + (A8 = r4 = f4 + 288 | 0) | 0], cA2 = DA(t4 = a3[A8 + 21 | 0] | a3[A8 + 22 | 0] << 8 | g6 << 16 & 2031616, 0, e4 = (a3[hA2 + 28 | 0] | a3[hA2 + 29 | 0] << 8 | a3[hA2 + 30 | 0] << 16 | a3[hA2 + 31 | 0] << 24) >>> 7 | 0, 0), eA2 = w3, g6 = (A8 = a3[hA2 + 27 | 0]) >>> 24 | 0, B4 = A8 << 8 | (fA2 = a3[hA2 + 23 | 0] | a3[hA2 + 24 | 0] << 8 | a3[hA2 + 25 | 0] << 16 | a3[hA2 + 26 | 0] << 24) >>> 24, A8 = DA(c4 = 2097151 & ((3 & (FA2 = (A8 = (C4 = a3[hA2 + 28 | 0]) >>> 16 | 0) | g6)) << 30 | (g6 = (C4 <<= 16) | B4) >>> 2), 0, y4 = (i4 = a3[r4 + 23 | 0] | a3[r4 + 24 | 0] << 8 | a3[r4 + 25 | 0] << 16 | a3[r4 + 26 | 0] << 24) >>> 5 & 2097151, 0), g6 = w3 + eA2 | 0, C4 = A8 >>> 0 > (B4 = A8 + cA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(h4 = (g6 = a3[hA2 + 23 | 0]) << 16 & 2031616 | a3[hA2 + 21 | 0] | a3[hA2 + 22 | 0] << 8, 0, s4 = (a3[r4 + 28 | 0] | a3[r4 + 29 | 0] << 8 | a3[r4 + 30 | 0] << 16 | a3[r4 + 31 | 0] << 24) >>> 7 | 0, 0), C4 = w3 + C4 | 0, eA2 = g6 = A8 + B4 | 0, B4 = A8 >>> 0 > g6 >>> 0 ? C4 + 1 | 0 : C4, C4 = (A8 = a3[r4 + 27 | 0]) >>> 24 | 0, i4 = A8 << 8 | i4 >>> 24, A8 = DA(p4 = 2097151 & ((3 & (C4 |= g6 = (A8 = a3[r4 + 28 | 0]) >>> 16 | 0)) << 30 | (g6 = (A8 <<= 16) | i4) >>> 2), 0, k4 = fA2 >>> 5 & 2097151, 0), g6 = w3 + B4 | 0, tA2 = C4 = A8 + eA2 | 0, B4 = A8 >>> 0 > C4 >>> 0 ? g6 + 1 | 0 : g6, fA2 = DA(y4, 0, k4, 0), eA2 = w3, g6 = (A8 = a3[r4 + 19 | 0]) >>> 24 | 0, i4 = A8 << 8 | (UA2 = a3[r4 + 15 | 0] | a3[r4 + 16 | 0] << 8 | a3[r4 + 17 | 0] << 16 | a3[r4 + 18 | 0] << 24) >>> 24, C4 = g6, g6 = DA(F4 = (7 & (C4 |= g6 = (A8 = a3[r4 + 20 | 0]) >>> 16 | 0)) << 29 | (g6 = (A8 <<= 16) | i4) >>> 3, FA2 = C4 >>> 3 | 0, e4, 0), A8 = w3 + eA2 | 0, A8 = g6 >>> 0 > (C4 = g6 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, i4 = (g6 = DA(t4, 0, c4, 0)) + C4 | 0, C4 = w3 + A8 | 0, g6 = g6 >>> 0 > (fA2 = i4) >>> 0 ? C4 + 1 | 0 : C4, C4 = (A8 = a3[hA2 + 19 | 0]) >>> 24 | 0, eA2 = A8 << 8 | (GA2 = a3[hA2 + 15 | 0] | a3[hA2 + 16 | 0] << 8 | a3[hA2 + 17 | 0] << 16 | a3[hA2 + 18 | 0] << 24) >>> 24, A8 = DA(l4 = (7 & (cA2 = (A8 = (i4 = a3[hA2 + 20 | 0]) >>> 16 | 0) | C4)) << 29 | (C4 = (i4 <<= 16) | eA2) >>> 3, S4 = cA2 >>> 3 | 0, s4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(h4, 0, p4, 0), g6 = w3 + g6 | 0, pA2 = g6 = A8 >>> 0 > (sA2 = A8 + C4 | 0) >>> 0 ? g6 + 1 | 0 : g6, lA2 = A8 = g6 - ((sA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (g6 = A8 >>> 21 | 0) + B4 | 0, fA2 = C4 = (A8 = (2097151 & A8) << 11 | (cA2 = sA2 - -1048576 | 0) >>> 21) >>> 0 > (tA2 = A8 + tA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, HA2 = A8 = C4 - ((tA2 >>> 0 < 4293918720) - 1 | 0) | 0, wA2 = (2097151 & A8) << 11 | (eA2 = tA2 - -1048576 | 0) >>> 21, i4 = A8 >>> 21 | 0, A8 = DA(s4, 0, k4, 0), g6 = w3, C4 = A8, A8 = DA(e4, 0, y4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, SA2 = (A8 = C4) + (C4 = DA(c4, 0, p4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > SA2 >>> 0 ? A8 + 1 | 0 : A8, yA2 = SA2 - (g6 = -2097152 & (C4 = SA2 - -1048576 | 0)) | 0, g6 = (A8 - ((131071 & (B4 = A8 - ((SA2 >>> 0 < 4293918720) - 1 | 0) | 0)) + (g6 >>> 0 > SA2 >>> 0) | 0) | 0) + i4 | 0, j4 = g6 = (A8 = yA2 + wA2 | 0) >>> 0 < yA2 >>> 0 ? g6 + 1 | 0 : g6, X4 = A8, yA2 = DA(A8, g6, 470296, 0), wA2 = w3, g6 = DA(e4, 0, p4, 0), A8 = w3, i4 = g6, g6 = DA(c4, 0, s4, 0), A8 = w3 + A8 | 0, g6 = g6 >>> 0 > (i4 = i4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, A8 = B4 >>> 21 | 0, B4 = (2097151 & B4) << 11 | C4 >>> 21, C4 = A8 + g6 | 0, _A2 = B4 = (C4 = B4 >>> 0 > (i4 = B4 + i4 | 0) >>> 0 ? C4 + 1 | 0 : C4) - ((i4 >>> 0 < 4293918720) - 1 | 0) | 0, A8 = i4 - (g6 = -2097152 & (bA2 = i4 - -1048576 | 0)) | 0, q4 = i4 = C4 - ((131071 & B4) + (g6 >>> 0 > i4 >>> 0) | 0) | 0, z4 = g6 = tA2 - (C4 = -2097152 & eA2) | 0, V4 = B4 = fA2 - ((C4 >>> 0 > tA2 >>> 0) + HA2 | 0) | 0, O4 = A8, C4 = DA(A8, i4, 666643, 0), A8 = w3 + wA2 | 0, A8 = C4 >>> 0 > (i4 = C4 + yA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(g6, B4, 654183, 0), g6 = w3 + A8 | 0, kA2 = B4 = C4 + i4 | 0, eA2 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, SA2 = sA2 - (A8 = -2097152 & cA2) | 0, lA2 = pA2 - ((A8 >>> 0 > sA2 >>> 0) + lA2 | 0) | 0, g6 = DA(c4, 0, F4, FA2), C4 = w3, B4 = (A8 = g6) + (g6 = DA(H4 = UA2 >>> 6 & 2097151, 0, e4, 0)) | 0, A8 = w3 + C4 | 0, A8 = g6 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(y4, 0, h4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (B4 = g6 + B4 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(t4, 0, k4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(s4, 0, G4 = GA2 >>> 6 & 2097151, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(p4, 0, l4, S4), g6 = w3 + A8 | 0, sA2 = B4 = C4 + B4 | 0, i4 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, g6 = (A8 = a3[r4 + 14 | 0]) >>> 24 | 0, B4 = A8 << 8 | (pA2 = a3[r4 + 10 | 0] | a3[r4 + 11 | 0] << 8 | a3[r4 + 12 | 0] << 16 | a3[r4 + 13 | 0] << 24) >>> 24, g6 = DA(U4 = 2097151 & ((1 & (g6 |= A8 = (C4 = a3[r4 + 15 | 0]) >>> 16 | 0)) << 31 | (A8 = (C4 <<= 16) | B4) >>> 1), 0, e4, 0), A8 = w3, C4 = g6, g6 = DA(c4, 0, H4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = DA(k4, 0, F4, FA2)) + C4 | 0, C4 = w3 + A8 | 0, C4 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(y4, 0, l4, S4), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(t4, 0, h4, 0), g6 = w3 + g6 | 0, cA2 = C4 = A8 + B4 | 0, B4 = A8 >>> 0 > C4 >>> 0 ? g6 + 1 | 0 : g6, g6 = (A8 = a3[hA2 + 14 | 0]) >>> 24 | 0, fA2 = A8 << 8 | (tA2 = a3[hA2 + 10 | 0] | a3[hA2 + 11 | 0] << 8 | a3[hA2 + 12 | 0] << 16 | a3[hA2 + 13 | 0] << 24) >>> 24, C4 = g6, g6 = (A8 = a3[hA2 + 15 | 0]) >>> 16 | 0, g6 = DA(J4 = 2097151 & ((1 & (g6 |= C4)) << 31 | (A8 = A8 << 16 | fA2) >>> 1), 0, s4, 0), A8 = w3 + B4 | 0, A8 = g6 >>> 0 > (C4 = g6 + cA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(p4, 0, G4, 0), A8 = w3 + A8 | 0, fA2 = A8 = g6 >>> 0 > (cA2 = g6 + C4 | 0) >>> 0 ? A8 + 1 | 0 : A8, KA2 = g6 = A8 - ((cA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (A8 = g6 >>> 21 | 0) + i4 | 0, wA2 = C4 = (g6 = (2097151 & g6) << 11 | (yA2 = cA2 - -1048576 | 0) >>> 21) >>> 0 > (HA2 = g6 + sA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, NA2 = g6 = C4 - ((HA2 >>> 0 < 4293918720) - 1 | 0) | 0, A8 = (A8 = g6 >>> 21 | 0) + lA2 | 0, T4 = A8 = (g6 = (C4 = (2097151 & g6) << 11 | (sA2 = HA2 - -1048576 | 0) >>> 21) + SA2 | 0) >>> 0 < C4 >>> 0 ? A8 + 1 | 0 : A8, W4 = g6, A8 = DA(g6, A8, -997805, -1), g6 = w3 + eA2 | 0, kA2 = C4 = A8 + kA2 | 0, eA2 = A8 >>> 0 > C4 >>> 0 ? g6 + 1 | 0 : g6, SA2 = (mA2 = a3[23 + (n4 = f4 + 224 | 0) | 0] | a3[n4 + 24 | 0] << 8 | a3[n4 + 25 | 0] << 16 | a3[n4 + 26 | 0] << 24) >>> 5 & 2097151, C4 = DA(N4 = (A8 = a3[r4 + 2 | 0]) << 16 & 2031616 | a3[0 | r4] | a3[r4 + 1 | 0] << 8, 0, k4, 0), g6 = w3, B4 = (A8 = DA(h4, 0, Y4 = (i4 = a3[r4 + 2 | 0] | a3[r4 + 3 | 0] << 8 | a3[r4 + 4 | 0] << 16 | a3[r4 + 5 | 0] << 24) >>> 5 & 2097151, 0)) + C4 | 0, C4 = w3 + g6 | 0, C4 = A8 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(b4 = (a3[r4 + 7 | 0] | a3[r4 + 8 | 0] << 8 | a3[r4 + 9 | 0] << 16 | a3[r4 + 10 | 0] << 24) >>> 7 & 2097151, 0, G4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(J4, 0, _4 = pA2 >>> 4 & 2097151, 0), A8 = w3 + g6 | 0, pA2 = B4 = C4 + B4 | 0, B4 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, i4 = (g6 = a3[r4 + 6 | 0]) << 8 | i4 >>> 24, C4 = A8 = g6 >>> 24 | 0, g6 = (A8 = a3[r4 + 7 | 0]) >>> 16 | 0, g6 = DA(K4 = 2097151 & ((3 & (g6 |= C4)) << 30 | (A8 = A8 << 16 | i4) >>> 2), 0, l4, S4), A8 = w3 + B4 | 0, A8 = g6 >>> 0 > (C4 = g6 + pA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = DA(H4, 0, P4 = (a3[hA2 + 7 | 0] | a3[hA2 + 8 | 0] << 8 | a3[hA2 + 9 | 0] << 16 | a3[hA2 + 10 | 0] << 24) >>> 7 & 2097151, 0)) + C4 | 0, C4 = w3 + A8 | 0, C4 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(U4, 0, YA2 = tA2 >>> 4 & 2097151, 0), A8 = w3 + C4 | 0, i4 = g6 >>> 0 > (B4 = g6 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, A8 = (g6 = a3[hA2 + 6 | 0]) >>> 24 | 0, pA2 = g6 << 8 | (tA2 = a3[hA2 + 2 | 0] | a3[hA2 + 3 | 0] << 8 | a3[hA2 + 4 | 0] << 16 | a3[hA2 + 5 | 0] << 24) >>> 24, g6 = A8, A8 = DA(F4, FA2, d4 = 2097151 & ((3 & (g6 |= C4 = (A8 = a3[hA2 + 7 | 0]) >>> 16 | 0)) << 30 | (A8 = A8 << 16 | pA2) >>> 2), 0), g6 = w3 + i4 | 0, g6 = A8 >>> 0 > (C4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, B4 = C4, C4 = DA(L4 = (A8 = a3[hA2 + 2 | 0]) << 16 & 2031616 | a3[0 | hA2] | a3[hA2 + 1 | 0] << 8, 0, y4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(t4, 0, R4 = tA2 >>> 5 & 2097151, 0), A8 = w3 + A8 | 0, g6 = g6 >>> 0 > (C4 = g6 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, pA2 = A8 = C4 + SA2 | 0, i4 = g6 = A8 >>> 0 < C4 >>> 0 ? g6 + 1 | 0 : g6, B4 = a3[n4 + 21 | 0] | a3[n4 + 22 | 0] << 8, A8 = DA(h4, 0, N4, 0), g6 = w3, tA2 = (C4 = A8) + (A8 = DA(l4, S4, Y4, 0)) | 0, C4 = w3 + g6 | 0, C4 = A8 >>> 0 > tA2 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(J4, 0, b4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (tA2 = A8 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(_4, 0, YA2, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, tA2 = (A8 = C4) + (C4 = DA(G4, 0, K4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > tA2 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(H4, 0, d4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + tA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, tA2 = (g6 = DA(U4, 0, P4, 0)) + C4 | 0, C4 = w3 + A8 | 0, C4 = g6 >>> 0 > tA2 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(F4, FA2, R4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (tA2 = A8 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(t4, 0, L4, 0), g6 = w3 + g6 | 0, A8 = A8 >>> 0 > (C4 = A8 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, g6 = (g6 = C4) >>> 0 > (C4 = C4 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = C4, C4 = (A8 = a3[n4 + 23 | 0]) << 16 & 2031616, A8 = g6, C4 = A8 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? A8 + 1 | 0 : A8, hA2 = A8 = A8 - ((B4 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (g6 = A8 >>> 21 | 0) + i4 | 0, A8 = (g6 = (i4 = pA2 = (A8 = (2097151 & A8) << 11 | (tA2 = B4 - -1048576 | 0) >>> 21) + pA2 | 0) >>> 0 < A8 >>> 0 ? g6 + 1 | 0 : g6) + eA2 | 0, A8 = (eA2 = i4 + kA2 | 0) >>> 0 < i4 >>> 0 ? A8 + 1 | 0 : A8, UA2 = i4 - -1048576 | 0, MA2 = i4 = g6 - ((i4 >>> 0 < 4293918720) - 1 | 0) | 0, JA2 = eA2 - (g6 = -2097152 & UA2) | 0, PA2 = A8 - ((g6 >>> 0 > eA2 >>> 0) + i4 | 0) | 0, pA2 = B4, eA2 = C4, A8 = DA(z4, V4, 470296, 0), g6 = w3, C4 = A8, A8 = DA(X4, j4, 666643, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, B4 = (A8 = C4) + (C4 = DA(W4, T4, 654183, 0)) | 0, A8 = w3 + g6 | 0, GA2 = B4, i4 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(l4, S4, N4, 0), A8 = w3, C4 = g6, g6 = DA(G4, 0, Y4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = C4) + (C4 = DA(b4, 0, YA2, 0)) | 0, g6 = w3 + A8 | 0, g6 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(_4, 0, P4, 0), C4 = w3 + g6 | 0, C4 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(J4, 0, K4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(H4, 0, R4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(U4, 0, d4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = C4) + (C4 = DA(F4, FA2, L4, 0)) | 0, g6 = w3 + A8 | 0, SA2 = B4, C4 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, g6 = (A8 = a3[n4 + 19 | 0]) >>> 24 | 0, lA2 = A8 << 8 | (kA2 = a3[n4 + 15 | 0] | a3[n4 + 16 | 0] << 8 | a3[n4 + 17 | 0] << 16 | a3[n4 + 18 | 0] << 24) >>> 24, C4 = ((vA2 = (A8 = (B4 = a3[n4 + 20 | 0]) >>> 16 | 0) | g6) >>> 3 | 0) + C4 | 0, SA2 = B4 = (g6 = (7 & vA2) << 29 | (g6 = (B4 <<= 16) | lA2) >>> 3) + SA2 | 0, B4 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, lA2 = kA2 >>> 6 & 2097151, A8 = DA(G4, 0, N4, 0), g6 = w3, C4 = A8, A8 = DA(J4, 0, Y4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, kA2 = (A8 = C4) + (C4 = DA(b4, 0, P4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > kA2 >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(_4, 0, d4, 0), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (kA2 = C4 + kA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(K4, 0, YA2, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (kA2 = C4 + kA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(H4, 0, L4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (kA2 = g6 + kA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(U4, 0, R4, 0), g6 = w3 + C4 | 0, A8 = A8 >>> 0 > (kA2 = A8 + kA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, VA2 = A8 = (LA2 = kA2 + lA2 | 0) >>> 0 < kA2 >>> 0 ? A8 + 1 | 0 : A8, gI2 = A8 = A8 - ((LA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (qA2 = LA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + B4 | 0, TA2 = A8 = C4 >>> 0 > (OA2 = C4 + SA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, CI2 = A8 = A8 - ((OA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (xA2 = OA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + i4 | 0, g6 = (C4 >>> 0 > (B4 = C4 + GA2 | 0) >>> 0 ? A8 + 1 | 0 : A8) + eA2 | 0, eA2 = (C4 = B4 + pA2 | 0) - (A8 = -2097152 & tA2) | 0, hA2 = A8 = (g6 = C4 >>> 0 < B4 >>> 0 ? g6 + 1 | 0 : g6) - ((A8 >>> 0 > C4 >>> 0) + hA2 | 0) | 0, BI2 = A8 = A8 - ((eA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (jA2 = eA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + PA2 | 0, B4 = A8 = C4 >>> 0 > (i4 = C4 + JA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, II2 = A8 = A8 - ((i4 >>> 0 < 4293918720) - 1 | 0) | 0, XA2 = (2097151 & A8) << 11 | (GA2 = i4 - -1048576 | 0) >>> 21, pA2 = A8 >> 21, vA2 = HA2 - (A8 = -2097152 & sA2) | 0, NA2 = wA2 - ((A8 >>> 0 > HA2 >>> 0) + NA2 | 0) | 0, A8 = DA(e4, 0, s4, 0), zA2 = g6 = w3, JA2 = A8, kA2 = A8 - -1048576 | 0, RA2 = g6 = g6 - ((A8 >>> 0 < 4293918720) - 1 | 0) | 0, Z3 = A8 = g6 >>> 21 | 0, A8 = DA(x4 = (2097151 & g6) << 11 | kA2 >>> 21, A8, -683901, -1), g6 = w3 + fA2 | 0, g6 = A8 >>> 0 > (C4 = A8 + cA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, sA2 = C4 - (A8 = -2097152 & yA2) | 0, tA2 = g6 - ((A8 >>> 0 > C4 >>> 0) + KA2 | 0) | 0, g6 = DA(k4, 0, H4, 0), A8 = w3, C4 = g6, g6 = DA(e4, 0, _4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(c4, 0, U4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + C4 | 0) >>> 0 ? A8 + 1 | 0 : A8, fA2 = (g6 = C4) + (C4 = DA(h4, 0, F4, FA2)) | 0, g6 = w3 + A8 | 0, g6 = C4 >>> 0 > fA2 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(y4, 0, G4, 0), C4 = w3 + g6 | 0, C4 = A8 >>> 0 > (fA2 = A8 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(t4, 0, l4, S4), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (fA2 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(s4, 0, YA2, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(p4, 0, J4, 0), A8 = w3 + A8 | 0, cA2 = C4 = g6 + fA2 | 0, fA2 = g6 >>> 0 > C4 >>> 0 ? A8 + 1 | 0 : A8, A8 = DA(c4, 0, _4, 0), g6 = w3, C4 = A8, A8 = DA(e4, 0, b4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, wA2 = (A8 = DA(h4, 0, H4, 0)) + C4 | 0, C4 = w3 + g6 | 0, C4 = A8 >>> 0 > wA2 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(k4, 0, U4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (wA2 = A8 + wA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(F4, FA2, l4, S4), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (wA2 = C4 + wA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(y4, 0, J4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + wA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, wA2 = (g6 = C4) + (C4 = DA(t4, 0, G4, 0)) | 0, g6 = w3 + A8 | 0, g6 = C4 >>> 0 > wA2 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(s4, 0, P4, 0), C4 = w3 + g6 | 0, C4 = A8 >>> 0 > (wA2 = A8 + wA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(p4, 0, YA2, 0), g6 = w3 + C4 | 0, lA2 = g6 = A8 >>> 0 > (SA2 = A8 + wA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, ZA2 = A8 = g6 - ((SA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (2097151 & A8) << 11 | (HA2 = SA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + fA2 | 0, yA2 = A8 = g6 >>> 0 > (KA2 = g6 + cA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, dA2 = A8 = A8 - ((KA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (C4 = A8 >>> 21 | 0) + tA2 | 0, sA2 = g6 = (A8 = (2097151 & A8) << 11 | (wA2 = KA2 - -1048576 | 0) >>> 21) >>> 0 > (PA2 = A8 + sA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, WA2 = A8 = g6 - ((PA2 >>> 0 < 4293918720) - 1 | 0) | 0, fA2 = (2097151 & A8) << 11 | (tA2 = PA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + NA2 | 0, $3 = A8 = (g6 = fA2 + vA2 | 0) >>> 0 < fA2 >>> 0 ? A8 + 1 | 0 : A8, AA2 = g6, A8 = DA(g6, A8, -683901, -1), g6 = w3 + pA2 | 0, XA2 = C4 = A8 + XA2 | 0, pA2 = A8 >>> 0 > C4 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(c4, 0, N4, 0), g6 = w3, C4 = A8, A8 = DA(k4, 0, Y4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, fA2 = (A8 = C4) + (C4 = DA(l4, S4, b4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > fA2 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(G4, 0, _4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (fA2 = g6 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(h4, 0, K4, 0), A8 = w3 + C4 | 0, A8 = g6 >>> 0 > (fA2 = g6 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(H4, 0, YA2, 0), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(U4, 0, J4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, fA2 = (A8 = C4) + (C4 = DA(F4, FA2, P4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > fA2 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(y4, 0, R4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (fA2 = g6 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(t4, 0, d4, 0), A8 = w3 + C4 | 0, A8 = g6 >>> 0 > (fA2 = g6 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(p4, 0, L4, 0), g6 = w3 + A8 | 0, NA2 = fA2 = C4 + fA2 | 0, C4 = C4 >>> 0 > fA2 >>> 0 ? g6 + 1 | 0 : g6, g6 = (A8 = a3[n4 + 27 | 0]) >>> 24 | 0, cA2 = A8 << 8 | mA2 >>> 24, fA2 = 2097151 & ((3 & (g6 |= A8 = (fA2 = a3[n4 + 28 | 0]) >>> 16 | 0)) << 30 | (A8 = (fA2 <<= 16) | cA2) >>> 2), g6 = C4, cA2 = A8 = fA2 + NA2 | 0, fA2 = A8 >>> 0 < fA2 >>> 0 ? g6 + 1 | 0 : g6, vA2 = DA(O4, q4, 470296, 0), NA2 = w3, A8 = (C4 = (2097151 & _A2) << 11 | bA2 >>> 21) + (JA2 - (g6 = -2097152 & kA2) | 0) | 0, g6 = zA2 - ((524287 & RA2) + (g6 >>> 0 > JA2 >>> 0) | 0) + (_A2 >>> 21) | 0, IA2 = g6 = A8 >>> 0 < C4 >>> 0 ? g6 + 1 | 0 : g6, gA2 = A8, g6 = DA(A8, g6, 666643, 0), A8 = w3 + NA2 | 0, A8 = g6 >>> 0 > (C4 = g6 + vA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, kA2 = (g6 = DA(X4, j4, 654183, 0)) + C4 | 0, C4 = w3 + A8 | 0, C4 = g6 >>> 0 > kA2 >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(z4, V4, -997805, -1), A8 = w3 + C4 | 0, A8 = g6 >>> 0 > (kA2 = g6 + kA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(W4, T4, 136657, 0), g6 = w3 + A8 | 0, UA2 = (A8 = (2097151 & MA2) << 11 | UA2 >>> 21) + (kA2 = C4 + kA2 | 0) | 0, g6 = (MA2 >>> 21 | 0) + (C4 >>> 0 > kA2 >>> 0 ? g6 + 1 | 0 : g6) | 0, RA2 = kA2 = fA2 - ((cA2 >>> 0 < 4293918720) - 1 | 0) | 0, A8 = (A8 >>> 0 > UA2 >>> 0 ? g6 + 1 | 0 : g6) + fA2 | 0, g6 = (fA2 = cA2 + UA2 | 0) - (C4 = -2097152 & (zA2 = cA2 - -1048576 | 0)) | 0, C4 = (A8 = (A8 = fA2 >>> 0 < UA2 >>> 0 ? A8 + 1 | 0 : A8) - ((C4 >>> 0 > fA2 >>> 0) + kA2 | 0) | 0) + pA2 | 0, vA2 = fA2 = A8 - ((g6 >>> 0 < 4293918720) - 1 | 0) | 0, JA2 = (C4 = (cA2 = g6 + XA2 | 0) >>> 0 < g6 >>> 0 ? C4 + 1 | 0 : C4) - (((g6 = -2097152 & (NA2 = g6 - -1048576 | 0)) >>> 0 > cA2 >>> 0) + fA2 | 0) | 0, mA2 = A8 = cA2 - g6 | 0, fA2 = i4, i4 = B4, AI2 = PA2 - (A8 = -2097152 & tA2) | 0, kA2 = sA2 - ((A8 >>> 0 > PA2 >>> 0) + WA2 | 0) | 0, A8 = DA(gA2, IA2, -683901, -1), g6 = w3, B4 = (C4 = A8) + (A8 = DA(x4, Z3, 136657, 0)) | 0, C4 = w3 + g6 | 0, g6 = yA2 + (A8 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4) | 0, wA2 = (C4 = B4 + KA2 | 0) - (A8 = -2097152 & wA2) | 0, sA2 = (g6 = C4 >>> 0 < KA2 >>> 0 ? g6 + 1 | 0 : g6) - ((A8 >>> 0 > C4 >>> 0) + dA2 | 0) | 0, g6 = DA(x4, Z3, -997805, -1), A8 = w3 + lA2 | 0, A8 = g6 >>> 0 > (C4 = g6 + SA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = DA(gA2, IA2, 136657, 0)) + C4 | 0, C4 = w3 + A8 | 0, C4 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(O4, q4, -683901, -1), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, tA2 = B4 - (A8 = -2097152 & HA2) | 0, pA2 = g6 - ((A8 >>> 0 > B4 >>> 0) + ZA2 | 0) | 0, g6 = DA(k4, 0, _4, 0), A8 = w3, C4 = g6, g6 = DA(c4, 0, b4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = DA(e4, 0, K4, 0)) + C4 | 0, C4 = w3 + A8 | 0, C4 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(l4, S4, H4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(h4, 0, U4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(F4, FA2, G4, 0), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(y4, 0, YA2, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(t4, 0, J4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (B4 = g6 + B4 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(s4, 0, d4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(p4, 0, P4, 0), A8 = w3 + g6 | 0, cA2 = B4 = C4 + B4 | 0, B4 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, A8 = DA(k4, 0, b4, 0), g6 = w3, C4 = A8, A8 = DA(e4, 0, Y4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, yA2 = (A8 = C4) + (C4 = DA(h4, 0, _4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > yA2 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(c4, 0, K4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (yA2 = g6 + yA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(H4, 0, G4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (yA2 = A8 + yA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(l4, S4, U4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (yA2 = C4 + yA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(F4, FA2, J4, 0), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (yA2 = C4 + yA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(y4, 0, P4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (yA2 = C4 + yA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(t4, 0, YA2, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (yA2 = g6 + yA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, yA2 = (A8 = DA(s4, 0, R4, 0)) + yA2 | 0, g6 = w3 + C4 | 0, C4 = DA(p4, 0, d4, 0), A8 = w3 + (A8 >>> 0 > yA2 >>> 0 ? g6 + 1 | 0 : g6) | 0, PA2 = A8 = C4 >>> 0 > (WA2 = C4 + yA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, BA2 = A8 = A8 - ((WA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (_A2 = WA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + B4 | 0, bA2 = A8 = C4 >>> 0 > (XA2 = C4 + cA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, iA2 = A8 = A8 - ((XA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (MA2 = XA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + pA2 | 0, UA2 = A8 = C4 >>> 0 > (KA2 = C4 + tA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, oA2 = A8 = A8 - ((KA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (lA2 = KA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + sA2 | 0, B4 = A8 = C4 >>> 0 > (tA2 = C4 + wA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, sA2 = A8 = A8 - ((tA2 >>> 0 < 4293918720) - 1 | 0) | 0, pA2 = (2097151 & A8) << 11 | (C4 = tA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + kA2 | 0, ZA2 = A8 = (cA2 = pA2 + AI2 | 0) >>> 0 < pA2 >>> 0 ? A8 + 1 | 0 : A8, dA2 = cA2, A8 = DA(cA2, A8, -683901, -1), g6 = w3, cA2 = A8, A8 = DA(AA2, $3, 136657, 0), g6 = w3 + g6 | 0, A8 = (A8 >>> 0 > (cA2 = cA2 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6) + i4 | 0, QI2 = (i4 = fA2 + cA2 | 0) - (g6 = -2097152 & GA2) | 0, iI2 = (A8 = i4 >>> 0 < cA2 >>> 0 ? A8 + 1 | 0 : A8) - ((g6 >>> 0 > i4 >>> 0) + II2 | 0) | 0, pA2 = eA2, cA2 = hA2, eA2 = DA(dA2, ZA2, 136657, 0), i4 = w3, AI2 = A8 = tA2 - (g6 = -2097152 & C4) | 0, CA2 = B4 = B4 - ((g6 >>> 0 > tA2 >>> 0) + sA2 | 0) | 0, C4 = DA(AA2, $3, -997805, -1), g6 = w3 + i4 | 0, g6 = C4 >>> 0 > (eA2 = C4 + eA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(A8, B4, -683901, -1), A8 = w3 + g6 | 0, II2 = B4 = C4 + eA2 | 0, fA2 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, A8 = DA(W4, T4, 470296, 0), g6 = w3, B4 = (C4 = A8) + (A8 = DA(z4, V4, 666643, 0)) | 0, C4 = w3 + g6 | 0, g6 = TA2 + (A8 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4) | 0, kA2 = A8 = B4 + OA2 | 0, i4 = g6 = A8 >>> 0 < OA2 >>> 0 ? g6 + 1 | 0 : g6, g6 = DA(W4, T4, 666643, 0), A8 = w3 + VA2 | 0, A8 = g6 >>> 0 > (C4 = g6 + LA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, wA2 = C4 - (g6 = -2097152 & qA2) | 0, SA2 = A8 - ((g6 >>> 0 > C4 >>> 0) + gI2 | 0) | 0, g6 = DA(J4, 0, N4, 0), A8 = w3, C4 = g6, g6 = DA(Y4, 0, YA2, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = C4) + (C4 = DA(b4, 0, d4, 0)) | 0, g6 = w3 + A8 | 0, g6 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(_4, 0, R4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(K4, 0, P4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (B4 = g6 + B4 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(U4, 0, L4, 0), g6 = w3 + C4 | 0, tA2 = B4 = A8 + B4 | 0, B4 = A8 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, g6 = (A8 = a3[n4 + 14 | 0]) >>> 24 | 0, eA2 = A8 << 8 | (sA2 = a3[n4 + 10 | 0] | a3[n4 + 11 | 0] << 8 | a3[n4 + 12 | 0] << 16 | a3[n4 + 13 | 0] << 24) >>> 24, g6 = 2097151 & ((1 & (g6 |= C4 = (A8 = a3[n4 + 15 | 0]) >>> 16 | 0)) << 31 | (A8 = eA2 | A8 << 16) >>> 1), A8 = B4, tA2 = C4 = g6 + tA2 | 0, B4 = g6 >>> 0 > C4 >>> 0 ? A8 + 1 | 0 : A8, eA2 = sA2 >>> 4 & 2097151, A8 = DA(N4, 0, YA2, 0), g6 = w3, C4 = A8, A8 = DA(Y4, 0, P4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(b4, 0, R4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + C4 | 0) >>> 0 ? g6 + 1 | 0 : g6, sA2 = (A8 = C4) + (C4 = DA(_4, 0, L4, 0)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > sA2 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(K4, 0, d4, 0), C4 = w3 + A8 | 0, A8 = g6 >>> 0 > (sA2 = g6 + sA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, hA2 = A8 = (qA2 = eA2 + sA2 | 0) >>> 0 < sA2 >>> 0 ? A8 + 1 | 0 : A8, aA2 = A8 = A8 - ((qA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (C4 = A8 >>> 21 | 0) + B4 | 0, HA2 = g6 = (A8 = (2097151 & A8) << 11 | (GA2 = qA2 - -1048576 | 0) >>> 21) >>> 0 > (TA2 = A8 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, nA2 = A8 = g6 - ((TA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (2097151 & A8) << 11 | (yA2 = TA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + SA2 | 0, sA2 = A8 = g6 >>> 0 > (wA2 = g6 + wA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, rA2 = A8 = A8 - ((wA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (C4 = A8 >> 21) + i4 | 0, gI2 = g6 = (g6 = (A8 = (2097151 & A8) << 11 | (tA2 = wA2 - -1048576 | 0) >>> 21) >>> 0 > (B4 = A8 + kA2 | 0) >>> 0 ? g6 + 1 | 0 : g6) - (((C4 = -2097152 & xA2) >>> 0 > B4 >>> 0) + CI2 | 0) | 0, xA2 = A8 = B4 - C4 | 0, eA2 = A8 - -1048576 | 0, CI2 = A8 = g6 - ((A8 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (g6 = A8 >> 21) + fA2 | 0, g6 = ((A8 = (2097151 & A8) << 11 | eA2 >>> 21) >>> 0 > (B4 = A8 + II2 | 0) >>> 0 ? C4 + 1 | 0 : C4) + cA2 | 0, LA2 = g6 = (g6 = (A8 = B4) >>> 0 > (B4 = B4 + pA2 | 0) >>> 0 ? g6 + 1 | 0 : g6) - (((C4 = -2097152 & jA2) >>> 0 > B4 >>> 0) + BI2 | 0) | 0, cA2 = A8 = B4 - C4 | 0, i4 = A8 - -1048576 | 0, VA2 = A8 = g6 - ((A8 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (g6 = A8 >> 21) + iI2 | 0, jA2 = A8 = (C4 = (A8 = (2097151 & A8) << 11 | i4 >>> 21) >>> 0 > (fA2 = A8 + QI2 | 0) >>> 0 ? C4 + 1 | 0 : C4) - ((fA2 >>> 0 < 4293918720) - 1 | 0) | 0, kA2 = mA2 - -1048576 | 0, SA2 = JA2 - ((mA2 >>> 0 < 4293918720) - 1 | 0) | 0, pA2 = (2097151 & A8) << 11 | (B4 = fA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + JA2 | 0, BI2 = (mA2 = pA2 + mA2 | 0) - (g6 = -2097152 & kA2) | 0, QI2 = (pA2 >>> 0 > mA2 >>> 0 ? A8 + 1 | 0 : A8) - ((g6 >>> 0 > mA2 >>> 0) + SA2 | 0) | 0, iI2 = fA2 - (A8 = -2097152 & B4) | 0, II2 = C4 - ((A8 >>> 0 > fA2 >>> 0) + jA2 | 0) | 0, OA2 = cA2 - (A8 = -2097152 & i4) | 0, mA2 = LA2 - ((A8 >>> 0 > cA2 >>> 0) + VA2 | 0) | 0, A8 = DA(dA2, ZA2, -997805, -1), g6 = w3, C4 = A8, A8 = DA(AA2, $3, 654183, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, B4 = (A8 = C4) + (C4 = DA(AI2, CA2, 136657, 0)) | 0, A8 = w3 + g6 | 0, g6 = gI2 + (C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8) | 0, LA2 = (C4 = B4 + xA2 | 0) - (A8 = -2097152 & eA2) | 0, VA2 = (g6 = C4 >>> 0 < xA2 >>> 0 ? g6 + 1 | 0 : g6) - ((A8 >>> 0 > C4 >>> 0) + CI2 | 0) | 0, xA2 = KA2 - (A8 = -2097152 & lA2) | 0, JA2 = UA2 - ((A8 >>> 0 > KA2 >>> 0) + oA2 | 0) | 0, g6 = DA(gA2, IA2, -997805, -1), A8 = w3, C4 = g6, g6 = DA(x4, Z3, 654183, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = C4) + (C4 = DA(O4, q4, 136657, 0)) | 0, g6 = w3 + A8 | 0, g6 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(X4, j4, -683901, -1), C4 = w3 + g6 | 0, g6 = bA2 + (A8 >>> 0 > (B4 = A8 + B4 | 0) >>> 0 ? C4 + 1 | 0 : C4) | 0, lA2 = (C4 = B4 + XA2 | 0) - (A8 = -2097152 & MA2) | 0, UA2 = (g6 = C4 >>> 0 < XA2 >>> 0 ? g6 + 1 | 0 : g6) - ((A8 >>> 0 > C4 >>> 0) + iA2 | 0) | 0, g6 = DA(gA2, IA2, 654183, 0), A8 = w3, C4 = g6, g6 = DA(x4, Z3, 470296, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = DA(O4, q4, -997805, -1)) + C4 | 0, C4 = w3 + A8 | 0, g6 = PA2 + (g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4) | 0, g6 = (A8 = B4 + WA2 | 0) >>> 0 < WA2 >>> 0 ? g6 + 1 | 0 : g6, C4 = A8, A8 = DA(X4, j4, 136657, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, B4 = (A8 = C4) + (C4 = DA(z4, V4, -683901, -1)) | 0, A8 = w3 + g6 | 0, eA2 = B4 - (g6 = -2097152 & _A2) | 0, i4 = (C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8) - ((g6 >>> 0 > B4 >>> 0) + BA2 | 0) | 0, B4 = (a3[n4 + 28 | 0] | a3[n4 + 29 | 0] << 8 | a3[n4 + 30 | 0] << 16 | a3[n4 + 31 | 0] << 24) >>> 7 | 0, A8 = DA(e4, 0, N4, 0), g6 = w3, fA2 = (C4 = A8) + (A8 = DA(c4, 0, Y4, 0)) | 0, C4 = w3 + g6 | 0, C4 = A8 >>> 0 > fA2 >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(h4, 0, b4, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (fA2 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(l4, S4, _4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(k4, 0, K4, 0), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(H4, 0, J4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(G4, 0, U4, 0), C4 = w3 + A8 | 0, C4 = g6 >>> 0 > (fA2 = g6 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, A8 = DA(F4, FA2, YA2, 0), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (fA2 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(y4, 0, d4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(t4, 0, P4, 0), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(s4, 0, L4, 0), A8 = w3 + g6 | 0, A8 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(p4, 0, R4, 0), C4 = w3 + A8 | 0, g6 = g6 >>> 0 > (fA2 = g6 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, bA2 = (C4 = (2097151 & RA2) << 11 | zA2 >>> 21) + (A8 = B4 + fA2 | 0) | 0, A8 = (RA2 >>> 21 | 0) + (g6 = A8 >>> 0 < fA2 >>> 0 ? g6 + 1 | 0 : g6) | 0, pA2 = A8 = C4 >>> 0 > bA2 >>> 0 ? A8 + 1 | 0 : A8, jA2 = g6 = A8 - ((bA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (A8 = g6 >>> 21 | 0) + i4 | 0, cA2 = C4 = (g6 = (2097151 & g6) << 11 | (FA2 = bA2 - -1048576 | 0) >>> 21) >>> 0 > (MA2 = g6 + eA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, zA2 = g6 = C4 - ((MA2 >>> 0 < 4293918720) - 1 | 0) | 0, A8 = (A8 = g6 >> 21) + UA2 | 0, eA2 = A8 = (g6 = (2097151 & g6) << 11 | (fA2 = MA2 - -1048576 | 0) >>> 21) >>> 0 > (lA2 = g6 + lA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, _A2 = g6 = A8 - ((lA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (A8 = g6 >> 21) + JA2 | 0, RA2 = C4 = (g6 = (B4 = (2097151 & g6) << 11 | (i4 = lA2 - -1048576 | 0) >>> 21) + xA2 | 0) >>> 0 < B4 >>> 0 ? C4 + 1 | 0 : C4, JA2 = g6, A8 = DA(g6, C4, -683901, -1), g6 = w3 + VA2 | 0, UA2 = C4 = A8 + LA2 | 0, B4 = A8 >>> 0 > C4 >>> 0 ? g6 + 1 | 0 : g6, g6 = DA(AA2, $3, 470296, 0), A8 = w3 + sA2 | 0, A8 = g6 >>> 0 > (wA2 = g6 + wA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(dA2, ZA2, 654183, 0), A8 = w3 + (A8 - (((C4 = -2097152 & tA2) >>> 0 > wA2 >>> 0) + rA2 | 0) | 0) | 0, A8 = g6 >>> 0 > (tA2 = g6 + (wA2 - C4 | 0) | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(AI2, CA2, -997805, -1), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (tA2 = C4 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, PA2 = C4 = lA2 - (A8 = -2097152 & i4) | 0, YA2 = eA2 = eA2 - ((A8 >>> 0 > lA2 >>> 0) + _A2 | 0) | 0, tA2 = (i4 = DA(JA2, RA2, 136657, 0)) + tA2 | 0, A8 = w3 + g6 | 0, C4 = DA(C4, eA2, -683901, -1), g6 = w3 + (i4 >>> 0 > tA2 >>> 0 ? A8 + 1 | 0 : A8) | 0, eA2 = g6 = C4 >>> 0 > (sA2 = C4 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, _A2 = A8 = g6 - ((sA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = (2097151 & A8) << 11 | (i4 = sA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + B4 | 0, lA2 = g6 = (A8 = g6 >>> 0 > (tA2 = g6 + UA2 | 0) >>> 0 ? A8 + 1 | 0 : A8) - ((tA2 >>> 0 < 4293918720) - 1 | 0) | 0, wA2 = (2097151 & g6) << 11 | (B4 = tA2 - -1048576 | 0) >>> 21, g6 = (g6 >> 21) + mA2 | 0, OA2 = UA2 = wA2 + OA2 | 0, UA2 = wA2 >>> 0 > UA2 >>> 0 ? g6 + 1 | 0 : g6, mA2 = tA2 - (g6 = -2097152 & B4) | 0, WA2 = A8 - ((g6 >>> 0 > tA2 >>> 0) + lA2 | 0) | 0, LA2 = sA2 - (A8 = -2097152 & i4) | 0, VA2 = eA2 - ((A8 >>> 0 > sA2 >>> 0) + _A2 | 0) | 0, A8 = DA(AA2, $3, 666643, 0), C4 = HA2 + w3 | 0, C4 = (i4 = A8 + TA2 | 0) >>> 0 < TA2 >>> 0 ? C4 + 1 | 0 : C4, B4 = (A8 = DA(dA2, ZA2, 470296, 0)) + (i4 - (g6 = -2097152 & yA2) | 0) | 0, g6 = w3 + (C4 - ((g6 >>> 0 > i4 >>> 0) + nA2 | 0) | 0) | 0, g6 = A8 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(AI2, CA2, 654183, 0), A8 = w3 + g6 | 0, tA2 = B4 = C4 + B4 | 0, B4 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, i4 = MA2 - (A8 = -2097152 & fA2) | 0, eA2 = cA2 - ((A8 >>> 0 > MA2 >>> 0) + zA2 | 0) | 0, A8 = DA(gA2, IA2, 470296, 0), g6 = w3, C4 = A8, A8 = DA(x4, Z3, 666643, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(O4, q4, 654183, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + C4 | 0) >>> 0 ? g6 + 1 | 0 : g6, fA2 = (A8 = C4) + (C4 = DA(X4, j4, -997805, -1)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > fA2 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(z4, V4, 136657, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + fA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, fA2 = (g6 = DA(W4, T4, -683901, -1)) + C4 | 0, C4 = w3 + A8 | 0, g6 = pA2 + (g6 >>> 0 > fA2 >>> 0 ? C4 + 1 | 0 : C4) | 0, MA2 = (C4 = (2097151 & vA2) << 11 | NA2 >>> 21) + ((fA2 = fA2 + bA2 | 0) - (A8 = -2097152 & FA2) | 0) | 0, A8 = ((g6 = fA2 >>> 0 < bA2 >>> 0 ? g6 + 1 | 0 : g6) - ((A8 >>> 0 > fA2 >>> 0) + jA2 | 0) | 0) + (vA2 >> 21) | 0, lA2 = A8 = C4 >>> 0 > MA2 >>> 0 ? A8 + 1 | 0 : A8, xA2 = A8 = A8 - ((MA2 >>> 0 < 4293918720) - 1 | 0) | 0, g6 = i4, i4 = (2097151 & A8) << 11 | (yA2 = MA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + eA2 | 0, _A2 = A8 = (C4 = g6 + i4 | 0) >>> 0 < i4 >>> 0 ? A8 + 1 | 0 : A8, bA2 = C4, A8 = DA(C4, A8, -683901, -1), g6 = w3 + B4 | 0, g6 = A8 >>> 0 > (C4 = A8 + tA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, B4 = (A8 = C4) + (C4 = DA(JA2, RA2, -997805, -1)) | 0, A8 = w3 + g6 | 0, A8 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(PA2, YA2, 136657, 0), C4 = w3 + A8 | 0, NA2 = B4 = g6 + B4 | 0, cA2 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, tA2 = qA2 - (A8 = -2097152 & GA2) | 0, pA2 = hA2 - ((A8 >>> 0 > qA2 >>> 0) + aA2 | 0) | 0, g6 = DA(N4, 0, P4, 0), A8 = w3, C4 = g6, g6 = DA(Y4, 0, d4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = C4 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(b4, 0, L4, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + C4 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = DA(K4, 0, R4, 0)) + C4 | 0, C4 = w3 + A8 | 0, g6 = g6 >>> 0 > B4 >>> 0 ? C4 + 1 | 0 : C4, FA2 = C4 = (A8 = (a3[n4 + 7 | 0] | a3[n4 + 8 | 0] << 8 | a3[n4 + 9 | 0] << 16 | a3[n4 + 10 | 0] << 24) >>> 7 & 2097151) + B4 | 0, fA2 = A8 >>> 0 > C4 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(N4, 0, d4, 0), g6 = w3, C4 = A8, A8 = DA(Y4, 0, R4, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = C4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, B4 = (A8 = C4) + (C4 = DA(K4, 0, L4, 0)) | 0, A8 = w3 + g6 | 0, eA2 = B4, B4 = C4 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, A8 = (g6 = a3[n4 + 6 | 0]) >>> 24 | 0, i4 = g6 << 8 | (jA2 = a3[n4 + 2 | 0] | a3[n4 + 3 | 0] << 8 | a3[n4 + 4 | 0] << 16 | a3[n4 + 5 | 0] << 24) >>> 24, C4 = A8, g6 = (A8 = a3[n4 + 7 | 0]) >>> 16 | 0, g6 |= C4, C4 = B4, i4 = C4 = (A8 = 2097151 & ((3 & g6) << 30 | (A8 = A8 << 16 | i4) >>> 2)) >>> 0 > (eA2 = A8 + eA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, XA2 = A8 = C4 - ((eA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (HA2 = eA2 - -1048576 | 0) >>> 21, A8 = (A8 >>> 21 | 0) + fA2 | 0, wA2 = A8 = C4 >>> 0 > (hA2 = C4 + FA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, zA2 = A8 = A8 - ((hA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (g6 = A8 >>> 21 | 0) + pA2 | 0, C4 = (A8 = (2097151 & A8) << 11 | (sA2 = hA2 - -1048576 | 0) >>> 21) >>> 0 > (B4 = A8 + tA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(dA2, ZA2, 666643, 0), A8 = w3 + C4 | 0, A8 = g6 >>> 0 > (B4 = g6 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(AI2, CA2, 470296, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + B4 | 0) >>> 0 ? A8 + 1 | 0 : A8, B4 = (g6 = C4) + (C4 = DA(bA2, _A2, 136657, 0)) | 0, g6 = w3 + A8 | 0, g6 = C4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(JA2, RA2, 654183, 0), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, tA2 = (A8 = DA(PA2, YA2, -997805, -1)) + C4 | 0, C4 = w3 + g6 | 0, pA2 = C4 = A8 >>> 0 > tA2 >>> 0 ? C4 + 1 | 0 : C4, vA2 = A8 = C4 - ((tA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & A8) << 11 | (FA2 = tA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + cA2 | 0, NA2 = C4 = (A8 = C4 >>> 0 > (B4 = C4 + NA2 | 0) >>> 0 ? A8 + 1 | 0 : A8) - ((B4 >>> 0 < 4293918720) - 1 | 0) | 0, fA2 = (2097151 & C4) << 11 | (cA2 = B4 - -1048576 | 0) >>> 21, C4 = (C4 >> 21) + VA2 | 0, KA2 = GA2 = fA2 + LA2 | 0, GA2 = fA2 >>> 0 > GA2 >>> 0 ? C4 + 1 | 0 : C4, fA2 = B4, g6 = A8, B4 = (MA2 - (A8 = -2097152 & yA2) | 0) + (yA2 = (2097151 & SA2) << 11 | kA2 >>> 21) | 0, A8 = (lA2 - ((A8 >>> 0 > MA2 >>> 0) + xA2 | 0) | 0) + (SA2 >> 21) | 0, kA2 = A8 = B4 >>> 0 < yA2 >>> 0 ? A8 + 1 | 0 : A8, LA2 = A8 = A8 - ((B4 >>> 0 < 4293918720) - 1 | 0) | 0, MA2 = C4 = A8 >> 21, A8 = DA(dA2 = (2097151 & A8) << 11 | (SA2 = B4 - -1048576 | 0) >>> 21, C4, -683901, -1), g6 = w3 + g6 | 0, g6 = A8 >>> 0 > (C4 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, VA2 = C4 - (A8 = -2097152 & cA2) | 0, qA2 = g6 - ((A8 >>> 0 > C4 >>> 0) + NA2 | 0) | 0, g6 = DA(dA2, MA2, 136657, 0), A8 = w3 + pA2 | 0, A8 = g6 >>> 0 > (C4 = g6 + tA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, TA2 = C4 - (g6 = -2097152 & FA2) | 0, vA2 = A8 - ((g6 >>> 0 > C4 >>> 0) + vA2 | 0) | 0, g6 = DA(AI2, CA2, 666643, 0), A8 = w3 + (wA2 - (((C4 = -2097152 & sA2) >>> 0 > hA2 >>> 0) + zA2 | 0) | 0) | 0, A8 = g6 >>> 0 > (fA2 = g6 + (hA2 - C4 | 0) | 0) >>> 0 ? A8 + 1 | 0 : A8, C4 = DA(bA2, _A2, -997805, -1), g6 = w3 + A8 | 0, g6 = C4 >>> 0 > (fA2 = C4 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(JA2, RA2, 470296, 0), C4 = w3 + g6 | 0, C4 = A8 >>> 0 > (fA2 = A8 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(PA2, YA2, 654183, 0), A8 = w3 + C4 | 0, NA2 = fA2 = g6 + fA2 | 0, pA2 = g6 >>> 0 > fA2 >>> 0 ? A8 + 1 | 0 : A8, C4 = jA2 >>> 5 & 2097151, A8 = DA(N4, 0, R4, 0), g6 = w3, cA2 = A8, A8 = DA(Y4, 0, L4, 0), g6 = w3 + g6 | 0, A8 = A8 >>> 0 > (fA2 = cA2 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, cA2 = g6 = C4 + fA2 | 0, C4 = A8 = g6 >>> 0 < fA2 >>> 0 ? A8 + 1 | 0 : A8, hA2 = (g6 = DA(N4, 0, L4, 0)) + (A8 = (A8 = a3[n4 + 2 | 0]) << 16 & 2031616 | a3[0 | n4] | a3[n4 + 1 | 0] << 8) | 0, g6 = w3, yA2 = g6 = A8 >>> 0 > hA2 >>> 0 ? g6 + 1 | 0 : g6, xA2 = g6 = g6 - ((hA2 >>> 0 < 4293918720) - 1 | 0) | 0, A8 = (A8 = g6 >>> 21 | 0) + C4 | 0, sA2 = A8 = (g6 = (2097151 & g6) << 11 | (wA2 = hA2 - -1048576 | 0) >>> 21) >>> 0 > (lA2 = g6 + cA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, jA2 = g6 = A8 - ((lA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (2097151 & g6) << 11 | (tA2 = lA2 - -1048576 | 0) >>> 21, g6 = (g6 >>> 21 | 0) + i4 | 0, g6 = C4 >>> 0 > (fA2 = C4 + eA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, C4 = DA(bA2, _A2, 654183, 0), A8 = w3 + (g6 - (((i4 = -2097152 & HA2) >>> 0 > fA2 >>> 0) + XA2 | 0) | 0) | 0, A8 = C4 >>> 0 > (eA2 = C4 + (fA2 - i4 | 0) | 0) >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(JA2, RA2, 666643, 0), A8 = w3 + A8 | 0, A8 = g6 >>> 0 > (C4 = g6 + eA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, FA2 = (g6 = C4) + (C4 = DA(PA2, YA2, 470296, 0)) | 0, g6 = w3 + A8 | 0, cA2 = g6 = C4 >>> 0 > FA2 >>> 0 ? g6 + 1 | 0 : g6, zA2 = g6 = g6 - ((FA2 >>> 0 < 4293918720) - 1 | 0) | 0, C4 = (A8 = g6 >> 21) + pA2 | 0, HA2 = g6 = (C4 = (g6 = (2097151 & g6) << 11 | (fA2 = FA2 - -1048576 | 0) >>> 21) >>> 0 > (eA2 = g6 + NA2 | 0) >>> 0 ? C4 + 1 | 0 : C4) - ((eA2 >>> 0 < 4293918720) - 1 | 0) | 0, pA2 = (2097151 & g6) << 11 | (i4 = eA2 - -1048576 | 0) >>> 21, g6 = (g6 >> 21) + vA2 | 0, RA2 = JA2 = pA2 + TA2 | 0, pA2 = pA2 >>> 0 > JA2 >>> 0 ? g6 + 1 | 0 : g6, A8 = DA(dA2, MA2, -997805, -1), g6 = w3 + C4 | 0, g6 = A8 >>> 0 > (eA2 = A8 + eA2 | 0) >>> 0 ? g6 + 1 | 0 : g6, vA2 = eA2 - (A8 = -2097152 & i4) | 0, NA2 = g6 - ((A8 >>> 0 > eA2 >>> 0) + HA2 | 0) | 0, g6 = DA(dA2, MA2, 654183, 0), A8 = w3 + cA2 | 0, A8 = g6 >>> 0 > (C4 = g6 + FA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, JA2 = C4 - (g6 = -2097152 & fA2) | 0, HA2 = A8 - ((g6 >>> 0 > C4 >>> 0) + zA2 | 0) | 0, A8 = DA(bA2, _A2, 470296, 0), C4 = w3 + (sA2 - (((g6 = -2097152 & tA2) >>> 0 > lA2 >>> 0) + jA2 | 0) | 0) | 0, C4 = A8 >>> 0 > (i4 = A8 + (lA2 - g6 | 0) | 0) >>> 0 ? C4 + 1 | 0 : C4, g6 = DA(PA2, YA2, 666643, 0), A8 = w3 + C4 | 0, eA2 = i4 = g6 + i4 | 0, C4 = g6 >>> 0 > i4 >>> 0 ? A8 + 1 | 0 : A8, g6 = DA(bA2, _A2, 666643, 0), A8 = w3 + (yA2 - ((4095 & xA2) + ((i4 = -2097152 & wA2) >>> 0 > hA2 >>> 0) | 0) | 0) | 0, FA2 = A8 = g6 >>> 0 > (tA2 = g6 + (hA2 - i4 | 0) | 0) >>> 0 ? A8 + 1 | 0 : A8, yA2 = A8 = A8 - ((tA2 >>> 0 < 4293918720) - 1 | 0) | 0, i4 = (2097151 & A8) << 11 | (cA2 = tA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + C4 | 0, C4 = A8 = i4 >>> 0 > (fA2 = i4 + eA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, wA2 = A8 = A8 - ((fA2 >>> 0 < 4293918720) - 1 | 0) | 0, i4 = (2097151 & A8) << 11 | (eA2 = fA2 - -1048576 | 0) >>> 21, A8 = (A8 >> 21) + HA2 | 0, i4 = i4 >>> 0 > (sA2 = i4 + JA2 | 0) >>> 0 ? A8 + 1 | 0 : A8, A8 = DA(dA2, MA2, 470296, 0), C4 = w3 + C4 | 0, C4 = A8 >>> 0 > (g6 = A8 + fA2 | 0) >>> 0 ? C4 + 1 | 0 : C4, fA2 = g6 - (A8 = -2097152 & eA2) | 0, eA2 = C4 - ((A8 >>> 0 > g6 >>> 0) + wA2 | 0) | 0, g6 = DA(dA2, MA2, 666643, 0), A8 = w3 + (FA2 - (((C4 = -2097152 & cA2) >>> 0 > tA2 >>> 0) + yA2 | 0) | 0) | 0, g6 = (C4 = (A8 = g6 >>> 0 > (lA2 = g6 + (tA2 - C4 | 0) | 0) >>> 0 ? A8 + 1 | 0 : A8) >> 21) + eA2 | 0, A8 = (A8 = (g6 = (A8 = (2097151 & A8) << 11 | lA2 >>> 21) >>> 0 > (HA2 = A8 + fA2 | 0) >>> 0 ? g6 + 1 | 0 : g6) >> 21) + i4 | 0, g6 = (g6 = (A8 = (g6 = (2097151 & g6) << 11 | HA2 >>> 21) >>> 0 > (yA2 = g6 + sA2 | 0) >>> 0 ? A8 + 1 | 0 : A8) >> 21) + NA2 | 0, C4 = (A8 = (g6 = (A8 = (2097151 & A8) << 11 | yA2 >>> 21) >>> 0 > (i4 = A8 + vA2 | 0) >>> 0 ? g6 + 1 | 0 : g6) >> 21) + pA2 | 0, A8 = (g6 = (C4 = (g6 = (2097151 & g6) << 11 | i4 >>> 21) >>> 0 > (wA2 = g6 + RA2 | 0) >>> 0 ? C4 + 1 | 0 : C4) >> 21) + qA2 | 0, g6 = (C4 = (A8 = (C4 = (2097151 & C4) << 11 | wA2 >>> 21) >>> 0 > (sA2 = C4 + VA2 | 0) >>> 0 ? A8 + 1 | 0 : A8) >> 21) + GA2 | 0, A8 = (A8 = (g6 = (A8 = (2097151 & A8) << 11 | sA2 >>> 21) >>> 0 > (tA2 = A8 + KA2 | 0) >>> 0 ? g6 + 1 | 0 : g6) >> 21) + WA2 | 0, g6 = (g6 = (A8 = (g6 = (2097151 & g6) << 11 | tA2 >>> 21) >>> 0 > (pA2 = g6 + mA2 | 0) >>> 0 ? A8 + 1 | 0 : A8) >> 21) + UA2 | 0, C4 = (A8 = (g6 = (A8 = (2097151 & A8) << 11 | pA2 >>> 21) >>> 0 > (FA2 = A8 + OA2 | 0) >>> 0 ? g6 + 1 | 0 : g6) >> 21) + II2 | 0, A8 = (g6 = (C4 = (g6 = (2097151 & g6) << 11 | FA2 >>> 21) >>> 0 > (cA2 = g6 + iI2 | 0) >>> 0 ? C4 + 1 | 0 : C4) >> 21) + QI2 | 0, eA2 = (SA2 = B4 - (g6 = -2097152 & SA2) | 0) + ((2097151 & (A8 = (C4 = (2097151 & C4) << 11 | cA2 >>> 21) >>> 0 > (fA2 = C4 + BI2 | 0) >>> 0 ? A8 + 1 | 0 : A8)) << 11 | fA2 >>> 21) | 0, A8 = (kA2 - ((g6 >>> 0 > B4 >>> 0) + LA2 | 0) | 0) + (A8 >> 21) | 0, SA2 = g6 = (A8 = eA2 >>> 0 < SA2 >>> 0 ? A8 + 1 | 0 : A8) >> 21, lA2 = (A8 = DA(GA2 = (2097151 & A8) << 11 | eA2 >>> 21, g6, 666643, 0)) + (g6 = 2097151 & lA2) | 0, A8 = w3, B4 = A8 = g6 >>> 0 > lA2 >>> 0 ? A8 + 1 | 0 : A8, E3[0 | Q4] = lA2, E3[Q4 + 1 | 0] = (255 & A8) << 24 | lA2 >>> 8, A8 = 2097151 & HA2, g6 = DA(GA2, SA2, 470296, 0) + A8 | 0, C4 = w3, A8 = (B4 >> 21) + (A8 >>> 0 > g6 >>> 0 ? C4 + 1 | 0 : C4) | 0, A8 = (kA2 = (2097151 & B4) << 11 | lA2 >>> 21) >>> 0 > (HA2 = kA2 + g6 | 0) >>> 0 ? A8 + 1 | 0 : A8, E3[Q4 + 4 | 0] = (2047 & A8) << 21 | HA2 >>> 11, g6 = A8, C4 = HA2, E3[Q4 + 3 | 0] = (7 & A8) << 29 | C4 >>> 3, E3[Q4 + 2 | 0] = 31 & ((65535 & B4) << 16 | lA2 >>> 16) | C4 << 5, B4 = 2097151 & yA2, yA2 = DA(GA2, SA2, 654183, 0) + B4 | 0, A8 = w3, HA2 = (2097151 & g6) << 11 | C4 >>> 21, g6 = (g6 >> 21) + (B4 = B4 >>> 0 > yA2 >>> 0 ? A8 + 1 | 0 : A8) | 0, A8 = g6 = (yA2 = HA2 + yA2 | 0) >>> 0 < HA2 >>> 0 ? g6 + 1 | 0 : g6, E3[Q4 + 6 | 0] = (63 & A8) << 26 | yA2 >>> 6, B4 = yA2, yA2 = 0, E3[Q4 + 5 | 0] = yA2 << 13 | (1572864 & C4) >>> 19 | B4 << 2, C4 = 2097151 & i4, i4 = DA(GA2, SA2, -997805, -1) + C4 | 0, g6 = w3, g6 = C4 >>> 0 > i4 >>> 0 ? g6 + 1 | 0 : g6, yA2 = (2097151 & (C4 = A8)) << 11 | B4 >>> 21, C4 = (A8 >>= 21) + g6 | 0, C4 = (i4 = yA2 + i4 | 0) >>> 0 < yA2 >>> 0 ? C4 + 1 | 0 : C4, E3[Q4 + 9 | 0] = (511 & C4) << 23 | i4 >>> 9, E3[Q4 + 8 | 0] = (1 & C4) << 31 | i4 >>> 1, g6 = 0, E3[Q4 + 7 | 0] = g6 << 18 | (2080768 & B4) >>> 14 | i4 << 7, g6 = 2097151 & wA2, B4 = DA(GA2, SA2, 136657, 0) + g6 | 0, A8 = w3, A8 = g6 >>> 0 > B4 >>> 0 ? A8 + 1 | 0 : A8, wA2 = (2097151 & (g6 = C4)) << 11 | i4 >>> 21, g6 = A8 + (C4 = g6 >> 21) | 0, g6 = (B4 = wA2 + B4 | 0) >>> 0 < wA2 >>> 0 ? g6 + 1 | 0 : g6, E3[Q4 + 12 | 0] = (4095 & g6) << 20 | B4 >>> 12, C4 = B4, E3[Q4 + 11 | 0] = (15 & g6) << 28 | C4 >>> 4, B4 = 0, E3[Q4 + 10 | 0] = B4 << 15 | (1966080 & i4) >>> 17 | C4 << 4, B4 = 2097151 & sA2, i4 = DA(GA2, SA2, -683901, -1) + B4 | 0, A8 = w3, A8 = B4 >>> 0 > i4 >>> 0 ? A8 + 1 | 0 : A8, B4 = g6, g6 = A8 + (g6 >>= 21) | 0, g6 = (B4 = (sA2 = i4) + (i4 = (2097151 & B4) << 11 | C4 >>> 21) | 0) >>> 0 < i4 >>> 0 ? g6 + 1 | 0 : g6, E3[Q4 + 14 | 0] = (127 & g6) << 25 | B4 >>> 7, i4 = 0, E3[Q4 + 13 | 0] = i4 << 12 | (1048576 & C4) >>> 20 | B4 << 1, A8 = g6 >> 21, C4 = (g6 = (2097151 & g6) << 11 | B4 >>> 21) >>> 0 > (i4 = g6 + (2097151 & tA2) | 0) >>> 0 ? A8 + 1 | 0 : A8, E3[Q4 + 17 | 0] = (1023 & C4) << 22 | i4 >>> 10, E3[Q4 + 16 | 0] = (3 & C4) << 30 | i4 >>> 2, g6 = 0, E3[Q4 + 15 | 0] = g6 << 17 | (2064384 & B4) >>> 15 | i4 << 6, A8 = C4 >> 21, A8 = (g6 = (2097151 & C4) << 11 | i4 >>> 21) >>> 0 > (C4 = g6 + (2097151 & pA2) | 0) >>> 0 ? A8 + 1 | 0 : A8, E3[Q4 + 20 | 0] = (8191 & A8) << 19 | C4 >>> 13, E3[Q4 + 19 | 0] = (31 & A8) << 27 | C4 >>> 5, B4 = (g6 = 2097151 & FA2) + (FA2 = (2097151 & A8) << 11 | C4 >>> 21) | 0, g6 = A8 >> 21, g6 = B4 >>> 0 < FA2 >>> 0 ? g6 + 1 | 0 : g6, FA2 = B4, E3[Q4 + 21 | 0] = B4, pA2 = 0, E3[Q4 + 18 | 0] = pA2 << 14 | (1835008 & i4) >>> 18 | C4 << 3, E3[Q4 + 22 | 0] = (255 & g6) << 24 | B4 >>> 8, C4 = g6 >> 21, C4 = (B4 = (i4 = (2097151 & g6) << 11 | B4 >>> 21) + (2097151 & cA2) | 0) >>> 0 < i4 >>> 0 ? C4 + 1 | 0 : C4, E3[Q4 + 25 | 0] = (2047 & C4) << 21 | B4 >>> 11, E3[Q4 + 24 | 0] = (7 & C4) << 29 | B4 >>> 3, E3[Q4 + 23 | 0] = 31 & ((65535 & g6) << 16 | FA2 >>> 16) | B4 << 5, A8 = C4 >> 21, A8 = (g6 = (2097151 & C4) << 11 | B4 >>> 21) >>> 0 > (C4 = g6 + (2097151 & fA2) | 0) >>> 0 ? A8 + 1 | 0 : A8, E3[Q4 + 27 | 0] = (63 & A8) << 26 | C4 >>> 6, i4 = 0, E3[Q4 + 26 | 0] = i4 << 13 | (1572864 & B4) >>> 19 | C4 << 2, g6 = A8 >> 21, g6 = (A8 = (B4 = (2097151 & A8) << 11 | C4 >>> 21) + (2097151 & eA2) | 0) >>> 0 < B4 >>> 0 ? g6 + 1 | 0 : g6, E3[Q4 + 31 | 0] = (131071 & g6) << 15 | A8 >>> 17, E3[Q4 + 30 | 0] = (511 & g6) << 23 | A8 >>> 9, E3[Q4 + 29 | 0] = (1 & g6) << 31 | A8 >>> 1, B4 = 0, E3[Q4 + 28 | 0] = B4 << 18 | (2080768 & C4) >>> 14 | A8 << 7, $A(r4, 64), $A(n4, 64), I7 && (o3[I7 >> 2] = 64, o3[I7 + 4 >> 2] = 0), D3 = f4 + 560 | 0, 0;
                    }
                    function p3(A8, I7, g6, C4) {
                      for (var B4 = 0, Q4 = 0, i4 = 0, E4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0, P4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0; i4 = (B4 = f4 << 3) + g6 | 0, Q4 = a3[0 | (B4 = I7 + B4 | 0)] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, H4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, n4 = Q4 << 24 | (65280 & Q4) << 8, e4 = (r4 = 16711680 & Q4) << 24, r4 = r4 >>> 8 | 0, B4 = (t4 = -16777216 & Q4) >>> 24 | 0, o3[i4 >> 2] = e4 | t4 << 8 | -16777216 & ((255 & H4) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & H4) << 8 | Q4 >>> 24) | H4 >>> 8 & 65280 | H4 >>> 24, Q4 = B4 | r4 | n4, B4 = 0, o3[i4 + 4 >> 2] = Q4 | B4 | B4, 16 != (0 | (f4 = f4 + 1 | 0)); )
                        ;
                      for (I7 = o3[A8 + 4 >> 2], o3[C4 >> 2] = o3[A8 >> 2], o3[C4 + 4 >> 2] = I7, I7 = o3[A8 + 60 >> 2], o3[C4 + 56 >> 2] = o3[A8 + 56 >> 2], o3[C4 + 60 >> 2] = I7, I7 = o3[A8 + 52 >> 2], o3[C4 + 48 >> 2] = o3[A8 + 48 >> 2], o3[C4 + 52 >> 2] = I7, I7 = o3[A8 + 44 >> 2], o3[C4 + 40 >> 2] = o3[A8 + 40 >> 2], o3[C4 + 44 >> 2] = I7, I7 = o3[A8 + 36 >> 2], o3[C4 + 32 >> 2] = o3[A8 + 32 >> 2], o3[C4 + 36 >> 2] = I7, I7 = o3[A8 + 28 >> 2], o3[C4 + 24 >> 2] = o3[A8 + 24 >> 2], o3[C4 + 28 >> 2] = I7, I7 = o3[A8 + 20 >> 2], o3[C4 + 16 >> 2] = o3[A8 + 16 >> 2], o3[C4 + 20 >> 2] = I7, I7 = o3[A8 + 12 >> 2], o3[C4 + 8 >> 2] = o3[A8 + 8 >> 2], o3[C4 + 12 >> 2] = I7; t4 = o3[C4 + 56 >> 2], n4 = o3[C4 + 60 >> 2], B4 = o3[(I7 = H4 = (M4 = x4 << 3) + g6 | 0) >> 2], I7 = o3[I7 + 4 >> 2], k4 = Q4 = o3[C4 + 36 >> 2], Q4 = nA(f4 = o3[C4 + 32 >> 2], Q4, 50), i4 = w3, Q4 = nA(f4, k4, 46) ^ Q4, i4 ^= w3, Q4 = nA(f4, k4, 23) ^ Q4, I7 = (w3 ^ i4) + I7 | 0, I7 = (B4 = Q4 + B4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, B4 = (i4 = o3[(Q4 = M4 + 34e3 | 0) >> 2]) + B4 | 0, I7 = o3[Q4 + 4 >> 2] + I7 | 0, I7 = B4 >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (e4 = ((i4 = o3[C4 + 48 >> 2]) ^ (r4 = o3[C4 + 40 >> 2])) & f4 ^ i4) + B4 | 0, B4 = (((u4 = o3[C4 + 52 >> 2]) ^ (c4 = o3[C4 + 44 >> 2])) & k4 ^ u4) + I7 | 0, I7 = (Q4 >>> 0 < e4 >>> 0 ? B4 + 1 | 0 : B4) + n4 | 0, I7 = (B4 = Q4) >>> 0 > (Q4 = Q4 + t4 | 0) >>> 0 ? I7 + 1 | 0 : I7, t4 = (n4 = o3[C4 + 24 >> 2]) + Q4 | 0, B4 = o3[C4 + 28 >> 2] + I7 | 0, y4 = B4 = n4 >>> 0 > t4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 24 >> 2] = t4, o3[C4 + 28 >> 2] = B4, l4 = B4 = o3[C4 + 4 >> 2], B4 = nA(h4 = o3[C4 >> 2], B4, 36), n4 = w3, B4 = nA(h4, l4, 30) ^ B4, e4 = w3 ^ n4, n4 = Q4 + (nA(h4, l4, 25) ^ B4) | 0, B4 = I7 + (w3 ^ e4) | 0, B4 = Q4 >>> 0 > n4 >>> 0 ? B4 + 1 | 0 : B4, e4 = (I7 = n4) + (n4 = h4 & ((Q4 = o3[C4 + 16 >> 2]) | (s4 = o3[C4 + 8 >> 2])) | Q4 & s4) | 0, I7 = (I7 = B4) + (l4 & ((B4 = o3[C4 + 20 >> 2]) | (F4 = o3[C4 + 12 >> 2])) | B4 & F4) | 0, n4 = I7 = n4 >>> 0 > e4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 56 >> 2] = e4, o3[C4 + 60 >> 2] = I7, E4 = Q4, D4 = B4, S4 = o3[(I7 = P4 = (p4 = 8 | M4) + g6 | 0) >> 2], K4 = o3[I7 + 4 >> 2], B4 = ((c4 ^ k4) & y4 ^ c4) + u4 | 0, B4 = (I7 = (Q4 = (r4 ^ f4) & t4 ^ r4) + i4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(t4, y4, 50), i4 = w3, Q4 = nA(t4, y4, 46) ^ Q4, i4 ^= w3, Q4 = (u4 = nA(t4, y4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ i4) + B4 | 0, I7 = (Q4 >>> 0 < u4 >>> 0 ? I7 + 1 | 0 : I7) + K4 | 0, I7 = (B4 = Q4 + S4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (Q4 = B4) + (i4 = o3[(B4 = p4 + 34e3 | 0) >> 2]) | 0, B4 = o3[B4 + 4 >> 2] + I7 | 0, B4 = (I7 = Q4 >>> 0 < i4 >>> 0 ? B4 + 1 | 0 : B4) + D4 | 0, p4 = B4 = (E4 = Q4 + E4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 16 >> 2] = E4, o3[C4 + 20 >> 2] = B4, I7 = I7 + ((F4 | l4) & n4 | F4 & l4) | 0, I7 = (B4 = Q4 + ((h4 | s4) & e4 | h4 & s4) | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(e4, n4, 36), i4 = w3, Q4 = nA(e4, n4, 30) ^ Q4, D4 = w3 ^ i4, i4 = B4, B4 = nA(e4, n4, 25) ^ Q4, I7 = (w3 ^ D4) + I7 | 0, D4 = I7 = B4 >>> 0 > (i4 = i4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 48 >> 2] = i4, o3[C4 + 52 >> 2] = I7, I7 = (I7 = r4) + (r4 = o3[(B4 = K4 = (Q4 = 16 | M4) + g6 | 0) >> 2]) | 0, B4 = o3[B4 + 4 >> 2] + c4 | 0, B4 = I7 >>> 0 < r4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (c4 = I7) + (r4 = o3[(I7 = Q4 + 34e3 | 0) >> 2]) | 0, I7 = o3[I7 + 4 >> 2] + B4 | 0, I7 = ((y4 ^ k4) & p4 ^ k4) + (I7 = Q4 >>> 0 < r4 >>> 0 ? I7 + 1 | 0 : I7) | 0, I7 = (B4 = (B4 = Q4) + (Q4 = (t4 ^ f4) & E4 ^ f4) | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(E4, p4, 50), r4 = w3, Q4 = nA(E4, p4, 46) ^ Q4, r4 ^= w3, Q4 = (c4 = nA(E4, p4, 23) ^ Q4) + B4 | 0, B4 = (w3 ^ r4) + I7 | 0, u4 = B4 = Q4 >>> 0 < c4 >>> 0 ? B4 + 1 | 0 : B4, I7 = B4, B4 = nA(i4, D4, 36), r4 = w3, B4 = nA(i4, D4, 30) ^ B4, c4 = w3 ^ r4, S4 = nA(i4, D4, 25) ^ B4, B4 = ((n4 | l4) & D4 | n4 & l4) + (w3 ^ c4) | 0, I7 = ((r4 = S4 + ((e4 | h4) & i4 | e4 & h4) | 0) >>> 0 < S4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, c4 = I7 = (B4 = r4) >>> 0 > (r4 = Q4 + r4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 40 >> 2] = r4, o3[C4 + 44 >> 2] = I7, B4 = u4 + F4 | 0, F4 = B4 = (s4 = Q4 + s4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 8 >> 2] = s4, o3[C4 + 12 >> 2] = B4, B4 = (B4 = f4) + (f4 = o3[(I7 = N4 = (Q4 = 24 | M4) + g6 | 0) >> 2]) | 0, I7 = o3[I7 + 4 >> 2] + k4 | 0, I7 = B4 >>> 0 < f4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (k4 = B4) + (f4 = o3[(B4 = Q4 + 34e3 | 0) >> 2]) | 0, B4 = o3[B4 + 4 >> 2] + I7 | 0, B4 = (y4 ^ (y4 ^ p4) & F4) + (B4 = Q4 >>> 0 < f4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (I7 = (I7 = Q4) + (Q4 = t4 ^ (t4 ^ E4) & s4) | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(s4, F4, 50), f4 = w3, Q4 = nA(s4, F4, 46) ^ Q4, f4 ^= w3, Q4 = (u4 = nA(s4, F4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ f4) + B4 | 0, I7 = Q4 >>> 0 < u4 >>> 0 ? I7 + 1 | 0 : I7, B4 = nA(r4, c4, 36), f4 = w3, B4 = nA(r4, c4, 30) ^ B4, u4 = w3 ^ f4, k4 = nA(r4, c4, 25) ^ B4, B4 = ((n4 | D4) & c4 | n4 & D4) + (w3 ^ u4) | 0, B4 = ((f4 = k4 + ((i4 | e4) & r4 | i4 & e4) | 0) >>> 0 < k4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, u4 = B4 = (k4 = f4) >>> 0 > (f4 = Q4 + f4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 32 >> 2] = f4, o3[C4 + 36 >> 2] = B4, I7 = I7 + l4 | 0, l4 = I7 = (h4 = Q4 + h4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 >> 2] = h4, o3[C4 + 4 >> 2] = I7, Q4 = o3[(B4 = v4 = (I7 = 32 | M4) + g6 | 0) >> 2], B4 = y4 + o3[B4 + 4 >> 2] | 0, B4 = (Q4 = Q4 + t4 | 0) >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (t4 = o3[(I7 = I7 + 34e3 | 0) >> 2]) + Q4 | 0, I7 = o3[I7 + 4 >> 2] + B4 | 0, I7 = (p4 ^ (p4 ^ F4) & l4) + (I7 = Q4 >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7) | 0, I7 = (B4 = (B4 = Q4) + (Q4 = E4 ^ (E4 ^ s4) & h4) | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(h4, l4, 50), t4 = w3, Q4 = nA(h4, l4, 46) ^ Q4, t4 ^= w3, Q4 = (y4 = nA(h4, l4, 23) ^ Q4) + B4 | 0, B4 = (w3 ^ t4) + I7 | 0, k4 = B4 = Q4 >>> 0 < y4 >>> 0 ? B4 + 1 | 0 : B4, I7 = B4, B4 = nA(f4, u4, 36), t4 = w3, B4 = nA(f4, u4, 30) ^ B4, y4 = w3 ^ t4, S4 = nA(f4, u4, 25) ^ B4, B4 = ((c4 | D4) & u4 | c4 & D4) + (w3 ^ y4) | 0, I7 = ((t4 = S4 + ((i4 | r4) & f4 | i4 & r4) | 0) >>> 0 < S4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, t4 = I7 = (y4 = Q4 + t4 | 0) >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 24 >> 2] = y4, o3[C4 + 28 >> 2] = I7, B4 = n4 + k4 | 0, k4 = B4 = (n4 = Q4 + e4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 56 >> 2] = n4, o3[C4 + 60 >> 2] = B4, Q4 = o3[(I7 = b4 = (B4 = 40 | M4) + g6 | 0) >> 2], I7 = p4 + o3[I7 + 4 >> 2] | 0, I7 = (Q4 = Q4 + E4 | 0) >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (e4 = o3[(B4 = B4 + 34e3 | 0) >> 2]) + Q4 | 0, B4 = o3[B4 + 4 >> 2] + I7 | 0, B4 = (F4 ^ (F4 ^ l4) & k4) + (B4 = Q4 >>> 0 < e4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (I7 = (I7 = Q4) + (Q4 = s4 ^ (h4 ^ s4) & n4) | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(n4, k4, 50), e4 = w3, Q4 = nA(n4, k4, 46) ^ Q4, e4 ^= w3, Q4 = (E4 = nA(n4, k4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ e4) + B4 | 0, I7 = Q4 >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7, B4 = nA(y4, t4, 36), e4 = w3, B4 = nA(y4, t4, 30) ^ B4, E4 = w3 ^ e4, p4 = nA(y4, t4, 25) ^ B4, B4 = ((c4 | u4) & t4 | c4 & u4) + (w3 ^ E4) | 0, B4 = ((e4 = p4 + ((r4 | f4) & y4 | r4 & f4) | 0) >>> 0 < p4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, e4 = B4 = (E4 = Q4 + e4 | 0) >>> 0 < e4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 16 >> 2] = E4, o3[C4 + 20 >> 2] = B4, I7 = I7 + D4 | 0, p4 = I7 = (D4 = Q4 + i4 | 0) >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 48 >> 2] = D4, o3[C4 + 52 >> 2] = I7, Q4 = o3[(B4 = _4 = (I7 = 48 | M4) + g6 | 0) >> 2], B4 = F4 + o3[B4 + 4 >> 2] | 0, B4 = (Q4 = Q4 + s4 | 0) >>> 0 < s4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (i4 = o3[(I7 = I7 + 34e3 | 0) >> 2]) + Q4 | 0, I7 = o3[I7 + 4 >> 2] + B4 | 0, I7 = (l4 ^ (k4 ^ l4) & p4) + (I7 = Q4 >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7) | 0, I7 = (B4 = (B4 = Q4) + (Q4 = h4 ^ (n4 ^ h4) & D4) | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(D4, p4, 50), i4 = w3, Q4 = nA(D4, p4, 46) ^ Q4, i4 ^= w3, Q4 = (s4 = nA(D4, p4, 23) ^ Q4) + B4 | 0, B4 = (w3 ^ i4) + I7 | 0, F4 = B4 = Q4 >>> 0 < s4 >>> 0 ? B4 + 1 | 0 : B4, I7 = B4, B4 = nA(E4, e4, 36), i4 = w3, B4 = nA(E4, e4, 30) ^ B4, s4 = w3 ^ i4, S4 = nA(E4, e4, 25) ^ B4, B4 = ((t4 | u4) & e4 | t4 & u4) + (w3 ^ s4) | 0, I7 = ((i4 = S4 + ((f4 | y4) & E4 | f4 & y4) | 0) >>> 0 < S4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, s4 = I7 = (B4 = i4) >>> 0 > (i4 = Q4 + i4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 8 >> 2] = i4, o3[C4 + 12 >> 2] = I7, B4 = c4 + F4 | 0, F4 = B4 = (S4 = Q4 + r4 | 0) >>> 0 < r4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 40 >> 2] = S4, o3[C4 + 44 >> 2] = B4, Q4 = o3[(I7 = Y4 = (B4 = 56 | M4) + g6 | 0) >> 2], I7 = l4 + o3[I7 + 4 >> 2] | 0, I7 = (Q4 = Q4 + h4 | 0) >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (r4 = o3[(B4 = B4 + 34e3 | 0) >> 2]) + Q4 | 0, B4 = o3[B4 + 4 >> 2] + I7 | 0, B4 = (k4 ^ (p4 ^ k4) & F4) + (B4 = Q4 >>> 0 < r4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (I7 = (I7 = Q4) + (Q4 = n4 ^ (n4 ^ D4) & S4) | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(S4, F4, 50), r4 = w3, Q4 = nA(S4, F4, 46) ^ Q4, r4 ^= w3, Q4 = (c4 = nA(S4, F4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ r4) + B4 | 0, I7 = Q4 >>> 0 < c4 >>> 0 ? I7 + 1 | 0 : I7, B4 = nA(i4, s4, 36), r4 = w3, B4 = nA(i4, s4, 30) ^ B4, c4 = w3 ^ r4, h4 = nA(i4, s4, 25) ^ B4, B4 = ((t4 | e4) & s4 | t4 & e4) + (w3 ^ c4) | 0, B4 = ((r4 = h4 + ((E4 | y4) & i4 | E4 & y4) | 0) >>> 0 < h4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, c4 = B4 = (c4 = r4) >>> 0 > (r4 = Q4 + r4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[C4 >> 2] = r4, o3[C4 + 4 >> 2] = B4, I7 = I7 + u4 | 0, l4 = I7 = (B4 = f4) >>> 0 > (f4 = Q4 + f4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 32 >> 2] = f4, o3[C4 + 36 >> 2] = I7, Q4 = o3[(B4 = m4 = (I7 = 64 | M4) + g6 | 0) >> 2], B4 = k4 + o3[B4 + 4 >> 2] | 0, B4 = (Q4 = Q4 + n4 | 0) >>> 0 < n4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (n4 = o3[(I7 = I7 + 34e3 | 0) >> 2]) + Q4 | 0, I7 = o3[I7 + 4 >> 2] + B4 | 0, I7 = (p4 ^ (p4 ^ F4) & l4) + (I7 = Q4 >>> 0 < n4 >>> 0 ? I7 + 1 | 0 : I7) | 0, I7 = (B4 = (B4 = Q4) + (Q4 = D4 ^ (D4 ^ S4) & f4) | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(f4, l4, 50), n4 = w3, Q4 = nA(f4, l4, 46) ^ Q4, n4 ^= w3, Q4 = (u4 = nA(f4, l4, 23) ^ Q4) + B4 | 0, B4 = (w3 ^ n4) + I7 | 0, h4 = B4 = Q4 >>> 0 < u4 >>> 0 ? B4 + 1 | 0 : B4, I7 = B4, B4 = nA(r4, c4, 36), n4 = w3, B4 = nA(r4, c4, 30) ^ B4, u4 = w3 ^ n4, k4 = nA(r4, c4, 25) ^ B4, B4 = ((e4 | s4) & c4 | e4 & s4) + (w3 ^ u4) | 0, I7 = ((n4 = k4 + ((i4 | E4) & r4 | i4 & E4) | 0) >>> 0 < k4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, n4 = I7 = (u4 = Q4 + n4 | 0) >>> 0 < n4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 56 >> 2] = u4, o3[C4 + 60 >> 2] = I7, B4 = t4 + h4 | 0, k4 = B4 = (t4 = Q4 + y4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 24 >> 2] = t4, o3[C4 + 28 >> 2] = B4, Q4 = o3[(I7 = G4 = (B4 = 72 | M4) + g6 | 0) >> 2], I7 = p4 + o3[I7 + 4 >> 2] | 0, I7 = (Q4 = Q4 + D4 | 0) >>> 0 < D4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (D4 = o3[(B4 = B4 + 34e3 | 0) >> 2]) + Q4 | 0, B4 = o3[B4 + 4 >> 2] + I7 | 0, B4 = (F4 ^ (F4 ^ l4) & k4) + (B4 = Q4 >>> 0 < D4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (I7 = (I7 = Q4) + (Q4 = S4 ^ (f4 ^ S4) & t4) | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(t4, k4, 50), D4 = w3, Q4 = nA(t4, k4, 46) ^ Q4, D4 ^= w3, Q4 = (h4 = nA(t4, k4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ D4) + B4 | 0, I7 = Q4 >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, B4 = nA(u4, n4, 36), D4 = w3, B4 = nA(u4, n4, 30) ^ B4, h4 = w3 ^ D4, y4 = nA(u4, n4, 25) ^ B4, B4 = ((c4 | s4) & n4 | c4 & s4) + (w3 ^ h4) | 0, B4 = ((D4 = y4 + ((i4 | r4) & u4 | i4 & r4) | 0) >>> 0 < y4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, D4 = B4 = (h4 = Q4 + D4 | 0) >>> 0 < D4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 48 >> 2] = h4, o3[C4 + 52 >> 2] = B4, I7 = I7 + e4 | 0, p4 = I7 = (e4 = Q4 + E4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 16 >> 2] = e4, o3[C4 + 20 >> 2] = I7, I7 = (E4 = o3[(B4 = J4 = (Q4 = 80 | M4) + g6 | 0) >> 2]) + S4 | 0, B4 = o3[B4 + 4 >> 2] + F4 | 0, B4 = I7 >>> 0 < E4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (y4 = I7) + (E4 = o3[(I7 = Q4 + 34e3 | 0) >> 2]) | 0, I7 = o3[I7 + 4 >> 2] + B4 | 0, I7 = (l4 ^ (k4 ^ l4) & p4) + (I7 = Q4 >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7) | 0, I7 = (B4 = (B4 = Q4) + (Q4 = f4 ^ (t4 ^ f4) & e4) | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(e4, p4, 50), E4 = w3, Q4 = nA(e4, p4, 46) ^ Q4, E4 ^= w3, Q4 = (y4 = nA(e4, p4, 23) ^ Q4) + B4 | 0, B4 = (w3 ^ E4) + I7 | 0, F4 = B4 = Q4 >>> 0 < y4 >>> 0 ? B4 + 1 | 0 : B4, I7 = B4, B4 = nA(h4, D4, 36), E4 = w3, B4 = nA(h4, D4, 30) ^ B4, y4 = w3 ^ E4, S4 = nA(h4, D4, 25) ^ B4, B4 = ((n4 | c4) & D4 | n4 & c4) + (w3 ^ y4) | 0, I7 = ((E4 = S4 + ((r4 | u4) & h4 | r4 & u4) | 0) >>> 0 < S4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, E4 = I7 = (y4 = Q4 + E4 | 0) >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 40 >> 2] = y4, o3[C4 + 44 >> 2] = I7, B4 = s4 + F4 | 0, F4 = B4 = (s4 = Q4 + i4 | 0) >>> 0 < i4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 8 >> 2] = s4, o3[C4 + 12 >> 2] = B4, B4 = 34e3 + (I7 = 88 | M4) | 0, i4 = o3[(I7 = U4 = I7 + g6 | 0) >> 2], Q4 = o3[B4 >> 2] + i4 | 0, I7 = o3[B4 + 4 >> 2] + o3[I7 + 4 >> 2] | 0, B4 = l4 + (Q4 >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7) | 0, B4 = (k4 ^ (p4 ^ k4) & F4) + (B4 = (I7 = Q4 + f4 | 0) >>> 0 < f4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (I7 = (Q4 = t4 ^ (t4 ^ e4) & s4) + I7 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(s4, F4, 50), i4 = w3, Q4 = nA(s4, F4, 46) ^ Q4, i4 ^= w3, Q4 = (f4 = nA(s4, F4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ i4) + B4 | 0, I7 = Q4 >>> 0 < f4 >>> 0 ? I7 + 1 | 0 : I7, B4 = nA(y4, E4, 36), i4 = w3, B4 = nA(y4, E4, 30) ^ B4, f4 = w3 ^ i4, l4 = nA(y4, E4, 25) ^ B4, B4 = ((n4 | D4) & E4 | n4 & D4) + (w3 ^ f4) | 0, B4 = ((i4 = l4 + ((h4 | u4) & y4 | h4 & u4) | 0) >>> 0 < l4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, f4 = B4 = (f4 = i4) >>> 0 > (i4 = Q4 + i4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 32 >> 2] = i4, o3[C4 + 36 >> 2] = B4, I7 = I7 + c4 | 0, c4 = I7 = (B4 = r4) >>> 0 > (r4 = Q4 + r4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[C4 >> 2] = r4, o3[C4 + 4 >> 2] = I7, B4 = 34e3 + (I7 = 96 | M4) | 0, l4 = o3[(I7 = d4 = I7 + g6 | 0) >> 2], Q4 = o3[B4 >> 2] + l4 | 0, B4 = o3[B4 + 4 >> 2] + o3[I7 + 4 >> 2] | 0, I7 = k4 + (Q4 >>> 0 < l4 >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (B4 = Q4 + t4 | 0) >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (t4 = e4 ^ (e4 ^ s4) & r4) + B4 | 0, B4 = (p4 ^ (p4 ^ F4) & c4) + I7 | 0, B4 = Q4 >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, I7 = nA(r4, c4, 50), t4 = w3, I7 = nA(r4, c4, 46) ^ I7, t4 ^= w3, k4 = Q4, Q4 = nA(r4, c4, 23) ^ I7, B4 = (w3 ^ t4) + B4 | 0, k4 = B4 = (I7 = k4 + Q4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = I7, I7 = nA(i4, f4, 36), t4 = w3, I7 = nA(i4, f4, 30) ^ I7, l4 = w3 ^ t4, S4 = nA(i4, f4, 25) ^ I7, I7 = ((E4 | D4) & f4 | E4 & D4) + (w3 ^ l4) | 0, B4 = ((t4 = S4 + ((h4 | y4) & i4 | h4 & y4) | 0) >>> 0 < S4 >>> 0 ? I7 + 1 | 0 : I7) + B4 | 0, t4 = B4 = (l4 = Q4 + t4 | 0) >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 24 >> 2] = l4, o3[C4 + 28 >> 2] = B4, B4 = n4 + k4 | 0, n4 = B4 = (u4 = Q4 + u4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 56 >> 2] = u4, o3[C4 + 60 >> 2] = B4, B4 = 34e3 + (I7 = 104 | M4) | 0, k4 = o3[(I7 = R4 = I7 + g6 | 0) >> 2], Q4 = o3[B4 >> 2] + k4 | 0, I7 = o3[B4 + 4 >> 2] + o3[I7 + 4 >> 2] | 0, B4 = p4 + (Q4 >>> 0 < k4 >>> 0 ? I7 + 1 | 0 : I7) | 0, B4 = (I7 = Q4 + e4 | 0) >>> 0 < e4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (e4 = s4 ^ (r4 ^ s4) & u4) + I7 | 0, I7 = (F4 ^ (c4 ^ F4) & n4) + B4 | 0, I7 = Q4 >>> 0 < e4 >>> 0 ? I7 + 1 | 0 : I7, B4 = nA(u4, n4, 50), e4 = w3, B4 = nA(u4, n4, 46) ^ B4, e4 ^= w3, p4 = nA(u4, n4, 23) ^ B4, B4 = (w3 ^ e4) + I7 | 0, k4 = B4 = (Q4 = p4 + Q4 | 0) >>> 0 < p4 >>> 0 ? B4 + 1 | 0 : B4, I7 = B4, B4 = nA(l4, t4, 36), e4 = w3, B4 = nA(l4, t4, 30) ^ B4, p4 = w3 ^ e4, S4 = nA(l4, t4, 25) ^ B4, B4 = ((E4 | f4) & t4 | E4 & f4) + (w3 ^ p4) | 0, I7 = ((e4 = S4 + ((i4 | y4) & l4 | i4 & y4) | 0) >>> 0 < S4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, e4 = I7 = (p4 = Q4 + e4 | 0) >>> 0 < e4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 16 >> 2] = p4, o3[C4 + 20 >> 2] = I7, I7 = D4 + k4 | 0, D4 = I7 = (h4 = Q4 + h4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 + 48 >> 2] = h4, o3[C4 + 52 >> 2] = I7, B4 = 34e3 + (I7 = 112 | M4) | 0, k4 = o3[(Q4 = S4 = I7 + g6 | 0) >> 2], I7 = o3[B4 >> 2] + k4 | 0, B4 = o3[B4 + 4 >> 2] + o3[Q4 + 4 >> 2] | 0, B4 = F4 + (I7 >>> 0 < k4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (c4 ^ (n4 ^ c4) & D4) + (B4 = (I7 = I7 + s4 | 0) >>> 0 < s4 >>> 0 ? B4 + 1 | 0 : B4) | 0, B4 = (I7 = (Q4 = r4 ^ (r4 ^ u4) & h4) + I7 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = nA(h4, D4, 50), s4 = w3, Q4 = nA(h4, D4, 46) ^ Q4, s4 ^= w3, Q4 = (F4 = nA(h4, D4, 23) ^ Q4) + I7 | 0, I7 = (w3 ^ s4) + B4 | 0, k4 = I7 = Q4 >>> 0 < F4 >>> 0 ? I7 + 1 | 0 : I7, B4 = I7, I7 = nA(p4, e4, 36), s4 = w3, I7 = nA(p4, e4, 30) ^ I7, F4 = w3 ^ s4, L4 = nA(p4, e4, 25) ^ I7, I7 = ((t4 | f4) & e4 | t4 & f4) + (w3 ^ F4) | 0, B4 = ((s4 = L4 + ((i4 | l4) & p4 | i4 & l4) | 0) >>> 0 < L4 >>> 0 ? I7 + 1 | 0 : I7) + B4 | 0, s4 = B4 = (F4 = Q4 + s4 | 0) >>> 0 < s4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 8 >> 2] = F4, o3[C4 + 12 >> 2] = B4, B4 = E4 + k4 | 0, Q4 = B4 = (E4 = Q4 + y4 | 0) >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 40 >> 2] = E4, o3[C4 + 44 >> 2] = B4, B4 = 34e3 + (I7 = 120 | M4) | 0, M4 = o3[(I7 = y4 = I7 + g6 | 0) >> 2], k4 = o3[B4 >> 2] + M4 | 0, B4 = o3[B4 + 4 >> 2] + o3[I7 + 4 >> 2] | 0, I7 = c4 + (k4 >>> 0 < M4 >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (n4 ^ (n4 ^ D4) & Q4) + (I7 = (B4 = r4 + k4 | 0) >>> 0 < r4 >>> 0 ? I7 + 1 | 0 : I7) | 0, I7 = (B4 = (r4 = u4 ^ (h4 ^ u4) & E4) + B4 | 0) >>> 0 < r4 >>> 0 ? I7 + 1 | 0 : I7, r4 = nA(E4, Q4, 50), n4 = w3, r4 = nA(E4, Q4, 46) ^ r4, n4 ^= w3, Q4 = (r4 = nA(E4, Q4, 23) ^ r4) + B4 | 0, B4 = (w3 ^ n4) + I7 | 0, B4 = Q4 >>> 0 < r4 >>> 0 ? B4 + 1 | 0 : B4, r4 = Q4, n4 = B4, I7 = B4, B4 = nA(F4, s4, 36), E4 = w3, B4 = nA(F4, s4, 30) ^ B4, D4 = w3 ^ E4, c4 = nA(F4, s4, 25) ^ B4, B4 = ((t4 | e4) & s4 | t4 & e4) + (w3 ^ D4) | 0, I7 = ((E4 = c4 + ((p4 | l4) & F4 | p4 & l4) | 0) >>> 0 < c4 >>> 0 ? B4 + 1 | 0 : B4) + I7 | 0, I7 = (Q4 = Q4 + E4 | 0) >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7, o3[C4 >> 2] = Q4, o3[C4 + 4 >> 2] = I7, B4 = n4 + f4 | 0, B4 = (f4 = i4) >>> 0 > (i4 = i4 + r4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[C4 + 32 >> 2] = i4, o3[C4 + 36 >> 2] = B4, 64 != (0 | x4); )
                        n4 = ((x4 = x4 + 16 | 0) << 3) + g6 | 0, r4 = o3[H4 >> 2], f4 = o3[H4 + 4 >> 2], L4 = o3[G4 >> 2], t4 = I7 = o3[G4 + 4 >> 2], B4 = I7, Q4 = I7 = o3[S4 + 4 >> 2], I7 = nA(F4 = o3[S4 >> 2], I7, 45), i4 = w3, E4 = ((63 & Q4) << 26 | F4 >>> 6) ^ (I7 = nA(F4, Q4, 3) ^ I7), I7 = (Q4 >>> 6 ^ (e4 = w3 ^ i4)) + B4 | 0, B4 = ((i4 = E4 + L4 | 0) >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7) + f4 | 0, B4 = (I7 = i4 + r4 | 0) >>> 0 < i4 >>> 0 ? B4 + 1 | 0 : B4, r4 = i4 = o3[P4 + 4 >> 2], i4 = nA(f4 = o3[P4 >> 2], i4, 63), e4 = w3, i4 = ((127 & r4) << 25 | f4 >>> 7) ^ nA(f4, r4, 56) ^ i4, B4 = (w3 ^ e4 ^ r4 >>> 7) + B4 | 0, i4 = B4 = i4 >>> 0 > (l4 = i4 + I7 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[n4 >> 2] = l4, o3[n4 + 4 >> 2] = B4, f4 = (S4 = o3[J4 >> 2]) + f4 | 0, I7 = (n4 = o3[J4 + 4 >> 2]) + r4 | 0, B4 = f4 >>> 0 < S4 >>> 0 ? I7 + 1 | 0 : I7, r4 = I7 = o3[y4 + 4 >> 2], I7 = nA(k4 = o3[y4 >> 2], I7, 45), e4 = w3, E4 = f4, f4 = ((63 & r4) << 26 | k4 >>> 6) ^ nA(k4, r4, 3) ^ I7, B4 = (w3 ^ e4 ^ r4 >>> 6) + B4 | 0, f4 = (E4 = E4 + f4 | 0) >>> 0 < f4 >>> 0 ? B4 + 1 | 0 : B4, B4 = nA(e4 = o3[K4 >> 2], I7 = o3[K4 + 4 >> 2], 63), D4 = w3, y4 = E4, E4 = ((127 & I7) << 25 | e4 >>> 7) ^ nA(e4, I7, 56) ^ B4, B4 = (w3 ^ D4 ^ I7 >>> 7) + f4 | 0, f4 = B4 = E4 >>> 0 > (p4 = y4 + E4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 136 >> 2] = p4, o3[H4 + 140 >> 2] = B4, B4 = (M4 = o3[U4 >> 2]) + e4 | 0, I7 = (e4 = o3[U4 + 4 >> 2]) + I7 | 0, E4 = nA(l4, i4, 45), D4 = w3, E4 = (c4 = ((63 & i4) << 26 | l4 >>> 6) ^ nA(l4, i4, 3) ^ E4) + B4 | 0, B4 = (w3 ^ D4 ^ i4 >>> 6) + (B4 >>> 0 < M4 >>> 0 ? I7 + 1 | 0 : I7) | 0, B4 = E4 >>> 0 < c4 >>> 0 ? B4 + 1 | 0 : B4, D4 = I7 = o3[N4 + 4 >> 2], I7 = nA(c4 = o3[N4 >> 2], I7, 63), s4 = w3, y4 = E4, E4 = ((127 & D4) << 25 | c4 >>> 7) ^ nA(c4, D4, 56) ^ I7, B4 = (w3 ^ s4 ^ D4 >>> 7) + B4 | 0, E4 = B4 = E4 >>> 0 > (P4 = y4 + E4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 144 >> 2] = P4, o3[H4 + 148 >> 2] = B4, c4 = (K4 = o3[d4 >> 2]) + c4 | 0, I7 = (I7 = D4) + (D4 = o3[d4 + 4 >> 2]) | 0, B4 = c4 >>> 0 < K4 >>> 0 ? I7 + 1 | 0 : I7, I7 = nA(p4, f4, 45), s4 = w3, u4 = ((63 & f4) << 26 | p4 >>> 6) ^ nA(p4, f4, 3) ^ I7, B4 = (w3 ^ s4 ^ f4 >>> 6) + B4 | 0, B4 = (c4 = u4 + c4 | 0) >>> 0 < u4 >>> 0 ? B4 + 1 | 0 : B4, s4 = I7 = o3[v4 + 4 >> 2], I7 = nA(u4 = o3[v4 >> 2], I7, 63), h4 = w3, y4 = c4, c4 = ((127 & s4) << 25 | u4 >>> 7) ^ nA(u4, s4, 56) ^ I7, B4 = (w3 ^ h4 ^ s4 >>> 7) + B4 | 0, c4 = B4 = c4 >>> 0 > (N4 = y4 + c4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 152 >> 2] = N4, o3[H4 + 156 >> 2] = B4, I7 = (v4 = o3[R4 >> 2]) + u4 | 0, B4 = (B4 = s4) + (s4 = o3[R4 + 4 >> 2]) | 0, u4 = nA(P4, E4, 45), h4 = w3, u4 = ((63 & E4) << 26 | P4 >>> 6) ^ nA(P4, E4, 3) ^ u4, B4 = (w3 ^ h4 ^ E4 >>> 6) + (I7 >>> 0 < v4 >>> 0 ? B4 + 1 | 0 : B4) | 0, u4 = (y4 = u4 + I7 | 0) >>> 0 < u4 >>> 0 ? B4 + 1 | 0 : B4, B4 = nA(h4 = o3[b4 >> 2], I7 = o3[b4 + 4 >> 2], 63), b4 = w3, U4 = y4, y4 = ((127 & I7) << 25 | h4 >>> 7) ^ (B4 = nA(h4, I7, 56) ^ B4), B4 = (I7 >>> 7 ^ (G4 = w3 ^ b4)) + u4 | 0, u4 = B4 = y4 >>> 0 > (b4 = U4 + y4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 160 >> 2] = b4, o3[H4 + 164 >> 2] = B4, I7 = I7 + Q4 | 0, I7 = (B4 = h4 + F4 | 0) >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, h4 = nA(N4, c4, 45), y4 = w3, h4 = (G4 = ((63 & c4) << 26 | N4 >>> 6) ^ nA(N4, c4, 3) ^ h4) + B4 | 0, B4 = (w3 ^ y4 ^ c4 >>> 6) + I7 | 0, B4 = h4 >>> 0 < G4 >>> 0 ? B4 + 1 | 0 : B4, G4 = I7 = o3[_4 + 4 >> 2], I7 = nA(y4 = o3[_4 >> 2], I7, 63), _4 = w3, I7 = nA(y4, G4, 56) ^ I7, U4 = h4, B4 = (G4 >>> 7 ^ (J4 = w3 ^ _4)) + B4 | 0, h4 = B4 = (h4 = ((127 & G4) << 25 | y4 >>> 7) ^ I7) >>> 0 > (_4 = U4 + h4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 168 >> 2] = _4, o3[H4 + 172 >> 2] = B4, I7 = r4 + G4 | 0, I7 = (B4 = y4 + k4 | 0) >>> 0 < y4 >>> 0 ? I7 + 1 | 0 : I7, U4 = y4 = o3[Y4 + 4 >> 2], y4 = nA(J4 = o3[Y4 >> 2], y4, 63), G4 = w3, y4 = (Y4 = ((127 & U4) << 25 | J4 >>> 7) ^ nA(J4, U4, 56) ^ y4) + B4 | 0, B4 = (w3 ^ G4 ^ U4 >>> 7) + I7 | 0, I7 = y4 >>> 0 < Y4 >>> 0 ? B4 + 1 | 0 : B4, B4 = nA(b4, u4, 45), G4 = w3, B4 = nA(b4, u4, 3) ^ B4, Y4 = w3 ^ G4, G4 = y4, I7 = (u4 >>> 6 ^ Y4) + I7 | 0, y4 = I7 = (y4 = ((63 & u4) << 26 | b4 >>> 6) ^ B4) >>> 0 > (G4 = G4 + y4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[H4 + 176 >> 2] = G4, o3[H4 + 180 >> 2] = I7, d4 = o3[m4 >> 2], m4 = I7 = o3[m4 + 4 >> 2], Y4 = I7, I7 = nA(L4, t4, 63), B4 = w3, R4 = ((127 & t4) << 25 | L4 >>> 7) ^ nA(L4, t4, 56) ^ I7, I7 = (w3 ^ B4 ^ t4 >>> 7) + f4 | 0, B4 = ((p4 = R4 + p4 | 0) >>> 0 < R4 >>> 0 ? I7 + 1 | 0 : I7) + Y4 | 0, B4 = (I7 = p4 + d4 | 0) >>> 0 < p4 >>> 0 ? B4 + 1 | 0 : B4, f4 = nA(G4, y4, 45), p4 = w3, Y4 = (f4 = ((63 & y4) << 26 | G4 >>> 6) ^ nA(G4, y4, 3) ^ f4) + I7 | 0, I7 = (w3 ^ p4 ^ y4 >>> 6) + B4 | 0, f4 = I7 = f4 >>> 0 > Y4 >>> 0 ? I7 + 1 | 0 : I7, o3[H4 + 192 >> 2] = Y4, o3[H4 + 196 >> 2] = I7, B4 = i4 + U4 | 0, B4 = (I7 = l4 + J4 | 0) >>> 0 < J4 >>> 0 ? B4 + 1 | 0 : B4, p4 = nA(d4, m4, 63), J4 = w3, U4 = ((127 & m4) << 25 | d4 >>> 7) ^ nA(d4, m4, 56) ^ p4, B4 = (w3 ^ J4 ^ m4 >>> 7) + B4 | 0, I7 = (p4 = U4 + I7 | 0) >>> 0 < U4 >>> 0 ? B4 + 1 | 0 : B4, B4 = nA(_4, h4, 45), J4 = w3, B4 = nA(_4, h4, 3) ^ B4, m4 = p4, I7 = (h4 >>> 6 ^ (U4 = w3 ^ J4)) + I7 | 0, p4 = I7 = (p4 = ((63 & h4) << 26 | _4 >>> 6) ^ B4) >>> 0 > (J4 = m4 + p4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[H4 + 184 >> 2] = J4, o3[H4 + 188 >> 2] = I7, I7 = nA(M4, e4, 63), B4 = w3, I7 = ((127 & e4) << 25 | M4 >>> 7) ^ nA(M4, e4, 56) ^ I7, B4 = (w3 ^ B4 ^ e4 >>> 7) + n4 | 0, I7 = c4 + (I7 >>> 0 > (U4 = I7 + S4 | 0) >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (B4 = N4 + U4 | 0) >>> 0 < N4 >>> 0 ? I7 + 1 | 0 : I7, c4 = nA(Y4, f4, 45), N4 = w3, c4 = nA(Y4, f4, 3) ^ c4, U4 = w3 ^ N4, N4 = (c4 ^= (63 & f4) << 26 | Y4 >>> 6) + B4 | 0, B4 = (f4 >>> 6 ^ U4) + I7 | 0, c4 = B4 = c4 >>> 0 > N4 >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 208 >> 2] = N4, o3[H4 + 212 >> 2] = B4, I7 = nA(S4, n4, 63), B4 = w3, U4 = nA(S4, n4, 56) ^ I7, B4 = ((I7 = n4 >>> 7 | 0) ^ w3 ^ B4) + t4 | 0, I7 = E4 + ((n4 = (S4 = U4 ^ ((127 & n4) << 25 | S4 >>> 7)) + L4 | 0) >>> 0 < S4 >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (B4 = n4 + P4 | 0) >>> 0 < P4 >>> 0 ? I7 + 1 | 0 : I7, t4 = nA(J4, p4, 45), n4 = w3, E4 = (t4 = ((63 & p4) << 26 | J4 >>> 6) ^ nA(J4, p4, 3) ^ t4) + B4 | 0, B4 = (w3 ^ n4 ^ p4 >>> 6) + I7 | 0, t4 = B4 = t4 >>> 0 > E4 >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 200 >> 2] = E4, o3[H4 + 204 >> 2] = B4, I7 = nA(v4, s4, 63), B4 = w3, S4 = ((127 & s4) << 25 | v4 >>> 7) ^ nA(v4, s4, 56) ^ I7, I7 = (w3 ^ B4 ^ s4 >>> 7) + D4 | 0, B4 = h4 + ((n4 = S4 + K4 | 0) >>> 0 < S4 >>> 0 ? I7 + 1 | 0 : I7) | 0, B4 = (I7 = n4 + _4 | 0) >>> 0 < _4 >>> 0 ? B4 + 1 | 0 : B4, n4 = nA(N4, c4, 45), h4 = w3, U4 = I7, I7 = c4 >>> 6 | 0, n4 = ((63 & c4) << 26 | N4 >>> 6) ^ nA(N4, c4, 3) ^ n4, B4 = (I7 ^ w3 ^ h4) + B4 | 0, n4 = B4 = n4 >>> 0 > (c4 = U4 + n4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 224 >> 2] = c4, o3[H4 + 228 >> 2] = B4, I7 = nA(K4, D4, 63), B4 = w3, I7 = nA(K4, D4, 56) ^ I7, h4 = w3 ^ B4, S4 = ((127 & D4) << 25 | K4 >>> 7) ^ I7, I7 = ((B4 = D4 >>> 7 | 0) ^ h4) + e4 | 0, B4 = u4 + ((D4 = S4 + M4 | 0) >>> 0 < S4 >>> 0 ? I7 + 1 | 0 : I7) | 0, B4 = (I7 = D4 + b4 | 0) >>> 0 < b4 >>> 0 ? B4 + 1 | 0 : B4, e4 = nA(E4, t4, 45), D4 = w3, h4 = I7, I7 = t4 >>> 6 | 0, t4 = ((63 & t4) << 26 | E4 >>> 6) ^ nA(E4, t4, 3) ^ e4, I7 = (I7 ^ w3 ^ D4) + B4 | 0, t4 = I7 = t4 >>> 0 > (e4 = h4 + t4 | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[H4 + 216 >> 2] = e4, o3[H4 + 220 >> 2] = I7, I7 = nA(k4, r4, 63), B4 = w3, D4 = ((127 & r4) << 25 | k4 >>> 7) ^ nA(k4, r4, 56) ^ I7, B4 = (w3 ^ B4 ^ r4 >>> 7) + Q4 | 0, B4 = p4 + ((I7 = D4 + F4 | 0) >>> 0 < D4 >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (E4 = I7 + J4 | 0) >>> 0 < J4 >>> 0 ? B4 + 1 | 0 : B4, B4 = nA(c4, n4, 45), D4 = w3, p4 = E4, E4 = nA(c4, n4, 3) ^ B4, B4 = n4 >>> 6 | 0, n4 = p4 + (E4 ^= (63 & n4) << 26 | c4 >>> 6) | 0, I7 = (B4 ^ w3 ^ D4) + I7 | 0, o3[H4 + 240 >> 2] = n4, o3[H4 + 244 >> 2] = n4 >>> 0 < E4 >>> 0 ? I7 + 1 | 0 : I7, I7 = nA(F4, Q4, 63), B4 = w3, I7 = nA(F4, Q4, 56) ^ I7, n4 = w3 ^ B4, B4 = ((B4 = Q4 >>> 7 | 0) ^ n4) + s4 | 0, I7 = y4 + ((I7 ^= (127 & Q4) << 25 | F4 >>> 7) >>> 0 > (Q4 = I7 + v4 | 0) >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (B4 = Q4 + G4 | 0) >>> 0 < G4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = nA(e4, t4, 45), n4 = w3, E4 = B4, B4 = t4 >>> 6 | 0, Q4 = ((63 & t4) << 26 | e4 >>> 6) ^ nA(e4, t4, 3) ^ Q4, B4 = (B4 ^ w3 ^ n4) + I7 | 0, Q4 = B4 = Q4 >>> 0 > (t4 = E4 + Q4 | 0) >>> 0 ? B4 + 1 | 0 : B4, o3[H4 + 232 >> 2] = t4, o3[H4 + 236 >> 2] = B4, I7 = nA(l4, i4, 63), B4 = w3, E4 = nA(l4, i4, 56) ^ I7, B4 = ((I7 = i4 >>> 7 | 0) ^ w3 ^ B4) + r4 | 0, I7 = f4 + ((i4 = (n4 = E4 ^ ((127 & i4) << 25 | l4 >>> 7)) + k4 | 0) >>> 0 < n4 >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = (B4 = i4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? I7 + 1 | 0 : I7, i4 = nA(t4, Q4, 45), r4 = w3, f4 = B4, B4 = Q4 >>> 6 | 0, Q4 = f4 + (i4 = ((63 & Q4) << 26 | t4 >>> 6) ^ nA(t4, Q4, 3) ^ i4) | 0, B4 = (B4 ^ w3 ^ r4) + I7 | 0, o3[H4 + 248 >> 2] = Q4, o3[H4 + 252 >> 2] = Q4 >>> 0 < i4 >>> 0 ? B4 + 1 | 0 : B4;
                      I7 = I7 + o3[A8 + 4 >> 2] | 0, I7 = (g6 = Q4 + o3[A8 >> 2] | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, o3[A8 >> 2] = g6, o3[A8 + 4 >> 2] = I7, B4 = o3[A8 + 12 >> 2] + o3[C4 + 12 >> 2] | 0, I7 = (g6 = o3[C4 + 8 >> 2]) + o3[A8 + 8 >> 2] | 0, o3[A8 + 8 >> 2] = I7, o3[A8 + 12 >> 2] = I7 >>> 0 < g6 >>> 0 ? B4 + 1 | 0 : B4, B4 = o3[A8 + 20 >> 2] + o3[C4 + 20 >> 2] | 0, I7 = (g6 = o3[C4 + 16 >> 2]) + o3[A8 + 16 >> 2] | 0, o3[A8 + 16 >> 2] = I7, o3[A8 + 20 >> 2] = I7 >>> 0 < g6 >>> 0 ? B4 + 1 | 0 : B4, I7 = o3[A8 + 28 >> 2] + o3[C4 + 28 >> 2] | 0, g6 = (B4 = o3[C4 + 24 >> 2]) + o3[A8 + 24 >> 2] | 0, o3[A8 + 24 >> 2] = g6, o3[A8 + 28 >> 2] = g6 >>> 0 < B4 >>> 0 ? I7 + 1 | 0 : I7, B4 = o3[A8 + 36 >> 2] + o3[C4 + 36 >> 2] | 0, I7 = (g6 = o3[C4 + 32 >> 2]) + o3[A8 + 32 >> 2] | 0, o3[A8 + 32 >> 2] = I7, o3[A8 + 36 >> 2] = I7 >>> 0 < g6 >>> 0 ? B4 + 1 | 0 : B4, I7 = o3[A8 + 44 >> 2] + o3[C4 + 44 >> 2] | 0, g6 = (B4 = o3[C4 + 40 >> 2]) + o3[A8 + 40 >> 2] | 0, o3[A8 + 40 >> 2] = g6, o3[A8 + 44 >> 2] = g6 >>> 0 < B4 >>> 0 ? I7 + 1 | 0 : I7, B4 = o3[A8 + 52 >> 2] + o3[C4 + 52 >> 2] | 0, I7 = (g6 = o3[C4 + 48 >> 2]) + o3[A8 + 48 >> 2] | 0, o3[A8 + 48 >> 2] = I7, o3[A8 + 52 >> 2] = I7 >>> 0 < g6 >>> 0 ? B4 + 1 | 0 : B4, B4 = o3[A8 + 60 >> 2] + o3[C4 + 60 >> 2] | 0, I7 = (g6 = o3[C4 + 56 >> 2]) + o3[A8 + 56 >> 2] | 0, o3[A8 + 56 >> 2] = I7, o3[A8 + 60 >> 2] = I7 >>> 0 < g6 >>> 0 ? B4 + 1 | 0 : B4;
                    }
                    function u3(A8) {
                      var I7, g6, C4, B4, Q4, i4, o4, n4, r4, f4, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0, P4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, X4 = 0, q4 = 0, z4 = 0, V4 = 0, O4 = 0, T4 = 0, W4 = 0;
                      y4 = (l4 = a3[A8 + 44 | 0] | a3[A8 + 45 | 0] << 8 | a3[A8 + 46 | 0] << 16 | a3[A8 + 47 | 0] << 24) >>> 5 & 2097151, c4 = DA(_4 = (a3[A8 + 60 | 0] | a3[A8 + 61 | 0] << 8 | a3[A8 + 62 | 0] << 16 | a3[A8 + 63 | 0] << 24) >>> 3 | 0, 0, -683901, -1), e4 = (t4 = a3[A8 + 44 | 0]) << 16 & 2031616 | a3[A8 + 42 | 0] | a3[A8 + 43 | 0] << 8, t4 = w3, p4 = t4 = e4 >>> 0 > (u4 = c4 + e4 | 0) >>> 0 ? t4 + 1 | 0 : t4, G4 = t4 = t4 - ((u4 >>> 0 < 4293918720) - 1 | 0) | 0, c4 = t4 >> 21, t4 = (e4 = y4) + (y4 = (2097151 & t4) << 11 | (h4 = u4 - -1048576 | 0) >>> 21) | 0, e4 = c4, x4 = e4 = t4 >>> 0 < y4 >>> 0 ? e4 + 1 | 0 : e4, j4 = t4, N4 = DA(t4, e4, -683901, -1), k4 = w3, s4 = DA(I7 = (a3[A8 + 49 | 0] | a3[A8 + 50 | 0] << 8 | a3[A8 + 51 | 0] << 16 | a3[A8 + 52 | 0] << 24) >>> 7 & 2097151, 0, -997805, -1), c4 = (t4 = a3[A8 + 27 | 0]) >>> 24 | 0, y4 = t4 << 8 | (S4 = a3[A8 + 23 | 0] | a3[A8 + 24 | 0] << 8 | a3[A8 + 25 | 0] << 16 | a3[A8 + 26 | 0] << 24) >>> 24, e4 = (t4 = a3[A8 + 28 | 0]) >>> 16 | 0, e4 = 2097151 & ((3 & (e4 |= c4)) << 30 | (t4 = y4 | t4 << 16) >>> 2), t4 = w3, t4 = e4 >>> 0 > (c4 = e4 + s4 | 0) >>> 0 ? t4 + 1 | 0 : t4, e4 = DA(d4 = (H4 = a3[A8 + 52 | 0] | a3[A8 + 53 | 0] << 8 | a3[A8 + 54 | 0] << 16 | a3[A8 + 55 | 0] << 24) >>> 4 & 2097151, 0, 654183, 0), t4 = w3 + t4 | 0, s4 = c4 = e4 + c4 | 0, c4 = e4 >>> 0 > c4 >>> 0 ? t4 + 1 | 0 : t4, D4 = (e4 = a3[A8 + 48 | 0]) << 8 | l4 >>> 24, e4 = t4 = e4 >>> 24 | 0, t4 = DA(g6 = 2097151 & ((3 & (l4 = (t4 = (y4 = a3[A8 + 49 | 0]) >>> 16 | 0) | e4)) << 30 | (e4 = (y4 <<= 16) | D4) >>> 2), 0, 136657, 0), c4 = w3 + c4 | 0, c4 = t4 >>> 0 > (e4 = t4 + s4 | 0) >>> 0 ? c4 + 1 | 0 : c4, y4 = (t4 = DA(C4 = (a3[A8 + 57 | 0] | a3[A8 + 58 | 0] << 8 | a3[A8 + 59 | 0] << 16 | a3[A8 + 60 | 0] << 24) >>> 6 & 2097151, 0, 666643, 0)) + e4 | 0, e4 = w3 + c4 | 0, s4 = y4, c4 = t4 >>> 0 > y4 >>> 0 ? e4 + 1 | 0 : e4, e4 = (t4 = a3[A8 + 56 | 0]) >>> 24 | 0, D4 = t4 << 8 | H4 >>> 24, e4 = DA(B4 = 2097151 & ((1 & (H4 = (t4 = (y4 = a3[A8 + 57 | 0]) >>> 16 | 0) | e4)) << 31 | (e4 = (y4 <<= 16) | D4) >>> 1), 0, 470296, 0), t4 = w3 + c4 | 0, e4 = (t4 = (c4 = y4 = e4 + s4 | 0) >>> 0 < e4 >>> 0 ? t4 + 1 | 0 : t4) + k4 | 0, e4 = c4 >>> 0 > (y4 = c4 + N4 | 0) >>> 0 ? e4 + 1 | 0 : e4, U4 = c4 - -1048576 | 0, J4 = c4 = t4 - ((c4 >>> 0 < 4293918720) - 1 | 0) | 0, k4 = y4 - (t4 = -2097152 & U4) | 0, N4 = e4 - ((t4 >>> 0 > y4 >>> 0) + c4 | 0) | 0, e4 = DA(I7, 0, 654183, 0), t4 = w3, t4 = e4 >>> 0 > (c4 = e4 + (S4 >>> 5 & 2097151) | 0) >>> 0 ? t4 + 1 | 0 : t4, y4 = (e4 = c4) + (c4 = DA(d4, 0, 470296, 0)) | 0, e4 = w3 + t4 | 0, e4 = c4 >>> 0 > y4 >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(g6, q4, -997805, -1), e4 = w3 + e4 | 0, e4 = t4 >>> 0 > (c4 = t4 + y4 | 0) >>> 0 ? e4 + 1 | 0 : e4, y4 = (t4 = c4) + (c4 = DA(B4, z4, 666643, 0)) | 0, t4 = w3 + e4 | 0, D4 = y4, y4 = c4 >>> 0 > y4 >>> 0 ? t4 + 1 | 0 : t4, s4 = (c4 = DA(I7, 0, 470296, 0)) + (t4 = (t4 = a3[A8 + 23 | 0]) << 16 & 2031616 | a3[A8 + 21 | 0] | a3[A8 + 22 | 0] << 8) | 0, c4 = w3, c4 = t4 >>> 0 > s4 >>> 0 ? c4 + 1 | 0 : c4, s4 = (e4 = DA(d4, 0, 666643, 0)) + s4 | 0, t4 = w3 + c4 | 0, c4 = DA(g6, q4, 654183, 0), e4 = w3 + (e4 >>> 0 > s4 >>> 0 ? t4 + 1 | 0 : t4) | 0, H4 = e4 = c4 >>> 0 > (S4 = c4 + s4 | 0) >>> 0 ? e4 + 1 | 0 : e4, m4 = e4 = e4 - ((S4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = (t4 = e4 >>> 21 | 0) + y4 | 0, c4 = t4 = (e4 = (2097151 & e4) << 11 | (s4 = S4 - -1048576 | 0) >>> 21) >>> 0 > (D4 = e4 + D4 | 0) >>> 0 ? t4 + 1 | 0 : t4, F4 = e4 = t4 - ((D4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = k4, k4 = (2097151 & e4) << 11 | (y4 = D4 - -1048576 | 0) >>> 21, e4 = (e4 >> 21) + N4 | 0, l4 = k4 = (e4 = k4 >>> 0 > (M4 = t4 + k4 | 0) >>> 0 ? e4 + 1 | 0 : e4) - ((M4 >>> 0 < 4293918720) - 1 | 0) | 0, L4 = M4 - (t4 = -2097152 & (N4 = M4 - -1048576 | 0)) | 0, V4 = e4 - ((t4 >>> 0 > M4 >>> 0) + k4 | 0) | 0, t4 = DA(j4, x4, 136657, 0), c4 = w3 + c4 | 0, c4 = t4 >>> 0 > (e4 = t4 + D4 | 0) >>> 0 ? c4 + 1 | 0 : c4, b4 = e4 - (t4 = -2097152 & y4) | 0, R4 = c4 - ((t4 >>> 0 > e4 >>> 0) + F4 | 0) | 0, M4 = u4 - (t4 = -2097152 & h4) | 0, G4 = p4 - ((t4 >>> 0 > u4 >>> 0) + G4 | 0) | 0, p4 = DA(_4, 0, 136657, 0), e4 = (t4 = a3[A8 + 40 | 0]) >>> 24 | 0, y4 = t4 << 8 | (h4 = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24) >>> 24, c4 = (t4 = a3[A8 + 41 | 0]) >>> 16 | 0, e4 = (c4 |= e4) >>> 3 | 0, c4 = (7 & c4) << 29 | (t4 = y4 | t4 << 16) >>> 3, t4 = e4 + w3 | 0, t4 = c4 >>> 0 > (y4 = c4 + p4 | 0) >>> 0 ? t4 + 1 | 0 : t4, e4 = DA(C4, 0, -683901, -1), t4 = w3 + t4 | 0, t4 = e4 >>> 0 > (c4 = e4 + y4 | 0) >>> 0 ? t4 + 1 | 0 : t4, D4 = c4, e4 = DA(_4, 0, -997805, -1), c4 = w3, c4 = e4 >>> 0 > (y4 = e4 + (h4 >>> 6 & 2097151) | 0) >>> 0 ? c4 + 1 | 0 : c4, h4 = (e4 = y4) + (y4 = DA(C4, 0, 136657, 0)) | 0, e4 = w3 + c4 | 0, c4 = DA(B4, z4, -683901, -1), e4 = w3 + (y4 >>> 0 > h4 >>> 0 ? e4 + 1 | 0 : e4) | 0, k4 = e4 = c4 >>> 0 > (K4 = c4 + h4 | 0) >>> 0 ? e4 + 1 | 0 : e4, O4 = c4 = e4 - ((K4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = t4 + (e4 = c4 >> 21) | 0, h4 = t4 = (c4 = (2097151 & c4) << 11 | (u4 = K4 - -1048576 | 0) >>> 21) >>> 0 > (F4 = c4 + D4 | 0) >>> 0 ? t4 + 1 | 0 : t4, P4 = t4 = t4 - ((F4 >>> 0 < 4293918720) - 1 | 0) | 0, e4 = (e4 = t4 >> 21) + G4 | 0, X4 = e4 = (t4 = (c4 = (2097151 & t4) << 11 | (D4 = F4 - -1048576 | 0) >>> 21) + M4 | 0) >>> 0 < c4 >>> 0 ? e4 + 1 | 0 : e4, v4 = t4, e4 = DA(t4, e4, -683901, -1), t4 = w3 + R4 | 0, Y4 = c4 = e4 + b4 | 0, y4 = e4 >>> 0 > c4 >>> 0 ? t4 + 1 | 0 : t4, R4 = S4 - (t4 = -2097152 & s4) | 0, G4 = H4 - ((4095 & m4) + (t4 >>> 0 > S4 >>> 0) | 0) | 0, S4 = DA(I7, 0, 666643, 0), t4 = (e4 = a3[A8 + 19 | 0]) >>> 24 | 0, s4 = e4 << 8 | (H4 = a3[A8 + 15 | 0] | a3[A8 + 16 | 0] << 8 | a3[A8 + 17 | 0] << 16 | a3[A8 + 18 | 0] << 24) >>> 24, c4 = t4, e4 = (7 & (c4 |= e4 = (t4 = a3[A8 + 20 | 0]) >>> 16 | 0)) << 29 | (e4 = (t4 <<= 16) | s4) >>> 3, c4 = w3 + (c4 >>> 3 | 0) | 0, c4 = e4 >>> 0 > (s4 = e4 + S4 | 0) >>> 0 ? c4 + 1 | 0 : c4, t4 = DA(g6, q4, 470296, 0), e4 = w3 + c4 | 0, t4 = t4 >>> 0 > (s4 = t4 + s4 | 0) >>> 0 ? e4 + 1 | 0 : e4, c4 = DA(g6, q4, 666643, 0), e4 = w3, S4 = e4 = c4 >>> 0 > (b4 = c4 + (H4 >>> 6 & 2097151) | 0) >>> 0 ? e4 + 1 | 0 : e4, T4 = c4 = e4 - ((b4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = t4 + (e4 = c4 >>> 21 | 0) | 0, H4 = t4 = (c4 = (2097151 & c4) << 11 | (p4 = b4 - -1048576 | 0) >>> 21) >>> 0 > (M4 = c4 + s4 | 0) >>> 0 ? t4 + 1 | 0 : t4, W4 = t4 = t4 - ((M4 >>> 0 < 4293918720) - 1 | 0) | 0, e4 = (e4 = t4 >>> 21 | 0) + G4 | 0, e4 = (t4 = (2097151 & t4) << 11 | (s4 = M4 - -1048576 | 0) >>> 21) >>> 0 > (c4 = t4 + R4 | 0) >>> 0 ? e4 + 1 | 0 : e4, G4 = (t4 = c4) + (c4 = DA(j4, x4, -997805, -1)) | 0, t4 = w3 + e4 | 0, t4 = c4 >>> 0 > G4 >>> 0 ? t4 + 1 | 0 : t4, m4 = e4 = F4 - (c4 = -2097152 & D4) | 0, Q4 = D4 = h4 - ((c4 >>> 0 > F4 >>> 0) + P4 | 0) | 0, c4 = DA(v4, X4, 136657, 0), t4 = w3 + t4 | 0, t4 = c4 >>> 0 > (h4 = c4 + G4 | 0) >>> 0 ? t4 + 1 | 0 : t4, c4 = DA(e4, D4, -683901, -1), e4 = w3 + t4 | 0, h4 = e4 = c4 >>> 0 > (G4 = c4 + h4 | 0) >>> 0 ? e4 + 1 | 0 : e4, P4 = t4 = e4 - ((G4 >>> 0 < 4293918720) - 1 | 0) | 0, e4 = (2097151 & t4) << 11 | (D4 = G4 - -1048576 | 0) >>> 21, t4 = (t4 >> 21) + y4 | 0, Y4 = e4 = (t4 = e4 >>> 0 > (F4 = e4 + Y4 | 0) >>> 0 ? t4 + 1 | 0 : t4) - ((F4 >>> 0 < 4293918720) - 1 | 0) | 0, R4 = (2097151 & e4) << 11 | (y4 = F4 - -1048576 | 0) >>> 21, e4 = (e4 >> 21) + V4 | 0, o4 = L4 = R4 + L4 | 0, R4 = L4 >>> 0 < R4 >>> 0 ? e4 + 1 | 0 : e4, n4 = F4 - (e4 = -2097152 & y4) | 0, r4 = t4 - ((e4 >>> 0 > F4 >>> 0) + Y4 | 0) | 0, L4 = G4 - (t4 = -2097152 & D4) | 0, V4 = h4 - ((t4 >>> 0 > G4 >>> 0) + P4 | 0) | 0, c4 = (t4 = DA(j4, x4, 654183, 0)) + (M4 - (e4 = -2097152 & s4) | 0) | 0, e4 = w3 + (H4 - ((e4 >>> 0 > M4 >>> 0) + W4 | 0) | 0) | 0, e4 = t4 >>> 0 > c4 >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(v4, X4, -997805, -1), e4 = w3 + e4 | 0, e4 = t4 >>> 0 > (c4 = t4 + c4 | 0) >>> 0 ? e4 + 1 | 0 : e4, y4 = (t4 = c4) + (c4 = DA(m4, Q4, 136657, 0)) | 0, t4 = w3 + e4 | 0, Y4 = y4, h4 = c4 >>> 0 > y4 >>> 0 ? t4 + 1 | 0 : t4, M4 = K4 - (t4 = -2097152 & u4) | 0, F4 = k4 - ((t4 >>> 0 > K4 >>> 0) + O4 | 0) | 0, H4 = DA(d4, 0, -683901, -1), t4 = (e4 = a3[A8 + 35 | 0]) >>> 24 | 0, y4 = e4 << 8 | (s4 = a3[A8 + 31 | 0] | a3[A8 + 32 | 0] << 8 | a3[A8 + 33 | 0] << 16 | a3[A8 + 34 | 0] << 24) >>> 24, c4 = t4, e4 = (t4 = a3[A8 + 36 | 0]) >>> 16 | 0, e4 |= c4, c4 = w3, c4 = (t4 = 2097151 & ((1 & e4) << 31 | (t4 = t4 << 16 | y4) >>> 1)) >>> 0 > (e4 = t4 + H4 | 0) >>> 0 ? c4 + 1 | 0 : c4, y4 = (t4 = DA(_4, 0, 654183, 0)) + e4 | 0, e4 = w3 + c4 | 0, e4 = t4 >>> 0 > y4 >>> 0 ? e4 + 1 | 0 : e4, c4 = DA(C4, 0, -997805, -1), t4 = w3 + e4 | 0, t4 = c4 >>> 0 > (y4 = c4 + y4 | 0) >>> 0 ? t4 + 1 | 0 : t4, e4 = DA(B4, z4, 136657, 0), t4 = w3 + t4 | 0, D4 = c4 = e4 + y4 | 0, y4 = e4 >>> 0 > c4 >>> 0 ? t4 + 1 | 0 : t4, t4 = DA(I7, 0, -683901, -1), e4 = w3, e4 = t4 >>> 0 > (c4 = t4 + (s4 >>> 4 & 2097151) | 0) >>> 0 ? e4 + 1 | 0 : e4, s4 = (t4 = DA(d4, 0, 136657, 0)) + c4 | 0, c4 = w3 + e4 | 0, c4 = t4 >>> 0 > s4 >>> 0 ? c4 + 1 | 0 : c4, t4 = DA(_4, 0, 470296, 0), e4 = w3 + c4 | 0, e4 = t4 >>> 0 > (s4 = t4 + s4 | 0) >>> 0 ? e4 + 1 | 0 : e4, s4 = (c4 = DA(C4, 0, 654183, 0)) + s4 | 0, t4 = w3 + e4 | 0, e4 = DA(B4, z4, -997805, -1), t4 = w3 + (c4 >>> 0 > s4 >>> 0 ? t4 + 1 | 0 : t4) | 0, H4 = t4 = e4 >>> 0 > (k4 = e4 + s4 | 0) >>> 0 ? t4 + 1 | 0 : t4, f4 = e4 = t4 - ((k4 >>> 0 < 4293918720) - 1 | 0) | 0, c4 = (t4 = e4 >> 21) + y4 | 0, G4 = e4 = (c4 = (e4 = (2097151 & e4) << 11 | (s4 = k4 - -1048576 | 0) >>> 21) >>> 0 > (u4 = e4 + D4 | 0) >>> 0 ? c4 + 1 | 0 : c4) - ((u4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = (t4 = e4 >> 21) + F4 | 0, P4 = t4 = (e4 = (y4 = (2097151 & e4) << 11 | (D4 = u4 - -1048576 | 0) >>> 21) + M4 | 0) >>> 0 < y4 >>> 0 ? t4 + 1 | 0 : t4, y4 = Y4, Y4 = e4, t4 = DA(e4, t4, -683901, -1), e4 = w3 + h4 | 0, F4 = y4 = y4 + t4 | 0, y4 = t4 >>> 0 > y4 >>> 0 ? e4 + 1 | 0 : e4, h4 = (t4 = DA(j4, x4, 470296, 0)) + (b4 - (e4 = -2097152 & p4) | 0) | 0, e4 = w3 + (S4 - ((2047 & T4) + (e4 >>> 0 > b4 >>> 0) | 0) | 0) | 0, e4 = t4 >>> 0 > h4 >>> 0 ? e4 + 1 | 0 : e4, p4 = (t4 = h4) + (h4 = DA(v4, X4, 654183, 0)) | 0, t4 = w3 + e4 | 0, t4 = h4 >>> 0 > p4 >>> 0 ? t4 + 1 | 0 : t4, h4 = DA(m4, Q4, -997805, -1), e4 = w3 + t4 | 0, e4 = h4 >>> 0 > (p4 = h4 + p4 | 0) >>> 0 ? e4 + 1 | 0 : e4, K4 = D4 = u4 - (t4 = -2097152 & D4) | 0, i4 = h4 = c4 - ((t4 >>> 0 > u4 >>> 0) + G4 | 0) | 0, c4 = DA(Y4, P4, 136657, 0), t4 = w3 + e4 | 0, t4 = c4 >>> 0 > (p4 = c4 + p4 | 0) >>> 0 ? t4 + 1 | 0 : t4, c4 = DA(D4, h4, -683901, -1), e4 = w3 + t4 | 0, h4 = e4 = c4 >>> 0 > (S4 = c4 + p4 | 0) >>> 0 ? e4 + 1 | 0 : e4, G4 = t4 = e4 - ((S4 >>> 0 < 4293918720) - 1 | 0) | 0, e4 = (2097151 & t4) << 11 | (D4 = S4 - -1048576 | 0) >>> 21, t4 = (t4 >> 21) + y4 | 0, F4 = e4 = (t4 = e4 >>> 0 > (p4 = e4 + F4 | 0) >>> 0 ? t4 + 1 | 0 : t4) - ((p4 >>> 0 < 4293918720) - 1 | 0) | 0, u4 = (2097151 & e4) << 11 | (y4 = p4 - -1048576 | 0) >>> 21, e4 = (e4 >> 21) + V4 | 0, O4 = M4 = u4 + L4 | 0, M4 = u4 >>> 0 > M4 >>> 0 ? e4 + 1 | 0 : e4, T4 = p4 - (e4 = -2097152 & y4) | 0, W4 = t4 - ((e4 >>> 0 > p4 >>> 0) + F4 | 0) | 0, L4 = S4 - (t4 = -2097152 & D4) | 0, V4 = h4 - ((t4 >>> 0 > S4 >>> 0) + G4 | 0) | 0, h4 = DA(j4, x4, 666643, 0), t4 = (e4 = a3[A8 + 14 | 0]) >>> 24 | 0, y4 = e4 << 8 | (G4 = a3[A8 + 10 | 0] | a3[A8 + 11 | 0] << 8 | a3[A8 + 12 | 0] << 16 | a3[A8 + 13 | 0] << 24) >>> 24, c4 = t4, e4 = (t4 = a3[A8 + 15 | 0]) >>> 16 | 0, e4 |= c4, c4 = w3, c4 = (t4 = 2097151 & ((1 & e4) << 31 | (t4 = t4 << 16 | y4) >>> 1)) >>> 0 > (e4 = t4 + h4 | 0) >>> 0 ? c4 + 1 | 0 : c4, y4 = (t4 = e4) + (e4 = DA(v4, X4, 470296, 0)) | 0, t4 = w3 + c4 | 0, t4 = e4 >>> 0 > y4 >>> 0 ? t4 + 1 | 0 : t4, e4 = DA(m4, Q4, 654183, 0), t4 = w3 + t4 | 0, t4 = e4 >>> 0 > (c4 = e4 + y4 | 0) >>> 0 ? t4 + 1 | 0 : t4, y4 = (e4 = c4) + (c4 = DA(Y4, P4, -997805, -1)) | 0, e4 = w3 + t4 | 0, e4 = c4 >>> 0 > y4 >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(K4, i4, 136657, 0), e4 = w3 + e4 | 0, S4 = c4 = t4 + y4 | 0, y4 = t4 >>> 0 > c4 >>> 0 ? e4 + 1 | 0 : e4, s4 = k4 - (t4 = -2097152 & s4) | 0, h4 = H4 - ((t4 >>> 0 > k4 >>> 0) + f4 | 0) | 0, c4 = DA(I7, 0, 136657, 0), t4 = w3, t4 = (e4 = (a3[A8 + 28 | 0] | a3[A8 + 29 | 0] << 8 | a3[A8 + 30 | 0] << 16 | a3[A8 + 31 | 0] << 24) >>> 7 & 2097151) >>> 0 > (c4 = e4 + c4 | 0) >>> 0 ? t4 + 1 | 0 : t4, D4 = (e4 = c4) + (c4 = DA(d4, 0, -997805, -1)) | 0, e4 = w3 + t4 | 0, e4 = c4 >>> 0 > D4 >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(g6, q4, -683901, -1), e4 = w3 + e4 | 0, e4 = t4 >>> 0 > (c4 = t4 + D4 | 0) >>> 0 ? e4 + 1 | 0 : e4, D4 = (t4 = DA(_4, 0, 666643, 0)) + c4 | 0, c4 = w3 + e4 | 0, c4 = t4 >>> 0 > D4 >>> 0 ? c4 + 1 | 0 : c4, e4 = DA(C4, 0, 470296, 0), t4 = w3 + c4 | 0, t4 = e4 >>> 0 > (D4 = e4 + D4 | 0) >>> 0 ? t4 + 1 | 0 : t4, e4 = DA(B4, z4, 654183, 0), t4 = w3 + t4 | 0, e4 = (J4 >> 21) + (e4 >>> 0 > (c4 = e4 + D4 | 0) >>> 0 ? t4 + 1 | 0 : t4) | 0, u4 = e4 = (D4 = (2097151 & J4) << 11 | U4 >>> 21) >>> 0 > (U4 = D4 + c4 | 0) >>> 0 ? e4 + 1 | 0 : e4, F4 = t4 = e4 - ((U4 >>> 0 < 4293918720) - 1 | 0) | 0, D4 = (2097151 & t4) << 11 | (p4 = U4 - -1048576 | 0) >>> 21, t4 = (t4 >> 21) + h4 | 0, b4 = t4 = (e4 = D4 + s4 | 0) >>> 0 < D4 >>> 0 ? t4 + 1 | 0 : t4, J4 = e4, e4 = DA(e4, t4, -683901, -1), t4 = w3 + y4 | 0, D4 = c4 = e4 + S4 | 0, y4 = e4 >>> 0 > c4 >>> 0 ? t4 + 1 | 0 : t4, t4 = DA(v4, X4, 666643, 0), e4 = w3, e4 = t4 >>> 0 > (c4 = t4 + (G4 >>> 4 & 2097151) | 0) >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(m4, Q4, 470296, 0), e4 = w3 + e4 | 0, e4 = t4 >>> 0 > (c4 = t4 + c4 | 0) >>> 0 ? e4 + 1 | 0 : e4, h4 = (t4 = DA(Y4, P4, 654183, 0)) + c4 | 0, c4 = w3 + e4 | 0, c4 = t4 >>> 0 > h4 >>> 0 ? c4 + 1 | 0 : c4, e4 = DA(K4, i4, -997805, -1), t4 = w3 + c4 | 0, t4 = e4 >>> 0 > (h4 = e4 + h4 | 0) >>> 0 ? t4 + 1 | 0 : t4, e4 = DA(J4, b4, 136657, 0), t4 = w3 + t4 | 0, H4 = t4 = e4 >>> 0 > (k4 = e4 + h4 | 0) >>> 0 ? t4 + 1 | 0 : t4, x4 = e4 = t4 - ((k4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = D4, D4 = (2097151 & e4) << 11 | (s4 = k4 - -1048576 | 0) >>> 21, e4 = (e4 >> 21) + y4 | 0, v4 = y4 = (e4 = (c4 = t4 + D4 | 0) >>> 0 < D4 >>> 0 ? e4 + 1 | 0 : e4) - ((c4 >>> 0 < 4293918720) - 1 | 0) | 0, t4 = (t4 = y4 >> 21) + V4 | 0, j4 = D4 = (y4 = (2097151 & y4) << 11 | (h4 = c4 - -1048576 | 0) >>> 21) + L4 | 0, S4 = y4 >>> 0 > D4 >>> 0 ? t4 + 1 | 0 : t4, D4 = c4, c4 = e4, y4 = (U4 - (e4 = -2097152 & p4) | 0) + (p4 = (2097151 & l4) << 11 | N4 >>> 21) | 0, e4 = (u4 - ((e4 >>> 0 > U4 >>> 0) + F4 | 0) | 0) + (l4 >> 21) | 0, G4 = e4 = y4 >>> 0 < p4 >>> 0 ? e4 + 1 | 0 : e4, d4 = e4 = e4 - ((y4 >>> 0 < 4293918720) - 1 | 0) | 0, N4 = t4 = e4 >> 21, t4 = DA(_4 = (2097151 & e4) << 11 | (F4 = y4 - -1048576 | 0) >>> 21, t4, -683901, -1), c4 = w3 + c4 | 0, c4 = t4 >>> 0 > (e4 = t4 + D4 | 0) >>> 0 ? c4 + 1 | 0 : c4, q4 = e4 - (t4 = -2097152 & h4) | 0, z4 = c4 - ((t4 >>> 0 > e4 >>> 0) + v4 | 0) | 0, t4 = DA(_4, N4, 136657, 0), e4 = H4 + w3 | 0, X4 = (c4 = t4 + k4 | 0) - (t4 = -2097152 & s4) | 0, v4 = (e4 = c4 >>> 0 < k4 >>> 0 ? e4 + 1 | 0 : e4) - ((t4 >>> 0 > c4 >>> 0) + x4 | 0) | 0, e4 = DA(m4, Q4, 666643, 0), c4 = w3, c4 = (t4 = (a3[A8 + 7 | 0] | a3[A8 + 8 | 0] << 8 | a3[A8 + 9 | 0] << 16 | a3[A8 + 10 | 0] << 24) >>> 7 & 2097151) >>> 0 > (e4 = t4 + e4 | 0) >>> 0 ? c4 + 1 | 0 : c4, D4 = (t4 = DA(Y4, P4, 470296, 0)) + e4 | 0, e4 = w3 + c4 | 0, e4 = t4 >>> 0 > D4 >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(K4, i4, 654183, 0), e4 = w3 + e4 | 0, e4 = t4 >>> 0 > (c4 = t4 + D4 | 0) >>> 0 ? e4 + 1 | 0 : e4, D4 = (t4 = c4) + (c4 = DA(J4, b4, -997805, -1)) | 0, t4 = w3 + e4 | 0, p4 = D4, D4 = c4 >>> 0 > D4 >>> 0 ? t4 + 1 | 0 : t4, H4 = DA(Y4, P4, 666643, 0), t4 = (e4 = a3[A8 + 6 | 0]) >>> 24 | 0, h4 = e4 << 8 | (U4 = a3[A8 + 2 | 0] | a3[A8 + 3 | 0] << 8 | a3[A8 + 4 | 0] << 16 | a3[A8 + 5 | 0] << 24) >>> 24, c4 = t4, e4 = (t4 = a3[A8 + 7 | 0]) >>> 16 | 0, e4 = 2097151 & ((3 & (e4 |= c4)) << 30 | (t4 = t4 << 16 | h4) >>> 2), t4 = w3, t4 = e4 >>> 0 > (c4 = e4 + H4 | 0) >>> 0 ? t4 + 1 | 0 : t4, h4 = (e4 = DA(K4, i4, 470296, 0)) + c4 | 0, c4 = w3 + t4 | 0, c4 = e4 >>> 0 > h4 >>> 0 ? c4 + 1 | 0 : c4, e4 = DA(J4, b4, 654183, 0), t4 = w3 + c4 | 0, H4 = t4 = e4 >>> 0 > (u4 = e4 + h4 | 0) >>> 0 ? t4 + 1 | 0 : t4, l4 = t4 = t4 - ((u4 >>> 0 < 4293918720) - 1 | 0) | 0, e4 = (c4 = t4 >> 21) + D4 | 0, k4 = t4 = (e4 = (t4 = (2097151 & t4) << 11 | (s4 = u4 - -1048576 | 0) >>> 21) >>> 0 > (h4 = t4 + p4 | 0) >>> 0 ? e4 + 1 | 0 : e4) - ((h4 >>> 0 < 4293918720) - 1 | 0) | 0, p4 = (2097151 & t4) << 11 | (D4 = h4 - -1048576 | 0) >>> 21, t4 = (t4 >> 21) + v4 | 0, v4 = Y4 = p4 + X4 | 0, p4 = p4 >>> 0 > Y4 >>> 0 ? t4 + 1 | 0 : t4, t4 = DA(_4, N4, -997805, -1), e4 = w3 + e4 | 0, e4 = t4 >>> 0 > (c4 = t4 + h4 | 0) >>> 0 ? e4 + 1 | 0 : e4, m4 = c4 - (t4 = -2097152 & D4) | 0, P4 = e4 - ((t4 >>> 0 > c4 >>> 0) + k4 | 0) | 0, e4 = DA(_4, N4, 654183, 0), t4 = H4 + w3 | 0, Y4 = (c4 = e4 + u4 | 0) - (e4 = -2097152 & s4) | 0, l4 = (t4 = c4 >>> 0 < u4 >>> 0 ? t4 + 1 | 0 : t4) - ((e4 >>> 0 > c4 >>> 0) + l4 | 0) | 0, t4 = DA(K4, i4, 666643, 0), e4 = w3, e4 = t4 >>> 0 > (c4 = t4 + (U4 >>> 5 & 2097151) | 0) >>> 0 ? e4 + 1 | 0 : e4, t4 = DA(J4, b4, 470296, 0), e4 = w3 + e4 | 0, h4 = c4 = t4 + c4 | 0, c4 = t4 >>> 0 > c4 >>> 0 ? e4 + 1 | 0 : e4, D4 = DA(J4, b4, 666643, 0), e4 = (t4 = a3[A8 + 2 | 0]) << 16 & 2031616 | a3[0 | A8] | a3[A8 + 1 | 0] << 8, t4 = w3, H4 = t4 = e4 >>> 0 > (k4 = D4 + e4 | 0) >>> 0 ? t4 + 1 | 0 : t4, b4 = t4 = t4 - ((k4 >>> 0 < 4293918720) - 1 | 0) | 0, D4 = (2097151 & t4) << 11 | (s4 = k4 - -1048576 | 0) >>> 21, t4 = (t4 >> 21) + c4 | 0, c4 = t4 = D4 >>> 0 > (u4 = D4 + h4 | 0) >>> 0 ? t4 + 1 | 0 : t4, U4 = t4 = t4 - ((u4 >>> 0 < 4293918720) - 1 | 0) | 0, D4 = (2097151 & t4) << 11 | (h4 = u4 - -1048576 | 0) >>> 21, t4 = (t4 >> 21) + l4 | 0, D4 = D4 >>> 0 > (l4 = J4 = D4 + Y4 | 0) >>> 0 ? t4 + 1 | 0 : t4, t4 = DA(_4, N4, 470296, 0), c4 = c4 + w3 | 0, c4 = (e4 = t4 + u4 | 0) >>> 0 < u4 >>> 0 ? c4 + 1 | 0 : c4, u4 = e4 - (t4 = -2097152 & h4) | 0, h4 = c4 - ((t4 >>> 0 > e4 >>> 0) + U4 | 0) | 0, e4 = DA(_4, N4, 666643, 0), t4 = w3 + (H4 - (((c4 = -2097152 & s4) >>> 0 > k4 >>> 0) + b4 | 0) | 0) | 0, e4 = (c4 = (t4 = e4 >>> 0 > (J4 = e4 + (k4 - c4 | 0) | 0) >>> 0 ? t4 + 1 | 0 : t4) >> 21) + h4 | 0, t4 = (t4 = (e4 = (t4 = (2097151 & t4) << 11 | J4 >>> 21) >>> 0 > (U4 = t4 + u4 | 0) >>> 0 ? e4 + 1 | 0 : e4) >> 21) + D4 | 0, e4 = (e4 = (t4 = (e4 = (2097151 & e4) << 11 | U4 >>> 21) >>> 0 > (l4 = e4 + l4 | 0) >>> 0 ? t4 + 1 | 0 : t4) >> 21) + P4 | 0, c4 = (t4 = (e4 = (t4 = (2097151 & t4) << 11 | l4 >>> 21) >>> 0 > (D4 = t4 + m4 | 0) >>> 0 ? e4 + 1 | 0 : e4) >> 21) + p4 | 0, t4 = (e4 = (c4 = (e4 = (2097151 & e4) << 11 | D4 >>> 21) >>> 0 > (N4 = e4 + v4 | 0) >>> 0 ? c4 + 1 | 0 : c4) >> 21) + z4 | 0, e4 = (c4 = (t4 = (c4 = (2097151 & c4) << 11 | N4 >>> 21) >>> 0 > (k4 = c4 + q4 | 0) >>> 0 ? t4 + 1 | 0 : t4) >> 21) + S4 | 0, t4 = (t4 = (e4 = (t4 = (2097151 & t4) << 11 | k4 >>> 21) >>> 0 > (u4 = t4 + j4 | 0) >>> 0 ? e4 + 1 | 0 : e4) >> 21) + W4 | 0, e4 = (e4 = (t4 = (e4 = (2097151 & e4) << 11 | u4 >>> 21) >>> 0 > (S4 = e4 + T4 | 0) >>> 0 ? t4 + 1 | 0 : t4) >> 21) + M4 | 0, c4 = (t4 = (e4 = (t4 = (2097151 & t4) << 11 | S4 >>> 21) >>> 0 > (p4 = t4 + O4 | 0) >>> 0 ? e4 + 1 | 0 : e4) >> 21) + r4 | 0, t4 = (e4 = (c4 = (e4 = (2097151 & e4) << 11 | p4 >>> 21) >>> 0 > (H4 = e4 + n4 | 0) >>> 0 ? c4 + 1 | 0 : c4) >> 21) + R4 | 0, h4 = (F4 = y4 - (e4 = -2097152 & F4) | 0) + ((2097151 & (t4 = (c4 = (2097151 & c4) << 11 | H4 >>> 21) >>> 0 > (s4 = c4 + o4 | 0) >>> 0 ? t4 + 1 | 0 : t4)) << 11 | s4 >>> 21) | 0, t4 = (G4 - ((e4 >>> 0 > y4 >>> 0) + d4 | 0) | 0) + (t4 >> 21) | 0, F4 = e4 = (t4 = h4 >>> 0 < F4 >>> 0 ? t4 + 1 | 0 : t4) >> 21, J4 = (t4 = DA(M4 = (2097151 & t4) << 11 | h4 >>> 21, e4, 666643, 0)) + (e4 = 2097151 & J4) | 0, t4 = w3, y4 = t4 = e4 >>> 0 > J4 >>> 0 ? t4 + 1 | 0 : t4, E3[0 | A8] = J4, E3[A8 + 1 | 0] = (255 & t4) << 24 | J4 >>> 8, t4 = 2097151 & U4, e4 = DA(M4, F4, 470296, 0) + t4 | 0, c4 = w3, t4 = (y4 >> 21) + (t4 >>> 0 > e4 >>> 0 ? c4 + 1 | 0 : c4) | 0, t4 = (G4 = (2097151 & y4) << 11 | J4 >>> 21) >>> 0 > (U4 = G4 + e4 | 0) >>> 0 ? t4 + 1 | 0 : t4, E3[A8 + 4 | 0] = (2047 & t4) << 21 | U4 >>> 11, e4 = t4, c4 = U4, E3[A8 + 3 | 0] = (7 & t4) << 29 | c4 >>> 3, E3[A8 + 2 | 0] = 31 & ((65535 & y4) << 16 | J4 >>> 16) | c4 << 5, y4 = 2097151 & l4, l4 = DA(M4, F4, 654183, 0) + y4 | 0, t4 = w3, U4 = (2097151 & e4) << 11 | c4 >>> 21, e4 = (e4 >> 21) + (y4 = y4 >>> 0 > l4 >>> 0 ? t4 + 1 | 0 : t4) | 0, t4 = e4 = (l4 = U4 + l4 | 0) >>> 0 < U4 >>> 0 ? e4 + 1 | 0 : e4, E3[A8 + 6 | 0] = (63 & t4) << 26 | l4 >>> 6, y4 = l4, l4 = 0, E3[A8 + 5 | 0] = l4 << 13 | (1572864 & c4) >>> 19 | y4 << 2, c4 = 2097151 & D4, D4 = DA(M4, F4, -997805, -1) + c4 | 0, e4 = w3, e4 = c4 >>> 0 > D4 >>> 0 ? e4 + 1 | 0 : e4, l4 = (2097151 & (c4 = t4)) << 11 | y4 >>> 21, c4 = (t4 >>= 21) + e4 | 0, c4 = (D4 = l4 + D4 | 0) >>> 0 < l4 >>> 0 ? c4 + 1 | 0 : c4, E3[A8 + 9 | 0] = (511 & c4) << 23 | D4 >>> 9, E3[A8 + 8 | 0] = (1 & c4) << 31 | D4 >>> 1, e4 = 0, E3[A8 + 7 | 0] = e4 << 18 | (2080768 & y4) >>> 14 | D4 << 7, e4 = 2097151 & N4, y4 = DA(M4, F4, 136657, 0) + e4 | 0, t4 = w3, t4 = e4 >>> 0 > y4 >>> 0 ? t4 + 1 | 0 : t4, N4 = (2097151 & (e4 = c4)) << 11 | D4 >>> 21, e4 = t4 + (c4 = e4 >> 21) | 0, e4 = (y4 = N4 + y4 | 0) >>> 0 < N4 >>> 0 ? e4 + 1 | 0 : e4, E3[A8 + 12 | 0] = (4095 & e4) << 20 | y4 >>> 12, c4 = y4, E3[A8 + 11 | 0] = (15 & e4) << 28 | c4 >>> 4, y4 = 0, E3[A8 + 10 | 0] = y4 << 15 | (1966080 & D4) >>> 17 | c4 << 4, y4 = 2097151 & k4, D4 = DA(M4, F4, -683901, -1) + y4 | 0, t4 = w3, t4 = y4 >>> 0 > D4 >>> 0 ? t4 + 1 | 0 : t4, y4 = e4, e4 = t4 + (e4 >>= 21) | 0, e4 = (y4 = (Y4 = D4) + (D4 = (2097151 & y4) << 11 | c4 >>> 21) | 0) >>> 0 < D4 >>> 0 ? e4 + 1 | 0 : e4, E3[A8 + 14 | 0] = (127 & e4) << 25 | y4 >>> 7, D4 = 0, E3[A8 + 13 | 0] = D4 << 12 | (1048576 & c4) >>> 20 | y4 << 1, t4 = e4 >> 21, c4 = (e4 = (2097151 & e4) << 11 | y4 >>> 21) >>> 0 > (D4 = e4 + (2097151 & u4) | 0) >>> 0 ? t4 + 1 | 0 : t4, E3[A8 + 17 | 0] = (1023 & c4) << 22 | D4 >>> 10, E3[A8 + 16 | 0] = (3 & c4) << 30 | D4 >>> 2, e4 = 0, E3[A8 + 15 | 0] = e4 << 17 | (2064384 & y4) >>> 15 | D4 << 6, t4 = c4 >> 21, t4 = (e4 = (2097151 & c4) << 11 | D4 >>> 21) >>> 0 > (c4 = e4 + (2097151 & S4) | 0) >>> 0 ? t4 + 1 | 0 : t4, E3[A8 + 20 | 0] = (8191 & t4) << 19 | c4 >>> 13, E3[A8 + 19 | 0] = (31 & t4) << 27 | c4 >>> 5, y4 = (e4 = 2097151 & p4) + (p4 = (2097151 & t4) << 11 | c4 >>> 21) | 0, e4 = t4 >> 21, e4 = y4 >>> 0 < p4 >>> 0 ? e4 + 1 | 0 : e4, p4 = y4, E3[A8 + 21 | 0] = y4, S4 = 0, E3[A8 + 18 | 0] = S4 << 14 | (1835008 & D4) >>> 18 | c4 << 3, E3[A8 + 22 | 0] = (255 & e4) << 24 | y4 >>> 8, c4 = e4 >> 21, c4 = (y4 = (D4 = (2097151 & e4) << 11 | y4 >>> 21) + (2097151 & H4) | 0) >>> 0 < D4 >>> 0 ? c4 + 1 | 0 : c4, E3[A8 + 25 | 0] = (2047 & c4) << 21 | y4 >>> 11, E3[A8 + 24 | 0] = (7 & c4) << 29 | y4 >>> 3, E3[A8 + 23 | 0] = 31 & ((65535 & e4) << 16 | p4 >>> 16) | y4 << 5, t4 = c4 >> 21, t4 = (e4 = (2097151 & c4) << 11 | y4 >>> 21) >>> 0 > (c4 = e4 + (2097151 & s4) | 0) >>> 0 ? t4 + 1 | 0 : t4, E3[A8 + 27 | 0] = (63 & t4) << 26 | c4 >>> 6, D4 = 0, E3[A8 + 26 | 0] = D4 << 13 | (1572864 & y4) >>> 19 | c4 << 2, e4 = t4 >> 21, e4 = (t4 = (y4 = (2097151 & t4) << 11 | c4 >>> 21) + (2097151 & h4) | 0) >>> 0 < y4 >>> 0 ? e4 + 1 | 0 : e4, E3[A8 + 31 | 0] = (131071 & e4) << 15 | t4 >>> 17, E3[A8 + 30 | 0] = (511 & e4) << 23 | t4 >>> 9, E3[A8 + 29 | 0] = (1 & e4) << 31 | t4 >>> 1, y4 = 0, E3[A8 + 28 | 0] = y4 << 18 | (2080768 & c4) >>> 14 | t4 << 7;
                    }
                    function k3(A8, I7, g6, C4, B4, Q4) {
                      var i4, n4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, k4 = 0, S4 = 0, H4 = 0, G4 = 0, J4 = 0, N4 = 0, Y4 = 0, P4 = 0, v4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, X4 = 0, q4 = 0, z4 = 0, O4 = 0, T4 = 0, W4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0, BA2 = 0, QA2 = 0;
                      for (D3 = i4 = D3 - 592 | 0, S4 = -1, H4 = A8 + 32 | 0, k4 = 32, G4 = 1; p4 = a3[2672 + (f4 = k4 - 1 | 0) | 0], t4 = (f4 = ((e4 = a3[f4 + H4 | 0]) ^ p4) - 1 >> 8 & G4) & (y4 = a3[H4 + (k4 = k4 - 2 | 0) | 0]) - (c4 = a3[k4 + 2672 | 0]) >> 8 | 255 & (e4 - p4 >>> 8 & G4 | t4), G4 = f4 & (c4 ^ y4) - 1 >> 8, k4; )
                        ;
                      if (255 & t4 && !(aA(A8) | !(((127 & (-1 ^ a3[B4 + 31 | 0]) | a3[B4 + 1 | 0] & a3[B4 + 2 | 0] & a3[B4 + 3 | 0] & a3[B4 + 4 | 0] & a3[B4 + 5 | 0] & a3[B4 + 6 | 0] & a3[B4 + 7 | 0] & a3[B4 + 8 | 0] & a3[B4 + 9 | 0] & a3[B4 + 10 | 0] & a3[B4 + 11 | 0] & a3[B4 + 12 | 0] & a3[B4 + 13 | 0] & a3[B4 + 14 | 0] & a3[B4 + 15 | 0] & a3[B4 + 16 | 0] & a3[B4 + 17 | 0] & a3[B4 + 18 | 0] & a3[B4 + 19 | 0] & a3[B4 + 20 | 0] & a3[B4 + 21 | 0] & a3[B4 + 22 | 0] & a3[B4 + 23 | 0] & a3[B4 + 24 | 0] & a3[B4 + 25 | 0] & a3[B4 + 26 | 0] & a3[B4 + 27 | 0] & a3[B4 + 28 | 0] & a3[B4 + 30 | 0] & a3[B4 + 29 | 0] ^ 255) - 1 & 236 - a3[0 | B4] ^ -1) >>> 8 & 1) || aA(B4) || U3(i4 + 128 | 0, B4))) {
                        for (EA(f4 = i4 + 384 | 0), Q4 && m3(f4, 34768, 34, 0), m3(f4, A8, 32, 0), m3(f4, B4, 32, 0), m3(f4, I7, g6, C4), M3(f4, g6 = i4 + 320 | 0), u3(g6), Q4 = i4 + 8 | 0, C4 = i4 + 128 | 0, B4 = 0, I7 = 0, D3 = n4 = D3 - 2272 | 0; e4 = g6 + (B4 >>> 3 | 0) | 0, E3[(f4 = n4 + 2016 | 0) + B4 | 0] = a3[0 | e4] >>> (6 & B4) & 1, E3[(t4 = f4) + (f4 = 1 | B4) | 0] = a3[0 | e4] >>> (7 & f4) & 1, 256 != (0 | (B4 = B4 + 2 | 0)); )
                          ;
                        for (; ; ) {
                          I7 = (g6 = I7) + 1 | 0;
                          A:
                            if (!(!a3[0 | (t4 = g6 + (n4 + 2016 | 0) | 0)] | g6 >>> 0 > 254)) {
                              I:
                                if (B4 = E3[0 | (c4 = (n4 + 2016 | 0) + I7 | 0)])
                                  if ((0 | (B4 = (e4 = B4 << 1) + (f4 = E3[0 | t4]) | 0)) <= 15)
                                    E3[0 | t4] = B4, E3[0 | c4] = 0;
                                  else {
                                    if ((0 | (B4 = f4 - e4 | 0)) < -15)
                                      break A;
                                    for (E3[0 | t4] = B4, B4 = I7; ; ) {
                                      if (!a3[0 | (f4 = (n4 + 2016 | 0) + B4 | 0)]) {
                                        E3[0 | f4] = 1;
                                        break I;
                                      }
                                      if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, !f4)
                                        break;
                                    }
                                  }
                              if (!(g6 >>> 0 > 253)) {
                                I:
                                  if (f4 = E3[0 | (y4 = (B4 = g6 + 2 | 0) + (n4 + 2016 | 0) | 0)])
                                    if ((0 | (f4 = (c4 = f4 << 2) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                      if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                        break A;
                                      for (E3[0 | t4] = f4; ; ) {
                                        if (a3[0 | (f4 = (n4 + 2016 | 0) + B4 | 0)]) {
                                          if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                            continue;
                                          break I;
                                        }
                                        break;
                                      }
                                      E3[0 | f4] = 1;
                                    } else
                                      E3[0 | t4] = f4, E3[0 | y4] = 0;
                                if (!(g6 >>> 0 > 252)) {
                                  I:
                                    if (f4 = E3[0 | (y4 = (B4 = g6 + 3 | 0) + (n4 + 2016 | 0) | 0)])
                                      if ((0 | (f4 = (c4 = f4 << 3) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                        if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                          break A;
                                        for (E3[0 | t4] = f4; ; ) {
                                          if (a3[0 | (f4 = (n4 + 2016 | 0) + B4 | 0)]) {
                                            if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                              continue;
                                            break I;
                                          }
                                          break;
                                        }
                                        E3[0 | f4] = 1;
                                      } else
                                        E3[0 | t4] = f4, E3[0 | y4] = 0;
                                  if (!(g6 >>> 0 > 251)) {
                                    I:
                                      if (f4 = E3[0 | (y4 = (B4 = g6 + 4 | 0) + (n4 + 2016 | 0) | 0)])
                                        if ((0 | (f4 = (c4 = f4 << 4) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                          if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                            break A;
                                          for (E3[0 | t4] = f4; ; ) {
                                            if (a3[0 | (f4 = (n4 + 2016 | 0) + B4 | 0)]) {
                                              if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                                continue;
                                              break I;
                                            }
                                            break;
                                          }
                                          E3[0 | f4] = 1;
                                        } else
                                          E3[0 | t4] = f4, E3[0 | y4] = 0;
                                    if (!(g6 >>> 0 > 250)) {
                                      I:
                                        if (f4 = E3[0 | (y4 = (B4 = g6 + 5 | 0) + (n4 + 2016 | 0) | 0)])
                                          if ((0 | (f4 = (c4 = f4 << 5) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                            if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                              break A;
                                            for (E3[0 | t4] = f4; ; ) {
                                              if (a3[0 | (f4 = (n4 + 2016 | 0) + B4 | 0)]) {
                                                if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                                  continue;
                                                break I;
                                              }
                                              break;
                                            }
                                            E3[0 | f4] = 1;
                                          } else
                                            E3[0 | t4] = f4, E3[0 | y4] = 0;
                                      if (!(g6 >>> 0 > 249) && (g6 = E3[0 | (c4 = (B4 = g6 + 6 | 0) + (n4 + 2016 | 0) | 0)]))
                                        if ((0 | (g6 = (e4 = g6 << 6) + (f4 = E3[0 | t4]) | 0)) >= 16) {
                                          if ((0 | (g6 = f4 - e4 | 0)) < -15)
                                            break A;
                                          for (E3[0 | t4] = g6; ; ) {
                                            if (a3[0 | (g6 = (n4 + 2016 | 0) + B4 | 0)]) {
                                              if (E3[0 | g6] = 0, g6 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, g6)
                                                continue;
                                              break A;
                                            }
                                            break;
                                          }
                                          E3[0 | g6] = 1;
                                        } else
                                          E3[0 | t4] = g6, E3[0 | c4] = 0;
                                    }
                                  }
                                }
                              }
                            }
                          if (256 == (0 | I7))
                            break;
                        }
                        for (B4 = 0; g6 = H4 + (B4 >>> 3 | 0) | 0, E3[(I7 = n4 + 1760 | 0) + B4 | 0] = a3[0 | g6] >>> (6 & B4) & 1, E3[(f4 = I7) + (I7 = 1 | B4) | 0] = a3[0 | g6] >>> (7 & I7) & 1, 256 != (0 | (B4 = B4 + 2 | 0)); )
                          ;
                        for (I7 = 0; ; ) {
                          I7 = (g6 = I7) + 1 | 0;
                          A:
                            if (!(!a3[0 | (t4 = g6 + (n4 + 1760 | 0) | 0)] | g6 >>> 0 > 254)) {
                              I:
                                if (B4 = E3[0 | (c4 = (n4 + 1760 | 0) + I7 | 0)])
                                  if ((0 | (B4 = (e4 = B4 << 1) + (f4 = E3[0 | t4]) | 0)) <= 15)
                                    E3[0 | t4] = B4, E3[0 | c4] = 0;
                                  else {
                                    if ((0 | (B4 = f4 - e4 | 0)) < -15)
                                      break A;
                                    for (E3[0 | t4] = B4, B4 = I7; ; ) {
                                      if (!a3[0 | (f4 = (n4 + 1760 | 0) + B4 | 0)]) {
                                        E3[0 | f4] = 1;
                                        break I;
                                      }
                                      if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, !f4)
                                        break;
                                    }
                                  }
                              if (!(g6 >>> 0 > 253)) {
                                I:
                                  if (f4 = E3[0 | (y4 = (B4 = g6 + 2 | 0) + (n4 + 1760 | 0) | 0)])
                                    if ((0 | (f4 = (c4 = f4 << 2) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                      if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                        break A;
                                      for (E3[0 | t4] = f4; ; ) {
                                        if (a3[0 | (f4 = (n4 + 1760 | 0) + B4 | 0)]) {
                                          if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                            continue;
                                          break I;
                                        }
                                        break;
                                      }
                                      E3[0 | f4] = 1;
                                    } else
                                      E3[0 | t4] = f4, E3[0 | y4] = 0;
                                if (!(g6 >>> 0 > 252)) {
                                  I:
                                    if (f4 = E3[0 | (y4 = (B4 = g6 + 3 | 0) + (n4 + 1760 | 0) | 0)])
                                      if ((0 | (f4 = (c4 = f4 << 3) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                        if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                          break A;
                                        for (E3[0 | t4] = f4; ; ) {
                                          if (a3[0 | (f4 = (n4 + 1760 | 0) + B4 | 0)]) {
                                            if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                              continue;
                                            break I;
                                          }
                                          break;
                                        }
                                        E3[0 | f4] = 1;
                                      } else
                                        E3[0 | t4] = f4, E3[0 | y4] = 0;
                                  if (!(g6 >>> 0 > 251)) {
                                    I:
                                      if (f4 = E3[0 | (y4 = (B4 = g6 + 4 | 0) + (n4 + 1760 | 0) | 0)])
                                        if ((0 | (f4 = (c4 = f4 << 4) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                          if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                            break A;
                                          for (E3[0 | t4] = f4; ; ) {
                                            if (a3[0 | (f4 = (n4 + 1760 | 0) + B4 | 0)]) {
                                              if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                                continue;
                                              break I;
                                            }
                                            break;
                                          }
                                          E3[0 | f4] = 1;
                                        } else
                                          E3[0 | t4] = f4, E3[0 | y4] = 0;
                                    if (!(g6 >>> 0 > 250)) {
                                      I:
                                        if (f4 = E3[0 | (y4 = (B4 = g6 + 5 | 0) + (n4 + 1760 | 0) | 0)])
                                          if ((0 | (f4 = (c4 = f4 << 5) + (e4 = E3[0 | t4]) | 0)) >= 16) {
                                            if ((0 | (f4 = e4 - c4 | 0)) < -15)
                                              break A;
                                            for (E3[0 | t4] = f4; ; ) {
                                              if (a3[0 | (f4 = (n4 + 1760 | 0) + B4 | 0)]) {
                                                if (E3[0 | f4] = 0, f4 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, f4)
                                                  continue;
                                                break I;
                                              }
                                              break;
                                            }
                                            E3[0 | f4] = 1;
                                          } else
                                            E3[0 | t4] = f4, E3[0 | y4] = 0;
                                      if (!(g6 >>> 0 > 249) && (g6 = E3[0 | (c4 = (B4 = g6 + 6 | 0) + (n4 + 1760 | 0) | 0)]))
                                        if ((0 | (g6 = (e4 = g6 << 6) + (f4 = E3[0 | t4]) | 0)) >= 16) {
                                          if ((0 | (g6 = f4 - e4 | 0)) < -15)
                                            break A;
                                          for (E3[0 | t4] = g6; ; ) {
                                            if (a3[0 | (g6 = (n4 + 1760 | 0) + B4 | 0)]) {
                                              if (E3[0 | g6] = 0, g6 = B4 >>> 0 < 255, B4 = B4 + 1 | 0, g6)
                                                continue;
                                              break A;
                                            }
                                            break;
                                          }
                                          E3[0 | g6] = 1;
                                        } else
                                          E3[0 | t4] = g6, E3[0 | c4] = 0;
                                    }
                                  }
                                }
                              }
                            }
                          if (256 == (0 | I7))
                            break;
                        }
                        for (V3(S4 = n4 + 480 | 0, C4), p4 = o3[C4 + 8 >> 2], t4 = o3[C4 + 12 >> 2], y4 = o3[C4 + 16 >> 2], c4 = o3[C4 + 20 >> 2], e4 = o3[C4 + 24 >> 2], f4 = o3[C4 + 28 >> 2], B4 = o3[C4 >> 2], g6 = o3[C4 + 4 >> 2], I7 = o3[C4 + 36 >> 2], o3[n4 + 192 >> 2] = o3[C4 + 32 >> 2], o3[n4 + 196 >> 2] = I7, o3[n4 + 184 >> 2] = e4, o3[n4 + 188 >> 2] = f4, o3[n4 + 176 >> 2] = y4, o3[n4 + 180 >> 2] = c4, o3[n4 + 168 >> 2] = p4, o3[n4 + 172 >> 2] = t4, o3[n4 + 160 >> 2] = B4, o3[n4 + 164 >> 2] = g6, p4 = o3[C4 + 40 >> 2], t4 = o3[C4 + 44 >> 2], y4 = o3[C4 + 48 >> 2], c4 = o3[C4 + 52 >> 2], e4 = o3[C4 + 56 >> 2], f4 = o3[C4 + 60 >> 2], B4 = o3[(I7 = C4 - -64 | 0) >> 2], g6 = o3[I7 + 4 >> 2], I7 = o3[C4 + 76 >> 2], o3[n4 + 232 >> 2] = o3[C4 + 72 >> 2], o3[n4 + 236 >> 2] = I7, o3[n4 + 224 >> 2] = B4, o3[n4 + 228 >> 2] = g6, o3[n4 + 216 >> 2] = e4, o3[n4 + 220 >> 2] = f4, o3[n4 + 208 >> 2] = y4, o3[n4 + 212 >> 2] = c4, o3[n4 + 200 >> 2] = p4, o3[n4 + 204 >> 2] = t4, p4 = o3[C4 + 80 >> 2], t4 = o3[C4 + 84 >> 2], y4 = o3[C4 + 88 >> 2], c4 = o3[C4 + 92 >> 2], e4 = o3[C4 + 96 >> 2], f4 = o3[C4 + 100 >> 2], B4 = o3[C4 + 104 >> 2], g6 = o3[C4 + 108 >> 2], I7 = o3[C4 + 116 >> 2], o3[n4 + 272 >> 2] = o3[C4 + 112 >> 2], o3[n4 + 276 >> 2] = I7, o3[n4 + 264 >> 2] = B4, o3[n4 + 268 >> 2] = g6, o3[n4 + 256 >> 2] = e4, o3[n4 + 260 >> 2] = f4, o3[n4 + 248 >> 2] = y4, o3[n4 + 252 >> 2] = c4, o3[n4 + 240 >> 2] = p4, o3[n4 + 244 >> 2] = t4, l3(C4 = n4 + 320 | 0, g6 = n4 + 160 | 0), F3(n4, C4, w4 = n4 + 440 | 0), F3(n4 + 40 | 0, h4 = n4 + 360 | 0, s4 = n4 + 400 | 0), F3(n4 + 80 | 0, s4, w4), F3(n4 + 120 | 0, C4, h4), _3(C4, n4, S4), F3(g6, C4, w4), F3(N4 = n4 + 200 | 0, h4, s4), F3(Y4 = n4 + 240 | 0, s4, w4), F3(J4 = n4 + 280 | 0, C4, h4), V3(I7 = n4 + 640 | 0, g6), _3(C4, n4, I7), F3(g6, C4, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), V3(I7 = n4 + 800 | 0, g6), _3(C4, n4, I7), F3(g6, C4, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), V3(I7 = n4 + 960 | 0, g6), _3(C4, n4, I7), F3(g6, C4, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), V3(I7 = n4 + 1120 | 0, g6), _3(C4, n4, I7), F3(g6, C4, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), V3(I7 = n4 + 1280 | 0, g6), _3(C4, n4, I7), F3(g6, C4, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), V3(I7 = n4 + 1440 | 0, g6), _3(C4, n4, I7), F3(g6, C4, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), V3(n4 + 1600 | 0, g6), o3[Q4 + 32 >> 2] = 0, o3[Q4 + 36 >> 2] = 0, o3[Q4 + 24 >> 2] = 0, o3[Q4 + 28 >> 2] = 0, o3[Q4 + 16 >> 2] = 0, o3[Q4 + 20 >> 2] = 0, o3[Q4 + 8 >> 2] = 0, o3[Q4 + 12 >> 2] = 0, o3[Q4 >> 2] = 0, o3[Q4 + 4 >> 2] = 0, o3[Q4 + 44 >> 2] = 0, o3[Q4 + 48 >> 2] = 0, o3[(z4 = Q4 + 40 | 0) >> 2] = 1, o3[Q4 + 52 >> 2] = 0, o3[Q4 + 56 >> 2] = 0, o3[Q4 + 60 >> 2] = 0, o3[Q4 + 64 >> 2] = 0, o3[Q4 + 68 >> 2] = 0, o3[Q4 + 72 >> 2] = 0, o3[Q4 + 84 >> 2] = 0, o3[Q4 + 88 >> 2] = 0, o3[Q4 + 76 >> 2] = 0, o3[Q4 + 80 >> 2] = 1, o3[Q4 + 92 >> 2] = 0, o3[Q4 + 96 >> 2] = 0, o3[Q4 + 100 >> 2] = 0, o3[Q4 + 104 >> 2] = 0, o3[Q4 + 108 >> 2] = 0, o3[Q4 + 112 >> 2] = 0, o3[Q4 + 116 >> 2] = 0, IA2 = Q4 + 80 | 0, I7 = 255; ; ) {
                          A: {
                            I: {
                              if (!(a3[(n4 + 2016 | 0) + I7 | 0] | a3[(n4 + 1760 | 0) + I7 | 0])) {
                                if (!(a3[(g6 = I7 - 1 | 0) + (n4 + 2016 | 0) | 0] | a3[g6 + (n4 + 1760 | 0) | 0]))
                                  break I;
                                I7 = g6;
                              }
                              if ((0 | I7) < 0)
                                break A;
                              for (; l3(n4 + 320 | 0, Q4), (0 | (B4 = E3[(g6 = I7) + (n4 + 2016 | 0) | 0])) > 0 ? (F3(I7 = n4 + 160 | 0, C4 = n4 + 320 | 0, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), _3(C4, I7, (n4 + 480 | 0) + r3((254 & B4) >>> 1 | 0, 160) | 0)) : (0 | B4) >= 0 || (F3(I7 = n4 + 160 | 0, C4 = n4 + 320 | 0, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), b3(C4, I7, (n4 + 480 | 0) + r3((0 - B4 & 254) >>> 1 | 0, 160) | 0)), (0 | (X4 = E3[g6 + (n4 + 1760 | 0) | 0])) > 0 ? (F3(I7 = n4 + 160 | 0, C4 = n4 + 320 | 0, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, C4, h4), K3(C4, I7, r3((254 & X4) >>> 1 | 0, 120) + 1488 | 0)) : (0 | X4) >= 0 || (F3(n4 + 160 | 0, q4 = n4 + 320 | 0, w4), F3(N4, h4, s4), F3(Y4, s4, w4), F3(J4, q4, h4), P4 = o3[n4 + 160 >> 2], v4 = o3[n4 + 200 >> 2], d4 = o3[n4 + 164 >> 2], L4 = o3[n4 + 204 >> 2], R4 = o3[n4 + 168 >> 2], x4 = o3[n4 + 208 >> 2], j4 = o3[n4 + 172 >> 2], k4 = o3[n4 + 212 >> 2], H4 = o3[n4 + 176 >> 2], G4 = o3[n4 + 216 >> 2], S4 = o3[n4 + 180 >> 2], p4 = o3[n4 + 220 >> 2], t4 = o3[n4 + 184 >> 2], y4 = o3[n4 + 224 >> 2], c4 = o3[n4 + 188 >> 2], e4 = o3[n4 + 228 >> 2], f4 = o3[n4 + 192 >> 2], B4 = o3[n4 + 232 >> 2], C4 = o3[n4 + 236 >> 2], I7 = o3[n4 + 196 >> 2], o3[n4 + 396 >> 2] = C4 - I7, o3[n4 + 392 >> 2] = B4 - f4, o3[n4 + 388 >> 2] = e4 - c4, o3[n4 + 384 >> 2] = y4 - t4, o3[n4 + 380 >> 2] = p4 - S4, o3[n4 + 376 >> 2] = G4 - H4, o3[n4 + 372 >> 2] = k4 - j4, o3[n4 + 368 >> 2] = x4 - R4, o3[n4 + 364 >> 2] = L4 - d4, o3[n4 + 360 >> 2] = v4 - P4, o3[n4 + 356 >> 2] = I7 + C4, o3[n4 + 352 >> 2] = B4 + f4, o3[n4 + 348 >> 2] = e4 + c4, o3[n4 + 344 >> 2] = t4 + y4, o3[n4 + 340 >> 2] = p4 + S4, o3[n4 + 336 >> 2] = H4 + G4, o3[n4 + 332 >> 2] = k4 + j4, o3[n4 + 328 >> 2] = R4 + x4, o3[n4 + 324 >> 2] = d4 + L4, o3[n4 + 320 >> 2] = P4 + v4, F3(s4, q4, 40 + (I7 = r3((0 - X4 & 254) >>> 1 | 0, 120) + 1488 | 0) | 0), F3(h4, h4, I7), F3(w4, I7 + 80 | 0, J4), gA2 = o3[n4 + 276 >> 2], CA2 = o3[n4 + 272 >> 2], X4 = o3[n4 + 268 >> 2], q4 = o3[n4 + 264 >> 2], t4 = o3[n4 + 260 >> 2], y4 = o3[n4 + 256 >> 2], c4 = o3[n4 + 252 >> 2], e4 = o3[n4 + 248 >> 2], f4 = o3[n4 + 244 >> 2], B4 = o3[n4 + 240 >> 2], O4 = o3[n4 + 360 >> 2], T4 = o3[n4 + 400 >> 2], W4 = o3[n4 + 364 >> 2], Z3 = o3[n4 + 404 >> 2], $3 = o3[n4 + 368 >> 2], AA2 = o3[n4 + 408 >> 2], P4 = o3[n4 + 372 >> 2], v4 = o3[n4 + 412 >> 2], d4 = o3[n4 + 376 >> 2], L4 = o3[n4 + 416 >> 2], R4 = o3[n4 + 380 >> 2], x4 = o3[n4 + 420 >> 2], j4 = o3[n4 + 384 >> 2], k4 = o3[n4 + 424 >> 2], H4 = o3[n4 + 388 >> 2], G4 = o3[n4 + 428 >> 2], S4 = o3[n4 + 392 >> 2], p4 = o3[n4 + 432 >> 2], C4 = o3[n4 + 396 >> 2], I7 = o3[n4 + 436 >> 2], o3[n4 + 396 >> 2] = C4 + I7, o3[n4 + 392 >> 2] = p4 + S4, o3[n4 + 388 >> 2] = H4 + G4, o3[n4 + 384 >> 2] = k4 + j4, o3[n4 + 380 >> 2] = R4 + x4, o3[n4 + 376 >> 2] = d4 + L4, o3[n4 + 372 >> 2] = P4 + v4, o3[n4 + 368 >> 2] = $3 + AA2, o3[n4 + 364 >> 2] = W4 + Z3, o3[n4 + 360 >> 2] = O4 + T4, o3[n4 + 356 >> 2] = I7 - C4, o3[n4 + 352 >> 2] = p4 - S4, o3[n4 + 348 >> 2] = G4 - H4, o3[n4 + 344 >> 2] = k4 - j4, o3[n4 + 340 >> 2] = x4 - R4, o3[n4 + 336 >> 2] = L4 - d4, o3[n4 + 332 >> 2] = v4 - P4, o3[n4 + 328 >> 2] = AA2 - $3, o3[n4 + 324 >> 2] = Z3 - W4, o3[n4 + 320 >> 2] = T4 - O4, P4 = B4 << 1, v4 = o3[n4 + 440 >> 2], o3[n4 + 400 >> 2] = P4 - v4, d4 = f4 << 1, L4 = o3[n4 + 444 >> 2], o3[n4 + 404 >> 2] = d4 - L4, R4 = e4 << 1, x4 = o3[n4 + 448 >> 2], o3[n4 + 408 >> 2] = R4 - x4, j4 = c4 << 1, k4 = o3[n4 + 452 >> 2], o3[n4 + 412 >> 2] = j4 - k4, H4 = y4 << 1, G4 = o3[n4 + 456 >> 2], o3[n4 + 416 >> 2] = H4 - G4, S4 = t4 << 1, p4 = o3[n4 + 460 >> 2], o3[n4 + 420 >> 2] = S4 - p4, t4 = q4 << 1, y4 = o3[n4 + 464 >> 2], o3[n4 + 424 >> 2] = t4 - y4, c4 = X4 << 1, e4 = o3[n4 + 468 >> 2], o3[n4 + 428 >> 2] = c4 - e4, f4 = CA2 << 1, B4 = o3[n4 + 472 >> 2], o3[n4 + 432 >> 2] = f4 - B4, C4 = gA2 << 1, I7 = o3[n4 + 476 >> 2], o3[n4 + 436 >> 2] = C4 - I7, o3[n4 + 440 >> 2] = P4 + v4, o3[n4 + 444 >> 2] = d4 + L4, o3[n4 + 448 >> 2] = R4 + x4, o3[n4 + 452 >> 2] = k4 + j4, o3[n4 + 456 >> 2] = H4 + G4, o3[n4 + 460 >> 2] = p4 + S4, o3[n4 + 464 >> 2] = t4 + y4, o3[n4 + 468 >> 2] = e4 + c4, o3[n4 + 472 >> 2] = B4 + f4, o3[n4 + 476 >> 2] = I7 + C4), F3(Q4, n4 + 320 | 0, w4), F3(z4, h4, s4), F3(IA2, s4, w4), I7 = g6 - 1 | 0, (0 | g6) > 0; )
                                ;
                              break A;
                            }
                            if (I7 = I7 - 2 | 0, g6)
                              continue;
                          }
                          break;
                        }
                        D3 = n4 + 2272 | 0, uA(I7 = i4 + 288 | 0, Q4), BA2 = -1, QA2 = cA(I7, A8), S4 = ((0 | A8) == (0 | I7) ? BA2 : QA2) | oA(A8, I7, 32);
                      }
                      return D3 = i4 + 592 | 0, S4;
                    }
                    function F3(A8, I7, g6) {
                      var C4, B4, Q4, i4, E4, a4, n4, f4, t4, e4, c4, y4, D4, h4, s4, p4, u4, k4, F4, l4, S4, H4, M4, G4, U4, J4, N4, Y4, b4, _4, K4, P4, v4, m4, d4, L4, R4, x4, j4, X4, q4, z4, V4, O4, T4, W4, Z3, $3, AA2, IA2, gA2, CA2, BA2, QA2, iA2 = 0, EA2 = 0, oA2 = 0, aA2 = 0, nA2 = 0, rA2 = 0, fA2 = 0, tA2 = 0, eA2 = 0, cA2 = 0, yA2 = 0, wA2 = 0, hA2 = 0, sA2 = 0, pA2 = 0, uA2 = 0, kA2 = 0, FA2 = 0, lA2 = 0, SA2 = 0, HA2 = 0, MA2 = 0, GA2 = 0, UA2 = 0;
                      iA2 = DA(C4 = o3[g6 + 4 >> 2], e4 = C4 >> 31, kA2 = (p4 = o3[I7 + 20 >> 2]) << 1, K4 = kA2 >> 31), oA2 = w3, EA2 = (hA2 = DA(pA2 = o3[g6 >> 2], Q4 = pA2 >> 31, B4 = o3[I7 + 24 >> 2], i4 = B4 >> 31)) + iA2 | 0, iA2 = w3 + oA2 | 0, iA2 = EA2 >>> 0 < hA2 >>> 0 ? iA2 + 1 | 0 : iA2, eA2 = DA(E4 = o3[g6 + 8 >> 2], D4 = E4 >> 31, hA2 = o3[I7 + 16 >> 2], a4 = hA2 >> 31), oA2 = w3 + iA2 | 0, oA2 = (EA2 = eA2 + EA2 | 0) >>> 0 < eA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = (eA2 = DA(c4 = o3[g6 + 12 >> 2], u4 = c4 >> 31, G4 = (k4 = o3[I7 + 12 >> 2]) << 1, P4 = G4 >> 31)) + EA2 | 0, EA2 = w3 + oA2 | 0, EA2 = iA2 >>> 0 < eA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = (sA2 = DA(h4 = o3[g6 + 16 >> 2], U4 = h4 >> 31, eA2 = o3[I7 + 8 >> 2], n4 = eA2 >> 31)) + iA2 | 0, iA2 = w3 + EA2 | 0, iA2 = oA2 >>> 0 < sA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = oA2, oA2 = DA(F4 = o3[g6 + 20 >> 2], v4 = F4 >> 31, J4 = (l4 = o3[I7 + 4 >> 2]) << 1, m4 = J4 >> 31), iA2 = w3 + iA2 | 0, iA2 = (EA2 = EA2 + oA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, W4 = tA2 = o3[g6 + 24 >> 2], oA2 = (cA2 = DA(tA2, O4 = tA2 >> 31, sA2 = o3[I7 >> 2], f4 = sA2 >> 31)) + EA2 | 0, EA2 = w3 + iA2 | 0, EA2 = oA2 >>> 0 < cA2 >>> 0 ? EA2 + 1 | 0 : EA2, d4 = o3[g6 + 28 >> 2], iA2 = (cA2 = DA(wA2 = r3(d4, 19), S4 = wA2 >> 31, N4 = (H4 = o3[I7 + 36 >> 2]) << 1, L4 = N4 >> 31)) + oA2 | 0, oA2 = w3 + EA2 | 0, oA2 = iA2 >>> 0 < cA2 >>> 0 ? oA2 + 1 | 0 : oA2, $3 = o3[g6 + 32 >> 2], EA2 = (fA2 = DA(aA2 = r3($3, 19), s4 = aA2 >> 31, cA2 = o3[I7 + 32 >> 2], t4 = cA2 >> 31)) + iA2 | 0, iA2 = w3 + oA2 | 0, iA2 = EA2 >>> 0 < fA2 >>> 0 ? iA2 + 1 | 0 : iA2, Z3 = o3[g6 + 36 >> 2], g6 = DA(fA2 = r3(Z3, 19), y4 = fA2 >> 31, Y4 = (M4 = o3[I7 + 28 >> 2]) << 1, R4 = Y4 >> 31), iA2 = w3 + iA2 | 0, nA2 = I7 = g6 + EA2 | 0, g6 = I7 >>> 0 < g6 >>> 0 ? iA2 + 1 | 0 : iA2, I7 = DA(hA2, a4, C4, e4), iA2 = w3, EA2 = DA(pA2, Q4, p4, x4 = p4 >> 31), oA2 = w3 + iA2 | 0, oA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = DA(E4, D4, k4, j4 = k4 >> 31), EA2 = w3 + oA2 | 0, EA2 = (I7 = iA2 + I7 | 0) >>> 0 < iA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = DA(eA2, n4, c4, u4), iA2 = w3 + EA2 | 0, iA2 = (I7 = oA2 + I7 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(h4, U4, l4, X4 = l4 >> 31), iA2 = w3 + iA2 | 0, iA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(sA2, f4, F4, v4), iA2 = w3 + iA2 | 0, iA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(tA2 = r3(tA2, 19), b4 = tA2 >> 31, H4, q4 = H4 >> 31), oA2 = w3 + iA2 | 0, oA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = DA(cA2, t4, wA2, S4), EA2 = w3 + oA2 | 0, EA2 = (I7 = iA2 + I7 | 0) >>> 0 < iA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = DA(aA2, s4, M4, z4 = M4 >> 31), iA2 = w3 + EA2 | 0, iA2 = (I7 = oA2 + I7 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(fA2, y4, B4, i4), iA2 = w3 + iA2 | 0, MA2 = I7 = EA2 + I7 | 0, lA2 = I7 >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, I7 = DA(C4, e4, G4, P4), iA2 = w3, EA2 = DA(pA2, Q4, hA2, a4), iA2 = w3 + iA2 | 0, iA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(eA2, n4, E4, D4), oA2 = w3 + iA2 | 0, oA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = DA(c4, u4, J4, m4), EA2 = w3 + oA2 | 0, EA2 = (I7 = iA2 + I7 | 0) >>> 0 < iA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = DA(sA2, f4, h4, U4), iA2 = w3 + EA2 | 0, iA2 = (I7 = oA2 + I7 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(_4 = r3(F4, 19), V4 = _4 >> 31, N4, L4), iA2 = w3 + iA2 | 0, iA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(cA2, t4, tA2, b4), iA2 = w3 + iA2 | 0, iA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(wA2, S4, Y4, R4), oA2 = w3 + iA2 | 0, oA2 = (I7 = EA2 + I7 | 0) >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = DA(aA2, s4, B4, i4), EA2 = w3 + oA2 | 0, EA2 = (I7 = iA2 + I7 | 0) >>> 0 < iA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = DA(fA2, y4, kA2, K4), iA2 = w3 + EA2 | 0, AA2 = I7 = oA2 + I7 | 0, IA2 = iA2 = I7 >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, gA2 = I7 = I7 + 33554432 | 0, CA2 = iA2 = I7 >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2, oA2 = (67108863 & iA2) << 6 | I7 >>> 26, iA2 = (iA2 >> 26) + lA2 | 0, MA2 = I7 = oA2 + MA2 | 0, iA2 = I7 >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, BA2 = I7 = I7 + 16777216 | 0, iA2 = g6 + (EA2 = (oA2 = I7 >>> 0 < 16777216 ? iA2 + 1 | 0 : iA2) >> 25) | 0, iA2 = (I7 = (oA2 = (33554431 & oA2) << 7 | I7 >>> 25) + nA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, FA2 = g6 = (EA2 = I7) + 33554432 | 0, I7 = iA2 = g6 >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2, o3[A8 + 24 >> 2] = EA2 - (-67108864 & g6), g6 = DA(C4, e4, J4, m4), iA2 = w3, EA2 = DA(pA2, Q4, eA2, n4), oA2 = w3 + iA2 | 0, oA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, EA2 = (iA2 = g6) + (g6 = DA(sA2, f4, E4, D4)) | 0, iA2 = w3 + oA2 | 0, iA2 = g6 >>> 0 > EA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(g6 = r3(c4, 19), SA2 = g6 >> 31, N4, L4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = (nA2 = DA(cA2, t4, lA2 = r3(h4, 19), T4 = lA2 >> 31)) + EA2 | 0, EA2 = w3 + iA2 | 0, EA2 = oA2 >>> 0 < nA2 >>> 0 ? EA2 + 1 | 0 : EA2, nA2 = DA(Y4, R4, _4, V4), iA2 = w3 + EA2 | 0, iA2 = (oA2 = nA2 + oA2 | 0) >>> 0 < nA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = (nA2 = DA(B4, i4, tA2, b4)) + oA2 | 0, oA2 = w3 + iA2 | 0, oA2 = EA2 >>> 0 < nA2 >>> 0 ? oA2 + 1 | 0 : oA2, nA2 = DA(wA2, S4, kA2, K4), iA2 = w3 + oA2 | 0, iA2 = (EA2 = nA2 + EA2 | 0) >>> 0 < nA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(aA2, s4, hA2, a4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = (nA2 = DA(fA2, y4, G4, P4)) + EA2 | 0, EA2 = w3 + iA2 | 0, yA2 = oA2, GA2 = oA2 >>> 0 < nA2 >>> 0 ? EA2 + 1 | 0 : EA2, iA2 = DA(sA2, f4, C4, e4), EA2 = w3, oA2 = (nA2 = DA(pA2, Q4, l4, X4)) + iA2 | 0, iA2 = w3 + EA2 | 0, iA2 = oA2 >>> 0 < nA2 >>> 0 ? iA2 + 1 | 0 : iA2, nA2 = EA2 = r3(E4, 19), EA2 = (rA2 = DA(EA2, HA2 = EA2 >> 31, H4, q4)) + oA2 | 0, oA2 = w3 + iA2 | 0, oA2 = EA2 >>> 0 < rA2 >>> 0 ? oA2 + 1 | 0 : oA2, rA2 = DA(cA2, t4, g6, SA2), iA2 = w3 + oA2 | 0, iA2 = (EA2 = rA2 + EA2 | 0) >>> 0 < rA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(lA2, T4, M4, z4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = (rA2 = DA(B4, i4, _4, V4)) + EA2 | 0, EA2 = w3 + iA2 | 0, EA2 = oA2 >>> 0 < rA2 >>> 0 ? EA2 + 1 | 0 : EA2, rA2 = DA(tA2, b4, p4, x4), iA2 = w3 + EA2 | 0, iA2 = (oA2 = rA2 + oA2 | 0) >>> 0 < rA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = (rA2 = DA(hA2, a4, wA2, S4)) + oA2 | 0, oA2 = w3 + iA2 | 0, oA2 = EA2 >>> 0 < rA2 >>> 0 ? oA2 + 1 | 0 : oA2, rA2 = DA(aA2, s4, k4, j4), iA2 = w3 + oA2 | 0, iA2 = (EA2 = rA2 + EA2 | 0) >>> 0 < rA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(fA2, y4, eA2, n4), iA2 = w3 + iA2 | 0, UA2 = EA2 = oA2 + EA2 | 0, rA2 = EA2 >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, iA2 = DA(iA2 = r3(C4, 19), iA2 >> 31, N4, L4), EA2 = w3, oA2 = DA(pA2, Q4, sA2, f4), EA2 = w3 + EA2 | 0, EA2 = (iA2 = oA2 + iA2 | 0) >>> 0 < oA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = (nA2 = DA(cA2, t4, nA2, HA2)) + iA2 | 0, iA2 = w3 + EA2 | 0, g6 = (EA2 = DA(g6, SA2, Y4, R4)) + oA2 | 0, oA2 = w3 + (oA2 >>> 0 < nA2 >>> 0 ? iA2 + 1 | 0 : iA2) | 0, oA2 = g6 >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, EA2 = DA(B4, i4, lA2, T4), iA2 = w3 + oA2 | 0, iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(kA2, K4, _4, V4), iA2 = w3 + iA2 | 0, iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(hA2, a4, tA2, b4), EA2 = w3 + iA2 | 0, EA2 = (g6 = oA2 + g6 | 0) >>> 0 < oA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = DA(wA2, S4, G4, P4), iA2 = w3 + EA2 | 0, iA2 = (g6 = oA2 + g6 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(aA2, s4, eA2, n4), oA2 = w3 + iA2 | 0, oA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? oA2 + 1 | 0 : oA2, EA2 = DA(fA2, y4, J4, m4), iA2 = w3 + oA2 | 0, nA2 = g6 = EA2 + g6 | 0, SA2 = iA2 = g6 >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, HA2 = g6 = g6 + 33554432 | 0, QA2 = iA2 = g6 >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2, EA2 = (oA2 = iA2 >> 26) + rA2 | 0, rA2 = g6 = (iA2 = (67108863 & iA2) << 6 | g6 >>> 26) + UA2 | 0, iA2 = EA2 = g6 >>> 0 < iA2 >>> 0 ? EA2 + 1 | 0 : EA2, UA2 = g6 = g6 + 16777216 | 0, EA2 = (33554431 & (iA2 = g6 >>> 0 < 16777216 ? iA2 + 1 | 0 : iA2)) << 7 | g6 >>> 25, iA2 = (iA2 >> 25) + GA2 | 0, iA2 = (g6 = EA2 + yA2 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, GA2 = EA2 = (oA2 = g6) + 33554432 | 0, g6 = iA2 = EA2 >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2, o3[A8 + 8 >> 2] = oA2 - (-67108864 & EA2), iA2 = DA(B4, i4, C4, e4), oA2 = w3, EA2 = (yA2 = DA(pA2, Q4, M4, z4)) + iA2 | 0, iA2 = w3 + oA2 | 0, iA2 = EA2 >>> 0 < yA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(E4, D4, p4, x4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(hA2, a4, c4, u4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, yA2 = DA(h4, U4, k4, j4), oA2 = w3 + iA2 | 0, oA2 = (EA2 = yA2 + EA2 | 0) >>> 0 < yA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = (yA2 = DA(eA2, n4, F4, v4)) + EA2 | 0, EA2 = w3 + oA2 | 0, EA2 = iA2 >>> 0 < yA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = (yA2 = DA(l4, X4, W4, O4)) + iA2 | 0, iA2 = w3 + EA2 | 0, iA2 = oA2 >>> 0 < yA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = oA2, oA2 = DA(sA2, f4, d4, yA2 = d4 >> 31), iA2 = w3 + iA2 | 0, iA2 = (EA2 = EA2 + oA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(aA2, s4, H4, q4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, uA2 = DA(fA2, y4, cA2, t4), oA2 = w3 + iA2 | 0, iA2 = I7 >> 26, I7 = (FA2 = (67108863 & I7) << 6 | FA2 >>> 26) + (EA2 = uA2 + EA2 | 0) | 0, EA2 = iA2 + (EA2 >>> 0 < uA2 >>> 0 ? oA2 + 1 | 0 : oA2) | 0, iA2 = (oA2 = I7) >>> 0 < FA2 >>> 0 ? EA2 + 1 | 0 : EA2, FA2 = EA2 = oA2 + 16777216 | 0, I7 = iA2 = EA2 >>> 0 < 16777216 ? iA2 + 1 | 0 : iA2, o3[A8 + 28 >> 2] = oA2 - (-33554432 & EA2), iA2 = DA(eA2, n4, C4, e4), EA2 = w3, uA2 = DA(pA2, Q4, k4, j4), oA2 = w3 + EA2 | 0, oA2 = (iA2 = uA2 + iA2 | 0) >>> 0 < uA2 >>> 0 ? oA2 + 1 | 0 : oA2, uA2 = DA(E4, D4, l4, X4), EA2 = w3 + oA2 | 0, EA2 = (iA2 = uA2 + iA2 | 0) >>> 0 < uA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = (uA2 = DA(sA2, f4, c4, u4)) + iA2 | 0, iA2 = w3 + EA2 | 0, iA2 = oA2 >>> 0 < uA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = oA2, oA2 = DA(lA2, T4, H4, q4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = EA2 + oA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(cA2, t4, _4, V4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = (tA2 = DA(tA2, b4, M4, z4)) + EA2 | 0, oA2 = w3 + iA2 | 0, iA2 = (wA2 = DA(B4, i4, wA2, S4)) + EA2 | 0, EA2 = w3 + (EA2 >>> 0 < tA2 >>> 0 ? oA2 + 1 | 0 : oA2) | 0, oA2 = (aA2 = DA(aA2, s4, p4, x4)) + iA2 | 0, iA2 = w3 + (iA2 >>> 0 < wA2 >>> 0 ? EA2 + 1 | 0 : EA2) | 0, iA2 = oA2 >>> 0 < aA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = oA2, oA2 = DA(fA2, y4, hA2, a4), iA2 = w3 + iA2 | 0, aA2 = EA2 = EA2 + oA2 | 0, iA2 = (iA2 = EA2 >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2) + (EA2 = g6 >> 26) | 0, oA2 = (EA2 = g6 = aA2 + (oA2 = (67108863 & g6) << 6 | GA2 >>> 26) | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, wA2 = iA2 = EA2 + 16777216 | 0, g6 = oA2 = iA2 >>> 0 < 16777216 ? oA2 + 1 | 0 : oA2, o3[A8 + 12 >> 2] = EA2 - (-33554432 & iA2), iA2 = DA(C4, e4, Y4, R4), oA2 = w3, EA2 = (aA2 = DA(pA2, Q4, cA2, t4)) + iA2 | 0, iA2 = w3 + oA2 | 0, iA2 = EA2 >>> 0 < aA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(B4, i4, E4, D4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, aA2 = DA(c4, u4, kA2, K4), oA2 = w3 + iA2 | 0, oA2 = (EA2 = aA2 + EA2 | 0) >>> 0 < aA2 >>> 0 ? oA2 + 1 | 0 : oA2, iA2 = (aA2 = DA(hA2, a4, h4, U4)) + EA2 | 0, EA2 = w3 + oA2 | 0, EA2 = iA2 >>> 0 < aA2 >>> 0 ? EA2 + 1 | 0 : EA2, oA2 = (aA2 = DA(G4, P4, F4, v4)) + iA2 | 0, iA2 = w3 + EA2 | 0, iA2 = oA2 >>> 0 < aA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = oA2, oA2 = DA(eA2, n4, W4, O4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = EA2 + oA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(d4, yA2, J4, m4), iA2 = w3 + iA2 | 0, iA2 = (EA2 = oA2 + EA2 | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = (kA2 = DA(sA2, f4, aA2 = $3, tA2 = aA2 >> 31)) + EA2 | 0, oA2 = w3 + iA2 | 0, iA2 = (fA2 = DA(fA2, y4, N4, L4)) + EA2 | 0, EA2 = w3 + (EA2 >>> 0 < kA2 >>> 0 ? oA2 + 1 | 0 : oA2) | 0, EA2 = iA2 >>> 0 < fA2 >>> 0 ? EA2 + 1 | 0 : EA2, fA2 = iA2, iA2 = (iA2 = I7 >> 25) + EA2 | 0, iA2 = (I7 = fA2 + (oA2 = (33554431 & I7) << 7 | FA2 >>> 25) | 0) >>> 0 < oA2 >>> 0 ? iA2 + 1 | 0 : iA2, fA2 = EA2 = (oA2 = I7) + 33554432 | 0, I7 = iA2 = EA2 >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2, o3[A8 + 32 >> 2] = oA2 - (-67108864 & EA2), EA2 = g6 >> 25, g6 = (wA2 = (33554431 & g6) << 7 | wA2 >>> 25) + (AA2 - (iA2 = -67108864 & gA2) | 0) | 0, iA2 = EA2 + (IA2 - ((iA2 >>> 0 > AA2 >>> 0) + CA2 | 0) | 0) | 0, iA2 = g6 >>> 0 < wA2 >>> 0 ? iA2 + 1 | 0 : iA2, FA2 = iA2 = (67108863 & (iA2 = (g6 = (EA2 = g6) + 33554432 | 0) >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2)) << 6 | g6 >>> 26, iA2 = iA2 + (oA2 = MA2 - (-33554432 & BA2) | 0) | 0, o3[A8 + 20 >> 2] = iA2, o3[A8 + 16 >> 2] = EA2 - (-67108864 & g6), g6 = DA(cA2, t4, C4, e4), iA2 = w3, EA2 = DA(pA2, Q4, H4, q4), iA2 = w3 + iA2 | 0, iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(E4, D4, M4, z4), EA2 = w3 + iA2 | 0, EA2 = (g6 = oA2 + g6 | 0) >>> 0 < oA2 >>> 0 ? EA2 + 1 | 0 : EA2, iA2 = DA(B4, i4, c4, u4), oA2 = w3 + EA2 | 0, oA2 = (g6 = iA2 + g6 | 0) >>> 0 < iA2 >>> 0 ? oA2 + 1 | 0 : oA2, EA2 = DA(h4, U4, p4, x4), iA2 = w3 + oA2 | 0, iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(hA2, a4, F4, v4), iA2 = w3 + iA2 | 0, iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, EA2 = DA(k4, j4, W4, O4), iA2 = w3 + iA2 | 0, iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2, oA2 = DA(eA2, n4, d4, yA2), EA2 = w3 + iA2 | 0, EA2 = (g6 = oA2 + g6 | 0) >>> 0 < oA2 >>> 0 ? EA2 + 1 | 0 : EA2, iA2 = DA(aA2, tA2, l4, X4), oA2 = w3 + EA2 | 0, oA2 = (g6 = iA2 + g6 | 0) >>> 0 < iA2 >>> 0 ? oA2 + 1 | 0 : oA2, EA2 = DA(sA2, f4, Z3, Z3 >> 31), iA2 = w3 + oA2 | 0, iA2 = (iA2 = (g6 = EA2 + g6 | 0) >>> 0 < EA2 >>> 0 ? iA2 + 1 | 0 : iA2) + (EA2 = I7 >> 26) | 0, iA2 = (I7 = (oA2 = g6) + (g6 = (67108863 & I7) << 6 | fA2 >>> 26) | 0) >>> 0 < g6 >>> 0 ? iA2 + 1 | 0 : iA2, iA2 = (I7 = (g6 = I7) + 16777216 | 0) >>> 0 < 16777216 ? iA2 + 1 | 0 : iA2, o3[A8 + 36 >> 2] = g6 - (-33554432 & I7), oA2 = rA2 - (-33554432 & UA2) | 0, EA2 = nA2 - (g6 = -67108864 & HA2) | 0, pA2 = SA2 - ((g6 >>> 0 > nA2 >>> 0) + QA2 | 0) | 0, I7 = (g6 = DA((33554431 & (g6 = iA2)) << 7 | I7 >>> 25, iA2 >>= 25, 19, 0)) + EA2 | 0, EA2 = w3 + pA2 | 0, iA2 = I7 >>> 0 < g6 >>> 0 ? EA2 + 1 | 0 : EA2, EA2 = iA2 = (67108863 & (iA2 = (I7 = (g6 = I7) + 33554432 | 0) >>> 0 < 33554432 ? iA2 + 1 | 0 : iA2)) << 6 | I7 >>> 26, iA2 = iA2 + oA2 | 0, o3[A8 + 4 >> 2] = iA2, o3[A8 >> 2] = g6 - (-67108864 & I7);
                    }
                    function l3(A8, I7) {
                      var g6, C4, B4, Q4, i4, E4, a4, n4, f4, t4, e4, c4, y4, h4, s4, p4, u4, k4, F4, l4, H4, M4, G4, U4, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0, P4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, X4 = 0, q4 = 0, z4 = 0, V4 = 0, O4 = 0, T4 = 0, W4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0, BA2 = 0, QA2 = 0, iA2 = 0, EA2 = 0, oA2 = 0, aA2 = 0, nA2 = 0, rA2 = 0;
                      D3 = g6 = D3 - 48 | 0, S3(A8, I7), S3(A8 + 80 | 0, I7 + 40 | 0), J4 = DA(x4 = (W4 = o3[I7 + 92 >> 2]) << 1, i4 = x4 >> 31, R4 = (b4 = o3[I7 + 84 >> 2]) << 1, C4 = R4 >> 31), Y4 = w3, BA2 = j4 = o3[I7 + 88 >> 2], N4 = (L4 = DA(j4, q4 = j4 >> 31, j4, q4)) + J4 | 0, J4 = w3 + Y4 | 0, J4 = N4 >>> 0 < L4 >>> 0 ? J4 + 1 | 0 : J4, Y4 = (m4 = DA(P4 = o3[I7 + 96 >> 2], E4 = P4 >> 31, L4 = (_4 = o3[I7 + 80 >> 2]) << 1, B4 = L4 >> 31)) + N4 | 0, N4 = w3 + J4 | 0, N4 = Y4 >>> 0 < m4 >>> 0 ? N4 + 1 | 0 : N4, IA2 = o3[I7 + 108 >> 2], m4 = DA(d4 = r3(IA2, 38), e4 = d4 >> 31, IA2, h4 = IA2 >> 31), J4 = w3 + N4 | 0, J4 = (Y4 = m4 + Y4 | 0) >>> 0 < m4 >>> 0 ? J4 + 1 | 0 : J4, v4 = Y4, Z3 = o3[I7 + 112 >> 2], Y4 = DA(K4 = r3(Z3, 19), a4 = K4 >> 31, N4 = (z4 = o3[I7 + 104 >> 2]) << 1, N4 >> 31), J4 = w3 + J4 | 0, J4 = (N4 = v4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? J4 + 1 | 0 : J4, iA2 = o3[I7 + 116 >> 2], Y4 = ($3 = DA(m4 = r3(iA2, 38), Q4 = m4 >> 31, X4 = (V4 = o3[I7 + 100 >> 2]) << 1, f4 = X4 >> 31)) + N4 | 0, N4 = w3 + J4 | 0, EA2 = J4 = (Y4 >>> 0 < $3 >>> 0 ? N4 + 1 | 0 : N4) << 1 | Y4 >>> 31, oA2 = Y4 = 33554432 + (s4 = Y4 << 1) | 0, aA2 = J4 = Y4 >>> 0 < 33554432 ? J4 + 1 | 0 : J4, gA2 = (67108863 & J4) << 6 | Y4 >>> 26, O4 = J4 >> 26, J4 = DA(R4, C4, P4, E4), N4 = w3, Y4 = DA(j4 <<= 1, t4 = j4 >> 31, W4, p4 = W4 >> 31), N4 = w3 + N4 | 0, N4 = (J4 = Y4 + J4 | 0) >>> 0 < Y4 >>> 0 ? N4 + 1 | 0 : N4, Y4 = ($3 = DA(V4, c4 = V4 >> 31, L4, B4)) + J4 | 0, J4 = w3 + N4 | 0, J4 = Y4 >>> 0 < $3 >>> 0 ? J4 + 1 | 0 : J4, N4 = Y4, Y4 = DA(K4, a4, $3 = IA2 << 1, u4 = $3 >> 31), J4 = w3 + J4 | 0, J4 = (N4 = N4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? J4 + 1 | 0 : J4, Y4 = DA(m4, Q4, z4, n4 = z4 >> 31), J4 = w3 + J4 | 0, J4 = (N4 = Y4 + N4 | 0) >>> 0 < Y4 >>> 0 ? J4 + 1 | 0 : J4, Y4 = gA2, gA2 = N4 << 1, N4 = (J4 << 1 | N4 >>> 31) + O4 | 0, N4 = (Y4 = Y4 + gA2 | 0) >>> 0 < gA2 >>> 0 ? N4 + 1 | 0 : N4, gA2 = Y4, nA2 = Y4 = Y4 + 16777216 | 0, v4 = (33554431 & (N4 = Y4 >>> 0 < 16777216 ? N4 + 1 | 0 : N4)) << 7 | Y4 >>> 25, O4 = N4 >> 25, J4 = DA(x4, i4, W4, p4), Y4 = w3, N4 = (T4 = DA(P4, E4, j4, t4)) + J4 | 0, J4 = w3 + Y4 | 0, J4 = N4 >>> 0 < T4 >>> 0 ? J4 + 1 | 0 : J4, Y4 = DA(R4, C4, X4, f4), J4 = w3 + J4 | 0, J4 = (N4 = Y4 + N4 | 0) >>> 0 < Y4 >>> 0 ? J4 + 1 | 0 : J4, Y4 = (T4 = DA(L4, B4, z4, n4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = Y4 >>> 0 < T4 >>> 0 ? N4 + 1 | 0 : N4, J4 = Y4, Y4 = DA(K4, a4, Z3, y4 = Z3 >> 31), N4 = w3 + N4 | 0, N4 = (J4 = J4 + Y4 | 0) >>> 0 < Y4 >>> 0 ? N4 + 1 | 0 : N4, Y4 = (T4 = DA(m4, Q4, $3, u4)) + J4 | 0, J4 = w3 + N4 | 0, N4 = (Y4 >>> 0 < T4 >>> 0 ? J4 + 1 | 0 : J4) << 1 | Y4 >>> 31, Y4 = (J4 = v4) + (v4 = Y4 << 1) | 0, J4 = N4 + O4 | 0, J4 = Y4 >>> 0 < v4 >>> 0 ? J4 + 1 | 0 : J4, O4 = Y4, T4 = N4 = Y4 + 33554432 | 0, Y4 = J4 = N4 >>> 0 < 33554432 ? J4 + 1 | 0 : J4, o3[A8 + 144 >> 2] = O4 - (-67108864 & N4), O4 = DA(J4 = r3(V4, 38), J4 >> 31, V4, c4), v4 = w3, _4 = DA(J4 = _4, N4 = J4 >> 31, J4, N4), J4 = w3 + v4 | 0, J4 = (N4 = _4 + O4 | 0) >>> 0 < _4 >>> 0 ? J4 + 1 | 0 : J4, v4 = DA(_4 = r3(z4, 19), k4 = _4 >> 31, O4 = P4 << 1, F4 = O4 >> 31), J4 = w3 + J4 | 0, J4 = (N4 = v4 + N4 | 0) >>> 0 < v4 >>> 0 ? J4 + 1 | 0 : J4, v4 = DA(x4, i4, d4, e4), J4 = w3 + J4 | 0, J4 = (N4 = v4 + N4 | 0) >>> 0 < v4 >>> 0 ? J4 + 1 | 0 : J4, v4 = (rA2 = DA(K4, a4, j4, t4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = v4 >>> 0 < rA2 >>> 0 ? N4 + 1 | 0 : N4, J4 = v4, v4 = DA(R4, C4, m4, Q4), N4 = w3 + N4 | 0, N4 = ((J4 = J4 + v4 | 0) >>> 0 < v4 >>> 0 ? N4 + 1 | 0 : N4) << 1, v4 = J4, rA2 = J4 = N4 | J4 >>> 31, M4 = v4 = 33554432 + (l4 = v4 << 1) | 0, G4 = J4 = v4 >>> 0 < 33554432 ? J4 + 1 | 0 : J4, AA2 = (67108863 & J4) << 6 | v4 >>> 26, v4 = J4 >> 26, J4 = DA(_4, k4, X4, f4), CA2 = w3, QA2 = b4, N4 = (b4 = DA(L4, B4, b4, H4 = b4 >> 31)) + J4 | 0, J4 = w3 + CA2 | 0, J4 = N4 >>> 0 < b4 >>> 0 ? J4 + 1 | 0 : J4, b4 = (CA2 = DA(P4, E4, d4, e4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = b4 >>> 0 < CA2 >>> 0 ? N4 + 1 | 0 : N4, CA2 = DA(K4, a4, x4, i4), J4 = w3 + N4 | 0, J4 = (b4 = CA2 + b4 | 0) >>> 0 < CA2 >>> 0 ? J4 + 1 | 0 : J4, N4 = b4, b4 = DA(m4, Q4, BA2, q4), J4 = w3 + J4 | 0, J4 = ((N4 = N4 + b4 | 0) >>> 0 < b4 >>> 0 ? J4 + 1 | 0 : J4) << 1, b4 = N4, N4 = (N4 = J4 | N4 >>> 31) + v4 | 0, v4 = b4 = (J4 = b4 << 1) + AA2 | 0, J4 = N4 = J4 >>> 0 > b4 >>> 0 ? N4 + 1 | 0 : N4, CA2 = b4 = b4 + 16777216 | 0, U4 = (33554431 & (J4 = b4 >>> 0 < 16777216 ? J4 + 1 | 0 : J4)) << 7 | b4 >>> 25, AA2 = J4 >> 25, J4 = DA(L4, B4, BA2, q4), b4 = w3, N4 = (QA2 = DA(R4, C4, QA2, H4)) + J4 | 0, J4 = w3 + b4 | 0, J4 = N4 >>> 0 < QA2 >>> 0 ? J4 + 1 | 0 : J4, b4 = DA(_4, k4, z4, n4), J4 = w3 + J4 | 0, J4 = (N4 = b4 + N4 | 0) >>> 0 < b4 >>> 0 ? J4 + 1 | 0 : J4, b4 = (_4 = DA(X4, f4, d4, e4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = b4 >>> 0 < _4 >>> 0 ? N4 + 1 | 0 : N4, _4 = DA(K4, a4, O4, F4), J4 = w3 + N4 | 0, J4 = (b4 = _4 + b4 | 0) >>> 0 < _4 >>> 0 ? J4 + 1 | 0 : J4, _4 = DA(m4, Q4, x4, i4), N4 = w3 + J4 | 0, J4 = (N4 = ((b4 = _4 + b4 | 0) >>> 0 < _4 >>> 0 ? N4 + 1 | 0 : N4) << 1 | b4 >>> 31) + AA2 | 0, J4 = (b4 = (_4 = b4 << 1) + U4 | 0) >>> 0 < _4 >>> 0 ? J4 + 1 | 0 : J4, _4 = b4, QA2 = N4 = b4 + 33554432 | 0, b4 = J4 = N4 >>> 0 < 33554432 ? J4 + 1 | 0 : J4, o3[A8 + 128 >> 2] = _4 - (-67108864 & N4), J4 = DA(j4, t4, V4, c4), N4 = w3, _4 = DA(P4, E4, x4, i4), N4 = w3 + N4 | 0, N4 = (J4 = _4 + J4 | 0) >>> 0 < _4 >>> 0 ? N4 + 1 | 0 : N4, _4 = (AA2 = DA(R4, C4, z4, n4)) + J4 | 0, J4 = w3 + N4 | 0, J4 = _4 >>> 0 < AA2 >>> 0 ? J4 + 1 | 0 : J4, N4 = _4, _4 = DA(L4, B4, IA2, h4), J4 = w3 + J4 | 0, J4 = (N4 = N4 + _4 | 0) >>> 0 < _4 >>> 0 ? J4 + 1 | 0 : J4, _4 = (AA2 = DA(m4, Q4, Z3, y4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = J4 = (_4 >>> 0 < AA2 >>> 0 ? N4 + 1 | 0 : N4) << 1 | _4 >>> 31, J4 = (J4 = Y4 >> 26) + N4 | 0, J4 = (Y4 = (AA2 = _4 <<= 1) + (_4 = (67108863 & Y4) << 6 | T4 >>> 26) | 0) >>> 0 < _4 >>> 0 ? J4 + 1 | 0 : J4, _4 = Y4, N4 = J4, T4 = J4 = Y4 + 16777216 | 0, Y4 = N4 = J4 >>> 0 < 16777216 ? N4 + 1 | 0 : N4, o3[A8 + 148 >> 2] = _4 - (-33554432 & J4), J4 = DA(L4, B4, W4, p4), W4 = w3, N4 = (q4 = DA(R4, C4, BA2, q4)) + J4 | 0, J4 = w3 + W4 | 0, J4 = N4 >>> 0 < q4 >>> 0 ? J4 + 1 | 0 : J4, d4 = DA(z4, n4, d4, e4), J4 = w3 + J4 | 0, J4 = (N4 = d4 + N4 | 0) >>> 0 < d4 >>> 0 ? J4 + 1 | 0 : J4, K4 = (d4 = DA(K4, a4, X4, f4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = K4 >>> 0 < d4 >>> 0 ? N4 + 1 | 0 : N4, d4 = DA(m4, Q4, P4, E4), J4 = w3 + N4 | 0, N4 = (J4 = ((K4 = d4 + K4 | 0) >>> 0 < d4 >>> 0 ? J4 + 1 | 0 : J4) << 1 | K4 >>> 31) + (N4 = b4 >> 26) | 0, N4 = (b4 = (_4 = K4 << 1) + (K4 = (67108863 & b4) << 6 | QA2 >>> 26) | 0) >>> 0 < K4 >>> 0 ? N4 + 1 | 0 : N4, K4 = b4, J4 = N4, d4 = N4 = b4 + 16777216 | 0, b4 = J4 = N4 >>> 0 < 16777216 ? J4 + 1 | 0 : J4, o3[A8 + 132 >> 2] = K4 - (-33554432 & N4), J4 = DA(z4, n4, j4, t4), K4 = w3, N4 = (P4 = DA(P4, E4, P4, E4)) + J4 | 0, J4 = w3 + K4 | 0, J4 = N4 >>> 0 < P4 >>> 0 ? J4 + 1 | 0 : J4, P4 = (K4 = DA(x4, i4, X4, f4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = P4 >>> 0 < K4 >>> 0 ? N4 + 1 | 0 : N4, K4 = DA(R4, C4, $3, u4), J4 = w3 + N4 | 0, J4 = (P4 = K4 + P4 | 0) >>> 0 < K4 >>> 0 ? J4 + 1 | 0 : J4, K4 = DA(L4, B4, Z3, y4), N4 = w3 + J4 | 0, N4 = (P4 = K4 + P4 | 0) >>> 0 < K4 >>> 0 ? N4 + 1 | 0 : N4, K4 = DA(J4 = m4, Q4, m4 = iA2, X4 = m4 >> 31), J4 = w3 + N4 | 0, J4 = (J4 = ((P4 = K4 + P4 | 0) >>> 0 < K4 >>> 0 ? J4 + 1 | 0 : J4) << 1 | P4 >>> 31) + (N4 = Y4 >> 25) | 0, J4 = (Y4 = (_4 = P4 << 1) + (P4 = (33554431 & Y4) << 7 | T4 >>> 25) | 0) >>> 0 < P4 >>> 0 ? J4 + 1 | 0 : J4, P4 = Y4, N4 = J4, K4 = J4 = Y4 + 33554432 | 0, Y4 = N4 = J4 >>> 0 < 33554432 ? N4 + 1 | 0 : N4, o3[A8 + 152 >> 2] = P4 - (-67108864 & J4), N4 = s4 - (J4 = -67108864 & oA2) | 0, q4 = EA2 - ((J4 >>> 0 > s4 >>> 0) + aA2 | 0) | 0, J4 = b4 >> 25, b4 = (d4 = (33554431 & b4) << 7 | d4 >>> 25) + N4 | 0, N4 = J4 + q4 | 0, N4 = b4 >>> 0 < d4 >>> 0 ? N4 + 1 | 0 : N4, _4 = N4 = (67108863 & (N4 = (J4 = b4 + 33554432 | 0) >>> 0 < 33554432 ? N4 + 1 | 0 : N4)) << 6 | J4 >>> 26, N4 = N4 + (P4 = gA2 - (-33554432 & nA2) | 0) | 0, o3[A8 + 140 >> 2] = N4, o3[A8 + 136 >> 2] = b4 - (-67108864 & J4), J4 = DA(x4, i4, z4, n4), N4 = w3, b4 = DA(V4, c4, O4, F4), N4 = w3 + N4 | 0, N4 = (J4 = b4 + J4 | 0) >>> 0 < b4 >>> 0 ? N4 + 1 | 0 : N4, b4 = (x4 = DA(j4, t4, IA2, h4)) + J4 | 0, J4 = w3 + N4 | 0, J4 = b4 >>> 0 < x4 >>> 0 ? J4 + 1 | 0 : J4, N4 = b4, b4 = DA(R4, C4, Z3, y4), J4 = w3 + J4 | 0, J4 = (N4 = N4 + b4 | 0) >>> 0 < b4 >>> 0 ? J4 + 1 | 0 : J4, b4 = (R4 = DA(L4, B4, m4, X4)) + N4 | 0, N4 = w3 + J4 | 0, N4 = J4 = (b4 >>> 0 < R4 >>> 0 ? N4 + 1 | 0 : N4) << 1 | b4 >>> 31, J4 = (J4 = Y4 >> 26) + N4 | 0, N4 = (Y4 = (_4 = b4 <<= 1) + (b4 = (67108863 & Y4) << 6 | K4 >>> 26) | 0) >>> 0 < b4 >>> 0 ? J4 + 1 | 0 : J4, N4 = (J4 = Y4 + 16777216 | 0) >>> 0 < 16777216 ? N4 + 1 | 0 : N4, o3[A8 + 156 >> 2] = Y4 - (-33554432 & J4), b4 = v4 - (-33554432 & CA2) | 0, R4 = l4 - (Y4 = -67108864 & M4) | 0, L4 = rA2 - ((Y4 >>> 0 > l4 >>> 0) + G4 | 0) | 0, N4 = DA((33554431 & N4) << 7 | J4 >>> 25, N4 >> 25, 19, 0), J4 = w3 + L4 | 0, N4 = N4 >>> 0 > (Y4 = N4 + R4 | 0) >>> 0 ? J4 + 1 | 0 : J4, _4 = N4 = (67108863 & (N4 = (J4 = Y4 + 33554432 | 0) >>> 0 < 33554432 ? N4 + 1 | 0 : N4)) << 6 | J4 >>> 26, N4 = N4 + b4 | 0, o3[A8 + 124 >> 2] = N4, o3[A8 + 120 >> 2] = Y4 - (-67108864 & J4), J4 = o3[I7 + 40 >> 2], N4 = o3[I7 + 44 >> 2], Y4 = o3[I7 + 4 >> 2], b4 = o3[I7 + 48 >> 2], R4 = o3[I7 + 8 >> 2], L4 = o3[I7 + 52 >> 2], m4 = o3[I7 + 12 >> 2], x4 = o3[I7 + 56 >> 2], P4 = o3[I7 + 16 >> 2], K4 = o3[I7 + 60 >> 2], z4 = o3[I7 + 20 >> 2], X4 = o3[I7 - -64 >> 2], j4 = o3[I7 + 24 >> 2], d4 = o3[I7 + 68 >> 2], q4 = o3[I7 + 28 >> 2], V4 = o3[I7 + 72 >> 2], Z3 = o3[I7 + 32 >> 2], BA2 = o3[I7 >> 2], o3[A8 + 76 >> 2] = o3[I7 + 76 >> 2] + o3[I7 + 36 >> 2], o3[A8 + 72 >> 2] = V4 + Z3, o3[A8 + 68 >> 2] = d4 + q4, o3[(IA2 = A8 - -64 | 0) >> 2] = j4 + X4, o3[A8 + 60 >> 2] = K4 + z4, o3[A8 + 56 >> 2] = P4 + x4, o3[A8 + 52 >> 2] = m4 + L4, o3[A8 + 48 >> 2] = b4 + R4, o3[A8 + 44 >> 2] = N4 + Y4, o3[(I7 = A8 + 40 | 0) >> 2] = J4 + BA2, S3(g6, I7), J4 = o3[A8 + 80 >> 2], N4 = o3[A8 + 4 >> 2], Y4 = o3[A8 + 84 >> 2], b4 = o3[A8 + 8 >> 2], R4 = o3[A8 + 88 >> 2], L4 = o3[A8 + 12 >> 2], m4 = o3[A8 + 92 >> 2], x4 = o3[A8 + 16 >> 2], P4 = o3[A8 + 96 >> 2], K4 = o3[A8 + 20 >> 2], z4 = o3[A8 + 100 >> 2], X4 = o3[A8 + 24 >> 2], j4 = o3[A8 + 104 >> 2], d4 = o3[A8 + 28 >> 2], q4 = o3[A8 + 108 >> 2], V4 = o3[A8 + 32 >> 2], Z3 = o3[A8 + 112 >> 2], BA2 = o3[A8 >> 2], _4 = (W4 = o3[A8 + 116 >> 2]) - ($3 = o3[A8 + 36 >> 2]) | 0, o3[A8 + 116 >> 2] = _4, O4 = Z3 - V4 | 0, o3[A8 + 112 >> 2] = O4, gA2 = q4 - d4 | 0, o3[A8 + 108 >> 2] = gA2, v4 = j4 - X4 | 0, o3[A8 + 104 >> 2] = v4, iA2 = z4 - K4 | 0, o3[A8 + 100 >> 2] = iA2, EA2 = P4 - x4 | 0, o3[A8 + 96 >> 2] = EA2, oA2 = m4 - L4 | 0, o3[A8 + 92 >> 2] = oA2, aA2 = R4 - b4 | 0, o3[A8 + 88 >> 2] = aA2, T4 = Y4 - N4 | 0, o3[A8 + 84 >> 2] = T4, nA2 = J4 - BA2 | 0, o3[A8 + 80 >> 2] = nA2, W4 = W4 + $3 | 0, o3[A8 + 76 >> 2] = W4, V4 = V4 + Z3 | 0, o3[A8 + 72 >> 2] = V4, d4 = d4 + q4 | 0, o3[A8 + 68 >> 2] = d4, X4 = j4 + X4 | 0, o3[IA2 >> 2] = X4, K4 = K4 + z4 | 0, o3[A8 + 60 >> 2] = K4, x4 = P4 + x4 | 0, o3[A8 + 56 >> 2] = x4, L4 = m4 + L4 | 0, o3[A8 + 52 >> 2] = L4, b4 = b4 + R4 | 0, o3[A8 + 48 >> 2] = b4, N4 = N4 + Y4 | 0, o3[A8 + 44 >> 2] = N4, Y4 = I7, I7 = J4 + BA2 | 0, o3[Y4 >> 2] = I7, J4 = o3[g6 >> 2], Y4 = o3[g6 + 4 >> 2], R4 = o3[g6 + 8 >> 2], m4 = o3[g6 + 12 >> 2], P4 = o3[g6 + 16 >> 2], z4 = o3[g6 + 20 >> 2], j4 = o3[g6 + 24 >> 2], q4 = o3[g6 + 28 >> 2], Z3 = o3[g6 + 32 >> 2], o3[A8 + 36 >> 2] = o3[g6 + 36 >> 2] - W4, o3[A8 + 32 >> 2] = Z3 - V4, o3[A8 + 28 >> 2] = q4 - d4, o3[A8 + 24 >> 2] = j4 - X4, o3[A8 + 20 >> 2] = z4 - K4, o3[A8 + 16 >> 2] = P4 - x4, o3[A8 + 12 >> 2] = m4 - L4, o3[A8 + 8 >> 2] = R4 - b4, o3[A8 + 4 >> 2] = Y4 - N4, o3[A8 >> 2] = J4 - I7, I7 = o3[A8 + 120 >> 2], J4 = o3[A8 + 124 >> 2], N4 = o3[A8 + 128 >> 2], Y4 = o3[A8 + 132 >> 2], b4 = o3[A8 + 136 >> 2], R4 = o3[A8 + 140 >> 2], L4 = o3[A8 + 144 >> 2], m4 = o3[A8 + 148 >> 2], x4 = o3[A8 + 152 >> 2], o3[A8 + 156 >> 2] = o3[A8 + 156 >> 2] - _4, o3[A8 + 152 >> 2] = x4 - O4, o3[A8 + 148 >> 2] = m4 - gA2, o3[A8 + 144 >> 2] = L4 - v4, o3[A8 + 140 >> 2] = R4 - iA2, o3[A8 + 136 >> 2] = b4 - EA2, o3[A8 + 132 >> 2] = Y4 - oA2, o3[A8 + 128 >> 2] = N4 - aA2, o3[A8 + 124 >> 2] = J4 - T4, o3[A8 + 120 >> 2] = I7 - nA2, D3 = g6 + 48 | 0;
                    }
                    function S3(A8, I7) {
                      var g6, C4, B4, Q4, i4, E4, a4, n4, f4, t4, e4, c4, y4, D4, h4, s4, p4, u4, k4, F4, l4, S4, H4, M4, G4, U4, J4, N4, Y4, b4, _4, K4, P4, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, X4 = 0, q4 = 0, z4 = 0, V4 = 0, O4 = 0, T4 = 0, W4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0, BA2 = 0, QA2 = 0;
                      v4 = DA(C4 = (s4 = o3[I7 + 12 >> 2]) << 1, E4 = C4 >> 31, s4, l4 = s4 >> 31), d4 = w3, m4 = (q4 = DA(R4 = o3[I7 + 16 >> 2], a4 = R4 >> 31, n4 = (L4 = o3[I7 + 8 >> 2]) << 1, c4 = n4 >> 31)) + v4 | 0, v4 = w3 + d4 | 0, v4 = m4 >>> 0 < q4 >>> 0 ? v4 + 1 | 0 : v4, d4 = (z4 = DA(T4 = (f4 = o3[I7 + 20 >> 2]) << 1, y4 = T4 >> 31, q4 = (x4 = o3[I7 + 4 >> 2]) << 1, B4 = q4 >> 31)) + m4 | 0, m4 = w3 + v4 | 0, m4 = d4 >>> 0 < z4 >>> 0 ? m4 + 1 | 0 : m4, j4 = DA(g6 = o3[I7 + 24 >> 2], t4 = g6 >> 31, z4 = ($3 = o3[I7 >> 2]) << 1, Q4 = z4 >> 31), v4 = w3 + m4 | 0, v4 = (d4 = j4 + d4 | 0) >>> 0 < j4 >>> 0 ? v4 + 1 | 0 : v4, m4 = d4, D4 = o3[I7 + 32 >> 2], d4 = DA(V4 = r3(D4, 19), e4 = V4 >> 31, D4, u4 = D4 >> 31), v4 = w3 + v4 | 0, v4 = (m4 = m4 + d4 | 0) >>> 0 < d4 >>> 0 ? v4 + 1 | 0 : v4, U4 = o3[I7 + 36 >> 2], d4 = DA(j4 = r3(U4, 38), i4 = j4 >> 31, k4 = (h4 = o3[I7 + 28 >> 2]) << 1, S4 = k4 >> 31), I7 = w3 + v4 | 0, Z3 = m4 = d4 + m4 | 0, d4 = m4 >>> 0 < d4 >>> 0 ? I7 + 1 | 0 : I7, I7 = DA(q4, B4, R4, a4), v4 = w3, m4 = DA(n4, c4, s4, l4), v4 = w3 + v4 | 0, v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, X4 = DA(f4, F4 = f4 >> 31, z4, Q4), m4 = w3 + v4 | 0, m4 = (I7 = X4 + I7 | 0) >>> 0 < X4 >>> 0 ? m4 + 1 | 0 : m4, X4 = DA(V4, e4, k4, S4), v4 = w3 + m4 | 0, v4 = (I7 = X4 + I7 | 0) >>> 0 < X4 >>> 0 ? v4 + 1 | 0 : v4, m4 = DA(j4, i4, g6, t4), v4 = w3 + v4 | 0, BA2 = I7 = m4 + I7 | 0, O4 = I7 >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, v4 = DA(q4, B4, C4, E4), m4 = w3, H4 = I7 = L4, L4 = DA(I7, W4 = I7 >> 31, I7, W4), I7 = w3 + m4 | 0, I7 = (v4 = L4 + v4 | 0) >>> 0 < L4 >>> 0 ? I7 + 1 | 0 : I7, m4 = (L4 = DA(z4, Q4, R4, a4)) + v4 | 0, v4 = w3 + I7 | 0, v4 = m4 >>> 0 < L4 >>> 0 ? v4 + 1 | 0 : v4, I7 = (L4 = DA(X4 = r3(h4, 38), p4 = X4 >> 31, h4, M4 = h4 >> 31)) + m4 | 0, m4 = w3 + v4 | 0, m4 = I7 >>> 0 < L4 >>> 0 ? m4 + 1 | 0 : m4, I7 = (v4 = I7) + (L4 = DA(V4, e4, I7 = g6 << 1, I7 >> 31)) | 0, v4 = w3 + m4 | 0, v4 = I7 >>> 0 < L4 >>> 0 ? v4 + 1 | 0 : v4, m4 = I7, I7 = DA(j4, i4, T4, y4), v4 = w3 + v4 | 0, J4 = m4 = m4 + I7 | 0, N4 = v4 = I7 >>> 0 > m4 >>> 0 ? v4 + 1 | 0 : v4, I7 = v4, Y4 = m4 = m4 + 33554432 | 0, b4 = I7 = m4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, v4 = (v4 = I7 >> 26) + O4 | 0, BA2 = I7 = (m4 = (67108863 & I7) << 6 | m4 >>> 26) + BA2 | 0, v4 = I7 >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, _4 = I7 = I7 + 16777216 | 0, v4 = (v4 = (m4 = I7 >>> 0 < 16777216 ? v4 + 1 | 0 : v4) >> 25) + d4 | 0, I7 = (I7 = (33554431 & m4) << 7 | I7 >>> 25) >>> 0 > (m4 = I7 + Z3 | 0) >>> 0 ? v4 + 1 | 0 : v4, Z3 = v4 = m4 + 33554432 | 0, L4 = I7 = v4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, o3[A8 + 24 >> 2] = m4 - (-67108864 & v4), I7 = DA(z4, Q4, H4, W4), v4 = w3, d4 = DA(q4, B4, x4, CA2 = x4 >> 31), m4 = w3 + v4 | 0, m4 = (I7 = d4 + I7 | 0) >>> 0 < d4 >>> 0 ? m4 + 1 | 0 : m4, O4 = DA(d4 = r3(g6, 19), gA2 = d4 >> 31, g6, t4), v4 = w3 + m4 | 0, v4 = (I7 = O4 + I7 | 0) >>> 0 < O4 >>> 0 ? v4 + 1 | 0 : v4, m4 = (O4 = DA(T4, y4, X4, p4)) + I7 | 0, I7 = w3 + v4 | 0, I7 = m4 >>> 0 < O4 >>> 0 ? I7 + 1 | 0 : I7, AA2 = DA(V4, e4, O4 = R4 << 1, G4 = O4 >> 31), v4 = w3 + I7 | 0, v4 = (m4 = AA2 + m4 | 0) >>> 0 < AA2 >>> 0 ? v4 + 1 | 0 : v4, I7 = m4, m4 = DA(j4, i4, C4, E4), v4 = w3 + v4 | 0, IA2 = I7 = I7 + m4 | 0, AA2 = I7 >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, I7 = DA(T4, y4, d4, gA2), v4 = w3, x4 = DA(z4, Q4, x4, CA2), m4 = w3 + v4 | 0, m4 = (I7 = x4 + I7 | 0) >>> 0 < x4 >>> 0 ? m4 + 1 | 0 : m4, x4 = DA(R4, a4, X4, p4), v4 = w3 + m4 | 0, v4 = (I7 = x4 + I7 | 0) >>> 0 < x4 >>> 0 ? v4 + 1 | 0 : v4, m4 = (x4 = DA(V4, e4, C4, E4)) + I7 | 0, I7 = w3 + v4 | 0, I7 = m4 >>> 0 < x4 >>> 0 ? I7 + 1 | 0 : I7, x4 = DA(j4, i4, H4, W4), v4 = w3 + I7 | 0, QA2 = m4 = x4 + m4 | 0, CA2 = m4 >>> 0 < x4 >>> 0 ? v4 + 1 | 0 : v4, m4 = DA(I7 = r3(f4, 38), I7 >> 31, f4, F4), x4 = w3, I7 = $3, $3 = m4, m4 = DA(I7, v4 = I7 >> 31, I7, v4), v4 = w3 + x4 | 0, v4 = (I7 = $3 + m4 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, d4 = DA(d4, gA2, O4, G4), m4 = w3 + v4 | 0, m4 = (I7 = d4 + I7 | 0) >>> 0 < d4 >>> 0 ? m4 + 1 | 0 : m4, d4 = DA(C4, E4, X4, p4), v4 = w3 + m4 | 0, v4 = (I7 = d4 + I7 | 0) >>> 0 < d4 >>> 0 ? v4 + 1 | 0 : v4, m4 = (d4 = DA(V4, e4, n4, c4)) + I7 | 0, I7 = w3 + v4 | 0, I7 = m4 >>> 0 < d4 >>> 0 ? I7 + 1 | 0 : I7, d4 = DA(q4, B4, j4, i4), v4 = w3 + I7 | 0, x4 = m4 = d4 + m4 | 0, gA2 = v4 = m4 >>> 0 < d4 >>> 0 ? v4 + 1 | 0 : v4, K4 = m4 = m4 + 33554432 | 0, P4 = v4 = m4 >>> 0 < 33554432 ? v4 + 1 | 0 : v4, I7 = v4 >> 26, v4 = (67108863 & v4) << 6 | m4 >>> 26, m4 = I7 + CA2 | 0, $3 = d4 = v4 + QA2 | 0, v4 = m4 = v4 >>> 0 > d4 >>> 0 ? m4 + 1 | 0 : m4, QA2 = m4 = d4 + 16777216 | 0, d4 = (33554431 & (v4 = m4 >>> 0 < 16777216 ? v4 + 1 | 0 : v4)) << 7 | m4 >>> 25, v4 = (v4 >> 25) + AA2 | 0, v4 = (m4 = d4 + IA2 | 0) >>> 0 < d4 >>> 0 ? v4 + 1 | 0 : v4, AA2 = I7 = m4 + 33554432 | 0, d4 = v4 = I7 >>> 0 < 33554432 ? v4 + 1 | 0 : v4, o3[A8 + 8 >> 2] = m4 - (-67108864 & I7), I7 = DA(n4, c4, f4, F4), v4 = w3, m4 = DA(R4, a4, C4, E4), v4 = w3 + v4 | 0, v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, m4 = DA(q4, B4, g6, t4), v4 = w3 + v4 | 0, v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, m4 = DA(z4, Q4, h4, M4), v4 = w3 + v4 | 0, v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, IA2 = (m4 = DA(j4, i4, D4, u4)) + I7 | 0, I7 = w3 + v4 | 0, m4 = (v4 = L4 >> 26) + (m4 = m4 >>> 0 > IA2 >>> 0 ? I7 + 1 | 0 : I7) | 0, Z3 = I7 = (L4 = (67108863 & L4) << 6 | Z3 >>> 26) + IA2 | 0, v4 = I7 >>> 0 < L4 >>> 0 ? m4 + 1 | 0 : m4, IA2 = I7 = I7 + 16777216 | 0, L4 = v4 = I7 >>> 0 < 16777216 ? v4 + 1 | 0 : v4, o3[A8 + 28 >> 2] = Z3 - (-33554432 & I7), I7 = DA(z4, Q4, s4, l4), m4 = w3, v4 = (W4 = DA(q4, B4, H4, W4)) + I7 | 0, I7 = w3 + m4 | 0, I7 = v4 >>> 0 < W4 >>> 0 ? I7 + 1 | 0 : I7, v4 = (X4 = DA(g6, t4, X4, p4)) + v4 | 0, m4 = w3 + I7 | 0, I7 = (V4 = DA(V4, e4, T4, y4)) + v4 | 0, v4 = w3 + (v4 >>> 0 < X4 >>> 0 ? m4 + 1 | 0 : m4) | 0, v4 = I7 >>> 0 < V4 >>> 0 ? v4 + 1 | 0 : v4, m4 = DA(j4, i4, R4, a4), v4 = w3 + v4 | 0, v4 = (v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4) + (m4 = d4 >> 26) | 0, I7 = (m4 = d4 = (Z3 = I7) + (I7 = (67108863 & d4) << 6 | AA2 >>> 26) | 0) >>> 0 < I7 >>> 0 ? v4 + 1 | 0 : v4, V4 = v4 = m4 + 16777216 | 0, d4 = I7 = v4 >>> 0 < 16777216 ? I7 + 1 | 0 : I7, o3[A8 + 12 >> 2] = m4 - (-33554432 & v4), I7 = DA(g6, t4, n4, c4), v4 = w3, m4 = DA(R4, a4, R4, a4), v4 = w3 + v4 | 0, v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, m4 = DA(C4, E4, T4, y4), v4 = w3 + v4 | 0, v4 = (I7 = m4 + I7 | 0) >>> 0 < m4 >>> 0 ? v4 + 1 | 0 : v4, m4 = (R4 = DA(q4, B4, k4, S4)) + I7 | 0, I7 = w3 + v4 | 0, I7 = m4 >>> 0 < R4 >>> 0 ? I7 + 1 | 0 : I7, v4 = (R4 = DA(z4, Q4, D4, u4)) + m4 | 0, m4 = w3 + I7 | 0, m4 = v4 >>> 0 < R4 >>> 0 ? m4 + 1 | 0 : m4, I7 = (R4 = DA(I7 = j4, i4, j4 = U4, T4 = j4 >> 31)) + v4 | 0, v4 = w3 + m4 | 0, v4 = I7 >>> 0 < R4 >>> 0 ? v4 + 1 | 0 : v4, m4 = I7, v4 = (I7 = L4 >> 25) + v4 | 0, v4 = (m4 = m4 + (L4 = (33554431 & L4) << 7 | IA2 >>> 25) | 0) >>> 0 < L4 >>> 0 ? v4 + 1 | 0 : v4, R4 = I7 = m4 + 33554432 | 0, L4 = v4 = I7 >>> 0 < 33554432 ? v4 + 1 | 0 : v4, o3[A8 + 32 >> 2] = m4 - (-67108864 & I7), v4 = d4 >> 25, m4 = (d4 = (33554431 & d4) << 7 | V4 >>> 25) + (J4 - (I7 = -67108864 & Y4) | 0) | 0, I7 = v4 + (N4 - ((I7 >>> 0 > J4 >>> 0) + b4 | 0) | 0) | 0, v4 = m4 >>> 0 < d4 >>> 0 ? I7 + 1 | 0 : I7, d4 = v4 = (67108863 & (v4 = (I7 = m4 + 33554432 | 0) >>> 0 < 33554432 ? v4 + 1 | 0 : v4)) << 6 | I7 >>> 26, v4 = v4 + (X4 = BA2 - (-33554432 & _4) | 0) | 0, o3[A8 + 20 >> 2] = v4, o3[A8 + 16 >> 2] = m4 - (-67108864 & I7), I7 = DA(C4, E4, g6, t4), m4 = w3, v4 = (d4 = DA(f4, F4, O4, G4)) + I7 | 0, I7 = w3 + m4 | 0, I7 = v4 >>> 0 < d4 >>> 0 ? I7 + 1 | 0 : I7, m4 = (d4 = DA(n4, c4, h4, M4)) + v4 | 0, v4 = w3 + I7 | 0, v4 = m4 >>> 0 < d4 >>> 0 ? v4 + 1 | 0 : v4, I7 = (d4 = DA(q4, B4, D4, u4)) + m4 | 0, m4 = w3 + v4 | 0, m4 = I7 >>> 0 < d4 >>> 0 ? m4 + 1 | 0 : m4, d4 = (v4 = I7) + (I7 = DA(z4, Q4, j4, T4)) | 0, v4 = w3 + m4 | 0, v4 = (I7 = I7 >>> 0 > d4 >>> 0 ? v4 + 1 | 0 : v4) + (v4 = L4 >> 26) | 0, I7 = (m4 = (L4 = (67108863 & L4) << 6 | R4 >>> 26) + d4 | 0) >>> 0 < L4 >>> 0 ? v4 + 1 | 0 : v4, I7 = (v4 = m4 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7, o3[A8 + 36 >> 2] = m4 - (-33554432 & v4), L4 = $3 - (-33554432 & QA2) | 0, d4 = x4 - (m4 = -67108864 & K4) | 0, q4 = gA2 - ((m4 >>> 0 > x4 >>> 0) + P4 | 0) | 0, I7 = DA((33554431 & I7) << 7 | v4 >>> 25, I7 >> 25, 19, 0), v4 = w3 + q4 | 0, I7 = I7 >>> 0 > (m4 = I7 + d4 | 0) >>> 0 ? v4 + 1 | 0 : v4, d4 = I7 = (67108863 & (I7 = (v4 = m4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7)) << 6 | v4 >>> 26, I7 = I7 + L4 | 0, o3[A8 + 4 >> 2] = I7, o3[A8 >> 2] = m4 - (-67108864 & v4);
                    }
                    function H3(A8, I7, g6, C4, B4) {
                      var Q4, i4, n4, r4, f4, t4, e4, c4, y4, w4, h4, s4, p4, u4, k4, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0, P4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, X4 = 0, q4 = 0, z4 = 0, V4 = 0, O4 = 0, T4 = 0, W4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0;
                      for (Q4 = D3 + -64 | 0, i4 = o3[A8 + 60 >> 2], n4 = o3[A8 + 56 >> 2], x4 = o3[A8 + 52 >> 2], R4 = o3[A8 + 48 >> 2], r4 = o3[A8 + 44 >> 2], f4 = o3[A8 + 40 >> 2], t4 = o3[A8 + 36 >> 2], e4 = o3[A8 + 32 >> 2], c4 = o3[A8 + 28 >> 2], y4 = o3[A8 + 24 >> 2], w4 = o3[A8 + 20 >> 2], h4 = o3[A8 + 16 >> 2], s4 = o3[A8 + 12 >> 2], p4 = o3[A8 + 8 >> 2], u4 = o3[A8 + 4 >> 2], k4 = o3[A8 >> 2]; ; ) {
                        if (!B4 & C4 >>> 0 > 63 | B4)
                          F4 = g6;
                        else {
                          if (o3[Q4 + 56 >> 2] = 0, o3[Q4 + 60 >> 2] = 0, o3[Q4 + 48 >> 2] = 0, o3[Q4 + 52 >> 2] = 0, o3[Q4 + 40 >> 2] = 0, o3[Q4 + 44 >> 2] = 0, o3[Q4 + 32 >> 2] = 0, o3[Q4 + 36 >> 2] = 0, o3[Q4 + 24 >> 2] = 0, o3[Q4 + 28 >> 2] = 0, o3[Q4 + 16 >> 2] = 0, o3[Q4 + 20 >> 2] = 0, o3[Q4 + 8 >> 2] = 0, o3[Q4 + 12 >> 2] = 0, o3[Q4 >> 2] = 0, o3[Q4 + 4 >> 2] = 0, S4 = 0, C4 | B4)
                            for (; E3[S4 + Q4 | 0] = a3[I7 + S4 | 0], !B4 & (S4 = S4 + 1 | 0) >>> 0 < C4 >>> 0 | B4; )
                              ;
                          I7 = F4 = Q4, V4 = g6;
                        }
                        for (j4 = 20, l4 = k4, Y4 = u4, b4 = p4, P4 = s4, S4 = h4, g6 = w4, M4 = y4, G4 = c4, U4 = e4, m4 = t4, _4 = f4, H4 = i4, d4 = n4, v4 = x4, K4 = R4, J4 = r4; N4 = S4, l4 = YA((S4 = l4 + S4 | 0) ^ K4, 16), N4 = K4 = YA(N4 ^ (U4 = l4 + U4 | 0), 12), K4 = YA((L4 = S4 + K4 | 0) ^ l4, 8), S4 = YA(N4 ^ (U4 = K4 + U4 | 0), 7), H4 = YA((l4 = G4 + P4 | 0) ^ H4, 16), G4 = YA((J4 = H4 + J4 | 0) ^ G4, 12), P4 = YA((b4 = M4 + b4 | 0) ^ d4, 16), M4 = YA((_4 = P4 + _4 | 0) ^ M4, 12), d4 = (X4 = l4 + G4 | 0) + S4 | 0, q4 = YA((b4 = M4 + b4 | 0) ^ P4, 8), l4 = YA(d4 ^ q4, 16), P4 = YA((Y4 = g6 + Y4 | 0) ^ v4, 16), g6 = YA((m4 = P4 + m4 | 0) ^ g6, 12), N4 = S4, v4 = YA((Y4 = g6 + Y4 | 0) ^ P4, 8), N4 = YA(N4 ^ (S4 = (z4 = v4 + m4 | 0) + l4 | 0), 12), d4 = YA(l4 ^ (P4 = N4 + d4 | 0), 8), S4 = YA((m4 = d4 + S4 | 0) ^ N4, 7), N4 = U4, U4 = b4, l4 = YA(H4 ^ X4, 8), b4 = YA((H4 = l4 + J4 | 0) ^ G4, 7), v4 = YA((U4 = U4 + b4 | 0) ^ v4, 16), J4 = YA((G4 = N4 + v4 | 0) ^ b4, 12), v4 = YA(v4 ^ (b4 = J4 + U4 | 0), 8), G4 = YA((U4 = G4 + v4 | 0) ^ J4, 7), J4 = H4, H4 = Y4, Y4 = YA((_4 = _4 + q4 | 0) ^ M4, 7), M4 = J4 + (K4 = YA((H4 = H4 + Y4 | 0) ^ K4, 16)) | 0, J4 = H4, H4 = YA(M4 ^ Y4, 12), K4 = YA(K4 ^ (Y4 = J4 + H4 | 0), 8), M4 = YA((J4 = M4 + K4 | 0) ^ H4, 7), N4 = _4, H4 = l4, l4 = YA(g6 ^ z4, 7), H4 = YA(H4 ^ (_4 = l4 + L4 | 0), 16), L4 = YA((g6 = N4 + H4 | 0) ^ l4, 12), H4 = YA(H4 ^ (l4 = L4 + _4 | 0), 8), g6 = YA((_4 = g6 + H4 | 0) ^ L4, 7), j4 = j4 - 2 | 0; )
                          ;
                        if (j4 = a3[I7 + 4 | 0] | a3[I7 + 5 | 0] << 8 | a3[I7 + 6 | 0] << 16 | a3[I7 + 7 | 0] << 24, L4 = a3[I7 + 8 | 0] | a3[I7 + 9 | 0] << 8 | a3[I7 + 10 | 0] << 16 | a3[I7 + 11 | 0] << 24, X4 = a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24, q4 = a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24, z4 = a3[I7 + 20 | 0] | a3[I7 + 21 | 0] << 8 | a3[I7 + 22 | 0] << 16 | a3[I7 + 23 | 0] << 24, N4 = a3[I7 + 24 | 0] | a3[I7 + 25 | 0] << 8 | a3[I7 + 26 | 0] << 16 | a3[I7 + 27 | 0] << 24, O4 = a3[I7 + 28 | 0] | a3[I7 + 29 | 0] << 8 | a3[I7 + 30 | 0] << 16 | a3[I7 + 31 | 0] << 24, T4 = a3[I7 + 32 | 0] | a3[I7 + 33 | 0] << 8 | a3[I7 + 34 | 0] << 16 | a3[I7 + 35 | 0] << 24, W4 = a3[I7 + 36 | 0] | a3[I7 + 37 | 0] << 8 | a3[I7 + 38 | 0] << 16 | a3[I7 + 39 | 0] << 24, Z3 = a3[I7 + 40 | 0] | a3[I7 + 41 | 0] << 8 | a3[I7 + 42 | 0] << 16 | a3[I7 + 43 | 0] << 24, $3 = a3[I7 + 44 | 0] | a3[I7 + 45 | 0] << 8 | a3[I7 + 46 | 0] << 16 | a3[I7 + 47 | 0] << 24, AA2 = a3[I7 + 48 | 0] | a3[I7 + 49 | 0] << 8 | a3[I7 + 50 | 0] << 16 | a3[I7 + 51 | 0] << 24, IA2 = a3[I7 + 52 | 0] | a3[I7 + 53 | 0] << 8 | a3[I7 + 54 | 0] << 16 | a3[I7 + 55 | 0] << 24, gA2 = a3[I7 + 56 | 0] | a3[I7 + 57 | 0] << 8 | a3[I7 + 58 | 0] << 16 | a3[I7 + 59 | 0] << 24, CA2 = a3[I7 + 60 | 0] | a3[I7 + 61 | 0] << 8 | a3[I7 + 62 | 0] << 16 | a3[I7 + 63 | 0] << 24, l4 = l4 + k4 ^ (a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24), E3[0 | F4] = l4, E3[F4 + 1 | 0] = l4 >>> 8, E3[F4 + 2 | 0] = l4 >>> 16, E3[F4 + 3 | 0] = l4 >>> 24, l4 = H4 + i4 ^ CA2, E3[F4 + 60 | 0] = l4, E3[F4 + 61 | 0] = l4 >>> 8, E3[F4 + 62 | 0] = l4 >>> 16, E3[F4 + 63 | 0] = l4 >>> 24, l4 = d4 + n4 ^ gA2, E3[F4 + 56 | 0] = l4, E3[F4 + 57 | 0] = l4 >>> 8, E3[F4 + 58 | 0] = l4 >>> 16, E3[F4 + 59 | 0] = l4 >>> 24, l4 = v4 + x4 ^ IA2, E3[F4 + 52 | 0] = l4, E3[F4 + 53 | 0] = l4 >>> 8, E3[F4 + 54 | 0] = l4 >>> 16, E3[F4 + 55 | 0] = l4 >>> 24, l4 = K4 + R4 ^ AA2, E3[F4 + 48 | 0] = l4, E3[F4 + 49 | 0] = l4 >>> 8, E3[F4 + 50 | 0] = l4 >>> 16, E3[F4 + 51 | 0] = l4 >>> 24, l4 = J4 + r4 ^ $3, E3[F4 + 44 | 0] = l4, E3[F4 + 45 | 0] = l4 >>> 8, E3[F4 + 46 | 0] = l4 >>> 16, E3[F4 + 47 | 0] = l4 >>> 24, l4 = _4 + f4 ^ Z3, E3[F4 + 40 | 0] = l4, E3[F4 + 41 | 0] = l4 >>> 8, E3[F4 + 42 | 0] = l4 >>> 16, E3[F4 + 43 | 0] = l4 >>> 24, l4 = m4 + t4 ^ W4, E3[F4 + 36 | 0] = l4, E3[F4 + 37 | 0] = l4 >>> 8, E3[F4 + 38 | 0] = l4 >>> 16, E3[F4 + 39 | 0] = l4 >>> 24, l4 = U4 + e4 ^ T4, E3[F4 + 32 | 0] = l4, E3[F4 + 33 | 0] = l4 >>> 8, E3[F4 + 34 | 0] = l4 >>> 16, E3[F4 + 35 | 0] = l4 >>> 24, G4 = G4 + c4 ^ O4, E3[F4 + 28 | 0] = G4, E3[F4 + 29 | 0] = G4 >>> 8, E3[F4 + 30 | 0] = G4 >>> 16, E3[F4 + 31 | 0] = G4 >>> 24, M4 = N4 ^ M4 + y4, E3[F4 + 24 | 0] = M4, E3[F4 + 25 | 0] = M4 >>> 8, E3[F4 + 26 | 0] = M4 >>> 16, E3[F4 + 27 | 0] = M4 >>> 24, g6 = z4 ^ g6 + w4, E3[F4 + 20 | 0] = g6, E3[F4 + 21 | 0] = g6 >>> 8, E3[F4 + 22 | 0] = g6 >>> 16, E3[F4 + 23 | 0] = g6 >>> 24, g6 = q4 ^ S4 + h4, E3[F4 + 16 | 0] = g6, E3[F4 + 17 | 0] = g6 >>> 8, E3[F4 + 18 | 0] = g6 >>> 16, E3[F4 + 19 | 0] = g6 >>> 24, g6 = X4 ^ P4 + s4, E3[F4 + 12 | 0] = g6, E3[F4 + 13 | 0] = g6 >>> 8, E3[F4 + 14 | 0] = g6 >>> 16, E3[F4 + 15 | 0] = g6 >>> 24, g6 = L4 ^ b4 + p4, E3[F4 + 8 | 0] = g6, E3[F4 + 9 | 0] = g6 >>> 8, E3[F4 + 10 | 0] = g6 >>> 16, E3[F4 + 11 | 0] = g6 >>> 24, g6 = j4 ^ Y4 + u4, E3[F4 + 4 | 0] = g6, E3[F4 + 5 | 0] = g6 >>> 8, E3[F4 + 6 | 0] = g6 >>> 16, E3[F4 + 7 | 0] = g6 >>> 24, x4 = !(R4 = R4 + 1 | 0) + x4 | 0, !B4 & C4 >>> 0 <= 64) {
                          if (!(!C4 | !B4 & C4 >>> 0 > 63 | 0 != (0 | B4)))
                            for (S4 = 0; E3[S4 + V4 | 0] = a3[F4 + S4 | 0], C4 >>> 0 > (S4 = S4 + 1 | 0) >>> 0; )
                              ;
                          o3[A8 + 52 >> 2] = x4, o3[A8 + 48 >> 2] = R4;
                          break;
                        }
                        I7 = I7 - -64 | 0, g6 = F4 - -64 | 0, B4 = B4 - 1 | 0, B4 = (C4 = C4 + -64 | 0) >>> 0 < 4294967232 ? B4 + 1 | 0 : B4;
                      }
                    }
                    function M3(A8, I7) {
                      var g6, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, a4 = 0, n4 = 0, r4 = 0;
                      D3 = g6 = D3 - 704 | 0, C4 = 80 + ((B4 = o3[A8 + 72 >> 2] >>> 3 & 127) + A8 | 0) | 0, B4 >>> 0 <= 111 ? HA(C4, 34640, 112 - B4 | 0) : (HA(C4, 34640, 128 - B4 | 0), p3(A8, B4 = A8 + 80 | 0, g6, g6 + 640 | 0), MA(B4, 0, 112)), n4 = (Q4 = o3[A8 + 64 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 68 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[A8 + 192 | 0] = C4, E3[A8 + 193 | 0] = C4 >>> 8, E3[A8 + 194 | 0] = C4 >>> 16, E3[A8 + 195 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[A8 + 196 | 0] = B4, E3[A8 + 197 | 0] = B4 >>> 8, E3[A8 + 198 | 0] = B4 >>> 16, E3[A8 + 199 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 72 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 76 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[A8 + 200 | 0] = C4, E3[A8 + 201 | 0] = C4 >>> 8, E3[A8 + 202 | 0] = C4 >>> 16, E3[A8 + 203 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[A8 + 204 | 0] = B4, E3[A8 + 205 | 0] = B4 >>> 8, E3[A8 + 206 | 0] = B4 >>> 16, E3[A8 + 207 | 0] = B4 >>> 24, p3(A8, A8 + 80 | 0, g6, g6 + 640 | 0), n4 = (Q4 = o3[A8 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 4 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[0 | I7] = C4, E3[I7 + 1 | 0] = C4 >>> 8, E3[I7 + 2 | 0] = C4 >>> 16, E3[I7 + 3 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 4 | 0] = B4, E3[I7 + 5 | 0] = B4 >>> 8, E3[I7 + 6 | 0] = B4 >>> 16, E3[I7 + 7 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 8 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 12 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[I7 + 8 | 0] = C4, E3[I7 + 9 | 0] = C4 >>> 8, E3[I7 + 10 | 0] = C4 >>> 16, E3[I7 + 11 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 12 | 0] = B4, E3[I7 + 13 | 0] = B4 >>> 8, E3[I7 + 14 | 0] = B4 >>> 16, E3[I7 + 15 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 16 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 20 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[I7 + 16 | 0] = C4, E3[I7 + 17 | 0] = C4 >>> 8, E3[I7 + 18 | 0] = C4 >>> 16, E3[I7 + 19 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 20 | 0] = B4, E3[I7 + 21 | 0] = B4 >>> 8, E3[I7 + 22 | 0] = B4 >>> 16, E3[I7 + 23 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 24 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 28 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[I7 + 24 | 0] = C4, E3[I7 + 25 | 0] = C4 >>> 8, E3[I7 + 26 | 0] = C4 >>> 16, E3[I7 + 27 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 28 | 0] = B4, E3[I7 + 29 | 0] = B4 >>> 8, E3[I7 + 30 | 0] = B4 >>> 16, E3[I7 + 31 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 32 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 36 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[I7 + 32 | 0] = C4, E3[I7 + 33 | 0] = C4 >>> 8, E3[I7 + 34 | 0] = C4 >>> 16, E3[I7 + 35 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 36 | 0] = B4, E3[I7 + 37 | 0] = B4 >>> 8, E3[I7 + 38 | 0] = B4 >>> 16, E3[I7 + 39 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 40 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 44 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[I7 + 40 | 0] = C4, E3[I7 + 41 | 0] = C4 >>> 8, E3[I7 + 42 | 0] = C4 >>> 16, E3[I7 + 43 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 44 | 0] = B4, E3[I7 + 45 | 0] = B4 >>> 8, E3[I7 + 46 | 0] = B4 >>> 16, E3[I7 + 47 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 48 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, C4 = r4 | a4 << 8 | -16777216 & ((255 & (C4 = o3[A8 + 52 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & C4) << 8 | Q4 >>> 24) | C4 >>> 8 & 65280 | C4 >>> 24, E3[I7 + 48 | 0] = C4, E3[I7 + 49 | 0] = C4 >>> 8, E3[I7 + 50 | 0] = C4 >>> 16, E3[I7 + 51 | 0] = C4 >>> 24, B4 = (C4 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[I7 + 52 | 0] = B4, E3[I7 + 53 | 0] = B4 >>> 8, E3[I7 + 54 | 0] = B4 >>> 16, E3[I7 + 55 | 0] = B4 >>> 24, n4 = (Q4 = o3[A8 + 56 >> 2]) << 24 | (65280 & Q4) << 8, B4 = (i4 = 16711680 & Q4) >>> 8 | 0, C4 = I7, r4 = i4 << 24, i4 = (a4 = -16777216 & Q4) >>> 24 | 0, I7 = r4 | a4 << 8 | -16777216 & ((255 & (I7 = o3[A8 + 60 >> 2])) << 24 | Q4 >>> 8) | 16711680 & ((16777215 & I7) << 8 | Q4 >>> 24) | I7 >>> 8 & 65280 | I7 >>> 24, E3[C4 + 56 | 0] = I7, E3[C4 + 57 | 0] = I7 >>> 8, E3[C4 + 58 | 0] = I7 >>> 16, E3[C4 + 59 | 0] = I7 >>> 24, I7 = (I7 = B4 | i4 | n4) | (B4 = 0) | B4 | 0, E3[C4 + 60 | 0] = I7, E3[C4 + 61 | 0] = I7 >>> 8, E3[C4 + 62 | 0] = I7 >>> 16, E3[C4 + 63 | 0] = I7 >>> 24, $A(g6, 704), $A(A8, 208), D3 = g6 + 704 | 0;
                    }
                    function G3(A8, I7, g6) {
                      var C4, B4 = 0, i4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0;
                      D3 = C4 = D3 + -64 | 0;
                      A: {
                        if ((g6 - 65 & 255) >>> 0 > 191) {
                          if (B4 = -1, !(a3[A8 + 80 | 0] | a3[A8 + 81 | 0] << 8 | a3[A8 + 82 | 0] << 16 | a3[A8 + 83 | 0] << 24 | a3[A8 + 84 | 0] | a3[A8 + 85 | 0] << 8 | a3[A8 + 86 | 0] << 16 | a3[A8 + 87 | 0] << 24)) {
                            if ((r4 = a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24) >>> 0 >= 129) {
                              if (n4 = a3[0 | (B4 = A8 - -64 | 0)] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, f4 = i4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, i4 = (r4 = n4 + 128 | 0) >>> 0 < 128 ? i4 + 1 | 0 : i4, E3[0 | B4] = r4, E3[B4 + 1 | 0] = r4 >>> 8, E3[B4 + 2 | 0] = r4 >>> 16, E3[B4 + 3 | 0] = r4 >>> 24, E3[B4 + 4 | 0] = i4, E3[B4 + 5 | 0] = i4 >>> 8, E3[B4 + 6 | 0] = i4 >>> 16, E3[B4 + 7 | 0] = i4 >>> 24, i4 = a3[A8 + 76 | 0] | a3[A8 + 77 | 0] << 8 | a3[A8 + 78 | 0] << 16 | a3[A8 + 79 | 0] << 24, i4 = (B4 = -1 == (0 | f4) & n4 >>> 0 > 4294967167) >>> 0 > (n4 = B4 + (a3[A8 + 72 | 0] | a3[A8 + 73 | 0] << 8 | a3[A8 + 74 | 0] << 16 | a3[A8 + 75 | 0] << 24) | 0) >>> 0 ? i4 + 1 | 0 : i4, E3[A8 + 72 | 0] = n4, E3[A8 + 73 | 0] = n4 >>> 8, E3[A8 + 74 | 0] = n4 >>> 16, E3[A8 + 75 | 0] = n4 >>> 24, E3[A8 + 76 | 0] = i4, E3[A8 + 77 | 0] = i4 >>> 8, E3[A8 + 78 | 0] = i4 >>> 16, E3[A8 + 79 | 0] = i4 >>> 24, h3(A8, i4 = A8 + 96 | 0), B4 = (a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24) - 128 | 0, E3[A8 + 352 | 0] = B4, E3[A8 + 353 | 0] = B4 >>> 8, E3[A8 + 354 | 0] = B4 >>> 16, E3[A8 + 355 | 0] = B4 >>> 24, B4 >>> 0 >= 129)
                                break A;
                              HA(i4, A8 + 224 | 0, B4), r4 = a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24;
                            }
                            i4 = a3[0 | (B4 = A8 - -64 | 0)] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, n4 = t4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, n4 = (f4 = i4 + r4 | 0) >>> 0 < r4 >>> 0 ? n4 + 1 | 0 : n4, E3[0 | B4] = f4, E3[B4 + 1 | 0] = f4 >>> 8, E3[B4 + 2 | 0] = f4 >>> 16, E3[B4 + 3 | 0] = f4 >>> 24, E3[B4 + 4 | 0] = n4, E3[B4 + 5 | 0] = n4 >>> 8, E3[B4 + 6 | 0] = n4 >>> 16, E3[B4 + 7 | 0] = n4 >>> 24, B4 = (0 | n4) == (0 | t4) & i4 >>> 0 > f4 >>> 0 | n4 >>> 0 < t4 >>> 0, i4 = a3[A8 + 76 | 0] | a3[A8 + 77 | 0] << 8 | a3[A8 + 78 | 0] << 16 | a3[A8 + 79 | 0] << 24, i4 = (n4 = B4 + (a3[A8 + 72 | 0] | a3[A8 + 73 | 0] << 8 | a3[A8 + 74 | 0] << 16 | a3[A8 + 75 | 0] << 24) | 0) >>> 0 < B4 >>> 0 ? i4 + 1 | 0 : i4, E3[A8 + 72 | 0] = n4, E3[A8 + 73 | 0] = n4 >>> 8, E3[A8 + 74 | 0] = n4 >>> 16, E3[A8 + 75 | 0] = n4 >>> 24, E3[A8 + 76 | 0] = i4, E3[A8 + 77 | 0] = i4 >>> 8, E3[A8 + 78 | 0] = i4 >>> 16, E3[A8 + 79 | 0] = i4 >>> 24, a3[A8 + 356 | 0] && (E3[A8 + 88 | 0] = 255, E3[A8 + 89 | 0] = 255, E3[A8 + 90 | 0] = 255, E3[A8 + 91 | 0] = 255, E3[A8 + 92 | 0] = 255, E3[A8 + 93 | 0] = 255, E3[A8 + 94 | 0] = 255, E3[A8 + 95 | 0] = 255), E3[A8 + 80 | 0] = 255, E3[A8 + 81 | 0] = 255, E3[A8 + 82 | 0] = 255, E3[A8 + 83 | 0] = 255, E3[A8 + 84 | 0] = 255, E3[A8 + 85 | 0] = 255, E3[A8 + 86 | 0] = 255, E3[A8 + 87 | 0] = 255, MA((B4 = A8 + 96 | 0) + r4 | 0, 0, 256 - r4 | 0), h3(A8, B4), i4 = a3[A8 + 4 | 0] | a3[A8 + 5 | 0] << 8 | a3[A8 + 6 | 0] << 16 | a3[A8 + 7 | 0] << 24, o3[C4 >> 2] = a3[0 | A8] | a3[A8 + 1 | 0] << 8 | a3[A8 + 2 | 0] << 16 | a3[A8 + 3 | 0] << 24, o3[C4 + 4 >> 2] = i4, i4 = a3[A8 + 12 | 0] | a3[A8 + 13 | 0] << 8 | a3[A8 + 14 | 0] << 16 | a3[A8 + 15 | 0] << 24, o3[C4 + 8 >> 2] = a3[A8 + 8 | 0] | a3[A8 + 9 | 0] << 8 | a3[A8 + 10 | 0] << 16 | a3[A8 + 11 | 0] << 24, o3[C4 + 12 >> 2] = i4, i4 = a3[A8 + 20 | 0] | a3[A8 + 21 | 0] << 8 | a3[A8 + 22 | 0] << 16 | a3[A8 + 23 | 0] << 24, o3[C4 + 16 >> 2] = a3[A8 + 16 | 0] | a3[A8 + 17 | 0] << 8 | a3[A8 + 18 | 0] << 16 | a3[A8 + 19 | 0] << 24, o3[C4 + 20 >> 2] = i4, i4 = a3[A8 + 28 | 0] | a3[A8 + 29 | 0] << 8 | a3[A8 + 30 | 0] << 16 | a3[A8 + 31 | 0] << 24, o3[C4 + 24 >> 2] = a3[A8 + 24 | 0] | a3[A8 + 25 | 0] << 8 | a3[A8 + 26 | 0] << 16 | a3[A8 + 27 | 0] << 24, o3[C4 + 28 >> 2] = i4, i4 = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24, o3[C4 + 32 >> 2] = a3[A8 + 32 | 0] | a3[A8 + 33 | 0] << 8 | a3[A8 + 34 | 0] << 16 | a3[A8 + 35 | 0] << 24, o3[C4 + 36 >> 2] = i4, i4 = a3[A8 + 44 | 0] | a3[A8 + 45 | 0] << 8 | a3[A8 + 46 | 0] << 16 | a3[A8 + 47 | 0] << 24, o3[C4 + 40 >> 2] = a3[A8 + 40 | 0] | a3[A8 + 41 | 0] << 8 | a3[A8 + 42 | 0] << 16 | a3[A8 + 43 | 0] << 24, o3[C4 + 44 >> 2] = i4, i4 = a3[A8 + 52 | 0] | a3[A8 + 53 | 0] << 8 | a3[A8 + 54 | 0] << 16 | a3[A8 + 55 | 0] << 24, o3[C4 + 48 >> 2] = a3[A8 + 48 | 0] | a3[A8 + 49 | 0] << 8 | a3[A8 + 50 | 0] << 16 | a3[A8 + 51 | 0] << 24, o3[C4 + 52 >> 2] = i4, i4 = a3[A8 + 60 | 0] | a3[A8 + 61 | 0] << 8 | a3[A8 + 62 | 0] << 16 | a3[A8 + 63 | 0] << 24, o3[C4 + 56 >> 2] = a3[A8 + 56 | 0] | a3[A8 + 57 | 0] << 8 | a3[A8 + 58 | 0] << 16 | a3[A8 + 59 | 0] << 24, o3[C4 + 60 >> 2] = i4, HA(I7, C4, g6), $A(A8, 64), $A(B4, 256), B4 = 0;
                          }
                          return D3 = C4 - -64 | 0, B4;
                        }
                        mA(), Q3();
                      }
                      e3(1280, 1142, 306, 1086), Q3();
                    }
                    function U3(A8, I7) {
                      var g6, C4, B4, Q4, i4, n4, r4, f4, t4, e4, c4, y4, w4, h4, s4, p4, u4 = 0, k4 = 0, l4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0;
                      for (D3 = g6 = D3 - 320 | 0, P3(C4 = A8 + 40 | 0, I7), o3[A8 + 84 >> 2] = 0, o3[A8 + 88 >> 2] = 0, o3[A8 + 80 >> 2] = 1, o3[A8 + 92 >> 2] = 0, o3[A8 + 96 >> 2] = 0, o3[A8 + 100 >> 2] = 0, o3[A8 + 104 >> 2] = 0, o3[A8 + 108 >> 2] = 0, o3[A8 + 112 >> 2] = 0, o3[A8 + 116 >> 2] = 0, S3(G4 = g6 + 240 | 0, C4), F3(H4 = g6 + 192 | 0, G4, 1344), U4 = -1, B4 = o3[g6 + 240 >> 2] - 1 | 0, o3[g6 + 240 >> 2] = B4, o3[g6 + 192 >> 2] = o3[g6 + 192 >> 2] + 1, Q4 = o3[g6 + 244 >> 2], i4 = o3[g6 + 248 >> 2], n4 = o3[g6 + 252 >> 2], r4 = o3[g6 + 256 >> 2], f4 = o3[g6 + 260 >> 2], t4 = o3[g6 + 264 >> 2], e4 = o3[g6 + 268 >> 2], c4 = o3[g6 + 272 >> 2], y4 = o3[g6 + 276 >> 2], S3(M4 = g6 + 144 | 0, H4), F3(M4, M4, H4), S3(A8, M4), F3(A8, A8, H4), F3(A8, A8, G4), D3 = k4 = D3 - 144 | 0, S3(l4 = k4 + 96 | 0, A8), S3(u4 = k4 + 48 | 0, l4), S3(u4, u4), F3(u4, A8, u4), F3(l4, l4, u4), S3(l4, l4), F3(l4, u4, l4), S3(u4, l4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), F3(l4, u4, l4), S3(u4, l4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), F3(u4, u4, l4), S3(k4, u4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), S3(k4, k4), F3(u4, k4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), F3(l4, u4, l4), S3(u4, l4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), F3(u4, u4, l4), S3(k4, u4), u4 = 1; S3(k4, k4), 100 != (0 | (u4 = u4 + 1 | 0)); )
                        ;
                      F3(u4 = k4 + 48 | 0, k4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), S3(u4, u4), F3(l4 = k4 + 96 | 0, u4, l4), S3(l4, l4), S3(l4, l4), F3(A8, l4, A8), D3 = k4 + 144 | 0, F3(A8, A8, M4), F3(A8, A8, G4), S3(u4 = g6 + 96 | 0, A8), F3(u4, u4, H4), u4 = o3[g6 + 132 >> 2], o3[g6 + 84 >> 2] = u4 - y4, k4 = o3[g6 + 128 >> 2], o3[g6 + 80 >> 2] = k4 - c4, l4 = o3[g6 + 124 >> 2], o3[g6 + 76 >> 2] = l4 - e4, H4 = o3[g6 + 120 >> 2], o3[g6 + 72 >> 2] = H4 - t4, M4 = o3[g6 + 116 >> 2], o3[g6 + 68 >> 2] = M4 - f4, G4 = o3[g6 + 112 >> 2], o3[g6 + 64 >> 2] = G4 - r4, w4 = o3[g6 + 108 >> 2], o3[g6 + 60 >> 2] = w4 - n4, h4 = o3[g6 + 104 >> 2], o3[g6 + 56 >> 2] = h4 - i4, s4 = o3[g6 + 100 >> 2], o3[g6 + 52 >> 2] = s4 - Q4, p4 = o3[g6 + 96 >> 2], o3[g6 + 48 >> 2] = p4 - B4, W3(g6, g6 + 48 | 0);
                      A: {
                        if (!iA(g6, 32)) {
                          if (o3[g6 + 36 >> 2] = u4 + y4, o3[g6 + 32 >> 2] = k4 + c4, o3[g6 + 28 >> 2] = l4 + e4, o3[g6 + 24 >> 2] = H4 + t4, o3[g6 + 20 >> 2] = M4 + f4, o3[g6 + 16 >> 2] = G4 + r4, o3[g6 + 12 >> 2] = n4 + w4, o3[g6 + 8 >> 2] = i4 + h4, o3[g6 + 4 >> 2] = Q4 + s4, o3[g6 >> 2] = B4 + p4, W3(u4 = g6 + 288 | 0, g6), !iA(u4, 32))
                            break A;
                          F3(A8, A8, 1392);
                        }
                        W3(g6 + 288 | 0, A8), (1 & E3[g6 + 288 | 0]) == (a3[I7 + 31 | 0] >>> 7 | 0) && (o3[A8 >> 2] = 0 - o3[A8 >> 2], o3[A8 + 36 >> 2] = 0 - o3[A8 + 36 >> 2], o3[A8 + 32 >> 2] = 0 - o3[A8 + 32 >> 2], o3[A8 + 28 >> 2] = 0 - o3[A8 + 28 >> 2], o3[A8 + 24 >> 2] = 0 - o3[A8 + 24 >> 2], o3[A8 + 20 >> 2] = 0 - o3[A8 + 20 >> 2], o3[A8 + 16 >> 2] = 0 - o3[A8 + 16 >> 2], o3[A8 + 12 >> 2] = 0 - o3[A8 + 12 >> 2], o3[A8 + 8 >> 2] = 0 - o3[A8 + 8 >> 2], o3[A8 + 4 >> 2] = 0 - o3[A8 + 4 >> 2]), F3(A8 + 120 | 0, A8, C4), U4 = 0;
                      }
                      return D3 = g6 + 320 | 0, U4;
                    }
                    function J3(A8, I7, g6) {
                      var C4, B4, Q4, i4, o4, n4, r4, f4, t4, e4, c4, y4, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0;
                      for (p4 = 1634760805, w4 = C4 = a3[0 | g6] | a3[g6 + 1 | 0] << 8 | a3[g6 + 2 | 0] << 16 | a3[g6 + 3 | 0] << 24, u4 = B4 = a3[g6 + 4 | 0] | a3[g6 + 5 | 0] << 8 | a3[g6 + 6 | 0] << 16 | a3[g6 + 7 | 0] << 24, k4 = Q4 = a3[g6 + 8 | 0] | a3[g6 + 9 | 0] << 8 | a3[g6 + 10 | 0] << 16 | a3[g6 + 11 | 0] << 24, F4 = i4 = a3[g6 + 12 | 0] | a3[g6 + 13 | 0] << 8 | a3[g6 + 14 | 0] << 16 | a3[g6 + 15 | 0] << 24, M4 = 857760878, l4 = o4 = a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24, h4 = n4 = a3[I7 + 4 | 0] | a3[I7 + 5 | 0] << 8 | a3[I7 + 6 | 0] << 16 | a3[I7 + 7 | 0] << 24, H4 = r4 = a3[I7 + 8 | 0] | a3[I7 + 9 | 0] << 8 | a3[I7 + 10 | 0] << 16 | a3[I7 + 11 | 0] << 24, U4 = f4 = a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24, I7 = 2036477234, s4 = t4 = a3[g6 + 16 | 0] | a3[g6 + 17 | 0] << 8 | a3[g6 + 18 | 0] << 16 | a3[g6 + 19 | 0] << 24, D4 = 1797285236, J4 = e4 = a3[g6 + 28 | 0] | a3[g6 + 29 | 0] << 8 | a3[g6 + 30 | 0] << 16 | a3[g6 + 31 | 0] << 24, G4 = c4 = a3[g6 + 24 | 0] | a3[g6 + 25 | 0] << 8 | a3[g6 + 26 | 0] << 16 | a3[g6 + 27 | 0] << 24, g6 = y4 = a3[g6 + 20 | 0] | a3[g6 + 21 | 0] << 8 | a3[g6 + 22 | 0] << 16 | a3[g6 + 23 | 0] << 24; S4 = YA(w4 + M4 | 0, 7) ^ U4, N4 = YA(S4 + M4 | 0, 9) ^ G4, F4 = YA(g6 + p4 | 0, 7) ^ F4, Y4 = YA(F4 + p4 | 0, 9) ^ H4, _4 = YA(Y4 + F4 | 0, 13) ^ g6, k4 = YA(D4 + s4 | 0, 7) ^ k4, b4 = YA(k4 + D4 | 0, 9) ^ h4, H4 = YA(k4 + b4 | 0, 13) ^ s4, s4 = YA(b4 + H4 | 0, 18) ^ D4, h4 = YA(I7 + l4 | 0, 7) ^ J4, g6 = _4 ^ YA(s4 + h4 | 0, 7), G4 = N4 ^ YA(g6 + s4 | 0, 9), J4 = YA(g6 + G4 | 0, 13) ^ h4, D4 = YA(G4 + J4 | 0, 18) ^ s4, u4 = YA(I7 + h4 | 0, 9) ^ u4, l4 = YA(u4 + h4 | 0, 13) ^ l4, I7 = YA(l4 + u4 | 0, 18) ^ I7, s4 = YA(I7 + S4 | 0, 7) ^ H4, H4 = YA(s4 + I7 | 0, 9) ^ Y4, U4 = YA(s4 + H4 | 0, 13) ^ S4, I7 = YA(H4 + U4 | 0, 18) ^ I7, S4 = YA(S4 + N4 | 0, 13) ^ w4, w4 = YA(S4 + N4 | 0, 18) ^ M4, l4 = YA(w4 + F4 | 0, 7) ^ l4, h4 = YA(l4 + w4 | 0, 9) ^ b4, F4 = YA(h4 + l4 | 0, 13) ^ F4, M4 = YA(h4 + F4 | 0, 18) ^ w4, p4 = YA(Y4 + _4 | 0, 18) ^ p4, w4 = YA(p4 + k4 | 0, 7) ^ S4, u4 = YA(w4 + p4 | 0, 9) ^ u4, k4 = YA(w4 + u4 | 0, 13) ^ k4, p4 = YA(u4 + k4 | 0, 18) ^ p4, S4 = K4 >>> 0 < 18, K4 = K4 + 2 | 0, S4; )
                        ;
                      D4 = D4 + 1797285236 | 0, E3[A8 + 60 | 0] = D4, E3[A8 + 61 | 0] = D4 >>> 8, E3[A8 + 62 | 0] = D4 >>> 16, E3[A8 + 63 | 0] = D4 >>> 24, D4 = J4 + e4 | 0, E3[A8 + 56 | 0] = D4, E3[A8 + 57 | 0] = D4 >>> 8, E3[A8 + 58 | 0] = D4 >>> 16, E3[A8 + 59 | 0] = D4 >>> 24, D4 = G4 + c4 | 0, E3[A8 + 52 | 0] = D4, E3[A8 + 53 | 0] = D4 >>> 8, E3[A8 + 54 | 0] = D4 >>> 16, E3[A8 + 55 | 0] = D4 >>> 24, g6 = g6 + y4 | 0, E3[A8 + 48 | 0] = g6, E3[A8 + 49 | 0] = g6 >>> 8, E3[A8 + 50 | 0] = g6 >>> 16, E3[A8 + 51 | 0] = g6 >>> 24, g6 = s4 + t4 | 0, E3[A8 + 44 | 0] = g6, E3[A8 + 45 | 0] = g6 >>> 8, E3[A8 + 46 | 0] = g6 >>> 16, E3[A8 + 47 | 0] = g6 >>> 24, I7 = I7 + 2036477234 | 0, E3[A8 + 40 | 0] = I7, E3[A8 + 41 | 0] = I7 >>> 8, E3[A8 + 42 | 0] = I7 >>> 16, E3[A8 + 43 | 0] = I7 >>> 24, I7 = U4 + f4 | 0, E3[A8 + 36 | 0] = I7, E3[A8 + 37 | 0] = I7 >>> 8, E3[A8 + 38 | 0] = I7 >>> 16, E3[A8 + 39 | 0] = I7 >>> 24, I7 = H4 + r4 | 0, E3[A8 + 32 | 0] = I7, E3[A8 + 33 | 0] = I7 >>> 8, E3[A8 + 34 | 0] = I7 >>> 16, E3[A8 + 35 | 0] = I7 >>> 24, I7 = h4 + n4 | 0, E3[A8 + 28 | 0] = I7, E3[A8 + 29 | 0] = I7 >>> 8, E3[A8 + 30 | 0] = I7 >>> 16, E3[A8 + 31 | 0] = I7 >>> 24, I7 = l4 + o4 | 0, E3[A8 + 24 | 0] = I7, E3[A8 + 25 | 0] = I7 >>> 8, E3[A8 + 26 | 0] = I7 >>> 16, E3[A8 + 27 | 0] = I7 >>> 24, I7 = M4 + 857760878 | 0, E3[A8 + 20 | 0] = I7, E3[A8 + 21 | 0] = I7 >>> 8, E3[A8 + 22 | 0] = I7 >>> 16, E3[A8 + 23 | 0] = I7 >>> 24, I7 = F4 + i4 | 0, E3[A8 + 16 | 0] = I7, E3[A8 + 17 | 0] = I7 >>> 8, E3[A8 + 18 | 0] = I7 >>> 16, E3[A8 + 19 | 0] = I7 >>> 24, I7 = k4 + Q4 | 0, E3[A8 + 12 | 0] = I7, E3[A8 + 13 | 0] = I7 >>> 8, E3[A8 + 14 | 0] = I7 >>> 16, E3[A8 + 15 | 0] = I7 >>> 24, I7 = u4 + B4 | 0, E3[A8 + 8 | 0] = I7, E3[A8 + 9 | 0] = I7 >>> 8, E3[A8 + 10 | 0] = I7 >>> 16, E3[A8 + 11 | 0] = I7 >>> 24, I7 = w4 + C4 | 0, E3[A8 + 4 | 0] = I7, E3[A8 + 5 | 0] = I7 >>> 8, E3[A8 + 6 | 0] = I7 >>> 16, E3[A8 + 7 | 0] = I7 >>> 24, I7 = p4 + 1634760805 | 0, E3[0 | A8] = I7, E3[A8 + 1 | 0] = I7 >>> 8, E3[A8 + 2 | 0] = I7 >>> 16, E3[A8 + 3 | 0] = I7 >>> 24;
                    }
                    function N3(A8, I7, g6, C4) {
                      var B4 = 0, Q4 = 0, i4 = 0, E4 = 0, n4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0;
                      if (D4 = o3[A8 + 36 >> 2], c4 = o3[A8 + 32 >> 2], y4 = o3[A8 + 28 >> 2], t4 = o3[A8 + 24 >> 2], e4 = o3[A8 + 20 >> 2], !C4 & g6 >>> 0 >= 16 | C4)
                        for (M4 = !a3[A8 + 80 | 0] << 24, s4 = o3[A8 + 4 >> 2], G4 = r3(s4, 5), u4 = o3[A8 + 8 >> 2], S4 = r3(u4, 5), F4 = o3[A8 + 12 >> 2], l4 = r3(F4, 5), H4 = o3[A8 + 16 >> 2], k4 = r3(H4, 5), p4 = o3[A8 >> 2]; B4 = DA(i4 = ((a3[I7 + 3 | 0] | a3[I7 + 4 | 0] << 8 | a3[I7 + 5 | 0] << 16 | a3[I7 + 6 | 0] << 24) >>> 2 & 67108863) + t4 | 0, 0, F4, 0), n4 = w3, e4 = (E4 = DA(t4 = (67108863 & (a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24)) + e4 | 0, 0, H4, 0)) + B4 | 0, B4 = w3 + n4 | 0, B4 = E4 >>> 0 > e4 >>> 0 ? B4 + 1 | 0 : B4, n4 = DA(y4 = ((a3[I7 + 6 | 0] | a3[I7 + 7 | 0] << 8 | a3[I7 + 8 | 0] << 16 | a3[I7 + 9 | 0] << 24) >>> 4 & 67108863) + y4 | 0, 0, u4, 0), B4 = w3 + B4 | 0, B4 = n4 >>> 0 > (e4 = n4 + e4 | 0) >>> 0 ? B4 + 1 | 0 : B4, n4 = DA(c4 = ((a3[I7 + 9 | 0] | a3[I7 + 10 | 0] << 8 | a3[I7 + 11 | 0] << 16 | a3[I7 + 12 | 0] << 24) >>> 6 | 0) + c4 | 0, 0, s4, 0), B4 = w3 + B4 | 0, B4 = n4 >>> 0 > (e4 = n4 + e4 | 0) >>> 0 ? B4 + 1 | 0 : B4, n4 = DA(D4 = D4 + M4 + ((a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24) >>> 8) | 0, 0, p4, 0), B4 = w3 + B4 | 0, U4 = e4 = n4 + e4 | 0, e4 = n4 >>> 0 > e4 >>> 0 ? B4 + 1 | 0 : B4, B4 = DA(i4, 0, u4, 0), n4 = w3, E4 = DA(t4, 0, F4, 0), Q4 = w3 + n4 | 0, Q4 = (B4 = E4 + B4 | 0) >>> 0 < E4 >>> 0 ? Q4 + 1 | 0 : Q4, n4 = (E4 = DA(y4, 0, s4, 0)) + B4 | 0, B4 = w3 + Q4 | 0, B4 = E4 >>> 0 > n4 >>> 0 ? B4 + 1 | 0 : B4, E4 = DA(c4, 0, p4, 0), B4 = w3 + B4 | 0, B4 = E4 >>> 0 > (n4 = E4 + n4 | 0) >>> 0 ? B4 + 1 | 0 : B4, E4 = DA(D4, 0, k4, 0), B4 = w3 + B4 | 0, J4 = n4 = E4 + n4 | 0, n4 = E4 >>> 0 > n4 >>> 0 ? B4 + 1 | 0 : B4, B4 = DA(i4, 0, s4, 0), f4 = w3, E4 = (Q4 = DA(t4, 0, u4, 0)) + B4 | 0, B4 = w3 + f4 | 0, B4 = Q4 >>> 0 > E4 >>> 0 ? B4 + 1 | 0 : B4, f4 = DA(y4, 0, p4, 0), Q4 = w3 + B4 | 0, Q4 = (E4 = f4 + E4 | 0) >>> 0 < f4 >>> 0 ? Q4 + 1 | 0 : Q4, f4 = DA(c4, 0, k4, 0), B4 = w3 + Q4 | 0, B4 = (E4 = f4 + E4 | 0) >>> 0 < f4 >>> 0 ? B4 + 1 | 0 : B4, f4 = DA(D4, 0, l4, 0), B4 = w3 + B4 | 0, N4 = E4 = f4 + E4 | 0, E4 = E4 >>> 0 < f4 >>> 0 ? B4 + 1 | 0 : B4, B4 = DA(i4, 0, p4, 0), Q4 = w3, f4 = (h4 = DA(t4, 0, s4, 0)) + B4 | 0, B4 = w3 + Q4 | 0, B4 = f4 >>> 0 < h4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = DA(y4, 0, k4, 0), B4 = w3 + B4 | 0, B4 = Q4 >>> 0 > (f4 = Q4 + f4 | 0) >>> 0 ? B4 + 1 | 0 : B4, h4 = DA(c4, 0, l4, 0), Q4 = w3 + B4 | 0, Q4 = (f4 = h4 + f4 | 0) >>> 0 < h4 >>> 0 ? Q4 + 1 | 0 : Q4, h4 = DA(D4, 0, S4, 0), B4 = w3 + Q4 | 0, B4 = (f4 = h4 + f4 | 0) >>> 0 < h4 >>> 0 ? B4 + 1 | 0 : B4, h4 = f4, f4 = B4, B4 = DA(i4, 0, k4, 0), Q4 = w3, i4 = (t4 = DA(t4, 0, p4, 0)) + B4 | 0, B4 = w3 + Q4 | 0, B4 = i4 >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, t4 = DA(y4, 0, l4, 0), B4 = w3 + B4 | 0, B4 = (i4 = t4 + i4 | 0) >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, t4 = DA(c4, 0, S4, 0), B4 = w3 + B4 | 0, B4 = (i4 = t4 + i4 | 0) >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, t4 = DA(D4, 0, G4, 0), Q4 = w3 + B4 | 0, Q4 = (i4 = t4 + i4 | 0) >>> 0 < t4 >>> 0 ? Q4 + 1 | 0 : Q4, t4 = i4, B4 = f4, B4 = (i4 = (y4 = (67108863 & Q4) << 6 | i4 >>> 26) + h4 | 0) >>> 0 < y4 >>> 0 ? B4 + 1 | 0 : B4, y4 = i4, c4 = (67108863 & B4) << 6 | i4 >>> 26, B4 = E4, B4 = (i4 = c4 + N4 | 0) >>> 0 < c4 >>> 0 ? B4 + 1 | 0 : B4, c4 = i4, Q4 = n4, D4 = B4 = (i4 = (67108863 & B4) << 6 | i4 >>> 26) + J4 | 0, n4 = (67108863 & (Q4 = B4 >>> 0 < i4 >>> 0 ? Q4 + 1 | 0 : Q4)) << 6 | B4 >>> 26, B4 = e4, t4 = (67108863 & y4) + ((B4 = r3((67108863 & ((i4 = n4 + U4 | 0) >>> 0 < n4 >>> 0 ? B4 + 1 | 0 : B4)) << 6 | i4 >>> 26, 5) + (67108863 & t4) | 0) >>> 26 | 0) | 0, y4 = 67108863 & c4, c4 = 67108863 & D4, D4 = 67108863 & i4, e4 = 67108863 & B4, I7 = I7 + 16 | 0, !(C4 = C4 - (g6 >>> 0 < 16) | 0) & (g6 = g6 - 16 | 0) >>> 0 > 15 | C4; )
                          ;
                      o3[A8 + 20 >> 2] = e4, o3[A8 + 36 >> 2] = D4, o3[A8 + 32 >> 2] = c4, o3[A8 + 28 >> 2] = y4, o3[A8 + 24 >> 2] = t4;
                    }
                    function Y3(A8, I7, g6, C4) {
                      A8 |= 0, I7 |= 0;
                      var B4 = 0;
                      return B4 = -1, (C4 |= 0) - 65 >>> 0 < 4294967232 | (g6 |= 0) >>> 0 > 64 || (g6 && I7 ? (D3 = B4 = D3 - 128 | 0, !I7 | ((C4 &= 255) - 65 & 255) >>> 0 <= 191 | ((g6 &= 255) - 65 & 255) >>> 0 <= 191 ? (mA(), Q3()) : (MA(A8 - -64 | 0, 0, 293), E3[A8 + 56 | 0] = 121, E3[A8 + 57 | 0] = 33, E3[A8 + 58 | 0] = 126, E3[A8 + 59 | 0] = 19, E3[A8 + 60 | 0] = 25, E3[A8 + 61 | 0] = 205, E3[A8 + 62 | 0] = 224, E3[A8 + 63 | 0] = 91, E3[A8 + 48 | 0] = 107, E3[A8 + 49 | 0] = 189, E3[A8 + 50 | 0] = 65, E3[A8 + 51 | 0] = 251, E3[A8 + 52 | 0] = 171, E3[A8 + 53 | 0] = 217, E3[A8 + 54 | 0] = 131, E3[A8 + 55 | 0] = 31, E3[A8 + 40 | 0] = 31, E3[A8 + 41 | 0] = 108, E3[A8 + 42 | 0] = 62, E3[A8 + 43 | 0] = 43, E3[A8 + 44 | 0] = 140, E3[A8 + 45 | 0] = 104, E3[A8 + 46 | 0] = 5, E3[A8 + 47 | 0] = 155, E3[A8 + 32 | 0] = 209, E3[A8 + 33 | 0] = 130, E3[A8 + 34 | 0] = 230, E3[A8 + 35 | 0] = 173, E3[A8 + 36 | 0] = 127, E3[A8 + 37 | 0] = 82, E3[A8 + 38 | 0] = 14, E3[A8 + 39 | 0] = 81, E3[A8 + 24 | 0] = 241, E3[A8 + 25 | 0] = 54, E3[A8 + 26 | 0] = 29, E3[A8 + 27 | 0] = 95, E3[A8 + 28 | 0] = 58, E3[A8 + 29 | 0] = 245, E3[A8 + 30 | 0] = 79, E3[A8 + 31 | 0] = 165, E3[A8 + 16 | 0] = 43, E3[A8 + 17 | 0] = 248, E3[A8 + 18 | 0] = 148, E3[A8 + 19 | 0] = 254, E3[A8 + 20 | 0] = 114, E3[A8 + 21 | 0] = 243, E3[A8 + 22 | 0] = 110, E3[A8 + 23 | 0] = 60, E3[A8 + 8 | 0] = 59, E3[A8 + 9 | 0] = 167, E3[A8 + 10 | 0] = 202, E3[A8 + 11 | 0] = 132, E3[A8 + 12 | 0] = 133, E3[A8 + 13 | 0] = 174, E3[A8 + 14 | 0] = 103, E3[A8 + 15 | 0] = 187, C4 = -222443256 ^ (g6 << 8 | C4), E3[0 | A8] = C4, E3[A8 + 1 | 0] = C4 >>> 8, E3[A8 + 2 | 0] = C4 >>> 16, E3[A8 + 3 | 0] = C4 >>> 24, C4 = g6 >>> 24 ^ 1779033703, E3[A8 + 4 | 0] = C4, E3[A8 + 5 | 0] = C4 >>> 8, E3[A8 + 6 | 0] = C4 >>> 16, E3[A8 + 7 | 0] = C4 >>> 24, MA(g6 + B4 | 0, 0, g6 << 24 >> 24 >= 0 ? 128 - g6 | 0 : 0), g6 = HA(B4, I7, g6), HA(A8 + 96 | 0, g6, 128), I7 = 128 + (a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24) | 0, E3[A8 + 352 | 0] = I7, E3[A8 + 353 | 0] = I7 >>> 8, E3[A8 + 354 | 0] = I7 >>> 16, E3[A8 + 355 | 0] = I7 >>> 24, $A(g6, 128), D3 = g6 + 128 | 0)) : (((I7 = 255 & C4) - 65 & 255) >>> 0 <= 191 && (mA(), Q3()), MA(A8 - -64 | 0, 0, 293), E3[A8 + 56 | 0] = 121, E3[A8 + 57 | 0] = 33, E3[A8 + 58 | 0] = 126, E3[A8 + 59 | 0] = 19, E3[A8 + 60 | 0] = 25, E3[A8 + 61 | 0] = 205, E3[A8 + 62 | 0] = 224, E3[A8 + 63 | 0] = 91, E3[A8 + 48 | 0] = 107, E3[A8 + 49 | 0] = 189, E3[A8 + 50 | 0] = 65, E3[A8 + 51 | 0] = 251, E3[A8 + 52 | 0] = 171, E3[A8 + 53 | 0] = 217, E3[A8 + 54 | 0] = 131, E3[A8 + 55 | 0] = 31, E3[A8 + 40 | 0] = 31, E3[A8 + 41 | 0] = 108, E3[A8 + 42 | 0] = 62, E3[A8 + 43 | 0] = 43, E3[A8 + 44 | 0] = 140, E3[A8 + 45 | 0] = 104, E3[A8 + 46 | 0] = 5, E3[A8 + 47 | 0] = 155, E3[A8 + 32 | 0] = 209, E3[A8 + 33 | 0] = 130, E3[A8 + 34 | 0] = 230, E3[A8 + 35 | 0] = 173, E3[A8 + 36 | 0] = 127, E3[A8 + 37 | 0] = 82, E3[A8 + 38 | 0] = 14, E3[A8 + 39 | 0] = 81, E3[A8 + 24 | 0] = 241, E3[A8 + 25 | 0] = 54, E3[A8 + 26 | 0] = 29, E3[A8 + 27 | 0] = 95, E3[A8 + 28 | 0] = 58, E3[A8 + 29 | 0] = 245, E3[A8 + 30 | 0] = 79, E3[A8 + 31 | 0] = 165, E3[A8 + 16 | 0] = 43, E3[A8 + 17 | 0] = 248, E3[A8 + 18 | 0] = 148, E3[A8 + 19 | 0] = 254, E3[A8 + 20 | 0] = 114, E3[A8 + 21 | 0] = 243, E3[A8 + 22 | 0] = 110, E3[A8 + 23 | 0] = 60, E3[A8 + 8 | 0] = 59, E3[A8 + 9 | 0] = 167, E3[A8 + 10 | 0] = 202, E3[A8 + 11 | 0] = 132, E3[A8 + 12 | 0] = 133, E3[A8 + 13 | 0] = 174, E3[A8 + 14 | 0] = 103, E3[A8 + 15 | 0] = 187, I7 ^= -222443256, E3[0 | A8] = I7, E3[A8 + 1 | 0] = I7 >>> 8, E3[A8 + 2 | 0] = I7 >>> 16, E3[A8 + 3 | 0] = I7 >>> 24, E3[A8 + 4 | 0] = 103, E3[A8 + 5 | 0] = 230, E3[A8 + 6 | 0] = 9, E3[A8 + 7 | 0] = 106), B4 = 0), 0 | B4;
                    }
                    function b3(A8, I7, g6) {
                      var C4, B4, Q4, i4, E4, a4, n4, r4, f4, t4, e4, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0;
                      c4 = o3[I7 + 40 >> 2], y4 = o3[I7 + 4 >> 2], w4 = o3[I7 + 44 >> 2], h4 = o3[I7 + 8 >> 2], s4 = o3[I7 + 48 >> 2], p4 = o3[I7 + 12 >> 2], u4 = o3[I7 + 52 >> 2], k4 = o3[I7 + 16 >> 2], l4 = o3[I7 + 56 >> 2], S4 = o3[I7 + 20 >> 2], H4 = o3[I7 + 60 >> 2], M4 = o3[I7 + 24 >> 2], G4 = o3[(D4 = I7 - -64 | 0) >> 2], U4 = o3[I7 + 28 >> 2], J4 = o3[I7 + 68 >> 2], N4 = o3[I7 + 32 >> 2], Y4 = o3[I7 + 72 >> 2], b4 = o3[I7 >> 2], o3[A8 + 36 >> 2] = o3[I7 + 36 >> 2] + o3[I7 + 76 >> 2], o3[A8 + 32 >> 2] = N4 + Y4, o3[A8 + 28 >> 2] = U4 + J4, o3[A8 + 24 >> 2] = M4 + G4, o3[A8 + 20 >> 2] = S4 + H4, o3[A8 + 16 >> 2] = k4 + l4, o3[A8 + 12 >> 2] = p4 + u4, o3[A8 + 8 >> 2] = h4 + s4, o3[A8 + 4 >> 2] = y4 + w4, o3[A8 >> 2] = c4 + b4, w4 = o3[I7 + 40 >> 2], c4 = o3[I7 + 4 >> 2], h4 = o3[I7 + 44 >> 2], s4 = o3[I7 + 8 >> 2], p4 = o3[I7 + 48 >> 2], u4 = o3[I7 + 12 >> 2], k4 = o3[I7 + 52 >> 2], l4 = o3[I7 + 16 >> 2], S4 = o3[I7 + 56 >> 2], H4 = o3[I7 + 20 >> 2], M4 = o3[I7 + 60 >> 2], G4 = o3[I7 + 24 >> 2], D4 = o3[D4 >> 2], y4 = o3[I7 + 28 >> 2], U4 = o3[I7 + 68 >> 2], J4 = o3[I7 + 32 >> 2], N4 = o3[I7 + 72 >> 2], Y4 = o3[I7 >> 2], o3[A8 + 76 >> 2] = o3[I7 + 76 >> 2] - o3[I7 + 36 >> 2], o3[A8 + 72 >> 2] = N4 - J4, o3[A8 + 68 >> 2] = U4 - y4, o3[(y4 = A8 - -64 | 0) >> 2] = D4 - G4, o3[A8 + 60 >> 2] = M4 - H4, o3[A8 + 56 >> 2] = S4 - l4, o3[A8 + 52 >> 2] = k4 - u4, o3[A8 + 48 >> 2] = p4 - s4, o3[A8 + 44 >> 2] = h4 - c4, o3[(c4 = A8 + 40 | 0) >> 2] = w4 - Y4, F3(A8 + 80 | 0, A8, g6 + 40 | 0), F3(c4, c4, g6), F3(A8 + 120 | 0, g6 + 120 | 0, I7 + 120 | 0), F3(A8, I7 + 80 | 0, g6 + 80 | 0), b4 = o3[A8 + 4 >> 2], Q4 = o3[A8 + 8 >> 2], i4 = o3[A8 + 12 >> 2], E4 = o3[A8 + 16 >> 2], a4 = o3[A8 + 20 >> 2], n4 = o3[A8 + 24 >> 2], r4 = o3[A8 + 28 >> 2], f4 = o3[A8 + 32 >> 2], t4 = o3[A8 + 36 >> 2], I7 = o3[c4 >> 2], g6 = o3[A8 + 80 >> 2], w4 = o3[A8 + 44 >> 2], h4 = o3[A8 + 84 >> 2], s4 = o3[A8 + 48 >> 2], p4 = o3[A8 + 88 >> 2], u4 = o3[A8 + 52 >> 2], k4 = o3[A8 + 92 >> 2], l4 = o3[A8 + 56 >> 2], S4 = o3[A8 + 96 >> 2], H4 = o3[A8 + 60 >> 2], M4 = o3[A8 + 100 >> 2], D4 = o3[y4 >> 2], G4 = o3[A8 + 104 >> 2], U4 = o3[A8 + 68 >> 2], J4 = o3[A8 + 108 >> 2], N4 = o3[A8 + 72 >> 2], Y4 = o3[A8 + 112 >> 2], e4 = o3[A8 >> 2], C4 = o3[A8 + 76 >> 2], B4 = o3[A8 + 116 >> 2], o3[A8 + 76 >> 2] = C4 + B4, o3[A8 + 72 >> 2] = N4 + Y4, o3[A8 + 68 >> 2] = U4 + J4, o3[y4 >> 2] = D4 + G4, o3[A8 + 60 >> 2] = H4 + M4, o3[A8 + 56 >> 2] = l4 + S4, o3[A8 + 52 >> 2] = u4 + k4, o3[A8 + 48 >> 2] = s4 + p4, o3[A8 + 44 >> 2] = w4 + h4, o3[c4 >> 2] = I7 + g6, o3[A8 + 36 >> 2] = B4 - C4, o3[A8 + 32 >> 2] = Y4 - N4, o3[A8 + 28 >> 2] = J4 - U4, o3[A8 + 24 >> 2] = G4 - D4, o3[A8 + 20 >> 2] = M4 - H4, o3[A8 + 16 >> 2] = S4 - l4, o3[A8 + 12 >> 2] = k4 - u4, o3[A8 + 8 >> 2] = p4 - s4, o3[A8 + 4 >> 2] = h4 - w4, o3[A8 >> 2] = g6 - I7, I7 = o3[A8 + 156 >> 2], g6 = t4 << 1, o3[A8 + 156 >> 2] = I7 + g6, c4 = o3[A8 + 152 >> 2], y4 = f4 << 1, o3[A8 + 152 >> 2] = c4 + y4, w4 = o3[A8 + 148 >> 2], h4 = r4 << 1, o3[A8 + 148 >> 2] = w4 + h4, s4 = o3[A8 + 144 >> 2], p4 = n4 << 1, o3[A8 + 144 >> 2] = s4 + p4, u4 = o3[A8 + 140 >> 2], k4 = a4 << 1, o3[A8 + 140 >> 2] = u4 + k4, l4 = o3[A8 + 136 >> 2], S4 = E4 << 1, o3[A8 + 136 >> 2] = l4 + S4, H4 = o3[A8 + 132 >> 2], M4 = i4 << 1, o3[A8 + 132 >> 2] = H4 + M4, D4 = o3[A8 + 128 >> 2], G4 = Q4 << 1, o3[A8 + 128 >> 2] = D4 + G4, U4 = o3[A8 + 124 >> 2], J4 = b4 << 1, o3[A8 + 124 >> 2] = U4 + J4, N4 = o3[A8 + 120 >> 2], Y4 = e4 << 1, o3[A8 + 120 >> 2] = N4 + Y4, o3[A8 + 112 >> 2] = y4 - c4, o3[A8 + 108 >> 2] = h4 - w4, o3[A8 + 104 >> 2] = p4 - s4, o3[A8 + 100 >> 2] = k4 - u4, o3[A8 + 96 >> 2] = S4 - l4, o3[A8 + 92 >> 2] = M4 - H4, o3[A8 + 88 >> 2] = G4 - D4, o3[A8 + 84 >> 2] = J4 - U4, o3[A8 + 80 >> 2] = Y4 - N4, o3[A8 + 116 >> 2] = g6 - I7;
                    }
                    function _3(A8, I7, g6) {
                      var C4, B4, Q4, i4, E4, a4, n4, r4, f4, t4, e4, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0;
                      c4 = o3[I7 + 40 >> 2], y4 = o3[I7 + 4 >> 2], w4 = o3[I7 + 44 >> 2], h4 = o3[I7 + 8 >> 2], s4 = o3[I7 + 48 >> 2], p4 = o3[I7 + 12 >> 2], u4 = o3[I7 + 52 >> 2], k4 = o3[I7 + 16 >> 2], l4 = o3[I7 + 56 >> 2], S4 = o3[I7 + 20 >> 2], H4 = o3[I7 + 60 >> 2], M4 = o3[I7 + 24 >> 2], G4 = o3[(D4 = I7 - -64 | 0) >> 2], U4 = o3[I7 + 28 >> 2], J4 = o3[I7 + 68 >> 2], N4 = o3[I7 + 32 >> 2], Y4 = o3[I7 + 72 >> 2], b4 = o3[I7 >> 2], o3[A8 + 36 >> 2] = o3[I7 + 36 >> 2] + o3[I7 + 76 >> 2], o3[A8 + 32 >> 2] = N4 + Y4, o3[A8 + 28 >> 2] = U4 + J4, o3[A8 + 24 >> 2] = M4 + G4, o3[A8 + 20 >> 2] = S4 + H4, o3[A8 + 16 >> 2] = k4 + l4, o3[A8 + 12 >> 2] = p4 + u4, o3[A8 + 8 >> 2] = h4 + s4, o3[A8 + 4 >> 2] = y4 + w4, o3[A8 >> 2] = c4 + b4, w4 = o3[I7 + 40 >> 2], c4 = o3[I7 + 4 >> 2], h4 = o3[I7 + 44 >> 2], s4 = o3[I7 + 8 >> 2], p4 = o3[I7 + 48 >> 2], u4 = o3[I7 + 12 >> 2], k4 = o3[I7 + 52 >> 2], l4 = o3[I7 + 16 >> 2], S4 = o3[I7 + 56 >> 2], H4 = o3[I7 + 20 >> 2], M4 = o3[I7 + 60 >> 2], G4 = o3[I7 + 24 >> 2], D4 = o3[D4 >> 2], y4 = o3[I7 + 28 >> 2], U4 = o3[I7 + 68 >> 2], J4 = o3[I7 + 32 >> 2], N4 = o3[I7 + 72 >> 2], Y4 = o3[I7 >> 2], o3[A8 + 76 >> 2] = o3[I7 + 76 >> 2] - o3[I7 + 36 >> 2], o3[A8 + 72 >> 2] = N4 - J4, o3[A8 + 68 >> 2] = U4 - y4, o3[(y4 = A8 - -64 | 0) >> 2] = D4 - G4, o3[A8 + 60 >> 2] = M4 - H4, o3[A8 + 56 >> 2] = S4 - l4, o3[A8 + 52 >> 2] = k4 - u4, o3[A8 + 48 >> 2] = p4 - s4, o3[A8 + 44 >> 2] = h4 - c4, o3[(c4 = A8 + 40 | 0) >> 2] = w4 - Y4, F3(A8 + 80 | 0, A8, g6), F3(c4, c4, g6 + 40 | 0), F3(A8 + 120 | 0, g6 + 120 | 0, I7 + 120 | 0), F3(A8, I7 + 80 | 0, g6 + 80 | 0), b4 = o3[A8 + 4 >> 2], Q4 = o3[A8 + 8 >> 2], i4 = o3[A8 + 12 >> 2], E4 = o3[A8 + 16 >> 2], a4 = o3[A8 + 20 >> 2], n4 = o3[A8 + 24 >> 2], r4 = o3[A8 + 28 >> 2], f4 = o3[A8 + 32 >> 2], t4 = o3[A8 + 36 >> 2], I7 = o3[c4 >> 2], g6 = o3[A8 + 80 >> 2], w4 = o3[A8 + 44 >> 2], h4 = o3[A8 + 84 >> 2], s4 = o3[A8 + 48 >> 2], p4 = o3[A8 + 88 >> 2], u4 = o3[A8 + 52 >> 2], k4 = o3[A8 + 92 >> 2], l4 = o3[A8 + 56 >> 2], S4 = o3[A8 + 96 >> 2], H4 = o3[A8 + 60 >> 2], M4 = o3[A8 + 100 >> 2], D4 = o3[y4 >> 2], G4 = o3[A8 + 104 >> 2], U4 = o3[A8 + 68 >> 2], J4 = o3[A8 + 108 >> 2], N4 = o3[A8 + 72 >> 2], Y4 = o3[A8 + 112 >> 2], e4 = o3[A8 >> 2], C4 = o3[A8 + 76 >> 2], B4 = o3[A8 + 116 >> 2], o3[A8 + 76 >> 2] = C4 + B4, o3[A8 + 72 >> 2] = N4 + Y4, o3[A8 + 68 >> 2] = U4 + J4, o3[y4 >> 2] = D4 + G4, o3[A8 + 60 >> 2] = H4 + M4, o3[A8 + 56 >> 2] = l4 + S4, o3[A8 + 52 >> 2] = u4 + k4, o3[A8 + 48 >> 2] = s4 + p4, o3[A8 + 44 >> 2] = w4 + h4, o3[c4 >> 2] = I7 + g6, o3[A8 + 36 >> 2] = B4 - C4, o3[A8 + 32 >> 2] = Y4 - N4, o3[A8 + 28 >> 2] = J4 - U4, o3[A8 + 24 >> 2] = G4 - D4, o3[A8 + 20 >> 2] = M4 - H4, o3[A8 + 16 >> 2] = S4 - l4, o3[A8 + 12 >> 2] = k4 - u4, o3[A8 + 8 >> 2] = p4 - s4, o3[A8 + 4 >> 2] = h4 - w4, o3[A8 >> 2] = g6 - I7, I7 = t4 << 1, g6 = o3[A8 + 156 >> 2], o3[A8 + 156 >> 2] = I7 - g6, c4 = f4 << 1, y4 = o3[A8 + 152 >> 2], o3[A8 + 152 >> 2] = c4 - y4, w4 = r4 << 1, h4 = o3[A8 + 148 >> 2], o3[A8 + 148 >> 2] = w4 - h4, s4 = n4 << 1, p4 = o3[A8 + 144 >> 2], o3[A8 + 144 >> 2] = s4 - p4, u4 = a4 << 1, k4 = o3[A8 + 140 >> 2], o3[A8 + 140 >> 2] = u4 - k4, l4 = E4 << 1, S4 = o3[A8 + 136 >> 2], o3[A8 + 136 >> 2] = l4 - S4, H4 = i4 << 1, M4 = o3[A8 + 132 >> 2], o3[A8 + 132 >> 2] = H4 - M4, D4 = Q4 << 1, G4 = o3[A8 + 128 >> 2], o3[A8 + 128 >> 2] = D4 - G4, U4 = b4 << 1, J4 = o3[A8 + 124 >> 2], o3[A8 + 124 >> 2] = U4 - J4, N4 = e4 << 1, Y4 = o3[A8 + 120 >> 2], o3[A8 + 120 >> 2] = N4 - Y4, o3[A8 + 112 >> 2] = c4 + y4, o3[A8 + 108 >> 2] = w4 + h4, o3[A8 + 104 >> 2] = s4 + p4, o3[A8 + 100 >> 2] = u4 + k4, o3[A8 + 96 >> 2] = l4 + S4, o3[A8 + 92 >> 2] = H4 + M4, o3[A8 + 88 >> 2] = D4 + G4, o3[A8 + 84 >> 2] = U4 + J4, o3[A8 + 80 >> 2] = N4 + Y4, o3[A8 + 116 >> 2] = I7 + g6;
                    }
                    function K3(A8, I7, g6) {
                      var C4, B4, Q4, i4, E4, a4, n4, r4, f4, t4, e4, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0;
                      c4 = o3[I7 + 40 >> 2], y4 = o3[I7 + 4 >> 2], w4 = o3[I7 + 44 >> 2], h4 = o3[I7 + 8 >> 2], s4 = o3[I7 + 48 >> 2], p4 = o3[I7 + 12 >> 2], u4 = o3[I7 + 52 >> 2], k4 = o3[I7 + 16 >> 2], l4 = o3[I7 + 56 >> 2], S4 = o3[I7 + 20 >> 2], H4 = o3[I7 + 60 >> 2], M4 = o3[I7 + 24 >> 2], G4 = o3[(D4 = I7 - -64 | 0) >> 2], U4 = o3[I7 + 28 >> 2], J4 = o3[I7 + 68 >> 2], N4 = o3[I7 + 32 >> 2], Y4 = o3[I7 + 72 >> 2], b4 = o3[I7 >> 2], o3[A8 + 36 >> 2] = o3[I7 + 36 >> 2] + o3[I7 + 76 >> 2], o3[A8 + 32 >> 2] = N4 + Y4, o3[A8 + 28 >> 2] = U4 + J4, o3[A8 + 24 >> 2] = M4 + G4, o3[A8 + 20 >> 2] = S4 + H4, o3[A8 + 16 >> 2] = k4 + l4, o3[A8 + 12 >> 2] = p4 + u4, o3[A8 + 8 >> 2] = h4 + s4, o3[A8 + 4 >> 2] = y4 + w4, o3[A8 >> 2] = c4 + b4, w4 = o3[I7 + 40 >> 2], c4 = o3[I7 + 4 >> 2], h4 = o3[I7 + 44 >> 2], s4 = o3[I7 + 8 >> 2], p4 = o3[I7 + 48 >> 2], u4 = o3[I7 + 12 >> 2], k4 = o3[I7 + 52 >> 2], l4 = o3[I7 + 16 >> 2], S4 = o3[I7 + 56 >> 2], H4 = o3[I7 + 20 >> 2], M4 = o3[I7 + 60 >> 2], G4 = o3[I7 + 24 >> 2], D4 = o3[D4 >> 2], y4 = o3[I7 + 28 >> 2], U4 = o3[I7 + 68 >> 2], J4 = o3[I7 + 32 >> 2], N4 = o3[I7 + 72 >> 2], Y4 = o3[I7 >> 2], o3[A8 + 76 >> 2] = o3[I7 + 76 >> 2] - o3[I7 + 36 >> 2], o3[A8 + 72 >> 2] = N4 - J4, o3[A8 + 68 >> 2] = U4 - y4, o3[(y4 = A8 - -64 | 0) >> 2] = D4 - G4, o3[A8 + 60 >> 2] = M4 - H4, o3[A8 + 56 >> 2] = S4 - l4, o3[A8 + 52 >> 2] = k4 - u4, o3[A8 + 48 >> 2] = p4 - s4, o3[A8 + 44 >> 2] = h4 - c4, o3[(c4 = A8 + 40 | 0) >> 2] = w4 - Y4, F3(A8 + 80 | 0, A8, g6), F3(c4, c4, g6 + 40 | 0), F3(A8 + 120 | 0, g6 + 80 | 0, I7 + 120 | 0), b4 = o3[I7 + 80 >> 2], Q4 = o3[I7 + 84 >> 2], i4 = o3[I7 + 88 >> 2], E4 = o3[I7 + 92 >> 2], a4 = o3[I7 + 96 >> 2], n4 = o3[I7 + 100 >> 2], r4 = o3[I7 + 104 >> 2], f4 = o3[I7 + 108 >> 2], t4 = o3[I7 + 112 >> 2], e4 = o3[I7 + 116 >> 2], I7 = o3[c4 >> 2], g6 = o3[A8 + 80 >> 2], w4 = o3[A8 + 44 >> 2], h4 = o3[A8 + 84 >> 2], s4 = o3[A8 + 48 >> 2], p4 = o3[A8 + 88 >> 2], u4 = o3[A8 + 52 >> 2], k4 = o3[A8 + 92 >> 2], l4 = o3[A8 + 56 >> 2], S4 = o3[A8 + 96 >> 2], H4 = o3[A8 + 60 >> 2], M4 = o3[A8 + 100 >> 2], D4 = o3[y4 >> 2], G4 = o3[A8 + 104 >> 2], U4 = o3[A8 + 68 >> 2], J4 = o3[A8 + 108 >> 2], N4 = o3[A8 + 72 >> 2], Y4 = o3[A8 + 112 >> 2], C4 = o3[A8 + 76 >> 2], B4 = o3[A8 + 116 >> 2], o3[A8 + 76 >> 2] = C4 + B4, o3[A8 + 72 >> 2] = N4 + Y4, o3[A8 + 68 >> 2] = U4 + J4, o3[y4 >> 2] = D4 + G4, o3[A8 + 60 >> 2] = H4 + M4, o3[A8 + 56 >> 2] = l4 + S4, o3[A8 + 52 >> 2] = u4 + k4, o3[A8 + 48 >> 2] = s4 + p4, o3[A8 + 44 >> 2] = w4 + h4, o3[c4 >> 2] = I7 + g6, o3[A8 + 36 >> 2] = B4 - C4, o3[A8 + 32 >> 2] = Y4 - N4, o3[A8 + 28 >> 2] = J4 - U4, o3[A8 + 24 >> 2] = G4 - D4, o3[A8 + 20 >> 2] = M4 - H4, o3[A8 + 16 >> 2] = S4 - l4, o3[A8 + 12 >> 2] = k4 - u4, o3[A8 + 8 >> 2] = p4 - s4, o3[A8 + 4 >> 2] = h4 - w4, o3[A8 >> 2] = g6 - I7, I7 = e4 << 1, g6 = o3[A8 + 156 >> 2], o3[A8 + 156 >> 2] = I7 - g6, c4 = t4 << 1, y4 = o3[A8 + 152 >> 2], o3[A8 + 152 >> 2] = c4 - y4, w4 = f4 << 1, h4 = o3[A8 + 148 >> 2], o3[A8 + 148 >> 2] = w4 - h4, s4 = r4 << 1, p4 = o3[A8 + 144 >> 2], o3[A8 + 144 >> 2] = s4 - p4, u4 = n4 << 1, k4 = o3[A8 + 140 >> 2], o3[A8 + 140 >> 2] = u4 - k4, l4 = a4 << 1, S4 = o3[A8 + 136 >> 2], o3[A8 + 136 >> 2] = l4 - S4, H4 = E4 << 1, M4 = o3[A8 + 132 >> 2], o3[A8 + 132 >> 2] = H4 - M4, D4 = i4 << 1, G4 = o3[A8 + 128 >> 2], o3[A8 + 128 >> 2] = D4 - G4, U4 = Q4 << 1, J4 = o3[A8 + 124 >> 2], o3[A8 + 124 >> 2] = U4 - J4, N4 = b4 << 1, Y4 = o3[A8 + 120 >> 2], o3[A8 + 120 >> 2] = N4 - Y4, o3[A8 + 112 >> 2] = c4 + y4, o3[A8 + 108 >> 2] = w4 + h4, o3[A8 + 104 >> 2] = s4 + p4, o3[A8 + 100 >> 2] = u4 + k4, o3[A8 + 96 >> 2] = l4 + S4, o3[A8 + 92 >> 2] = H4 + M4, o3[A8 + 88 >> 2] = D4 + G4, o3[A8 + 84 >> 2] = U4 + J4, o3[A8 + 80 >> 2] = N4 + Y4, o3[A8 + 116 >> 2] = I7 + g6;
                    }
                    function P3(A8, I7) {
                      var g6, C4, B4, Q4, i4, E4, n4, r4, f4, t4, e4, c4, y4, D4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0, l4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0;
                      c4 = a3[I7 + 31 | 0], g6 = a3[I7 + 30 | 0], C4 = a3[I7 + 29 | 0], B4 = a3[I7 + 6 | 0], Q4 = a3[I7 + 5 | 0], i4 = a3[I7 + 4 | 0], E4 = a3[I7 + 9 | 0], n4 = a3[I7 + 8 | 0], r4 = a3[I7 + 7 | 0], H4 = a3[I7 + 12 | 0], M4 = a3[I7 + 11 | 0], f4 = a3[I7 + 10 | 0], t4 = a3[I7 + 15 | 0], G4 = a3[I7 + 14 | 0], e4 = a3[I7 + 13 | 0], F4 = a3[I7 + 28 | 0], S4 = a3[I7 + 27 | 0], l4 = a3[I7 + 26 | 0], k4 = a3[I7 + 25 | 0], p4 = a3[I7 + 24 | 0], s4 = a3[I7 + 23 | 0], y4 = a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24, u4 = (D4 = a3[I7 + 21 | 0]) << 15, D4 = h4 = D4 >>> 17 | 0, J4 = u4, h4 = (u4 = a3[I7 + 20 | 0]) >>> 25 | 0, u4 = J4 | u4 << 7, U4 = D4 | h4, D4 = (h4 = a3[I7 + 22 | 0]) >>> 9 | 0, u4 |= h4 << 23, D4 |= U4, h4 = a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24, I7 = 0, J4 = h4, h4 = (33554431 & (I7 = (U4 = h4 + 16777216 | 0) >>> 0 < 16777216 ? 1 : I7)) << 7 | U4 >>> 25, I7 = (I7 >>> 25 | 0) + D4 | 0, h4 = (D4 = u4 = h4 + u4 | 0) >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, I7 = (u4 = D4 + 33554432 | 0) >>> 0 < 33554432 ? h4 + 1 | 0 : h4, o3[A8 + 24 >> 2] = D4 - (-67108864 & u4), h4 = (D4 = s4 >>> 27 | 0) | p4 >>> 19 | k4 >>> 11, D4 = s4 = (p4 = k4 << 21 | (s4 = p4 << 13 | s4 << 5)) + (D4 = (67108863 & (D4 = I7)) << 6 | u4 >>> 26) | 0, I7 = h4, h4 = (s4 = p4 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7, o3[A8 + 28 >> 2] = D4 - (1040187392 & s4), D4 = (D4 = S4 >>> 20 | l4 >>> 28 | F4 >>> 12) + (h4 = (I7 = h4) >>> 25 | 0) | 0, I7 = (h4 = s4 = (I7 = (33554431 & I7) << 7 | s4 >>> 25) + (S4 << 12 | l4 << 4 | F4 << 20) | 0) >>> 0 < I7 >>> 0 ? D4 + 1 | 0 : D4, s4 = (F4 = h4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, o3[A8 + 32 >> 2] = h4 - (-67108864 & F4), D4 = (I7 = H4 >>> 13 | 0) | (h4 = M4 >>> 21 | f4 >>> 29), I7 = (D4 = (S4 = 16777216 + (H4 = M4 << 11 | f4 << 3 | H4 << 19) | 0) >>> 0 < 16777216 ? D4 + 1 | 0 : D4) >>> 25 | 0, D4 = (h4 = p4 = G4 << 10 | e4 << 2 | t4 << 18) + (p4 = (33554431 & D4) << 7 | S4 >>> 25) | 0, h4 = I7 + (k4 = G4 >>> 22 | e4 >>> 30 | t4 >>> 14) | 0, I7 = D4 >>> 0 < p4 >>> 0 ? h4 + 1 | 0 : h4, p4 = I7 = (67108863 & (I7 = (h4 = D4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7)) << 6 | h4 >>> 26, I7 = I7 + (l4 = J4 - (-33554432 & U4) | 0) | 0, o3[A8 + 20 >> 2] = I7, o3[A8 + 16 >> 2] = D4 - (-67108864 & h4), h4 = Q4 >>> 18 | i4 >>> 26 | B4 >>> 10, D4 = (h4 = (l4 = 16777216 + (M4 = Q4 << 14 | i4 << 6 | B4 << 22) | 0) >>> 0 < 16777216 ? h4 + 1 | 0 : h4) >>> 25 | 0, h4 = (I7 = p4 = n4 << 13 | r4 << 5 | E4 << 21) + (p4 = (33554431 & h4) << 7 | l4 >>> 25) | 0, I7 = D4 + (k4 = n4 >>> 19 | r4 >>> 27 | E4 >>> 11) | 0, I7 = h4 >>> 0 < p4 >>> 0 ? I7 + 1 | 0 : I7, D4 = (k4 = h4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, o3[A8 + 8 >> 2] = h4 - (-67108864 & k4), F4 = (s4 = (67108863 & s4) << 6 | F4 >>> 26) + (G4 = c4 << 18 & 33292288 | g6 << 10 | C4 << 2) | 0, I7 = h4 = g6 >>> 22 | C4 >>> 30, h4 = (s4 = G4 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7, o3[A8 + 36 >> 2] = F4 - (33554432 & s4), D4 = H4 + ((67108863 & D4) << 6 | k4 >>> 26) | 0, o3[A8 + 12 >> 2] = D4 - (234881024 & S4), p4 = M4 - (2113929216 & l4) | 0, D4 = DA((33554431 & (I7 = h4)) << 7 | s4 >>> 25, h4 = I7 >>> 25 | 0, 19, 0), I7 = w3, D4 = D4 >>> 0 > (h4 = D4 + y4 | 0) >>> 0 ? I7 + 1 | 0 : I7, s4 = D4 = (67108863 & (D4 = (I7 = h4 + 33554432 | 0) >>> 0 < 33554432 ? D4 + 1 | 0 : D4)) << 6 | I7 >>> 26, D4 = D4 + p4 | 0, o3[A8 + 4 >> 2] = D4, o3[A8 >> 2] = h4 - (-67108864 & I7);
                    }
                    function v3(A8, I7) {
                      var g6, C4, B4, Q4 = 0, i4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, w4 = 0, h4 = 0, s4 = 0;
                      for (D3 = g6 = D3 - 480 | 0; i4 = (n4 = g6 + 288 | 0) + (Q4 << 1) | 0, c4 = a3[I7 + Q4 | 0], E3[i4 + 1 | 0] = c4 >>> 4, E3[0 | i4] = 15 & c4, n4 = n4 + ((i4 = 1 | Q4) << 1) | 0, i4 = a3[I7 + i4 | 0], E3[n4 + 1 | 0] = i4 >>> 4, E3[0 | n4] = 15 & i4, 32 != (0 | (Q4 = Q4 + 2 | 0)); )
                        ;
                      for (I7 = 0; Q4 = 8 + (n4 = (Q4 = I7) + a3[0 | (I7 = (g6 + 288 | 0) + r4 | 0)] | 0) | 0, E3[0 | I7] = n4 - (240 & Q4), Q4 = 8 + (n4 = a3[I7 + 1 | 0] + (Q4 << 24 >> 24 >> 4) | 0) | 0, E3[I7 + 1 | 0] = n4 - (240 & Q4), Q4 = 8 + (n4 = a3[I7 + 2 | 0] + (Q4 << 24 >> 24 >> 4) | 0) | 0, E3[I7 + 2 | 0] = n4 - (240 & Q4), I7 = Q4 << 24 >> 24 >> 4, 63 != (0 | (r4 = r4 + 3 | 0)); )
                        ;
                      for (E3[g6 + 351 | 0] = a3[g6 + 351 | 0] + I7, o3[A8 + 32 >> 2] = 0, o3[A8 + 36 >> 2] = 0, o3[A8 + 24 >> 2] = 0, o3[A8 + 28 >> 2] = 0, o3[A8 + 16 >> 2] = 0, o3[A8 + 20 >> 2] = 0, o3[A8 + 8 >> 2] = 0, o3[A8 + 12 >> 2] = 0, o3[A8 >> 2] = 0, o3[A8 + 4 >> 2] = 0, o3[A8 + 44 >> 2] = 0, o3[A8 + 48 >> 2] = 0, o3[(c4 = A8 + 40 | 0) >> 2] = 1, o3[A8 + 52 >> 2] = 0, o3[A8 + 56 >> 2] = 0, o3[A8 + 60 >> 2] = 0, o3[A8 + 64 >> 2] = 0, o3[A8 + 68 >> 2] = 0, o3[A8 + 72 >> 2] = 0, o3[A8 + 76 >> 2] = 0, o3[A8 + 80 >> 2] = 1, MA(A8 + 84 | 0, 0, 76), C4 = A8 + 120 | 0, B4 = A8 + 80 | 0, I7 = g6 + 208 | 0, n4 = g6 + 168 | 0, r4 = g6 + 248 | 0, Q4 = 1; q3(f4 = g6 + 8 | 0, Q4 >>> 1 | 0, E3[(g6 + 288 | 0) + Q4 | 0]), K3(i4 = g6 + 128 | 0, A8, f4), F3(A8, i4, r4), F3(c4, n4, I7), F3(B4, I7, r4), F3(C4, i4, n4), i4 = Q4 >>> 0 < 62, Q4 = Q4 + 2 | 0, i4; )
                        ;
                      for (Q4 = o3[A8 + 8 >> 2], i4 = o3[A8 + 12 >> 2], f4 = o3[A8 + 16 >> 2], t4 = o3[A8 + 20 >> 2], y4 = o3[A8 + 24 >> 2], w4 = o3[A8 + 28 >> 2], e4 = o3[A8 >> 2], h4 = o3[A8 + 4 >> 2], s4 = o3[A8 + 36 >> 2], o3[g6 + 392 >> 2] = o3[A8 + 32 >> 2], o3[g6 + 396 >> 2] = s4, o3[g6 + 384 >> 2] = y4, o3[g6 + 388 >> 2] = w4, o3[g6 + 376 >> 2] = f4, o3[g6 + 380 >> 2] = t4, o3[g6 + 368 >> 2] = Q4, o3[g6 + 372 >> 2] = i4, o3[g6 + 360 >> 2] = e4, o3[g6 + 364 >> 2] = h4, Q4 = o3[A8 + 40 >> 2], i4 = o3[A8 + 44 >> 2], f4 = o3[A8 + 48 >> 2], t4 = o3[A8 + 52 >> 2], y4 = o3[A8 + 56 >> 2], w4 = o3[A8 + 60 >> 2], h4 = o3[(e4 = A8 - -64 | 0) >> 2], e4 = o3[e4 + 4 >> 2], s4 = o3[A8 + 76 >> 2], o3[g6 + 432 >> 2] = o3[A8 + 72 >> 2], o3[g6 + 436 >> 2] = s4, o3[g6 + 424 >> 2] = h4, o3[g6 + 428 >> 2] = e4, o3[g6 + 416 >> 2] = y4, o3[g6 + 420 >> 2] = w4, o3[g6 + 408 >> 2] = f4, o3[g6 + 412 >> 2] = t4, o3[g6 + 400 >> 2] = Q4, o3[g6 + 404 >> 2] = i4, Q4 = o3[A8 + 80 >> 2], i4 = o3[A8 + 84 >> 2], f4 = o3[A8 + 88 >> 2], t4 = o3[A8 + 92 >> 2], y4 = o3[A8 + 96 >> 2], w4 = o3[A8 + 100 >> 2], e4 = o3[A8 + 104 >> 2], h4 = o3[A8 + 108 >> 2], s4 = o3[A8 + 116 >> 2], o3[g6 + 472 >> 2] = o3[A8 + 112 >> 2], o3[g6 + 476 >> 2] = s4, o3[g6 + 464 >> 2] = e4, o3[g6 + 468 >> 2] = h4, o3[g6 + 456 >> 2] = y4, o3[g6 + 460 >> 2] = w4, o3[g6 + 448 >> 2] = f4, o3[g6 + 452 >> 2] = t4, o3[g6 + 440 >> 2] = Q4, o3[g6 + 444 >> 2] = i4, l3(Q4 = g6 + 128 | 0, i4 = g6 + 360 | 0), F3(i4, Q4, r4), F3(f4 = g6 + 400 | 0, n4, I7), F3(t4 = g6 + 440 | 0, I7, r4), l3(Q4, i4), F3(i4, Q4, r4), F3(f4, n4, I7), F3(t4, I7, r4), l3(Q4, i4), F3(i4, Q4, r4), F3(f4, n4, I7), F3(t4, I7, r4), l3(Q4, i4), F3(A8, Q4, r4), F3(c4, n4, I7), F3(B4, I7, r4), F3(C4, Q4, n4), Q4 = 0; q3(f4 = g6 + 8 | 0, Q4 >>> 1 | 0, E3[(g6 + 288 | 0) + Q4 | 0]), K3(i4 = g6 + 128 | 0, A8, f4), F3(A8, i4, r4), F3(c4, n4, I7), F3(B4, I7, r4), F3(C4, i4, n4), i4 = Q4 >>> 0 < 62, Q4 = Q4 + 2 | 0, i4; )
                        ;
                      D3 = g6 + 480 | 0;
                    }
                    function m3(A8, I7, g6, C4) {
                      var B4, Q4 = 0, i4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, w4 = 0, h4 = 0, s4 = 0;
                      if (D3 = B4 = D3 - 704 | 0, g6 | C4)
                        if (Q4 = (C4 << 3 | g6 >>> 29) + (i4 = n4 = o3[A8 + 76 >> 2]) | 0, f4 = (t4 = o3[A8 + 72 >> 2]) + (r4 = g6 << 3) | 0, o3[A8 + 72 >> 2] = f4, Q4 = r4 >>> 0 > f4 >>> 0 ? Q4 + 1 | 0 : Q4, o3[A8 + 76 >> 2] = Q4, n4 = o3[4 + (r4 = A8 - -64 | 0) >> 2], n4 = (e4 = Q4 = (0 | Q4) == (0 | i4) & f4 >>> 0 < t4 >>> 0 | Q4 >>> 0 < i4 >>> 0) >>> 0 > (Q4 = Q4 + o3[r4 >> 2] | 0) >>> 0 ? n4 + 1 | 0 : n4, f4 = (e4 = C4 >>> 29 | 0) + Q4 | 0, Q4 = n4, o3[r4 >> 2] = f4, o3[r4 + 4 >> 2] = f4 >>> 0 < e4 >>> 0 ? Q4 + 1 | 0 : Q4, (0 | (n4 = e4 = 0 - ((Q4 = 0) + ((r4 = 127 & ((7 & i4) << 29 | t4 >>> 3)) >>> 0 > 128) | 0) | 0)) == (0 | C4) & g6 >>> 0 >= (f4 = 128 - r4 | 0) >>> 0 | C4 >>> 0 > n4 >>> 0) {
                          if (i4 = 0, n4 = 0, !Q4 & (127 ^ r4) >>> 0 >= 3 | Q4)
                            for (s4 = 252 & f4, t4 = A8 + 80 | 0; E3[(Q4 = i4 + r4 | 0) + t4 | 0] = a3[I7 + i4 | 0], E3[t4 + (r4 + (Q4 = 1 | i4) | 0) | 0] = a3[I7 + Q4 | 0], E3[t4 + (r4 + (Q4 = 2 | i4) | 0) | 0] = a3[I7 + Q4 | 0], E3[t4 + (r4 + (Q4 = 3 | i4) | 0) | 0] = a3[I7 + Q4 | 0], Q4 = n4, n4 = (i4 = i4 + 4 | 0) >>> 0 < 4 ? Q4 + 1 | 0 : Q4, Q4 = y4, y4 = Q4 = (w4 = w4 + 4 | 0) >>> 0 < 4 ? Q4 + 1 | 0 : Q4, (0 | w4) != (0 | s4) | (0 | h4) != (0 | Q4); )
                              ;
                          if (t4 = Q4 = 0, Q4 | (y4 = 3 & f4))
                            for (; E3[80 + (A8 + (Q4 = i4 + r4 | 0) | 0) | 0] = a3[I7 + i4 | 0], Q4 = n4, n4 = (i4 = i4 + 1 | 0) ? Q4 : Q4 + 1 | 0, Q4 = h4, h4 = Q4 = (c4 = c4 + 1 | 0) ? Q4 : Q4 + 1 | 0, (0 | y4) != (0 | c4) | (0 | t4) != (0 | Q4); )
                              ;
                          if (p3(A8, A8 + 80 | 0, B4, i4 = B4 + 640 | 0), I7 = I7 + f4 | 0, !(C4 = C4 - ((g6 >>> 0 < f4 >>> 0) + e4 | 0) | 0) & (g6 = g6 - f4 | 0) >>> 0 > 127 | C4)
                            for (; p3(A8, I7, B4, i4), I7 = I7 + 128 | 0, !(C4 = C4 - (g6 >>> 0 < 128) | 0) & (g6 = g6 - 128 | 0) >>> 0 > 127 | C4; )
                              ;
                          if (g6 | C4) {
                            if (w4 = 3 & g6, f4 = 0, c4 = 0, h4 = 0, i4 = 0, n4 = 0, !C4 & g6 >>> 0 >= 4 | C4)
                              for (r4 = -4 & g6, t4 = C4, y4 = A8 + 80 | 0, g6 = 0, C4 = 0; E3[i4 + y4 | 0] = a3[I7 + i4 | 0], E3[(Q4 = 1 | i4) + y4 | 0] = a3[I7 + Q4 | 0], E3[(Q4 = 2 | i4) + y4 | 0] = a3[I7 + Q4 | 0], E3[(Q4 = 3 | i4) + y4 | 0] = a3[I7 + Q4 | 0], Q4 = n4, n4 = (i4 = i4 + 4 | 0) >>> 0 < 4 ? Q4 + 1 | 0 : Q4, Q4 = C4, C4 = Q4 = (g6 = g6 + 4 | 0) >>> 0 < 4 ? Q4 + 1 | 0 : Q4, (0 | g6) != (0 | r4) | (0 | t4) != (0 | Q4); )
                                ;
                            if (f4 | w4)
                              for (; E3[80 + (A8 + i4 | 0) | 0] = a3[I7 + i4 | 0], n4 = (i4 = i4 + 1 | 0) ? n4 : n4 + 1 | 0, Q4 = h4, h4 = Q4 = (c4 = c4 + 1 | 0) ? Q4 : Q4 + 1 | 0, (0 | c4) != (0 | w4) | (0 | f4) != (0 | Q4); )
                                ;
                          }
                          $A(B4, 704);
                        } else {
                          if (i4 = 0, n4 = 0, !C4 & g6 >>> 0 >= 4 | C4)
                            for (f4 = -4 & g6, t4 = C4, C4 = A8 + 80 | 0; E3[C4 + (Q4 = i4 + r4 | 0) | 0] = a3[I7 + i4 | 0], E3[C4 + (e4 = r4 + (Q4 = 1 | i4) | 0) | 0] = a3[I7 + Q4 | 0], E3[C4 + (e4 = r4 + (Q4 = 2 | i4) | 0) | 0] = a3[I7 + Q4 | 0], E3[C4 + (e4 = r4 + (Q4 = 3 | i4) | 0) | 0] = a3[I7 + Q4 | 0], Q4 = n4, n4 = (i4 = i4 + 4 | 0) >>> 0 < 4 ? Q4 + 1 | 0 : Q4, Q4 = y4, y4 = Q4 = (w4 = w4 + 4 | 0) >>> 0 < 4 ? Q4 + 1 | 0 : Q4, (0 | f4) != (0 | w4) | (0 | t4) != (0 | Q4); )
                              ;
                          if ((g6 &= 3) | (C4 = 0))
                            for (; E3[80 + (A8 + (Q4 = i4 + r4 | 0) | 0) | 0] = a3[I7 + i4 | 0], n4 = (i4 = i4 + 1 | 0) ? n4 : n4 + 1 | 0, Q4 = h4, h4 = Q4 = (c4 = c4 + 1 | 0) ? Q4 : Q4 + 1 | 0, (0 | g6) != (0 | c4) | (0 | C4) != (0 | Q4); )
                              ;
                        }
                      return D3 = B4 + 704 | 0, 0;
                    }
                    function d3(A8, I7, g6) {
                      var C4 = 0, B4 = 0, Q4 = 0, i4 = 0, o4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0;
                      for (B4 = 2036477234, i4 = 857760878, C4 = 1634760805, n4 = 1797285236, Q4 = a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24, t4 = a3[I7 + 8 | 0] | a3[I7 + 9 | 0] << 8 | a3[I7 + 10 | 0] << 16 | a3[I7 + 11 | 0] << 24, o4 = a3[I7 + 4 | 0] | a3[I7 + 5 | 0] << 8 | a3[I7 + 6 | 0] << 16 | a3[I7 + 7 | 0] << 24, e4 = a3[g6 + 28 | 0] | a3[g6 + 29 | 0] << 8 | a3[g6 + 30 | 0] << 16 | a3[g6 + 31 | 0] << 24, r4 = a3[g6 + 24 | 0] | a3[g6 + 25 | 0] << 8 | a3[g6 + 26 | 0] << 16 | a3[g6 + 27 | 0] << 24, p4 = a3[g6 + 20 | 0] | a3[g6 + 21 | 0] << 8 | a3[g6 + 22 | 0] << 16 | a3[g6 + 23 | 0] << 24, c4 = a3[g6 + 16 | 0] | a3[g6 + 17 | 0] << 8 | a3[g6 + 18 | 0] << 16 | a3[g6 + 19 | 0] << 24, y4 = a3[g6 + 12 | 0] | a3[g6 + 13 | 0] << 8 | a3[g6 + 14 | 0] << 16 | a3[g6 + 15 | 0] << 24, D4 = a3[g6 + 8 | 0] | a3[g6 + 9 | 0] << 8 | a3[g6 + 10 | 0] << 16 | a3[g6 + 11 | 0] << 24, w4 = a3[g6 + 4 | 0] | a3[g6 + 5 | 0] << 8 | a3[g6 + 6 | 0] << 16 | a3[g6 + 7 | 0] << 24, I7 = a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24, g6 = a3[0 | g6] | a3[g6 + 1 | 0] << 8 | a3[g6 + 2 | 0] << 16 | a3[g6 + 3 | 0] << 24; f4 = g6, g6 = YA((h4 = I7) ^ (I7 = g6 + C4 | 0), 16), f4 = c4 = YA(f4 ^ (C4 = g6 + c4 | 0), 12), u4 = YA((h4 = I7 + c4 | 0) ^ g6, 8), I7 = YA(f4 ^ (c4 = u4 + C4 | 0), 7), C4 = y4, y4 = YA((g6 = n4 + y4 | 0) ^ Q4, 16), C4 = YA(C4 ^ (e4 = y4 + e4 | 0), 12), Q4 = D4, n4 = YA((B4 = B4 + D4 | 0) ^ t4, 16), Q4 = YA(Q4 ^ (D4 = n4 + r4 | 0), 12), r4 = YA((B4 = Q4 + B4 | 0) ^ n4, 8), g6 = YA(r4 ^ (n4 = I7 + (s4 = g6 + C4 | 0) | 0), 16), t4 = YA((i4 = i4 + w4 | 0) ^ o4, 16), w4 = YA((o4 = t4 + p4 | 0) ^ w4, 12), f4 = I7, I7 = YA((i4 = i4 + w4 | 0) ^ t4, 8), f4 = YA(f4 ^ (o4 = g6 + (k4 = I7 + o4 | 0) | 0), 12), t4 = YA(g6 ^ (n4 = f4 + n4 | 0), 8), g6 = YA((p4 = t4 + o4 | 0) ^ f4, 7), f4 = B4, B4 = C4, s4 = YA(y4 ^ s4, 8), B4 = YA(B4 ^ (C4 = s4 + e4 | 0), 7), y4 = YA((o4 = f4 + B4 | 0) ^ I7, 16), e4 = YA((I7 = y4 + c4 | 0) ^ B4, 12), o4 = YA(y4 ^ (B4 = e4 + o4 | 0), 8), y4 = YA((c4 = I7 + o4 | 0) ^ e4, 7), I7 = YA((I7 = Q4) ^ (Q4 = r4 + D4 | 0), 7), D4 = YA((i4 = I7 + i4 | 0) ^ u4, 16), r4 = YA(I7 ^ (C4 = D4 + C4 | 0), 12), I7 = YA(D4 ^ (i4 = r4 + i4 | 0), 8), D4 = YA((e4 = C4 + I7 | 0) ^ r4, 7), f4 = Q4, C4 = YA(w4 ^ k4, 7), r4 = YA((Q4 = C4 + h4 | 0) ^ s4, 16), h4 = YA(C4 ^ (w4 = f4 + r4 | 0), 12), Q4 = YA(r4 ^ (C4 = h4 + Q4 | 0), 8), w4 = YA((r4 = w4 + Q4 | 0) ^ h4, 7), 10 != (0 | (F4 = F4 + 1 | 0)); )
                        ;
                      E3[0 | A8] = C4, E3[A8 + 1 | 0] = C4 >>> 8, E3[A8 + 2 | 0] = C4 >>> 16, E3[A8 + 3 | 0] = C4 >>> 24, E3[A8 + 28 | 0] = Q4, E3[A8 + 29 | 0] = Q4 >>> 8, E3[A8 + 30 | 0] = Q4 >>> 16, E3[A8 + 31 | 0] = Q4 >>> 24, E3[A8 + 24 | 0] = t4, E3[A8 + 25 | 0] = t4 >>> 8, E3[A8 + 26 | 0] = t4 >>> 16, E3[A8 + 27 | 0] = t4 >>> 24, E3[A8 + 20 | 0] = o4, E3[A8 + 21 | 0] = o4 >>> 8, E3[A8 + 22 | 0] = o4 >>> 16, E3[A8 + 23 | 0] = o4 >>> 24, E3[A8 + 16 | 0] = I7, E3[A8 + 17 | 0] = I7 >>> 8, E3[A8 + 18 | 0] = I7 >>> 16, E3[A8 + 19 | 0] = I7 >>> 24, E3[A8 + 12 | 0] = n4, E3[A8 + 13 | 0] = n4 >>> 8, E3[A8 + 14 | 0] = n4 >>> 16, E3[A8 + 15 | 0] = n4 >>> 24, E3[A8 + 8 | 0] = B4, E3[A8 + 9 | 0] = B4 >>> 8, E3[A8 + 10 | 0] = B4 >>> 16, E3[A8 + 11 | 0] = B4 >>> 24, E3[A8 + 4 | 0] = i4, E3[A8 + 5 | 0] = i4 >>> 8, E3[A8 + 6 | 0] = i4 >>> 16, E3[A8 + 7 | 0] = i4 >>> 24;
                    }
                    function L3(A8, I7, g6) {
                      var C4 = 0, B4 = 0, Q4 = 0, i4 = 0, o4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0;
                      for (C4 = 1797285236, r4 = 2036477234, f4 = 857760878, B4 = 1634760805, Q4 = a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24, o4 = a3[I7 + 8 | 0] | a3[I7 + 9 | 0] << 8 | a3[I7 + 10 | 0] << 16 | a3[I7 + 11 | 0] << 24, i4 = a3[I7 + 4 | 0] | a3[I7 + 5 | 0] << 8 | a3[I7 + 6 | 0] << 16 | a3[I7 + 7 | 0] << 24, h4 = a3[g6 + 28 | 0] | a3[g6 + 29 | 0] << 8 | a3[g6 + 30 | 0] << 16 | a3[g6 + 31 | 0] << 24, w4 = a3[g6 + 24 | 0] | a3[g6 + 25 | 0] << 8 | a3[g6 + 26 | 0] << 16 | a3[g6 + 27 | 0] << 24, s4 = 20, y4 = a3[g6 + 20 | 0] | a3[g6 + 21 | 0] << 8 | a3[g6 + 22 | 0] << 16 | a3[g6 + 23 | 0] << 24, D4 = a3[g6 + 16 | 0] | a3[g6 + 17 | 0] << 8 | a3[g6 + 18 | 0] << 16 | a3[g6 + 19 | 0] << 24, t4 = a3[g6 + 12 | 0] | a3[g6 + 13 | 0] << 8 | a3[g6 + 14 | 0] << 16 | a3[g6 + 15 | 0] << 24, e4 = a3[g6 + 8 | 0] | a3[g6 + 9 | 0] << 8 | a3[g6 + 10 | 0] << 16 | a3[g6 + 11 | 0] << 24, c4 = a3[g6 + 4 | 0] | a3[g6 + 5 | 0] << 8 | a3[g6 + 6 | 0] << 16 | a3[g6 + 7 | 0] << 24, I7 = a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24, g6 = a3[0 | g6] | a3[g6 + 1 | 0] << 8 | a3[g6 + 2 | 0] << 16 | a3[g6 + 3 | 0] << 24; n4 = YA(g6 + f4 | 0, 7) ^ Q4, p4 = YA(n4 + f4 | 0, 9) ^ w4, t4 = YA(B4 + y4 | 0, 7) ^ t4, u4 = YA(t4 + B4 | 0, 9) ^ o4, k4 = YA(u4 + t4 | 0, 13) ^ y4, e4 = YA(C4 + D4 | 0, 7) ^ e4, i4 = YA(e4 + C4 | 0, 9) ^ i4, o4 = YA(i4 + e4 | 0, 13) ^ D4, C4 = YA(i4 + o4 | 0, 18) ^ C4, Q4 = YA(I7 + r4 | 0, 7) ^ h4, y4 = k4 ^ YA(C4 + Q4 | 0, 7), w4 = p4 ^ YA(y4 + C4 | 0, 9), h4 = YA(y4 + w4 | 0, 13) ^ Q4, C4 = YA(w4 + h4 | 0, 18) ^ C4, c4 = YA(Q4 + r4 | 0, 9) ^ c4, F4 = YA(c4 + Q4 | 0, 13) ^ I7, I7 = YA(F4 + c4 | 0, 18) ^ r4, D4 = YA(I7 + n4 | 0, 7) ^ o4, o4 = YA(D4 + I7 | 0, 9) ^ u4, Q4 = YA(o4 + D4 | 0, 13) ^ n4, r4 = YA(Q4 + o4 | 0, 18) ^ I7, n4 = YA(n4 + p4 | 0, 13) ^ g6, g6 = YA(n4 + p4 | 0, 18) ^ f4, I7 = YA(g6 + t4 | 0, 7) ^ F4, i4 = YA(I7 + g6 | 0, 9) ^ i4, t4 = YA(I7 + i4 | 0, 13) ^ t4, f4 = YA(i4 + t4 | 0, 18) ^ g6, B4 = YA(u4 + k4 | 0, 18) ^ B4, g6 = YA(B4 + e4 | 0, 7) ^ n4, c4 = YA(g6 + B4 | 0, 9) ^ c4, e4 = YA(g6 + c4 | 0, 13) ^ e4, B4 = YA(c4 + e4 | 0, 18) ^ B4, n4 = s4 >>> 0 > 2, s4 = s4 - 2 | 0, n4; )
                        ;
                      return E3[0 | A8] = B4, E3[A8 + 1 | 0] = B4 >>> 8, E3[A8 + 2 | 0] = B4 >>> 16, E3[A8 + 3 | 0] = B4 >>> 24, E3[A8 + 28 | 0] = Q4, E3[A8 + 29 | 0] = Q4 >>> 8, E3[A8 + 30 | 0] = Q4 >>> 16, E3[A8 + 31 | 0] = Q4 >>> 24, E3[A8 + 24 | 0] = o4, E3[A8 + 25 | 0] = o4 >>> 8, E3[A8 + 26 | 0] = o4 >>> 16, E3[A8 + 27 | 0] = o4 >>> 24, E3[A8 + 20 | 0] = i4, E3[A8 + 21 | 0] = i4 >>> 8, E3[A8 + 22 | 0] = i4 >>> 16, E3[A8 + 23 | 0] = i4 >>> 24, E3[A8 + 16 | 0] = I7, E3[A8 + 17 | 0] = I7 >>> 8, E3[A8 + 18 | 0] = I7 >>> 16, E3[A8 + 19 | 0] = I7 >>> 24, E3[A8 + 12 | 0] = C4, E3[A8 + 13 | 0] = C4 >>> 8, E3[A8 + 14 | 0] = C4 >>> 16, E3[A8 + 15 | 0] = C4 >>> 24, E3[A8 + 8 | 0] = r4, E3[A8 + 9 | 0] = r4 >>> 8, E3[A8 + 10 | 0] = r4 >>> 16, E3[A8 + 11 | 0] = r4 >>> 24, E3[A8 + 4 | 0] = f4, E3[A8 + 5 | 0] = f4 >>> 8, E3[A8 + 6 | 0] = f4 >>> 16, E3[A8 + 7 | 0] = f4 >>> 24, 0;
                    }
                    function R3(A8, I7, g6, C4, B4, i4, E4) {
                      var a4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0;
                      if (I7 - 65 >>> 0 < 4294967232 | E4 >>> 0 > 64)
                        A8 = -1;
                      else {
                        e4 = a4 = D3, D3 = a4 = a4 - 512 & -64;
                        A: {
                          I:
                            if (!(!(!(C4 | B4) | g6) | !A8 | ((n4 = 255 & I7) - 65 & 255) >>> 0 <= 191 | !(!(I7 = 255 & E4) || i4) | I7 >>> 0 >= 65)) {
                              if (I7) {
                                if (!i4)
                                  break I;
                                MA(a4 - -64 | 0, 0, 293), o3[a4 + 56 >> 2] = 327033209, o3[a4 + 60 >> 2] = 1541459225, o3[a4 + 48 >> 2] = -79577749, o3[a4 + 52 >> 2] = 528734635, o3[a4 + 40 >> 2] = 725511199, o3[a4 + 44 >> 2] = -1694144372, o3[a4 + 32 >> 2] = -1377402159, o3[a4 + 36 >> 2] = 1359893119, o3[a4 + 24 >> 2] = 1595750129, o3[a4 + 28 >> 2] = -1521486534, o3[a4 + 16 >> 2] = -23791573, o3[a4 + 20 >> 2] = 1013904242, o3[a4 + 8 >> 2] = -2067093701, o3[a4 + 12 >> 2] = -1150833019, o3[a4 >> 2] = -222443256 ^ (I7 << 8 | n4), o3[a4 + 4 >> 2] = I7 >>> 24 ^ 1779033703, MA((E4 = a4 + 384 | 0) + I7 | 0, 0, 128 - I7 | 0), HA(E4, i4, I7), HA(a4 + 96 | 0, E4, 128), o3[a4 + 352 >> 2] = 128, $A(E4, 128), I7 = 128;
                              } else
                                MA(a4 - -64 | 0, 0, 293), o3[a4 + 56 >> 2] = 327033209, o3[a4 + 60 >> 2] = 1541459225, o3[a4 + 48 >> 2] = -79577749, o3[a4 + 52 >> 2] = 528734635, o3[a4 + 40 >> 2] = 725511199, o3[a4 + 44 >> 2] = -1694144372, o3[a4 + 32 >> 2] = -1377402159, o3[a4 + 36 >> 2] = 1359893119, o3[a4 + 24 >> 2] = 1595750129, o3[a4 + 28 >> 2] = -1521486534, o3[a4 + 16 >> 2] = -23791573, o3[a4 + 20 >> 2] = 1013904242, o3[a4 + 8 >> 2] = -2067093701, o3[a4 + 12 >> 2] = -1150833019, o3[a4 >> 2] = -222443256 ^ n4, o3[a4 + 4 >> 2] = 1779033703, I7 = 0;
                              g:
                                if (C4 | B4)
                                  for (c4 = a4 + 224 | 0, r4 = a4 + 96 | 0; ; ) {
                                    if (E4 = I7 + r4 | 0, !B4 & C4 >>> 0 <= (i4 = 256 - I7 | 0) >>> 0) {
                                      HA(E4, g6, C4), o3[a4 + 352 >> 2] = C4 + o3[a4 + 352 >> 2];
                                      break g;
                                    }
                                    if (HA(E4, g6, i4), o3[a4 + 352 >> 2] = i4 + o3[a4 + 352 >> 2], f4 = I7 = o3[a4 + 68 >> 2], I7 = (t4 = (E4 = o3[a4 + 64 >> 2]) + 128 | 0) >>> 0 < 128 ? I7 + 1 | 0 : I7, o3[a4 + 64 >> 2] = t4, o3[a4 + 68 >> 2] = I7, I7 = o3[a4 + 76 >> 2], I7 = (f4 = E4 = -1 == (0 | f4) & E4 >>> 0 > 4294967167) >>> 0 > (E4 = E4 + o3[a4 + 72 >> 2] | 0) >>> 0 ? I7 + 1 | 0 : I7, o3[a4 + 72 >> 2] = E4, o3[a4 + 76 >> 2] = I7, h3(a4, r4), HA(r4, c4, 128), I7 = o3[a4 + 352 >> 2] - 128 | 0, o3[a4 + 352 >> 2] = I7, g6 = g6 + i4 | 0, !((B4 = B4 - (C4 >>> 0 < i4 >>> 0) | 0) | (C4 = C4 - i4 | 0)))
                                      break;
                                  }
                              G3(a4, A8, n4), D3 = e4;
                              break A;
                            }
                          mA(), Q3();
                        }
                        A8 = 0;
                      }
                      return A8;
                    }
                    function x3(A8, I7, g6, C4) {
                      var B4 = 0, Q4 = 0, i4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0;
                      A: {
                        if ((i4 = o3[A8 + 56 >> 2]) | (B4 = o3[A8 + 60 >> 2])) {
                          if (c4 = Q4 = 16 - i4 | 0, r4 = (Q4 = (0 | (n4 = 0 - ((i4 >>> 0 > 16) + B4 | 0) | 0)) == (0 | C4) & g6 >>> 0 > Q4 >>> 0 | C4 >>> 0 > n4 >>> 0) ? c4 : g6, c4 = Q4 = Q4 ? n4 : C4, Q4 | r4) {
                            if (Q4 = 0, i4 = 0, !c4 & r4 >>> 0 >= 4 | c4)
                              for (f4 = -4 & r4, n4 = A8 - -64 | 0; B4 = Q4 + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + Q4 | 0], B4 = (y4 = 1 | Q4) + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + y4 | 0], B4 = (y4 = 2 | Q4) + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + y4 | 0], B4 = (y4 = 3 | Q4) + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + y4 | 0], B4 = i4, i4 = (Q4 = Q4 + 4 | 0) >>> 0 < 4 ? B4 + 1 | 0 : B4, B4 = t4, t4 = B4 = (e4 = e4 + 4 | 0) >>> 0 < 4 ? B4 + 1 | 0 : B4, (0 | e4) != (0 | f4) | (0 | c4) != (0 | B4); )
                                ;
                            if (n4 = B4 = 0, B4 | (t4 = 3 & r4))
                              for (; e4 = Q4 + o3[A8 + 56 >> 2] | 0, E3[(A8 + e4 | 0) - -64 | 0] = a3[I7 + Q4 | 0], i4 = (Q4 = Q4 + 1 | 0) ? i4 : i4 + 1 | 0, B4 = w4, w4 = B4 = (D4 = D4 + 1 | 0) ? B4 : B4 + 1 | 0, (0 | t4) != (0 | D4) | (0 | n4) != (0 | B4); )
                                ;
                            i4 = o3[A8 + 56 >> 2], B4 = o3[A8 + 60 >> 2];
                          }
                          if (B4 = B4 + c4 | 0, B4 = (i4 = i4 + r4 | 0) >>> 0 < r4 >>> 0 ? B4 + 1 | 0 : B4, o3[A8 + 56 >> 2] = i4, o3[A8 + 60 >> 2] = B4, !B4 & i4 >>> 0 < 16)
                            break A;
                          N3(A8, A8 - -64 | 0, 16, 0), o3[A8 + 56 >> 2] = 0, o3[A8 + 60 >> 2] = 0, g6 = (i4 = g6) - r4 | 0, C4 = C4 - ((i4 >>> 0 < r4 >>> 0) + c4 | 0) | 0, I7 = I7 + r4 | 0;
                        }
                        if (!C4 & g6 >>> 0 >= 16 | C4 && (N3(A8, I7, i4 = -16 & g6, C4), g6 &= 15, C4 = 0, I7 = I7 + i4 | 0), g6 | C4) {
                          if (D4 = 0, w4 = 0, Q4 = 0, i4 = 0, !C4 & g6 >>> 0 >= 4 | C4)
                            for (r4 = 12 & g6, c4 = 0, n4 = A8 - -64 | 0, e4 = 0, t4 = 0; B4 = Q4 + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + Q4 | 0], B4 = (f4 = 1 | Q4) + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + f4 | 0], B4 = (f4 = 2 | Q4) + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + f4 | 0], B4 = (f4 = 3 | Q4) + o3[A8 + 56 >> 2] | 0, E3[B4 + n4 | 0] = a3[I7 + f4 | 0], i4 = (Q4 = Q4 + 4 | 0) >>> 0 < 4 ? i4 + 1 | 0 : i4, B4 = t4, t4 = B4 = (e4 = e4 + 4 | 0) >>> 0 < 4 ? B4 + 1 | 0 : B4, (0 | r4) != (0 | e4) | (0 | c4) != (0 | B4); )
                              ;
                          if (n4 = B4 = 0, B4 | (t4 = 3 & g6))
                            for (; B4 = Q4 + o3[A8 + 56 >> 2] | 0, E3[(A8 + B4 | 0) - -64 | 0] = a3[I7 + Q4 | 0], i4 = (Q4 = Q4 + 1 | 0) ? i4 : i4 + 1 | 0, B4 = w4, w4 = B4 = (D4 = D4 + 1 | 0) ? B4 : B4 + 1 | 0, (0 | t4) != (0 | D4) | (0 | n4) != (0 | B4); )
                              ;
                          i4 = C4 + o3[A8 + 60 >> 2] | 0, i4 = (I7 = g6 + o3[A8 + 56 >> 2] | 0) >>> 0 < g6 >>> 0 ? i4 + 1 | 0 : i4, o3[A8 + 56 >> 2] = I7, o3[A8 + 60 >> 2] = i4;
                        }
                      }
                    }
                    function j3(A8, I7, g6) {
                      var C4, B4 = 0, Q4 = 0, i4 = 0, E4 = 0, a4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0;
                      y4 = o3[I7 + 4 >> 2], B4 = o3[A8 + 4 >> 2], D4 = o3[I7 + 8 >> 2], Q4 = o3[A8 + 8 >> 2], w4 = o3[I7 + 12 >> 2], i4 = o3[A8 + 12 >> 2], h4 = o3[I7 + 16 >> 2], E4 = o3[A8 + 16 >> 2], s4 = o3[I7 + 20 >> 2], a4 = o3[A8 + 20 >> 2], p4 = o3[I7 + 24 >> 2], n4 = o3[A8 + 24 >> 2], e4 = o3[I7 + 28 >> 2], r4 = o3[A8 + 28 >> 2], u4 = o3[I7 + 32 >> 2], f4 = o3[A8 + 32 >> 2], k4 = o3[I7 + 36 >> 2], t4 = o3[A8 + 36 >> 2], g6 = 0 - g6 | 0, c4 = o3[A8 >> 2], o3[A8 >> 2] = g6 & (c4 ^ o3[I7 >> 2]) ^ c4, o3[A8 + 36 >> 2] = t4 ^ g6 & (t4 ^ k4), o3[A8 + 32 >> 2] = f4 ^ g6 & (f4 ^ u4), o3[A8 + 28 >> 2] = r4 ^ g6 & (r4 ^ e4), o3[A8 + 24 >> 2] = n4 ^ g6 & (n4 ^ p4), o3[A8 + 20 >> 2] = a4 ^ g6 & (a4 ^ s4), o3[A8 + 16 >> 2] = E4 ^ g6 & (E4 ^ h4), o3[A8 + 12 >> 2] = i4 ^ g6 & (i4 ^ w4), o3[A8 + 8 >> 2] = Q4 ^ g6 & (Q4 ^ D4), o3[A8 + 4 >> 2] = B4 ^ g6 & (B4 ^ y4), B4 = o3[A8 + 40 >> 2], y4 = o3[I7 + 40 >> 2], Q4 = o3[A8 + 44 >> 2], D4 = o3[I7 + 44 >> 2], i4 = o3[A8 + 48 >> 2], w4 = o3[I7 + 48 >> 2], E4 = o3[A8 + 52 >> 2], h4 = o3[I7 + 52 >> 2], a4 = o3[A8 + 56 >> 2], s4 = o3[I7 + 56 >> 2], n4 = o3[A8 + 60 >> 2], p4 = o3[I7 + 60 >> 2], r4 = o3[(e4 = A8 - -64 | 0) >> 2], u4 = o3[I7 - -64 >> 2], f4 = o3[A8 + 68 >> 2], k4 = o3[I7 + 68 >> 2], t4 = o3[A8 + 72 >> 2], c4 = o3[I7 + 72 >> 2], C4 = o3[A8 + 76 >> 2], o3[A8 + 76 >> 2] = C4 ^ g6 & (o3[I7 + 76 >> 2] ^ C4), o3[A8 + 72 >> 2] = t4 ^ g6 & (t4 ^ c4), o3[A8 + 68 >> 2] = f4 ^ g6 & (f4 ^ k4), o3[e4 >> 2] = r4 ^ g6 & (r4 ^ u4), o3[A8 + 60 >> 2] = n4 ^ g6 & (n4 ^ p4), o3[A8 + 56 >> 2] = a4 ^ g6 & (a4 ^ s4), o3[A8 + 52 >> 2] = E4 ^ g6 & (E4 ^ h4), o3[A8 + 48 >> 2] = i4 ^ g6 & (i4 ^ w4), o3[A8 + 44 >> 2] = Q4 ^ g6 & (Q4 ^ D4), o3[A8 + 40 >> 2] = B4 ^ g6 & (B4 ^ y4), B4 = o3[A8 + 80 >> 2], y4 = o3[I7 + 80 >> 2], Q4 = o3[A8 + 84 >> 2], D4 = o3[I7 + 84 >> 2], i4 = o3[A8 + 88 >> 2], w4 = o3[I7 + 88 >> 2], E4 = o3[A8 + 92 >> 2], h4 = o3[I7 + 92 >> 2], a4 = o3[A8 + 96 >> 2], s4 = o3[I7 + 96 >> 2], n4 = o3[A8 + 100 >> 2], p4 = o3[I7 + 100 >> 2], r4 = o3[A8 + 104 >> 2], e4 = o3[I7 + 104 >> 2], f4 = o3[A8 + 108 >> 2], u4 = o3[I7 + 108 >> 2], t4 = o3[A8 + 112 >> 2], k4 = o3[I7 + 112 >> 2], c4 = o3[I7 + 116 >> 2], I7 = o3[A8 + 116 >> 2], o3[A8 + 116 >> 2] = g6 & (c4 ^ I7) ^ I7, o3[A8 + 112 >> 2] = t4 ^ g6 & (t4 ^ k4), o3[A8 + 108 >> 2] = f4 ^ g6 & (f4 ^ u4), o3[A8 + 104 >> 2] = r4 ^ g6 & (r4 ^ e4), o3[A8 + 100 >> 2] = n4 ^ g6 & (n4 ^ p4), o3[A8 + 96 >> 2] = a4 ^ g6 & (a4 ^ s4), o3[A8 + 92 >> 2] = E4 ^ g6 & (E4 ^ h4), o3[A8 + 88 >> 2] = i4 ^ g6 & (i4 ^ w4), o3[A8 + 84 >> 2] = Q4 ^ g6 & (Q4 ^ D4), o3[A8 + 80 >> 2] = B4 ^ g6 & (B4 ^ y4);
                    }
                    function X3(A8, I7) {
                      var g6, C4, B4 = 0;
                      for (D3 = g6 = D3 - 192 | 0, S3(C4 = g6 + 144 | 0, I7), S3(B4 = g6 + 96 | 0, C4), S3(B4, B4), F3(B4, I7, B4), F3(C4, C4, B4), S3(I7 = g6 + 48 | 0, C4), F3(B4, B4, I7), S3(I7, B4), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), F3(B4, I7, B4), S3(I7, B4), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), F3(I7, I7, B4), S3(g6, I7), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), S3(g6, g6), F3(I7, g6, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), F3(B4, I7, B4), S3(I7, B4), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), F3(I7, I7, B4), S3(g6, I7), I7 = 1; S3(g6, g6), 100 != (0 | (I7 = I7 + 1 | 0)); )
                        ;
                      F3(I7 = g6 + 48 | 0, g6, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), S3(I7, I7), F3(B4 = g6 + 96 | 0, I7, B4), S3(B4, B4), S3(B4, B4), S3(B4, B4), S3(B4, B4), S3(B4, B4), F3(A8, B4, g6 + 144 | 0), D3 = g6 + 192 | 0;
                    }
                    function q3(A8, I7, g6) {
                      var C4, B4 = 0, Q4 = 0, i4 = 0, E4 = 0, a4 = 0, n4 = 0, f4 = 0, t4 = 0;
                      D3 = C4 = D3 - 128 | 0, o3[A8 >> 2] = 1, o3[A8 + 4 >> 2] = 0, o3[A8 + 8 >> 2] = 0, o3[A8 + 12 >> 2] = 0, o3[A8 + 16 >> 2] = 0, o3[A8 + 20 >> 2] = 0, o3[A8 + 24 >> 2] = 0, o3[A8 + 28 >> 2] = 0, o3[A8 + 32 >> 2] = 0, o3[A8 + 36 >> 2] = 0, o3[A8 + 40 >> 2] = 1, MA(A8 + 44 | 0, 0, 76), j3(A8, B4 = r3(I7, 960) + 2704 | 0, (255 & (1 ^ (I7 = g6 - ((g6 >> 31 & g6) << 1) | 0))) - 1 >>> 31 | 0), j3(A8, B4 + 120 | 0, (255 & (2 ^ I7)) - 1 >>> 31 | 0), j3(A8, B4 + 240 | 0, (255 & (3 ^ I7)) - 1 >>> 31 | 0), j3(A8, B4 + 360 | 0, (255 & (4 ^ I7)) - 1 >>> 31 | 0), j3(A8, B4 + 480 | 0, (255 & (5 ^ I7)) - 1 >>> 31 | 0), j3(A8, B4 + 600 | 0, (255 & (6 ^ I7)) - 1 >>> 31 | 0), j3(A8, B4 + 720 | 0, (255 & (7 ^ I7)) - 1 >>> 31 | 0), j3(A8, B4 + 840 | 0, (255 & (8 ^ I7)) - 1 >>> 31 | 0), Q4 = o3[A8 + 40 >> 2], i4 = o3[A8 + 44 >> 2], E4 = o3[A8 + 48 >> 2], a4 = o3[A8 + 52 >> 2], n4 = o3[A8 + 56 >> 2], f4 = o3[A8 + 60 >> 2], t4 = o3[(I7 = A8 - -64 | 0) >> 2], B4 = o3[I7 + 4 >> 2], I7 = o3[A8 + 76 >> 2], o3[C4 + 40 >> 2] = o3[A8 + 72 >> 2], o3[C4 + 44 >> 2] = I7, o3[C4 + 32 >> 2] = t4, o3[C4 + 36 >> 2] = B4, o3[C4 + 24 >> 2] = n4, o3[C4 + 28 >> 2] = f4, o3[C4 + 16 >> 2] = E4, o3[C4 + 20 >> 2] = a4, o3[C4 + 8 >> 2] = Q4, o3[C4 + 12 >> 2] = i4, Q4 = o3[A8 + 8 >> 2], i4 = o3[A8 + 12 >> 2], E4 = o3[A8 + 16 >> 2], a4 = o3[A8 + 20 >> 2], n4 = o3[A8 + 24 >> 2], f4 = o3[A8 + 28 >> 2], t4 = o3[A8 >> 2], B4 = o3[A8 + 4 >> 2], I7 = o3[A8 + 36 >> 2], o3[C4 + 80 >> 2] = o3[A8 + 32 >> 2], o3[C4 + 84 >> 2] = I7, o3[C4 + 72 >> 2] = n4, o3[C4 + 76 >> 2] = f4, o3[(I7 = C4 - -64 | 0) >> 2] = E4, o3[I7 + 4 >> 2] = a4, o3[C4 + 56 >> 2] = Q4, o3[C4 + 60 >> 2] = i4, o3[C4 + 48 >> 2] = t4, o3[C4 + 52 >> 2] = B4, Q4 = o3[A8 + 80 >> 2], i4 = o3[A8 + 84 >> 2], E4 = o3[A8 + 88 >> 2], a4 = o3[A8 + 92 >> 2], n4 = o3[A8 + 96 >> 2], f4 = o3[A8 + 100 >> 2], t4 = o3[A8 + 104 >> 2], B4 = o3[A8 + 108 >> 2], I7 = o3[A8 + 112 >> 2], o3[C4 + 124 >> 2] = 0 - o3[A8 + 116 >> 2], o3[C4 + 120 >> 2] = 0 - I7, o3[C4 + 116 >> 2] = 0 - B4, o3[C4 + 112 >> 2] = 0 - t4, o3[C4 + 108 >> 2] = 0 - f4, o3[C4 + 104 >> 2] = 0 - n4, o3[C4 + 100 >> 2] = 0 - a4, o3[C4 + 96 >> 2] = 0 - E4, o3[C4 + 92 >> 2] = 0 - i4, o3[C4 + 88 >> 2] = 0 - Q4, j3(A8, C4 + 8 | 0, (128 & g6) >>> 7 | 0), D3 = C4 + 128 | 0;
                    }
                    function z3(A8, I7, g6, C4) {
                      var B4 = 0, Q4 = 0, i4 = 0, o4 = 0, n4 = 0, r4 = 0, f4 = 0;
                      if (g6 | C4)
                        A:
                          for (f4 = A8 + 224 | 0, n4 = A8 + 96 | 0, Q4 = a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24; ; ) {
                            if (B4 = Q4 + n4 | 0, !C4 & g6 >>> 0 <= (i4 = 256 - Q4 | 0) >>> 0) {
                              HA(B4, I7, g6), I7 = (a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24) + g6 | 0, E3[A8 + 352 | 0] = I7, E3[A8 + 353 | 0] = I7 >>> 8, E3[A8 + 354 | 0] = I7 >>> 16, E3[A8 + 355 | 0] = I7 >>> 24;
                              break A;
                            }
                            if (HA(B4, I7, i4), B4 = (a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24) + i4 | 0, E3[A8 + 352 | 0] = B4, E3[A8 + 353 | 0] = B4 >>> 8, E3[A8 + 354 | 0] = B4 >>> 16, E3[A8 + 355 | 0] = B4 >>> 24, r4 = Q4 = a3[A8 + 68 | 0] | a3[A8 + 69 | 0] << 8 | a3[A8 + 70 | 0] << 16 | a3[A8 + 71 | 0] << 24, Q4 = (o4 = 128 + (B4 = a3[A8 + 64 | 0] | a3[A8 + 65 | 0] << 8 | a3[A8 + 66 | 0] << 16 | a3[A8 + 67 | 0] << 24) | 0) >>> 0 < 128 ? Q4 + 1 | 0 : Q4, E3[A8 + 64 | 0] = o4, E3[A8 + 65 | 0] = o4 >>> 8, E3[A8 + 66 | 0] = o4 >>> 16, E3[A8 + 67 | 0] = o4 >>> 24, E3[A8 + 68 | 0] = Q4, E3[A8 + 69 | 0] = Q4 >>> 8, E3[A8 + 70 | 0] = Q4 >>> 16, E3[A8 + 71 | 0] = Q4 >>> 24, Q4 = a3[A8 + 76 | 0] | a3[A8 + 77 | 0] << 8 | a3[A8 + 78 | 0] << 16 | a3[A8 + 79 | 0] << 24, Q4 = (r4 = B4 = -1 == (0 | r4) & B4 >>> 0 > 4294967167) >>> 0 > (B4 = B4 + (a3[A8 + 72 | 0] | a3[A8 + 73 | 0] << 8 | a3[A8 + 74 | 0] << 16 | a3[A8 + 75 | 0] << 24) | 0) >>> 0 ? Q4 + 1 | 0 : Q4, E3[A8 + 72 | 0] = B4, E3[A8 + 73 | 0] = B4 >>> 8, E3[A8 + 74 | 0] = B4 >>> 16, E3[A8 + 75 | 0] = B4 >>> 24, E3[A8 + 76 | 0] = Q4, E3[A8 + 77 | 0] = Q4 >>> 8, E3[A8 + 78 | 0] = Q4 >>> 16, E3[A8 + 79 | 0] = Q4 >>> 24, h3(A8, n4), HA(n4, f4, 128), B4 = Q4 = (a3[A8 + 352 | 0] | a3[A8 + 353 | 0] << 8 | a3[A8 + 354 | 0] << 16 | a3[A8 + 355 | 0] << 24) - 128 | 0, E3[A8 + 352 | 0] = B4, E3[A8 + 353 | 0] = B4 >>> 8, E3[A8 + 354 | 0] = B4 >>> 16, E3[A8 + 355 | 0] = B4 >>> 24, I7 = I7 + i4 | 0, !((C4 = C4 - (g6 >>> 0 < i4 >>> 0) | 0) | (g6 = g6 - i4 | 0)))
                              break;
                          }
                      return 0;
                    }
                    function V3(A8, I7) {
                      var g6, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, E4 = 0, a4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0;
                      C4 = o3[I7 + 40 >> 2], B4 = o3[I7 + 4 >> 2], Q4 = o3[I7 + 44 >> 2], i4 = o3[I7 + 8 >> 2], E4 = o3[I7 + 48 >> 2], a4 = o3[I7 + 12 >> 2], n4 = o3[I7 + 52 >> 2], r4 = o3[I7 + 16 >> 2], f4 = o3[I7 + 56 >> 2], e4 = o3[I7 + 20 >> 2], c4 = o3[I7 + 60 >> 2], y4 = o3[I7 + 24 >> 2], D4 = o3[(t4 = I7 - -64 | 0) >> 2], w4 = o3[I7 + 28 >> 2], h4 = o3[I7 + 68 >> 2], s4 = o3[I7 + 32 >> 2], p4 = o3[I7 + 72 >> 2], g6 = o3[I7 >> 2], o3[A8 + 36 >> 2] = o3[I7 + 36 >> 2] + o3[I7 + 76 >> 2], o3[A8 + 32 >> 2] = s4 + p4, o3[A8 + 28 >> 2] = w4 + h4, o3[A8 + 24 >> 2] = y4 + D4, o3[A8 + 20 >> 2] = e4 + c4, o3[A8 + 16 >> 2] = r4 + f4, o3[A8 + 12 >> 2] = a4 + n4, o3[A8 + 8 >> 2] = i4 + E4, o3[A8 + 4 >> 2] = B4 + Q4, o3[A8 >> 2] = C4 + g6, C4 = o3[I7 + 40 >> 2], B4 = o3[I7 + 4 >> 2], Q4 = o3[I7 + 44 >> 2], i4 = o3[I7 + 8 >> 2], E4 = o3[I7 + 48 >> 2], a4 = o3[I7 + 12 >> 2], n4 = o3[I7 + 52 >> 2], r4 = o3[I7 + 16 >> 2], f4 = o3[I7 + 56 >> 2], e4 = o3[I7 + 20 >> 2], c4 = o3[I7 + 60 >> 2], y4 = o3[I7 + 24 >> 2], t4 = o3[t4 >> 2], D4 = o3[I7 + 28 >> 2], w4 = o3[I7 + 68 >> 2], h4 = o3[I7 + 32 >> 2], s4 = o3[I7 + 72 >> 2], p4 = o3[I7 >> 2], o3[A8 + 76 >> 2] = o3[I7 + 76 >> 2] - o3[I7 + 36 >> 2], o3[A8 + 72 >> 2] = s4 - h4, o3[A8 + 68 >> 2] = w4 - D4, o3[A8 - -64 >> 2] = t4 - y4, o3[A8 + 60 >> 2] = c4 - e4, o3[A8 + 56 >> 2] = f4 - r4, o3[A8 + 52 >> 2] = n4 - a4, o3[A8 + 48 >> 2] = E4 - i4, o3[A8 + 44 >> 2] = Q4 - B4, o3[A8 + 40 >> 2] = C4 - p4, C4 = o3[I7 + 80 >> 2], B4 = o3[I7 + 84 >> 2], Q4 = o3[I7 + 88 >> 2], i4 = o3[I7 + 92 >> 2], E4 = o3[I7 + 96 >> 2], a4 = o3[I7 + 100 >> 2], n4 = o3[I7 + 104 >> 2], r4 = o3[I7 + 108 >> 2], f4 = o3[I7 + 116 >> 2], o3[A8 + 112 >> 2] = o3[I7 + 112 >> 2], o3[A8 + 116 >> 2] = f4, o3[A8 + 104 >> 2] = n4, o3[A8 + 108 >> 2] = r4, o3[A8 + 96 >> 2] = E4, o3[A8 + 100 >> 2] = a4, o3[A8 + 88 >> 2] = Q4, o3[A8 + 92 >> 2] = i4, o3[A8 + 80 >> 2] = C4, o3[A8 + 84 >> 2] = B4, F3(A8 + 120 | 0, I7 + 120 | 0, 1440);
                    }
                    function O3(A8, I7) {
                      var g6, C4, B4, Q4, i4, a4 = 0, n4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0;
                      (f4 = o3[A8 + 56 >> 2]) | (a4 = o3[A8 + 60 >> 2]) && (E3[f4 + (n4 = A8 - -64 | 0) | 0] = 1, !((h4 = f4 + 1 | 0) ? a4 : a4 + 1 | 0) & h4 >>> 0 <= 15 && MA(65 + (A8 + f4 | 0) | 0, 0, 15 - f4 | 0), E3[A8 + 80 | 0] = 1, N3(A8, n4, 16, 0)), h4 = o3[A8 + 52 >> 2], D4 = o3[A8 + 48 >> 2], n4 = o3[A8 + 44 >> 2], f4 = o3[A8 + 24 >> 2], e4 = o3[A8 + 28 >> 2] + (f4 >>> 26 | 0) | 0, t4 = o3[A8 + 32 >> 2] + (e4 >>> 26 | 0) | 0, g6 = o3[A8 + 36 >> 2] + (t4 >>> 26 | 0) | 0, a4 = (y4 = (f4 = (f4 = (67108863 & f4) + ((c4 = o3[A8 + 20 >> 2] + r3(g6 >>> 26 | 0, 5) | 0) >>> 26 | 0) | 0) & (e4 = (t4 = (i4 = (67108863 & g6) + ((Q4 = (C4 = 67108863 & t4) + ((B4 = (w4 = 67108863 & e4) + ((c4 = f4 + ((a4 = 5 + (y4 = 67108863 & c4) | 0) >>> 26 | 0) | 0) >>> 26 | 0) | 0) >>> 26 | 0) | 0) >>> 26 | 0) | 0) - 67108864 | 0) >> 31) | c4 & (t4 = 67108863 & (c4 = (t4 >>> 31 | 0) - 1 | 0))) << 26 | a4 & t4 | e4 & y4) + o3[A8 + 40 >> 2] | 0, E3[0 | I7] = a4, E3[I7 + 1 | 0] = a4 >>> 8, E3[I7 + 2 | 0] = a4 >>> 16, E3[I7 + 3 | 0] = a4 >>> 24, y4 = a4 >>> 0 < y4 >>> 0, a4 = (w4 = e4 & w4 | t4 & B4) << 20 | f4 >>> 6, f4 = 0, a4 = (n4 = a4 + n4 | 0) >>> 0 < a4 >>> 0 ? 1 : f4, a4 = (f4 = n4 + y4 | 0) >>> 0 < n4 >>> 0 ? a4 + 1 | 0 : a4, E3[(n4 = I7) + 4 | 0] = f4, E3[n4 + 5 | 0] = f4 >>> 8, E3[n4 + 6 | 0] = f4 >>> 16, E3[n4 + 7 | 0] = f4 >>> 24, f4 = 0, n4 = (n4 = (t4 = e4 & C4 | t4 & Q4) << 14 | w4 >>> 12) >>> 0 > (D4 = n4 + D4 | 0) >>> 0 ? 1 : f4, f4 = D4, D4 = a4, f4 = (a4 = f4 + a4 | 0) >>> 0 < D4 >>> 0 ? n4 + 1 | 0 : n4, E3[(n4 = I7) + 8 | 0] = a4, E3[n4 + 9 | 0] = a4 >>> 8, E3[n4 + 10 | 0] = a4 >>> 16, E3[n4 + 11 | 0] = a4 >>> 24, a4 = n4 = (c4 & i4 | e4 & g6) << 8 | t4 >>> 18, a4 = (a4 = f4) + (n4 = n4 + h4 | 0) | 0, E3[I7 + 12 | 0] = a4, E3[I7 + 13 | 0] = a4 >>> 8, E3[I7 + 14 | 0] = a4 >>> 16, E3[I7 + 15 | 0] = a4 >>> 24, $A(A8, 88);
                    }
                    function T3(A8, I7, g6) {
                      var C4, B4 = 0;
                      return D3 = C4 = D3 - 16 | 0, E3[C4 + 15 | 0] = 0, B4 = -1, 0 | nI[o3[8722]](A8, I7, g6) || (E3[C4 + 15 | 0] = a3[0 | A8] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 1 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 2 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 3 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 4 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 5 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 6 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 7 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 8 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 9 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 10 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 11 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 12 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 13 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 14 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 15 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 16 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 17 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 18 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 19 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 20 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 21 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 22 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 23 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 24 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 25 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 26 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 27 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 28 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 29 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 30 | 0] | a3[C4 + 15 | 0], E3[C4 + 15 | 0] = a3[A8 + 31 | 0] | a3[C4 + 15 | 0], B4 = (a3[C4 + 15 | 0] << 23) - 8388608 >> 31), D3 = C4 + 16 | 0, B4;
                    }
                    function W3(A8, I7) {
                      var g6, C4, B4, Q4, i4, a4, n4, f4 = 0, t4 = 0;
                      C4 = o3[I7 + 32 >> 2], B4 = o3[I7 + 28 >> 2], Q4 = o3[I7 + 24 >> 2], i4 = o3[I7 + 20 >> 2], a4 = o3[I7 + 16 >> 2], n4 = o3[I7 + 12 >> 2], f4 = o3[I7 + 4 >> 2], t4 = o3[I7 >> 2], g6 = o3[I7 + 36 >> 2], I7 = o3[I7 + 8 >> 2], t4 = r3((C4 + (B4 + (Q4 + (i4 + (a4 + (n4 + ((f4 + (t4 + (r3(g6, 19) + 16777216 >>> 25 | 0) >> 26) >> 25) + I7 >> 26) >> 25) >> 26) >> 25) >> 26) >> 25) >> 26) + g6 >> 25, 19) + t4 | 0, E3[0 | A8] = t4, E3[A8 + 2 | 0] = t4 >>> 16, E3[A8 + 1 | 0] = t4 >>> 8, f4 = f4 + (t4 >> 26) | 0, E3[A8 + 5 | 0] = f4 >>> 14, E3[A8 + 4 | 0] = f4 >>> 6, E3[A8 + 3 | 0] = t4 >>> 24 & 3 | f4 << 2, I7 = I7 + (f4 >> 25) | 0, E3[A8 + 8 | 0] = I7 >>> 13, E3[A8 + 7 | 0] = I7 >>> 5, E3[A8 + 6 | 0] = I7 << 3 | (29360128 & f4) >>> 22, t4 = (I7 >> 26) + n4 | 0, E3[A8 + 11 | 0] = t4 >>> 11, E3[A8 + 10 | 0] = t4 >>> 3, E3[A8 + 9 | 0] = t4 << 5 | (65011712 & I7) >>> 21, f4 = (t4 >> 25) + a4 | 0, E3[A8 + 15 | 0] = f4 >>> 18, E3[A8 + 14 | 0] = f4 >>> 10, E3[A8 + 13 | 0] = f4 >>> 2, I7 = (f4 >> 26) + i4 | 0, E3[A8 + 16 | 0] = I7, E3[A8 + 12 | 0] = f4 << 6 | (33030144 & t4) >>> 19, E3[A8 + 18 | 0] = I7 >>> 16, E3[A8 + 17 | 0] = I7 >>> 8, f4 = (I7 >> 25) + Q4 | 0, E3[A8 + 21 | 0] = f4 >>> 15, E3[A8 + 20 | 0] = f4 >>> 7, E3[A8 + 19 | 0] = I7 >>> 24 & 1 | f4 << 1, I7 = (f4 >> 26) + B4 | 0, E3[A8 + 24 | 0] = I7 >>> 13, E3[A8 + 23 | 0] = I7 >>> 5, E3[A8 + 22 | 0] = I7 << 3 | (58720256 & f4) >>> 23, f4 = (I7 >> 25) + C4 | 0, E3[A8 + 27 | 0] = f4 >>> 12, E3[A8 + 26 | 0] = f4 >>> 4, E3[A8 + 25 | 0] = f4 << 4 | (31457280 & I7) >>> 21, I7 = g6 + (f4 >> 26) | 0, E3[A8 + 30 | 0] = I7 >>> 10, E3[A8 + 29 | 0] = I7 >>> 2, E3[A8 + 31 | 0] = (33292288 & I7) >>> 18, E3[A8 + 28 | 0] = I7 << 6 | (66060288 & f4) >>> 20;
                    }
                    function Z2(A8, I7) {
                      var g6;
                      return o3[12 + (g6 = D3 - 16 | 0) >> 2] = A8, o3[g6 + 8 >> 2] = I7, o3[g6 + 4 >> 2] = 0, o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2]] ^ a3[o3[g6 + 8 >> 2]], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 1 | 0] ^ a3[o3[g6 + 8 >> 2] + 1 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 2 | 0] ^ a3[o3[g6 + 8 >> 2] + 2 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 3 | 0] ^ a3[o3[g6 + 8 >> 2] + 3 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 4 | 0] ^ a3[o3[g6 + 8 >> 2] + 4 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 5 | 0] ^ a3[o3[g6 + 8 >> 2] + 5 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 6 | 0] ^ a3[o3[g6 + 8 >> 2] + 6 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 7 | 0] ^ a3[o3[g6 + 8 >> 2] + 7 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 8 | 0] ^ a3[o3[g6 + 8 >> 2] + 8 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 9 | 0] ^ a3[o3[g6 + 8 >> 2] + 9 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 10 | 0] ^ a3[o3[g6 + 8 >> 2] + 10 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 11 | 0] ^ a3[o3[g6 + 8 >> 2] + 11 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 12 | 0] ^ a3[o3[g6 + 8 >> 2] + 12 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 13 | 0] ^ a3[o3[g6 + 8 >> 2] + 13 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 14 | 0] ^ a3[o3[g6 + 8 >> 2] + 14 | 0], o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + 15 | 0] ^ a3[o3[g6 + 8 >> 2] + 15 | 0], (o3[g6 + 4 >> 2] - 1 >>> 8 & 1) - 1 | 0;
                    }
                    function $2(A8, I7) {
                      var g6, C4 = 0, B4 = 0;
                      g6 = I7;
                      A:
                        if (C4 = 255 & I7) {
                          if (3 & A8)
                            for (; ; ) {
                              if (!(I7 = a3[0 | A8]) | (0 | I7) == (255 & g6))
                                break A;
                              if (!(3 & (A8 = A8 + 1 | 0)))
                                break;
                            }
                          I:
                            if (!((-1 ^ (I7 = o3[A8 >> 2])) & I7 - 16843009 & -2139062144))
                              for (C4 = r3(C4, 16843009); ; ) {
                                if ((-1 ^ (I7 ^= C4)) & I7 - 16843009 & -2139062144)
                                  break I;
                                if (I7 = o3[A8 + 4 >> 2], A8 = A8 + 4 | 0, I7 - 16843009 & (-1 ^ I7) & -2139062144)
                                  break;
                              }
                          for (; I7 = A8, (C4 = a3[0 | A8]) && (A8 = I7 + 1 | 0, (0 | C4) != (255 & g6)); )
                            ;
                          A8 = I7;
                        } else {
                          C4 = A8;
                          I: {
                            if (3 & A8)
                              for (; ; ) {
                                if (!a3[0 | A8])
                                  break I;
                                if (!(3 & (A8 = A8 + 1 | 0)))
                                  break;
                              }
                            for (; I7 = A8, A8 = A8 + 4 | 0, !((-1 ^ (B4 = o3[I7 >> 2])) & B4 - 16843009 & -2139062144); )
                              ;
                            for (; I7 = (A8 = I7) + 1 | 0, a3[0 | A8]; )
                              ;
                          }
                          A8 = C4 + (A8 - C4 | 0) | 0;
                        }
                      return a3[0 | A8] == (255 & g6) ? A8 : 0;
                    }
                    function AA(A8, I7) {
                      var g6, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, o4 = 0;
                      for (D3 = g6 = D3 - 192 | 0, EA(A8), MA(g6 - -64 | 0, 54, 128); E3[0 | (C4 = (i4 = g6 - -64 | 0) + B4 | 0)] = a3[0 | C4] ^ a3[I7 + B4 | 0], E3[0 | (Q4 = (C4 = 1 | B4) + i4 | 0)] = a3[0 | Q4] ^ a3[I7 + C4 | 0], E3[0 | (Q4 = (C4 = 2 | B4) + i4 | 0)] = a3[0 | Q4] ^ a3[I7 + C4 | 0], E3[0 | (C4 = (C4 = i4) + (i4 = 3 | B4) | 0)] = a3[0 | C4] ^ a3[I7 + i4 | 0], B4 = B4 + 4 | 0, 32 != (0 | (o4 = o4 + 4 | 0)); )
                        ;
                      for (m3(A8, B4 = g6 - -64 | 0, 128, 0), EA(i4 = A8 + 208 | 0), MA(B4, 92, 128), B4 = 0, o4 = 0; E3[0 | (C4 = (A8 = g6 - -64 | 0) + B4 | 0)] = a3[0 | C4] ^ a3[I7 + B4 | 0], E3[0 | (Q4 = (C4 = 1 | B4) + A8 | 0)] = a3[0 | Q4] ^ a3[I7 + C4 | 0], E3[0 | (Q4 = (C4 = 2 | B4) + A8 | 0)] = a3[0 | Q4] ^ a3[I7 + C4 | 0], E3[0 | (C4 = (C4 = A8) + (A8 = 3 | B4) | 0)] = a3[0 | C4] ^ a3[A8 + I7 | 0], B4 = B4 + 4 | 0, 32 != (0 | (o4 = o4 + 4 | 0)); )
                        ;
                      m3(i4, A8 = g6 - -64 | 0, 128, 0), $A(A8, 128), $A(g6, 64), D3 = g6 + 192 | 0;
                    }
                    function IA(A8, I7, g6, C4, B4, Q4, i4) {
                      var E4, a4, n4, r4, f4, t4 = 0;
                      return D3 = E4 = D3 - 352 | 0, L3(E4, Q4, i4), !((!B4 & C4 >>> 0 > A8 - g6 >>> 0 | 0 != (0 | B4)) & A8 >>> 0 > g6 >>> 0) & (!B4 & C4 >>> 0 <= g6 - A8 >>> 0 | A8 >>> 0 >= g6 >>> 0) || (g6 = kA(A8, g6, C4)), o3[E4 + 56 >> 2] = 0, o3[E4 + 60 >> 2] = 0, o3[E4 + 48 >> 2] = 0, o3[E4 + 52 >> 2] = 0, o3[E4 + 40 >> 2] = 0, o3[E4 + 44 >> 2] = 0, o3[E4 + 32 >> 2] = 0, o3[E4 + 36 >> 2] = 0, i4 = (t4 = !B4 & C4 >>> 0 >= 32 | 0 != (0 | B4)) ? 32 : C4, f4 = t4 = t4 ? 0 : B4, (n4 = !(i4 | t4)) || HA(E4 - -64 | 0, g6, i4), LA(a4 = E4 + 32 | 0, a4, r4 = i4 + 32 | 0, t4 = r4 >>> 0 < 32 ? t4 + 1 | 0 : t4, Q4 = Q4 + 16 | 0, E4), OA(E4 + 96 | 0, a4), n4 || HA(A8, E4 - -64 | 0, i4), $A(E4 + 32 | 0, 64), !B4 & C4 >>> 0 >= 33 | B4 && vA(A8 + i4 | 0, g6 + i4 | 0, C4 - i4 | 0, B4 - (f4 + (C4 >>> 0 < i4 >>> 0) | 0) | 0, Q4, E4), $A(E4, 32), zA(g6 = E4 + 96 | 0, A8, C4, B4), TA(g6, I7), $A(g6, 256), D3 = E4 + 352 | 0, 0;
                    }
                    function gA(A8, I7, g6, C4, B4, Q4, i4) {
                      var E4, a4, n4 = 0, r4 = 0;
                      D3 = E4 = D3 - 96 | 0, L3(E4, Q4, i4), i4 = E4 + 32 | 0, a4 = Q4 + 16 | 0, nI[o3[8724]](i4, 32, 0, a4, E4), Q4 = -1;
                      A: {
                        if (!(0 | nI[o3[8718]](g6, I7, C4, B4, i4))) {
                          if (Q4 = 0, !A8)
                            break A;
                          !((!B4 & C4 >>> 0 > I7 - A8 >>> 0 | 0 != (0 | B4)) & A8 >>> 0 < I7 >>> 0) & (!B4 & C4 >>> 0 <= A8 - I7 >>> 0 | A8 >>> 0 <= I7 >>> 0) || (I7 = kA(A8, I7, C4)), (i4 = (g6 = !B4 & C4 >>> 0 >= 32 | 0 != (0 | B4)) ? 32 : C4) | (g6 = g6 ? 0 : B4) ? (r4 = HA(E4 - -64 | 0, I7, i4), LA(Q4 = E4 + 32 | 0, Q4, n4 = i4 + 32 | 0, n4 >>> 0 < 32 ? g6 + 1 | 0 : g6, a4, E4), HA(A8, r4, i4)) : LA(Q4 = E4 + 32 | 0, Q4, n4 = i4 + 32 | 0, n4 >>> 0 < 32 ? g6 + 1 | 0 : g6, a4, E4), $A(E4 + 32 | 0, 64), Q4 = 0, !B4 & C4 >>> 0 < 33 || vA(A8 + i4 | 0, I7 + i4 | 0, C4 - i4 | 0, B4 - (g6 + (C4 >>> 0 < i4 >>> 0) | 0) | 0, a4, E4);
                        }
                        $A(E4, 32);
                      }
                      return D3 = E4 + 96 | 0, Q4;
                    }
                    function CA(A8, I7, g6, C4, B4, Q4, i4, E4, n4, r4) {
                      var f4, t4;
                      return D3 = f4 = D3 - 400 | 0, o3[f4 + 4 >> 2] = 0, d3(t4 = f4 + 16 | 0, n4, r4), r4 = a3[n4 + 20 | 0] | a3[n4 + 21 | 0] << 8 | a3[n4 + 22 | 0] << 16 | a3[n4 + 23 | 0] << 24, o3[f4 + 8 >> 2] = a3[n4 + 16 | 0] | a3[n4 + 17 | 0] << 8 | a3[n4 + 18 | 0] << 16 | a3[n4 + 19 | 0] << 24, o3[f4 + 12 >> 2] = r4, XA(r4 = f4 + 80 | 0, 64, f4 + 4 | 0, t4), OA(n4 = f4 + 144 | 0, r4), $A(r4, 64), zA(n4, Q4, i4, E4), zA(n4, 34816, 0 - i4 & 15, 0), zA(n4, I7, g6, C4), zA(n4, 34816, 0 - g6 & 15, 0), o3[f4 + 72 >> 2] = i4, o3[f4 + 76 >> 2] = E4, zA(n4, Q4 = f4 + 72 | 0, 8, 0), o3[f4 + 72 >> 2] = g6, o3[f4 + 76 >> 2] = C4, zA(n4, Q4, 8, 0), TA(n4, Q4 = f4 + 48 | 0), $A(n4, 256), n4 = Z2(Q4, B4), $A(Q4, 16), A8 && (n4 ? (MA(A8, 0, g6), n4 = -1) : (_A(A8, I7, g6, C4, f4 + 4 | 0, f4 + 16 | 0), n4 = 0)), $A(f4 + 16 | 0, 32), D3 = f4 + 400 | 0, n4;
                    }
                    function BA(A8, I7, g6, C4, B4, Q4, i4, E4, n4, r4, f4) {
                      var t4, e4, c4;
                      return D3 = t4 = D3 - 384 | 0, o3[t4 + 4 >> 2] = 0, d3(e4 = t4 + 16 | 0, r4, f4), f4 = a3[r4 + 20 | 0] | a3[r4 + 21 | 0] << 8 | a3[r4 + 22 | 0] << 16 | a3[r4 + 23 | 0] << 24, o3[t4 + 8 >> 2] = a3[r4 + 16 | 0] | a3[r4 + 17 | 0] << 8 | a3[r4 + 18 | 0] << 16 | a3[r4 + 19 | 0] << 24, o3[t4 + 12 >> 2] = f4, XA(f4 = t4 - -64 | 0, 64, c4 = t4 + 4 | 0, e4), OA(r4 = t4 + 128 | 0, f4), $A(f4, 64), zA(r4, i4, E4, n4), zA(r4, 34816, 0 - E4 & 15, 0), _A(A8, C4, B4, Q4, c4, e4), zA(r4, A8, B4, Q4), zA(r4, 34816, 0 - B4 & 15, 0), o3[t4 + 56 >> 2] = E4, o3[t4 + 60 >> 2] = n4, zA(r4, A8 = t4 + 56 | 0, 8, 0), o3[t4 + 56 >> 2] = B4, o3[t4 + 60 >> 2] = Q4, zA(r4, A8, 8, 0), TA(r4, I7), $A(r4, 256), g6 && (o3[g6 >> 2] = 16, o3[g6 + 4 >> 2] = 0), $A(t4 + 16 | 0, 32), D3 = t4 + 384 | 0, 0;
                    }
                    function QA(A8, I7, g6, C4) {
                      var B4, Q4 = 0;
                      return D3 = B4 = D3 - 208 | 0, o3[B4 + 72 >> 2] = 0, o3[B4 + 76 >> 2] = 0, Q4 = o3[8487], o3[B4 + 8 >> 2] = o3[8486], o3[B4 + 12 >> 2] = Q4, Q4 = o3[8489], o3[B4 + 16 >> 2] = o3[8488], o3[B4 + 20 >> 2] = Q4, Q4 = o3[8491], o3[B4 + 24 >> 2] = o3[8490], o3[B4 + 28 >> 2] = Q4, Q4 = o3[8493], o3[B4 + 32 >> 2] = o3[8492], o3[B4 + 36 >> 2] = Q4, Q4 = o3[8495], o3[B4 + 40 >> 2] = o3[8494], o3[B4 + 44 >> 2] = Q4, Q4 = o3[8497], o3[B4 + 48 >> 2] = o3[8496], o3[B4 + 52 >> 2] = Q4, Q4 = o3[8499], o3[B4 + 56 >> 2] = o3[8498], o3[B4 + 60 >> 2] = Q4, o3[B4 + 64 >> 2] = 0, o3[B4 + 68 >> 2] = 0, Q4 = o3[8485], o3[B4 >> 2] = o3[8484], o3[B4 + 4 >> 2] = Q4, m3(B4, I7, g6, C4), M3(B4, A8), D3 = B4 + 208 | 0, 0;
                    }
                    function iA(A8, I7) {
                      var g6, C4 = 0, B4 = 0, Q4 = 0;
                      if (E3[15 + (g6 = D3 - 16 | 0) | 0] = 0, I7) {
                        if (B4 = 3 & I7, I7 >>> 0 >= 4)
                          for (Q4 = -4 & I7, I7 = 0; E3[g6 + 15 | 0] = a3[A8 + C4 | 0] | a3[g6 + 15 | 0], E3[g6 + 15 | 0] = a3[(1 | C4) + A8 | 0] | a3[g6 + 15 | 0], E3[g6 + 15 | 0] = a3[(2 | C4) + A8 | 0] | a3[g6 + 15 | 0], E3[g6 + 15 | 0] = a3[(3 | C4) + A8 | 0] | a3[g6 + 15 | 0], C4 = C4 + 4 | 0, (0 | Q4) != (0 | (I7 = I7 + 4 | 0)); )
                            ;
                        if (B4)
                          for (I7 = 0; E3[g6 + 15 | 0] = a3[A8 + C4 | 0] | a3[g6 + 15 | 0], C4 = C4 + 1 | 0, (0 | B4) != (0 | (I7 = I7 + 1 | 0)); )
                            ;
                      }
                      return a3[g6 + 15 | 0] - 1 >>> 8 & 1;
                    }
                    function EA(A8) {
                      var I7 = 0;
                      o3[A8 + 64 >> 2] = 0, o3[A8 + 68 >> 2] = 0, o3[A8 + 72 >> 2] = 0, o3[A8 + 76 >> 2] = 0, I7 = o3[8485], o3[A8 >> 2] = o3[8484], o3[A8 + 4 >> 2] = I7, I7 = o3[8487], o3[A8 + 8 >> 2] = o3[8486], o3[A8 + 12 >> 2] = I7, I7 = o3[8489], o3[A8 + 16 >> 2] = o3[8488], o3[A8 + 20 >> 2] = I7, I7 = o3[8491], o3[A8 + 24 >> 2] = o3[8490], o3[A8 + 28 >> 2] = I7, I7 = o3[8493], o3[A8 + 32 >> 2] = o3[8492], o3[A8 + 36 >> 2] = I7, I7 = o3[8495], o3[A8 + 40 >> 2] = o3[8494], o3[A8 + 44 >> 2] = I7, I7 = o3[8497], o3[A8 + 48 >> 2] = o3[8496], o3[A8 + 52 >> 2] = I7, I7 = o3[8499], o3[A8 + 56 >> 2] = o3[8498], o3[A8 + 60 >> 2] = I7;
                    }
                    function oA(A8, I7, g6) {
                      var C4, B4 = 0, Q4 = 0;
                      if (o3[12 + (C4 = D3 - 16 | 0) >> 2] = A8, o3[C4 + 8 >> 2] = I7, A8 = 0, E3[C4 + 7 | 0] = 0, g6) {
                        if (I7 = 1 & g6, 1 != (0 | g6))
                          for (Q4 = -2 & g6, g6 = 0; E3[C4 + 7 | 0] = a3[C4 + 7 | 0] | a3[o3[C4 + 12 >> 2] + A8 | 0] ^ a3[o3[C4 + 8 >> 2] + A8 | 0], B4 = 1 | A8, E3[C4 + 7 | 0] = a3[C4 + 7 | 0] | a3[B4 + o3[C4 + 12 >> 2] | 0] ^ a3[o3[C4 + 8 >> 2] + B4 | 0], A8 = A8 + 2 | 0, (0 | Q4) != (0 | (g6 = g6 + 2 | 0)); )
                            ;
                        I7 && (E3[C4 + 7 | 0] = a3[C4 + 7 | 0] | a3[o3[C4 + 12 >> 2] + A8 | 0] ^ a3[o3[C4 + 8 >> 2] + A8 | 0]);
                      }
                      return (a3[C4 + 7 | 0] - 1 >>> 8 & 1) - 1 | 0;
                    }
                    function aA(A8) {
                      for (var I7 = 0, g6 = 0, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, E4 = 0, o4 = 0, n4 = 0, r4 = 0; B4 = (g6 = a3[A8 + C4 | 0]) ^ a3[0 | (I7 = C4 + 2448 | 0)] | B4, Q4 = g6 ^ a3[I7 + 192 | 0] | Q4, i4 = g6 ^ a3[I7 + 160 | 0] | i4, E4 = g6 ^ a3[I7 + 128 | 0] | E4, o4 = g6 ^ a3[I7 + 96 | 0] | o4, n4 = g6 ^ a3[I7 - -64 | 0] | n4, r4 = g6 ^ a3[I7 + 32 | 0] | r4, 31 != (0 | (C4 = C4 + 1 | 0)); )
                        ;
                      return ((255 & ((I7 = 127 ^ (A8 = 127 & a3[A8 + 31 | 0])) | Q4)) - 1 | (255 & (I7 | i4)) - 1 | (255 & (I7 | E4)) - 1 | (255 & (122 ^ A8 | o4)) - 1 | (255 & (5 ^ A8 | n4)) - 1 | (255 & (A8 | r4)) - 1 | (255 & (A8 | B4)) - 1) >>> 8 & 1;
                    }
                    function nA(A8, I7, g6) {
                      var C4 = 0, B4 = 0, Q4 = 0, i4 = 0;
                      return B4 = 31 & (Q4 = i4 = 63 & g6), Q4 = Q4 >>> 0 >= 32 ? -1 >>> B4 | 0 : (C4 = -1 >>> B4 | 0) | (1 << B4) - 1 << 32 - B4, Q4 &= A8, C4 &= I7, B4 = 31 & i4, i4 >>> 0 >= 32 ? (C4 = Q4 << B4, i4 = 0) : (C4 = (1 << B4) - 1 & Q4 >>> 32 - B4 | C4 << B4, i4 = Q4 << B4), Q4 = C4, C4 = 31 & (B4 = 0 - g6 & 63), B4 >>> 0 >= 32 ? (C4 = -1 << C4, g6 = 0) : C4 = (g6 = -1 << C4) | (1 << C4) - 1 & -1 >>> 32 - C4, A8 &= g6, I7 &= C4, C4 = 31 & B4, B4 >>> 0 >= 32 ? (g6 = 0, A8 = I7 >>> C4 | 0) : (g6 = I7 >>> C4 | 0, A8 = ((1 << C4) - 1 & I7) << 32 - C4 | A8 >>> C4), w3 = g6 | Q4, A8 | i4;
                    }
                    function rA(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4) {
                      var r4, f4, t4;
                      return D3 = r4 = D3 - 352 | 0, XA(t4 = r4 + 32 | 0, 64, a4, n4), OA(f4 = r4 + 96 | 0, t4), $A(t4, 64), zA(f4, Q4, i4, E4), zA(f4, 33920, 0 - i4 & 15, 0), zA(f4, I7, g6, C4), zA(f4, 33920, 0 - g6 & 15, 0), o3[r4 + 24 >> 2] = i4, o3[r4 + 28 >> 2] = E4, zA(f4, Q4 = r4 + 24 | 0, 8, 0), o3[r4 + 24 >> 2] = g6, o3[r4 + 28 >> 2] = C4, zA(f4, Q4, 8, 0), TA(f4, r4), $A(f4, 256), Q4 = Z2(r4, B4), $A(r4, 16), A8 && (Q4 ? (MA(A8, 0, g6), Q4 = -1) : (wA(A8, I7, g6, C4, a4, 1, n4), Q4 = 0)), D3 = r4 + 352 | 0, Q4;
                    }
                    function fA(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4, r4) {
                      var f4, t4, e4;
                      return D3 = f4 = D3 - 336 | 0, XA(e4 = f4 + 16 | 0, 64, n4, r4), OA(t4 = f4 + 80 | 0, e4), $A(e4, 64), zA(t4, i4, E4, a4), zA(t4, 33920, 0 - E4 & 15, 0), wA(A8, C4, B4, Q4, n4, 1, r4), zA(t4, A8, B4, Q4), zA(t4, 33920, 0 - B4 & 15, 0), o3[f4 + 8 >> 2] = E4, o3[f4 + 12 >> 2] = a4, zA(t4, A8 = f4 + 8 | 0, 8, 0), o3[f4 + 8 >> 2] = B4, o3[f4 + 12 >> 2] = Q4, zA(t4, A8, 8, 0), TA(t4, I7), $A(t4, 256), g6 && (o3[g6 >> 2] = 16, o3[g6 + 4 >> 2] = 0), D3 = f4 + 336 | 0, 0;
                    }
                    function tA(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4) {
                      var r4, f4, t4;
                      return D3 = r4 = D3 - 352 | 0, qA(t4 = r4 + 32 | 0, a4, n4), OA(f4 = r4 + 96 | 0, t4), $A(t4, 64), zA(f4, Q4, i4, E4), o3[r4 + 24 >> 2] = i4, o3[r4 + 28 >> 2] = E4, zA(f4, Q4 = r4 + 24 | 0, 8, 0), zA(f4, I7, g6, C4), o3[r4 + 24 >> 2] = g6, o3[r4 + 28 >> 2] = C4, zA(f4, Q4, 8, 0), TA(f4, r4), $A(f4, 256), Q4 = Z2(r4, B4), $A(r4, 16), A8 && (Q4 ? (MA(A8, 0, g6), Q4 = -1) : (bA(A8, I7, g6, C4, a4, n4), Q4 = 0)), D3 = r4 + 352 | 0, Q4;
                    }
                    function eA(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4, r4) {
                      var f4, t4, e4;
                      return D3 = f4 = D3 - 336 | 0, qA(e4 = f4 + 16 | 0, n4, r4), OA(t4 = f4 + 80 | 0, e4), $A(e4, 64), zA(t4, i4, E4, a4), o3[f4 + 8 >> 2] = E4, o3[f4 + 12 >> 2] = a4, zA(t4, i4 = f4 + 8 | 0, 8, 0), bA(A8, C4, B4, Q4, n4, r4), zA(t4, A8, B4, Q4), o3[f4 + 8 >> 2] = B4, o3[f4 + 12 >> 2] = Q4, zA(t4, i4, 8, 0), TA(t4, I7), $A(t4, 256), g6 && (o3[g6 >> 2] = 16, o3[g6 + 4 >> 2] = 0), D3 = f4 + 336 | 0, 0;
                    }
                    function cA(A8, I7) {
                      var g6;
                      for (o3[12 + (g6 = D3 - 16 | 0) >> 2] = A8, o3[g6 + 8 >> 2] = I7, A8 = 0, o3[g6 + 4 >> 2] = 0; o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[o3[g6 + 12 >> 2] + A8 | 0] ^ a3[o3[g6 + 8 >> 2] + A8 | 0], I7 = 1 | A8, o3[g6 + 4 >> 2] = o3[g6 + 4 >> 2] | a3[I7 + o3[g6 + 12 >> 2] | 0] ^ a3[I7 + o3[g6 + 8 >> 2] | 0], 32 != (0 | (A8 = A8 + 2 | 0)); )
                        ;
                      return (o3[g6 + 4 >> 2] - 1 >>> 8 & 1) - 1 | 0;
                    }
                    function yA(A8) {
                      var I7 = 0, g6 = 0, C4 = 0, B4 = 0;
                      for (I7 = 1; I7 = a3[0 | (g6 = A8 + C4 | 0)] + I7 | 0, E3[0 | g6] = I7, I7 = a3[0 | (g6 = (1 | C4) + A8 | 0)] + (I7 >>> 8 | 0) | 0, E3[0 | g6] = I7, I7 = a3[0 | (g6 = (2 | C4) + A8 | 0)] + (I7 >>> 8 | 0) | 0, E3[0 | g6] = I7, I7 = a3[0 | (g6 = (3 | C4) + A8 | 0)] + (I7 >>> 8 | 0) | 0, E3[0 | g6] = I7, I7 = I7 >>> 8 | 0, C4 = C4 + 4 | 0, 4 != (0 | (B4 = B4 + 4 | 0)); )
                        ;
                    }
                    function DA(A8, I7, g6, C4) {
                      var B4, Q4, i4, E4, o4 = 0, a4 = 0;
                      return E4 = r3(o4 = g6 >>> 16 | 0, a4 = A8 >>> 16 | 0), o4 = (65535 & (a4 = ((i4 = r3(B4 = 65535 & g6, Q4 = 65535 & A8)) >>> 16 | 0) + r3(a4, B4) | 0)) + r3(o4, Q4) | 0, w3 = (r3(I7, g6) + E4 | 0) + r3(A8, C4) + (a4 >>> 16) + (o4 >>> 16) | 0, 65535 & i4 | o4 << 16;
                    }
                    function wA(A8, I7, g6, C4, B4, i4, E4) {
                      var a4 = 0, n4 = 0;
                      a4 = C4, 1 == (((a4 = (n4 = g6 + 63 | 0) >>> 0 < 63 ? a4 + 1 | 0 : a4) >>> 6 | 0) + (0 != (0 | (a4 = (63 & a4) << 26 | n4 >>> 6))) | 0) & i4 >>> 0 > (n4 = 0 - a4 | 0) >>> 0 | 1 == (0 | C4) | C4 >>> 0 > 1 ? (mA(), Q3()) : nI[o3[8716]](A8, I7, g6, C4, B4, i4, E4);
                    }
                    function hA(A8, I7) {
                      A8 |= 0;
                      var g6, C4 = 0, B4 = 0, Q4 = 0;
                      if (D3 = g6 = D3 - 16 | 0, I7 |= 0)
                        for (; E3[g6 + 15 | 0] = 0, B4 = A8 + C4 | 0, Q4 = 0 | t3(34904, g6 + 15 | 0, 0), E3[0 | B4] = Q4, (0 | (C4 = C4 + 1 | 0)) != (0 | I7); )
                          ;
                      D3 = g6 + 16 | 0;
                    }
                    function sA(A8, I7, g6, C4, B4, Q4, i4) {
                      var E4, o4 = 0;
                      return D3 = E4 = D3 - 32 | 0, o4 = -1, !C4 & g6 >>> 0 < 16 || SA(E4, Q4, i4) || (o4 = gA(A8, I7 + 16 | 0, I7, g6 - 16 | 0, C4 - (g6 >>> 0 < 16) | 0, B4, E4), $A(E4, 32)), D3 = E4 + 32 | 0, o4;
                    }
                    function pA(A8) {
                      var I7, g6;
                      return (A8 = (I7 = o3[8712]) + (g6 = A8 + 7 & -8) | 0) >>> 0 <= I7 >>> 0 && g6 || A8 >>> 0 > rI() << 16 >>> 0 && !(0 | y3(0 | A8)) ? (o3[8916] = 48, -1) : (o3[8712] = A8, I7);
                    }
                    function uA(A8, I7) {
                      var g6, C4, B4;
                      D3 = g6 = D3 - 176 | 0, X3(C4 = g6 + 96 | 0, I7 + 80 | 0), F3(B4 = g6 + 48 | 0, I7, C4), F3(g6, I7 + 40 | 0, C4), W3(A8, g6), W3(g6 + 144 | 0, B4), E3[A8 + 31 | 0] = a3[A8 + 31 | 0] ^ a3[g6 + 144 | 0] << 7, D3 = g6 + 176 | 0;
                    }
                    function kA(A8, I7, g6) {
                      var C4 = 0;
                      if (A8 >>> 0 < I7 >>> 0)
                        return HA(A8, I7, g6);
                      if (g6)
                        for (C4 = A8 + g6 | 0, I7 = I7 + g6 | 0; I7 = I7 - 1 | 0, E3[0 | (C4 = C4 - 1 | 0)] = a3[0 | I7], g6 = g6 - 1 | 0; )
                          ;
                      return A8;
                    }
                    function FA(A8, I7, g6, C4, B4, i4, E4) {
                      var o4, a4 = 0;
                      if (D3 = o4 = D3 - 32 | 0, !C4 & g6 >>> 0 < 4294967280)
                        return a4 = -1, SA(o4, i4, E4) || (a4 = IA(A8 + 16 | 0, A8, I7, g6, C4, B4, o4), $A(o4, 32)), D3 = o4 + 32 | 0, a4;
                      mA(), Q3();
                    }
                    function lA(A8, I7, g6, C4, B4, Q4) {
                      return I7 |= 0, 0 | (!(C4 |= 0) & (g6 |= 0) >>> 0 >= 16 | C4 ? gA(A8 |= 0, I7 + 16 | 0, I7, g6 - 16 | 0, C4 - (g6 >>> 0 < 16) | 0, B4 |= 0, Q4 |= 0) : -1);
                    }
                    function SA(A8, I7, g6) {
                      A8 |= 0;
                      var C4, B4 = 0;
                      return D3 = C4 = D3 - 32 | 0, B4 = -1, T3(C4, g6 |= 0, I7 |= 0) || (B4 = L3(A8, 34832, C4)), D3 = C4 + 32 | 0, 0 | B4;
                    }
                    function HA(A8, I7, g6) {
                      var C4 = 0;
                      if (g6)
                        for (C4 = A8; E3[0 | C4] = a3[0 | I7], C4 = C4 + 1 | 0, I7 = I7 + 1 | 0, g6 = g6 - 1 | 0; )
                          ;
                      return A8;
                    }
                    function MA(A8, I7, g6) {
                      var C4 = 0;
                      if (g6)
                        for (C4 = A8; E3[0 | C4] = I7, C4 = C4 + 1 | 0, g6 = g6 - 1 | 0; )
                          ;
                      return A8;
                    }
                    function GA(A8, I7, g6) {
                      return A8 |= 0, I7 |= 0, (g6 |= 0) >>> 0 >= 256 && (e3(1260, 1187, 107, 1067), Q3()), 0 | G3(A8, I7, 255 & g6);
                    }
                    function UA(A8, I7) {
                      var g6;
                      D3 = g6 = D3 + -64 | 0, M3(A8, g6), m3(A8 = A8 + 208 | 0, g6, 64, 0), M3(A8, I7), $A(g6, 64), D3 = g6 - -64 | 0;
                    }
                    function JA(A8, I7, g6, C4, B4, Q4, i4) {
                      return 0 | IA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0);
                    }
                    function NA(A8, I7, g6, C4, B4, Q4, i4) {
                      return 0 | gA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0);
                    }
                    function YA(A8, I7) {
                      var g6 = 0;
                      return (-1 >>> (g6 = 31 & I7) & A8) << g6 | ((g6 = A8) & -1 << (A8 = 0 - I7 & 31)) >>> A8;
                    }
                    function bA(A8, I7, g6, C4, B4, i4) {
                      1 == (0 | C4) | C4 >>> 0 > 1 && (mA(), Q3()), nI[o3[8715]](A8, I7, g6, C4, B4, 1, 0, i4);
                    }
                    function _A(A8, I7, g6, C4, B4, i4) {
                      1 == (0 | C4) | C4 >>> 0 > 1 && (mA(), Q3()), nI[o3[8716]](A8, I7, g6, C4, B4, 1, i4);
                    }
                    function KA() {
                      var A8;
                      D3 = A8 = D3 - 16 | 0, E3[A8 + 15 | 0] = 0, t3(34940, A8 + 15 | 0, 0), D3 = A8 + 16 | 0;
                    }
                    function PA(A8, I7, g6) {
                      return 0 | T3(A8 |= 0, I7 |= 0, g6 |= 0);
                    }
                    function vA(A8, I7, g6, C4, B4, Q4) {
                      nI[o3[8725]](A8, I7, g6, C4, B4, 1, 0, Q4);
                    }
                    function mA() {
                      var A8;
                      (A8 = o3[9050]) && nI[0 | A8](), c3(), Q3();
                    }
                    function dA(A8, I7) {
                      return A8 |= 0, hA(I7 |= 0, 32), 0 | VA(A8, I7);
                    }
                    function LA(A8, I7, g6, C4, B4, Q4) {
                      nI[o3[8725]](A8, I7, g6, C4, B4, 0, 0, Q4);
                    }
                    function RA(A8) {
                      return A8 ? 31 - f3(A8 - 1 ^ A8) | 0 : 32;
                    }
                    function xA(A8, I7, g6, C4) {
                      nI[o3[8716]](A8, I7, 40, 0, g6, 0, C4);
                    }
                    function jA(A8, I7) {
                      return 0 | VA(A8 |= 0, I7 |= 0);
                    }
                    function XA(A8, I7, g6, C4) {
                      nI[o3[8714]](A8, I7, 0, g6, C4);
                    }
                    function qA(A8, I7, g6) {
                      nI[o3[8713]](A8, 64, 0, I7, g6);
                    }
                    function zA(A8, I7, g6, C4) {
                      nI[o3[8720]](A8, I7, g6, C4);
                    }
                    function VA(A8, I7) {
                      return 0 | nI[o3[8723]](A8, I7);
                    }
                    function OA(A8, I7) {
                      nI[o3[8719]](A8, I7);
                    }
                    function TA(A8, I7) {
                      nI[o3[8721]](A8, I7);
                    }
                    function WA(A8, I7, g6, C4) {
                      m3(A8, I7, g6, C4);
                    }
                    function ZA(A8) {
                      hA(A8 |= 0, 32);
                    }
                    function $A(A8, I7) {
                      MA(A8, 0, I7);
                    }
                    function AI() {
                      return 16;
                    }
                    function II() {
                      return 32;
                    }
                    function gI() {
                      return 24;
                    }
                    function CI() {
                      return -17;
                    }
                    function BI() {
                      return 64;
                    }
                    function QI() {
                      return 1;
                    }
                    function iI() {
                      return 3;
                    }
                    function EI() {
                      return 8;
                    }
                    function oI() {
                      return 0;
                    }
                    B3(I6 = a3, 1024, "TGlic29kaXVtRFJHcmFuZG9tYnl0ZXMAYjY0X3BvcyA8PSBiNjRfbGVuAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2ZpbmFsAHJhbmRvbWJ5dGVzL3JhbmRvbWJ5dGVzLmMAc29kaXVtL2NvZGVjcy5jAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9ibGFrZTJiLXJlZi5jAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9nZW5lcmljaGFzaF9ibGFrZTJiLmMAYnVmX2xlbiA8PSBTSVpFX01BWABvdXRsZW4gPD0gVUlOVDhfTUFYAFMtPmJ1ZmxlbiA8PSBCTEFLRTJCX0JMT0NLQllURVMAMS4wLjE4AHNvZGl1bV9iaW4yYmFzZTY0AAAAAAAAAAC2eFn/hXLTAL1uFf8PCmoAKcABAJjoef+8PKD/mXHO/wC34v60DUj/AAAAAAAAAACwoA7+08mG/54YjwB/aTUAYAy9AKfX+/+fTID+amXh/x78BACSDK4="), B3(I6, 1440, "WfGy/grlpv973Sr+HhTUAFKAAwAw0fMAd3lA/zLjnP8AbsUBZxuQ"), B3(I6, 1488, "hTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqYAJsr8f6boGj/M7ulAAIRrwBCVKAB9zoeACNBNf5F7L8ALYb1AaN73QAgbhT/NBelALrWRwDpsGAA8u82ATlZigBTAFT/iKBkAFyOeP5ofL4AtbE+//opVQCYgioBYPz2AJeXP/7vhT4AIDicAC2nvf+OhbMBg1bTALuzlv76qg7/0qNOACU0lwBjTRoA7pzV/9XA0QFJLlQAFEEpATbOTwDJg5L+qm8Y/7EhMv6rJsv/Tvd0ANHdmQCFgLIBOiwZAMknOwG9E/wAMeXSAXW7dQC1s7gBAHLbADBekwD1KTgAfQ3M/vStdwAs3SD+VOoUAPmgxgHsfur/L2Oo/qrimf9ms9gA4o16/3pCmf629YYA4+QZAdY56//YrTj/tefSAHeAnf+BX4j/bn4zAAKpt/8HgmL+RbBe/3QE4wHZ8pH/yq0fAWkBJ/8ur0UA5C86/9fgRf7POEX/EP6L/xfP1P/KFH7/X9Vg/wmwIQDIBc//8SqA/iMhwP/45cQBgRF4APtnl/8HNHD/jDhC/yji9f/ZRiX+rNYJ/0hDhgGSwNb/LCZwAES4S//OWvsAleuNALWqOgB09O8AXJ0CAGatYgDpiWABfzHLAAWblAAXlAn/03oMACKGGv/bzIgAhggp/+BTK/5VGfcAbX8A/qmIMADud9v/563VAM4S/v4Iugf/fgkHAW8qSABvNOz+YD+NAJO/f/7NTsD/DmrtAbvbTACv87v+aVmtAFUZWQGi85QAAnbR/iGeCQCLoy7/XUYoAGwqjv5v/I7/m9+QADPlp/9J/Jv/XnQM/5ig2v+c7iX/s+rP/8UAs/+apI0A4cRoAAojGf7R1PL/Yf3e/rhl5QDeEn8BpIiH/x7PjP6SYfMAgcAa/slUIf9vCk7/k1Gy/wQEGACh7tf/Bo0hADXXDv8ptdD/54udALPL3f//uXEAveKs/3FC1v/KPi3/ZkAI/06uEP6FdUT/"), B3(I6, 2480, "AQ=="), B3(I6, 2512, "JuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////f+3T9VwaYxJY1pz3ot753hQ="), B3(I6, 2703, "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"), B3(I6, 33676, "AQ=="), B3(I6, 33712, "AQ=="), B3(I6, 33744, "4Ot6fDtBuK4WVuP68Z/EatoJjeucMrH9hmIFFl9JuABfnJW8o1CMJLHQsVWcg+9bBERcxFgcjobYIk7d0J8RV+z///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fw=="), B3(I6, 33936, "CMm882fmCWo7p8qEha5nuyv4lP5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gWyKuKNeYL4pCzWXvI5FEN3EvO03sz/vAtbzbiYGl27XpOLVI81vCVjkZ0AW28RHxWZtPGa+kgj+SGIFt2tVeHKtCAgOjmKoH2L5vcEUBW4MSjLLkTr6FMSTitP/Vw30MVW+Je/J0Xb5ysZYWO/6x3oA1Esclpwbcm5Qmac908ZvB0krxnsFpm+TjJU84hke+77XVjIvGncEPZZysd8yhDCR1AitZbyzpLYPkpm6qhHRK1PtBvdypsFy1UxGD2oj5dqvfZu5SUT6YEDK0LW3GMag/IfuYyCcDsOQO777Hf1m/wo+oPfML4MYlpwqTR5Gn1W+CA+BRY8oGcG4OCmcpKRT8L9JGhQq3JybJJlw4IRsu7SrEWvxtLE3fs5WdEw04U95jr4tUcwplqLJ3PLsKanbmru1HLsnCgTs1ghSFLHKSZAPxTKHov6IBMEK8S2YaqJGX+NBwi0vCML5UBqNRbMcYUu/WGeiS0RCpZVUkBpnWKiBxV4U1DvS40bsycKBqEMjQ0rgWwaQZU6tBUQhsNx6Z647fTHdIJ6hIm+G1vLA0Y1rJxbMMHDnLikHjSqrYTnPjY3dPypxbo7iy1vNvLmj8su9d7oKPdGAvF0NvY6V4cqvwoRR4yITsOWQaCALHjCgeYyP6/76Q6b2C3utsUKQVecay96P5vitTcuPyeHHGnGEm6s4+J8oHwsAhx7iG0R7r4M3WfdrqeNFu7n9PffW6bxdyqmfwBqaYyKLFfWMKrg35vgSYPxEbRxwTNQtxG4R9BCP1d9sokyTHQHuryjK8vskVCr6ePEwNEJzEZx1DtkI+y77UxUwqfmX8nCl/Wez61jqrb8tfF1hHSowZRGyA"), B3(I6, 34768, "U2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMB"), B3(I6, 34848, "cI0BAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0=");
                    var aI, nI = (aI = [null, function(A8, I7, g6, C4, B4) {
                      var Q4;
                      return A8 |= 0, C4 |= 0, B4 |= 0, D3 = Q4 = D3 + -64 | 0, (I7 |= 0) | (g6 |= 0) && (o3[Q4 + 8 >> 2] = 2036477234, o3[Q4 + 12 >> 2] = 1797285236, o3[Q4 >> 2] = 1634760805, o3[Q4 + 4 >> 2] = 857760878, o3[Q4 + 16 >> 2] = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[Q4 + 20 >> 2] = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, o3[Q4 + 24 >> 2] = a3[B4 + 8 | 0] | a3[B4 + 9 | 0] << 8 | a3[B4 + 10 | 0] << 16 | a3[B4 + 11 | 0] << 24, o3[Q4 + 28 >> 2] = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, o3[Q4 + 32 >> 2] = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, o3[Q4 + 36 >> 2] = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, o3[Q4 + 40 >> 2] = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, B4 = a3[B4 + 28 | 0] | a3[B4 + 29 | 0] << 8 | a3[B4 + 30 | 0] << 16 | a3[B4 + 31 | 0] << 24, o3[Q4 + 48 >> 2] = 0, o3[Q4 + 52 >> 2] = 0, o3[Q4 + 44 >> 2] = B4, o3[Q4 + 56 >> 2] = a3[0 | C4] | a3[C4 + 1 | 0] << 8 | a3[C4 + 2 | 0] << 16 | a3[C4 + 3 | 0] << 24, o3[Q4 + 60 >> 2] = a3[C4 + 4 | 0] | a3[C4 + 5 | 0] << 8 | a3[C4 + 6 | 0] << 16 | a3[C4 + 7 | 0] << 24, H3(Q4, A8 = MA(A8, 0, I7), A8, I7, g6), $A(Q4, 64)), D3 = Q4 - -64 | 0, 0;
                    }, function(A8, I7, g6, C4, B4) {
                      var Q4;
                      return A8 |= 0, C4 |= 0, B4 |= 0, D3 = Q4 = D3 + -64 | 0, (I7 |= 0) | (g6 |= 0) && (o3[Q4 + 8 >> 2] = 2036477234, o3[Q4 + 12 >> 2] = 1797285236, o3[Q4 >> 2] = 1634760805, o3[Q4 + 4 >> 2] = 857760878, o3[Q4 + 16 >> 2] = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[Q4 + 20 >> 2] = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, o3[Q4 + 24 >> 2] = a3[B4 + 8 | 0] | a3[B4 + 9 | 0] << 8 | a3[B4 + 10 | 0] << 16 | a3[B4 + 11 | 0] << 24, o3[Q4 + 28 >> 2] = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, o3[Q4 + 32 >> 2] = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, o3[Q4 + 36 >> 2] = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, o3[Q4 + 40 >> 2] = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, B4 = a3[B4 + 28 | 0] | a3[B4 + 29 | 0] << 8 | a3[B4 + 30 | 0] << 16 | a3[B4 + 31 | 0] << 24, o3[Q4 + 48 >> 2] = 0, o3[Q4 + 44 >> 2] = B4, o3[Q4 + 52 >> 2] = a3[0 | C4] | a3[C4 + 1 | 0] << 8 | a3[C4 + 2 | 0] << 16 | a3[C4 + 3 | 0] << 24, o3[Q4 + 56 >> 2] = a3[C4 + 4 | 0] | a3[C4 + 5 | 0] << 8 | a3[C4 + 6 | 0] << 16 | a3[C4 + 7 | 0] << 24, o3[Q4 + 60 >> 2] = a3[C4 + 8 | 0] | a3[C4 + 9 | 0] << 8 | a3[C4 + 10 | 0] << 16 | a3[C4 + 11 | 0] << 24, H3(Q4, A8 = MA(A8, 0, I7), A8, I7, g6), $A(Q4, 64)), D3 = Q4 - -64 | 0, 0;
                    }, function(A8, I7, g6, C4, B4, Q4, i4, E4) {
                      var n4;
                      return A8 |= 0, I7 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0, E4 |= 0, D3 = n4 = D3 + -64 | 0, (g6 |= 0) | (C4 |= 0) && (o3[n4 + 8 >> 2] = 2036477234, o3[n4 + 12 >> 2] = 1797285236, o3[n4 >> 2] = 1634760805, o3[n4 + 4 >> 2] = 857760878, o3[n4 + 16 >> 2] = a3[0 | E4] | a3[E4 + 1 | 0] << 8 | a3[E4 + 2 | 0] << 16 | a3[E4 + 3 | 0] << 24, o3[n4 + 20 >> 2] = a3[E4 + 4 | 0] | a3[E4 + 5 | 0] << 8 | a3[E4 + 6 | 0] << 16 | a3[E4 + 7 | 0] << 24, o3[n4 + 24 >> 2] = a3[E4 + 8 | 0] | a3[E4 + 9 | 0] << 8 | a3[E4 + 10 | 0] << 16 | a3[E4 + 11 | 0] << 24, o3[n4 + 28 >> 2] = a3[E4 + 12 | 0] | a3[E4 + 13 | 0] << 8 | a3[E4 + 14 | 0] << 16 | a3[E4 + 15 | 0] << 24, o3[n4 + 32 >> 2] = a3[E4 + 16 | 0] | a3[E4 + 17 | 0] << 8 | a3[E4 + 18 | 0] << 16 | a3[E4 + 19 | 0] << 24, o3[n4 + 36 >> 2] = a3[E4 + 20 | 0] | a3[E4 + 21 | 0] << 8 | a3[E4 + 22 | 0] << 16 | a3[E4 + 23 | 0] << 24, o3[n4 + 40 >> 2] = a3[E4 + 24 | 0] | a3[E4 + 25 | 0] << 8 | a3[E4 + 26 | 0] << 16 | a3[E4 + 27 | 0] << 24, o3[n4 + 44 >> 2] = a3[E4 + 28 | 0] | a3[E4 + 29 | 0] << 8 | a3[E4 + 30 | 0] << 16 | a3[E4 + 31 | 0] << 24, o3[n4 + 48 >> 2] = Q4, o3[n4 + 52 >> 2] = i4, o3[n4 + 56 >> 2] = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[n4 + 60 >> 2] = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, H3(n4, I7, A8, g6, C4), $A(n4, 64)), D3 = n4 - -64 | 0, 0;
                    }, function(A8, I7, g6, C4, B4, Q4, i4) {
                      var E4;
                      return A8 |= 0, I7 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0, D3 = E4 = D3 + -64 | 0, (g6 |= 0) | (C4 |= 0) && (o3[E4 + 8 >> 2] = 2036477234, o3[E4 + 12 >> 2] = 1797285236, o3[E4 >> 2] = 1634760805, o3[E4 + 4 >> 2] = 857760878, o3[E4 + 16 >> 2] = a3[0 | i4] | a3[i4 + 1 | 0] << 8 | a3[i4 + 2 | 0] << 16 | a3[i4 + 3 | 0] << 24, o3[E4 + 20 >> 2] = a3[i4 + 4 | 0] | a3[i4 + 5 | 0] << 8 | a3[i4 + 6 | 0] << 16 | a3[i4 + 7 | 0] << 24, o3[E4 + 24 >> 2] = a3[i4 + 8 | 0] | a3[i4 + 9 | 0] << 8 | a3[i4 + 10 | 0] << 16 | a3[i4 + 11 | 0] << 24, o3[E4 + 28 >> 2] = a3[i4 + 12 | 0] | a3[i4 + 13 | 0] << 8 | a3[i4 + 14 | 0] << 16 | a3[i4 + 15 | 0] << 24, o3[E4 + 32 >> 2] = a3[i4 + 16 | 0] | a3[i4 + 17 | 0] << 8 | a3[i4 + 18 | 0] << 16 | a3[i4 + 19 | 0] << 24, o3[E4 + 36 >> 2] = a3[i4 + 20 | 0] | a3[i4 + 21 | 0] << 8 | a3[i4 + 22 | 0] << 16 | a3[i4 + 23 | 0] << 24, o3[E4 + 40 >> 2] = a3[i4 + 24 | 0] | a3[i4 + 25 | 0] << 8 | a3[i4 + 26 | 0] << 16 | a3[i4 + 27 | 0] << 24, i4 = a3[i4 + 28 | 0] | a3[i4 + 29 | 0] << 8 | a3[i4 + 30 | 0] << 16 | a3[i4 + 31 | 0] << 24, o3[E4 + 48 >> 2] = Q4, o3[E4 + 44 >> 2] = i4, o3[E4 + 52 >> 2] = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[E4 + 56 >> 2] = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, o3[E4 + 60 >> 2] = a3[B4 + 8 | 0] | a3[B4 + 9 | 0] << 8 | a3[B4 + 10 | 0] << 16 | a3[B4 + 11 | 0] << 24, H3(E4, I7, A8, g6, C4), $A(E4, 64)), D3 = E4 - -64 | 0, 0;
                    }, function(A8, I7, g6, C4, B4) {
                      var Q4, i4, n4;
                      return A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, D3 = Q4 = (i4 = D3) - 128 & -64, o3[Q4 >> 2] = 67108863 & (a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24), o3[Q4 + 4 >> 2] = (a3[B4 + 3 | 0] | a3[B4 + 4 | 0] << 8 | a3[B4 + 5 | 0] << 16 | a3[B4 + 6 | 0] << 24) >>> 2 & 67108611, o3[Q4 + 8 >> 2] = (a3[B4 + 6 | 0] | a3[B4 + 7 | 0] << 8 | a3[B4 + 8 | 0] << 16 | a3[B4 + 9 | 0] << 24) >>> 4 & 67092735, o3[Q4 + 12 >> 2] = (a3[B4 + 9 | 0] | a3[B4 + 10 | 0] << 8 | a3[B4 + 11 | 0] << 16 | a3[B4 + 12 | 0] << 24) >>> 6 & 66076671, n4 = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, o3[Q4 + 20 >> 2] = 0, o3[Q4 + 24 >> 2] = 0, o3[Q4 + 28 >> 2] = 0, o3[Q4 + 32 >> 2] = 0, o3[Q4 + 36 >> 2] = 0, o3[Q4 + 16 >> 2] = n4 >>> 8 & 1048575, o3[Q4 + 40 >> 2] = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, o3[Q4 + 44 >> 2] = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, o3[Q4 + 48 >> 2] = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, B4 = a3[B4 + 28 | 0] | a3[B4 + 29 | 0] << 8 | a3[B4 + 30 | 0] << 16 | a3[B4 + 31 | 0] << 24, E3[Q4 + 80 | 0] = 0, o3[Q4 + 56 >> 2] = 0, o3[Q4 + 60 >> 2] = 0, o3[Q4 + 52 >> 2] = B4, x3(Q4, I7, g6, C4), O3(Q4, A8), D3 = i4, 0;
                    }, function(A8, I7, g6, C4, B4) {
                      var Q4, i4, n4;
                      return A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, D3 = Q4 = (i4 = D3) - 192 & -64, o3[Q4 + 64 >> 2] = 67108863 & (a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24), o3[Q4 + 68 >> 2] = (a3[B4 + 3 | 0] | a3[B4 + 4 | 0] << 8 | a3[B4 + 5 | 0] << 16 | a3[B4 + 6 | 0] << 24) >>> 2 & 67108611, o3[Q4 + 72 >> 2] = (a3[B4 + 6 | 0] | a3[B4 + 7 | 0] << 8 | a3[B4 + 8 | 0] << 16 | a3[B4 + 9 | 0] << 24) >>> 4 & 67092735, o3[Q4 + 76 >> 2] = (a3[B4 + 9 | 0] | a3[B4 + 10 | 0] << 8 | a3[B4 + 11 | 0] << 16 | a3[B4 + 12 | 0] << 24) >>> 6 & 66076671, n4 = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, o3[Q4 + 84 >> 2] = 0, o3[Q4 + 88 >> 2] = 0, o3[Q4 + 92 >> 2] = 0, o3[Q4 + 96 >> 2] = 0, o3[Q4 + 100 >> 2] = 0, o3[Q4 + 80 >> 2] = n4 >>> 8 & 1048575, o3[Q4 + 104 >> 2] = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, o3[Q4 + 108 >> 2] = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, o3[Q4 + 112 >> 2] = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, B4 = a3[B4 + 28 | 0] | a3[B4 + 29 | 0] << 8 | a3[B4 + 30 | 0] << 16 | a3[B4 + 31 | 0] << 24, E3[Q4 + 144 | 0] = 0, o3[Q4 + 120 >> 2] = 0, o3[Q4 + 124 >> 2] = 0, o3[Q4 + 116 >> 2] = B4, x3(B4 = Q4 - -64 | 0, I7, g6, C4), O3(B4, I7 = Q4 + 48 | 0), A8 = Z2(A8, I7), D3 = i4, 0 | A8;
                    }, function(A8, I7) {
                      var g6;
                      return I7 |= 0, o3[(A8 |= 0) >> 2] = 67108863 & (a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24), o3[A8 + 4 >> 2] = (a3[I7 + 3 | 0] | a3[I7 + 4 | 0] << 8 | a3[I7 + 5 | 0] << 16 | a3[I7 + 6 | 0] << 24) >>> 2 & 67108611, o3[A8 + 8 >> 2] = (a3[I7 + 6 | 0] | a3[I7 + 7 | 0] << 8 | a3[I7 + 8 | 0] << 16 | a3[I7 + 9 | 0] << 24) >>> 4 & 67092735, o3[A8 + 12 >> 2] = (a3[I7 + 9 | 0] | a3[I7 + 10 | 0] << 8 | a3[I7 + 11 | 0] << 16 | a3[I7 + 12 | 0] << 24) >>> 6 & 66076671, g6 = a3[I7 + 12 | 0] | a3[I7 + 13 | 0] << 8 | a3[I7 + 14 | 0] << 16 | a3[I7 + 15 | 0] << 24, o3[A8 + 20 >> 2] = 0, o3[A8 + 24 >> 2] = 0, o3[A8 + 28 >> 2] = 0, o3[A8 + 32 >> 2] = 0, o3[A8 + 36 >> 2] = 0, o3[A8 + 16 >> 2] = g6 >>> 8 & 1048575, o3[A8 + 40 >> 2] = a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24, o3[A8 + 44 >> 2] = a3[I7 + 20 | 0] | a3[I7 + 21 | 0] << 8 | a3[I7 + 22 | 0] << 16 | a3[I7 + 23 | 0] << 24, o3[A8 + 48 >> 2] = a3[I7 + 24 | 0] | a3[I7 + 25 | 0] << 8 | a3[I7 + 26 | 0] << 16 | a3[I7 + 27 | 0] << 24, I7 = a3[I7 + 28 | 0] | a3[I7 + 29 | 0] << 8 | a3[I7 + 30 | 0] << 16 | a3[I7 + 31 | 0] << 24, E3[A8 + 80 | 0] = 0, o3[A8 + 56 >> 2] = 0, o3[A8 + 60 >> 2] = 0, o3[A8 + 52 >> 2] = I7, 0;
                    }, function(A8, I7, g6, C4) {
                      return x3(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0), 0;
                    }, function(A8, I7) {
                      return O3(A8 |= 0, I7 |= 0), 0;
                    }, function(A8, I7, g6) {
                      A8 |= 0, I7 |= 0, g6 |= 0;
                      var C4, B4 = 0, Q4 = 0, i4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, l4 = 0, H4 = 0, M4 = 0, G4 = 0, U4 = 0, J4 = 0, N4 = 0, Y4 = 0, b4 = 0, _4 = 0, K4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, q4 = 0, z4 = 0, V4 = 0, O4 = 0, T4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0, BA2 = 0, QA2 = 0, iA2 = 0, EA2 = 0, oA2 = 0, aA2 = 0, nA2 = 0, rA2 = 0, fA2 = 0, tA2 = 0, eA2 = 0, cA2 = 0, yA2 = 0, wA2 = 0, hA2 = 0, sA2 = 0, pA2 = 0, uA2 = 0, kA2 = 0, FA2 = 0, lA2 = 0;
                      for (D3 = C4 = D3 - 368 | 0; h4 = (i4 = a3[g6 + B4 | 0]) ^ a3[0 | (r4 = B4 + 33680 | 0)] | h4, c4 = i4 ^ a3[r4 + 192 | 0] | c4, y4 = i4 ^ a3[r4 + 160 | 0] | y4, e4 = i4 ^ a3[r4 + 128 | 0] | e4, n4 = i4 ^ a3[r4 + 96 | 0] | n4, f4 = i4 ^ a3[r4 - -64 | 0] | f4, Q4 = i4 ^ a3[r4 + 32 | 0] | Q4, 31 != (0 | (B4 = B4 + 1 | 0)); )
                        ;
                      if (B4 = -1, !(256 & ((255 & ((i4 = 127 ^ (r4 = 127 & a3[g6 + 31 | 0])) | c4)) - 1 | (255 & (i4 | y4)) - 1 | (255 & (i4 | e4)) - 1 | (255 & (87 ^ r4 | n4)) - 1 | (255 & (f4 | r4)) - 1 | (255 & (Q4 | r4)) - 1 | (255 & (r4 | h4)) - 1))) {
                        for (B4 = I7, I7 = a3[I7 + 28 | 0] | a3[I7 + 29 | 0] << 8 | a3[I7 + 30 | 0] << 16 | a3[I7 + 31 | 0] << 24, o3[C4 + 360 >> 2] = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, o3[C4 + 364 >> 2] = I7, I7 = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, o3[C4 + 352 >> 2] = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, o3[C4 + 356 >> 2] = I7, Q4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, I7 = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[C4 + 336 >> 2] = I7, o3[C4 + 340 >> 2] = Q4, Q4 = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, o3[C4 + 344 >> 2] = a3[B4 + 8 | 0] | a3[B4 + 9 | 0] << 8 | a3[B4 + 10 | 0] << 16 | a3[B4 + 11 | 0] << 24, o3[C4 + 348 >> 2] = Q4, E3[C4 + 336 | 0] = 248 & I7, E3[C4 + 367 | 0] = 63 & a3[C4 + 367 | 0] | 64, P3(C4 + 288 | 0, g6), o3[C4 + 260 >> 2] = 0, o3[C4 + 264 >> 2] = 0, o3[C4 + 268 >> 2] = 0, o3[C4 + 272 >> 2] = 0, o3[C4 + 276 >> 2] = 0, o3[C4 + 208 >> 2] = 0, o3[C4 + 212 >> 2] = 0, o3[C4 + 216 >> 2] = 0, o3[C4 + 220 >> 2] = 0, o3[C4 + 224 >> 2] = 0, o3[C4 + 228 >> 2] = 0, o3[C4 + 244 >> 2] = 0, o3[C4 + 248 >> 2] = 0, o3[C4 + 240 >> 2] = 1, o3[C4 + 252 >> 2] = 0, o3[C4 + 256 >> 2] = 0, o3[C4 + 192 >> 2] = 0, o3[C4 + 196 >> 2] = 0, o3[C4 + 200 >> 2] = 0, o3[C4 + 204 >> 2] = 0, I7 = o3[C4 + 316 >> 2], o3[C4 + 168 >> 2] = o3[C4 + 312 >> 2], o3[C4 + 172 >> 2] = I7, I7 = o3[C4 + 308 >> 2], o3[C4 + 160 >> 2] = o3[C4 + 304 >> 2], o3[C4 + 164 >> 2] = I7, I7 = o3[C4 + 300 >> 2], o3[C4 + 152 >> 2] = o3[C4 + 296 >> 2], o3[C4 + 156 >> 2] = I7, I7 = o3[C4 + 292 >> 2], o3[C4 + 144 >> 2] = o3[C4 + 288 >> 2], o3[C4 + 148 >> 2] = I7, I7 = o3[C4 + 324 >> 2], o3[C4 + 176 >> 2] = o3[C4 + 320 >> 2], o3[C4 + 180 >> 2] = I7, o3[C4 + 116 >> 2] = 0, o3[C4 + 120 >> 2] = 0, o3[C4 + 124 >> 2] = 0, o3[C4 + 128 >> 2] = 0, o3[C4 + 132 >> 2] = 0, o3[C4 + 100 >> 2] = 0, o3[C4 + 104 >> 2] = 0, o3[C4 + 96 >> 2] = 1, o3[C4 + 108 >> 2] = 0, o3[C4 + 112 >> 2] = 0, g6 = 254; Z3 = o3[C4 + 276 >> 2], i4 = o3[C4 + 180 >> 2], $3 = o3[C4 + 96 >> 2], AA2 = o3[C4 + 192 >> 2], IA2 = o3[C4 + 144 >> 2], gA2 = o3[C4 + 240 >> 2], CA2 = o3[C4 + 100 >> 2], BA2 = o3[C4 + 196 >> 2], QA2 = o3[C4 + 148 >> 2], iA2 = o3[C4 + 244 >> 2], J4 = o3[C4 + 104 >> 2], EA2 = o3[C4 + 200 >> 2], N4 = o3[C4 + 152 >> 2], oA2 = o3[C4 + 248 >> 2], K4 = o3[C4 + 108 >> 2], aA2 = o3[C4 + 204 >> 2], Y4 = o3[C4 + 156 >> 2], nA2 = o3[C4 + 252 >> 2], b4 = o3[C4 + 112 >> 2], rA2 = o3[C4 + 208 >> 2], G4 = o3[C4 + 160 >> 2], fA2 = o3[C4 + 256 >> 2], h4 = o3[C4 + 116 >> 2], tA2 = o3[C4 + 212 >> 2], t4 = o3[C4 + 164 >> 2], eA2 = o3[C4 + 260 >> 2], c4 = o3[C4 + 120 >> 2], cA2 = o3[C4 + 216 >> 2], y4 = o3[C4 + 168 >> 2], yA2 = o3[C4 + 264 >> 2], e4 = o3[C4 + 124 >> 2], wA2 = o3[C4 + 220 >> 2], n4 = o3[C4 + 172 >> 2], hA2 = o3[C4 + 268 >> 2], f4 = o3[C4 + 128 >> 2], sA2 = o3[C4 + 224 >> 2], Q4 = o3[C4 + 176 >> 2], pA2 = o3[C4 + 272 >> 2], uA2 = g6, U4 = (H4 = (I7 = 0 - ((I7 = T4) ^ (T4 = a3[C4 + 336 + (g6 >>> 3) | 0] >>> (7 & g6) & 1)) | 0) & ((B4 = o3[C4 + 132 >> 2]) ^ (q4 = o3[C4 + 228 >> 2]))) ^ B4, o3[C4 + 132 >> 2] = U4, z4 = i4 ^ (p4 = I7 & (i4 ^ Z3)), o3[C4 + 84 >> 2] = z4 - U4, _4 = f4 ^ (u4 = I7 & (f4 ^ sA2)), o3[C4 + 128 >> 2] = _4, V4 = (M4 = I7 & (Q4 ^ pA2)) ^ Q4, o3[C4 + 80 >> 2] = V4 - _4, m4 = e4 ^ (k4 = I7 & (e4 ^ wA2)), o3[C4 + 124 >> 2] = m4, kA2 = n4 ^ (l4 = I7 & (n4 ^ hA2)), o3[C4 + 76 >> 2] = kA2 - m4, d4 = c4 ^ (s4 = I7 & (c4 ^ cA2)), o3[C4 + 120 >> 2] = d4, FA2 = y4 ^ (r4 = I7 & (y4 ^ yA2)), o3[C4 + 72 >> 2] = FA2 - d4, L4 = h4 ^ (i4 = I7 & (h4 ^ tA2)), o3[C4 + 116 >> 2] = L4, lA2 = t4 ^ (h4 = I7 & (t4 ^ eA2)), o3[C4 + 68 >> 2] = lA2 - L4, R4 = b4 ^ (c4 = I7 & (b4 ^ rA2)), o3[C4 + 112 >> 2] = R4, v4 = G4 ^ (y4 = I7 & (G4 ^ fA2)), o3[C4 + 64 >> 2] = v4 - R4, x4 = K4 ^ (e4 = I7 & (K4 ^ aA2)), o3[C4 + 108 >> 2] = x4, O4 = Y4 ^ (n4 = I7 & (Y4 ^ nA2)), o3[C4 + 60 >> 2] = O4 - x4, j4 = J4 ^ (f4 = I7 & (J4 ^ EA2)), o3[C4 + 104 >> 2] = j4, K4 = N4 ^ (Q4 = I7 & (N4 ^ oA2)), o3[C4 + 56 >> 2] = K4 - j4, J4 = CA2 ^ (B4 = I7 & (CA2 ^ BA2)), o3[C4 + 100 >> 2] = J4, Y4 = QA2 ^ (g6 = I7 & (QA2 ^ iA2)), o3[C4 + 52 >> 2] = Y4 - J4, N4 = $3 ^ (b4 = I7 & ($3 ^ AA2)), o3[C4 + 96 >> 2] = N4, G4 = (I7 &= IA2 ^ gA2) ^ IA2, o3[C4 + 48 >> 2] = G4 - N4, t4 = p4 ^ Z3, H4 ^= q4, o3[C4 + 36 >> 2] = t4 - H4, p4 = M4 ^ pA2, u4 ^= sA2, o3[C4 + 32 >> 2] = p4 - u4, M4 = l4 ^ hA2, k4 ^= wA2, o3[C4 + 28 >> 2] = M4 - k4, l4 = r4 ^ yA2, s4 ^= cA2, o3[C4 + 24 >> 2] = l4 - s4, r4 = h4 ^ eA2, i4 ^= tA2, o3[C4 + 20 >> 2] = r4 - i4, h4 = y4 ^ fA2, c4 ^= rA2, o3[C4 + 16 >> 2] = h4 - c4, y4 = n4 ^ nA2, e4 ^= aA2, o3[C4 + 12 >> 2] = y4 - e4, n4 = Q4 ^ oA2, f4 ^= EA2, o3[C4 + 8 >> 2] = n4 - f4, Q4 = g6 ^ iA2, B4 ^= BA2, o3[C4 + 4 >> 2] = Q4 - B4, g6 = I7 ^ gA2, I7 = b4 ^ AA2, o3[C4 >> 2] = g6 - I7, o3[C4 + 276 >> 2] = t4 + H4, o3[C4 + 272 >> 2] = p4 + u4, o3[C4 + 268 >> 2] = k4 + M4, o3[C4 + 264 >> 2] = s4 + l4, o3[C4 + 260 >> 2] = i4 + r4, o3[C4 + 256 >> 2] = c4 + h4, o3[C4 + 248 >> 2] = n4 + f4, o3[C4 + 244 >> 2] = B4 + Q4, o3[C4 + 240 >> 2] = I7 + g6, o3[C4 + 252 >> 2] = e4 + y4, o3[C4 + 228 >> 2] = U4 + z4, o3[C4 + 224 >> 2] = _4 + V4, o3[C4 + 220 >> 2] = m4 + kA2, o3[C4 + 216 >> 2] = d4 + FA2, o3[C4 + 212 >> 2] = L4 + lA2, o3[C4 + 208 >> 2] = v4 + R4, o3[C4 + 204 >> 2] = x4 + O4, o3[C4 + 200 >> 2] = K4 + j4, o3[C4 + 196 >> 2] = J4 + Y4, o3[C4 + 192 >> 2] = G4 + N4, F3(z4 = C4 + 96 | 0, _4 = C4 + 48 | 0, G4 = C4 + 240 | 0), F3(U4 = C4 + 192 | 0, U4, C4), S3(_4, C4), S3(C4, G4), t4 = o3[C4 + 192 >> 2], H4 = o3[C4 + 96 >> 2], p4 = o3[C4 + 196 >> 2], u4 = o3[C4 + 100 >> 2], M4 = o3[C4 + 200 >> 2], k4 = o3[C4 + 104 >> 2], l4 = o3[C4 + 204 >> 2], s4 = o3[C4 + 108 >> 2], r4 = o3[C4 + 208 >> 2], i4 = o3[C4 + 112 >> 2], h4 = o3[C4 + 212 >> 2], c4 = o3[C4 + 116 >> 2], y4 = o3[C4 + 216 >> 2], e4 = o3[C4 + 120 >> 2], n4 = o3[C4 + 220 >> 2], f4 = o3[C4 + 124 >> 2], Q4 = o3[C4 + 224 >> 2], B4 = o3[C4 + 128 >> 2], g6 = o3[C4 + 228 >> 2], I7 = o3[C4 + 132 >> 2], o3[C4 + 180 >> 2] = g6 + I7, o3[C4 + 176 >> 2] = B4 + Q4, o3[C4 + 172 >> 2] = n4 + f4, o3[C4 + 168 >> 2] = e4 + y4, o3[C4 + 164 >> 2] = c4 + h4, o3[C4 + 160 >> 2] = i4 + r4, o3[C4 + 156 >> 2] = s4 + l4, o3[C4 + 152 >> 2] = k4 + M4, o3[C4 + 148 >> 2] = p4 + u4, o3[C4 + 144 >> 2] = t4 + H4, o3[C4 + 228 >> 2] = I7 - g6, o3[C4 + 224 >> 2] = B4 - Q4, o3[C4 + 220 >> 2] = f4 - n4, o3[C4 + 216 >> 2] = e4 - y4, o3[C4 + 212 >> 2] = c4 - h4, o3[C4 + 208 >> 2] = i4 - r4, o3[C4 + 204 >> 2] = s4 - l4, o3[C4 + 200 >> 2] = k4 - M4, o3[C4 + 196 >> 2] = u4 - p4, o3[C4 + 192 >> 2] = H4 - t4, F3(G4, C4, _4), m4 = o3[C4 + 52 >> 2], s4 = o3[C4 + 4 >> 2], d4 = o3[C4 + 56 >> 2], r4 = o3[C4 + 8 >> 2], L4 = o3[C4 + 64 >> 2], i4 = o3[C4 + 16 >> 2], R4 = o3[C4 + 60 >> 2], e4 = o3[C4 + 12 >> 2], x4 = o3[C4 + 72 >> 2], n4 = o3[C4 + 24 >> 2], j4 = o3[C4 + 68 >> 2], f4 = o3[C4 + 20 >> 2], J4 = o3[C4 + 80 >> 2], B4 = o3[C4 + 32 >> 2], N4 = o3[C4 + 76 >> 2], g6 = o3[C4 + 28 >> 2], q4 = o3[C4 + 84 >> 2], I7 = o3[C4 + 36 >> 2], V4 = o3[C4 + 48 >> 2], Q4 = o3[C4 >> 2] - V4 | 0, o3[C4 >> 2] = Q4, I7 = I7 - q4 | 0, o3[C4 + 36 >> 2] = I7, b4 = g6 - N4 | 0, o3[C4 + 28 >> 2] = b4, G4 = B4 - J4 | 0, o3[C4 + 32 >> 2] = G4, h4 = f4 - j4 | 0, o3[C4 + 20 >> 2] = h4, c4 = n4 - x4 | 0, o3[C4 + 24 >> 2] = c4, y4 = e4 - R4 | 0, o3[C4 + 12 >> 2] = y4, e4 = i4 - L4 | 0, o3[C4 + 16 >> 2] = e4, n4 = r4 - d4 | 0, o3[C4 + 8 >> 2] = n4, B4 = s4 - m4 | 0, o3[C4 + 4 >> 2] = B4, S3(U4, U4), I7 = DA(I7, I7 >> 31, 121666, 0), g6 = w3, O4 = I7, I7 = DA((33554431 & (g6 = (t4 = I7 + 16777216 | 0) >>> 0 < 16777216 ? g6 + 1 | 0 : g6)) << 7 | t4 >>> 25, g6 >> 25, 19, 0), f4 = w3, g6 = I7, I7 = DA(Q4, Q4 >> 31, 121666, 0), v4 = w3 + f4 | 0, I7 = I7 >>> 0 > (g6 = g6 + I7 | 0) >>> 0 ? v4 + 1 | 0 : v4, I7 = (f4 = g6 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, H4 = g6 - (-67108864 & f4) | 0, o3[C4 + 96 >> 2] = H4, Q4 = DA(B4, B4 >> 31, 121666, 0), g6 = w3, g6 = (B4 = Q4 + 16777216 | 0) >>> 0 < 16777216 ? g6 + 1 | 0 : g6, p4 = (I7 = (67108863 & I7) << 6 | f4 >>> 26) + (Q4 - (-33554432 & B4) | 0) | 0, o3[C4 + 100 >> 2] = p4, v4 = g6 >> 25, B4 = (33554431 & g6) << 7 | B4 >>> 25, g6 = DA(n4, n4 >> 31, 121666, 0) + B4 | 0, I7 = v4 + w3 | 0, I7 = g6 >>> 0 < B4 >>> 0 ? I7 + 1 | 0 : I7, f4 = (u4 = g6 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, M4 = g6 - (-67108864 & u4) | 0, o3[C4 + 104 >> 2] = M4, B4 = DA(e4, e4 >> 31, 121666, 0), Q4 = w3, g6 = DA(y4, y4 >> 31, 121666, 0), I7 = w3, Y4 = B4, K4 = g6, B4 = (33554431 & (I7 = (k4 = g6 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7)) << 7 | k4 >>> 25, I7 = (I7 >> 25) + Q4 | 0, I7 = (g6 = Y4 + B4 | 0) >>> 0 < B4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = (l4 = g6 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, s4 = g6 - (-67108864 & l4) | 0, o3[C4 + 112 >> 2] = s4, B4 = DA(c4, c4 >> 31, 121666, 0), n4 = w3, g6 = DA(h4, h4 >> 31, 121666, 0), I7 = w3, Y4 = g6, g6 = (33554431 & (I7 = (r4 = g6 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7)) << 7 | r4 >>> 25, I7 = (I7 >> 25) + n4 | 0, I7 = g6 >>> 0 > (B4 = g6 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, g6 = (i4 = B4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, h4 = B4 - (-67108864 & i4) | 0, o3[C4 + 120 >> 2] = h4, n4 = DA(G4, G4 >> 31, 121666, 0), e4 = w3, B4 = DA(b4, b4 >> 31, 121666, 0), I7 = w3, G4 = B4, B4 = (33554431 & (I7 = (c4 = B4 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7)) << 7 | c4 >>> 25, I7 = (I7 >> 25) + e4 | 0, I7 = B4 >>> 0 > (n4 = B4 + n4 | 0) >>> 0 ? I7 + 1 | 0 : I7, B4 = (y4 = n4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7, e4 = n4 - (-67108864 & y4) | 0, o3[C4 + 128 >> 2] = e4, n4 = (f4 = K4 + ((67108863 & f4) << 6 | u4 >>> 26) | 0) - (-33554432 & k4) | 0, o3[C4 + 108 >> 2] = n4, f4 = (Q4 = Y4 + ((67108863 & Q4) << 6 | l4 >>> 26) | 0) - (-33554432 & r4) | 0, o3[C4 + 116 >> 2] = f4, Q4 = (I7 = G4 + ((67108863 & g6) << 6 | i4 >>> 26) | 0) - (-33554432 & c4) | 0, o3[C4 + 124 >> 2] = Q4, g6 = (B4 = O4 + ((67108863 & B4) << 6 | y4 >>> 26) | 0) - (-33554432 & t4) | 0, o3[C4 + 132 >> 2] = g6, S3(I7 = C4 + 144 | 0, I7), o3[C4 + 84 >> 2] = g6 + q4, o3[C4 + 80 >> 2] = e4 + J4, o3[C4 + 76 >> 2] = Q4 + N4, o3[C4 + 72 >> 2] = h4 + x4, o3[C4 + 68 >> 2] = f4 + j4, o3[C4 + 64 >> 2] = s4 + L4, o3[C4 + 60 >> 2] = n4 + R4, o3[C4 + 56 >> 2] = M4 + d4, o3[C4 + 52 >> 2] = p4 + m4, o3[C4 + 48 >> 2] = H4 + V4, g6 = uA2 - 1 | 0, F3(z4, C4 + 288 | 0, U4), F3(U4, C4, _4), uA2; )
                          ;
                        h4 = o3[C4 + 144 >> 2], H4 = o3[C4 + 240 >> 2], c4 = o3[C4 + 148 >> 2], p4 = o3[C4 + 244 >> 2], y4 = o3[C4 + 152 >> 2], u4 = o3[C4 + 248 >> 2], e4 = o3[C4 + 156 >> 2], M4 = o3[C4 + 252 >> 2], n4 = o3[C4 + 160 >> 2], k4 = o3[C4 + 256 >> 2], f4 = o3[C4 + 164 >> 2], l4 = o3[C4 + 260 >> 2], Q4 = o3[C4 + 168 >> 2], s4 = o3[C4 + 264 >> 2], B4 = o3[C4 + 172 >> 2], r4 = o3[C4 + 268 >> 2], g6 = o3[C4 + 176 >> 2], i4 = o3[C4 + 272 >> 2], t4 = 0 - T4 | 0, I7 = o3[C4 + 276 >> 2], o3[C4 + 276 >> 2] = t4 & (I7 ^ o3[C4 + 180 >> 2]) ^ I7, o3[C4 + 272 >> 2] = i4 ^ t4 & (g6 ^ i4), o3[C4 + 268 >> 2] = r4 ^ t4 & (B4 ^ r4), o3[C4 + 264 >> 2] = s4 ^ t4 & (Q4 ^ s4), o3[C4 + 260 >> 2] = l4 ^ t4 & (f4 ^ l4), o3[C4 + 256 >> 2] = k4 ^ t4 & (n4 ^ k4), o3[C4 + 252 >> 2] = M4 ^ t4 & (e4 ^ M4), o3[C4 + 248 >> 2] = u4 ^ t4 & (y4 ^ u4), o3[C4 + 244 >> 2] = p4 ^ t4 & (c4 ^ p4), o3[C4 + 240 >> 2] = H4 ^ t4 & (h4 ^ H4), H4 = o3[C4 + 192 >> 2], h4 = o3[C4 + 96 >> 2], p4 = o3[C4 + 196 >> 2], c4 = o3[C4 + 100 >> 2], u4 = o3[C4 + 200 >> 2], y4 = o3[C4 + 104 >> 2], M4 = o3[C4 + 204 >> 2], e4 = o3[C4 + 108 >> 2], k4 = o3[C4 + 208 >> 2], n4 = o3[C4 + 112 >> 2], l4 = o3[C4 + 212 >> 2], f4 = o3[C4 + 116 >> 2], s4 = o3[C4 + 216 >> 2], Q4 = o3[C4 + 120 >> 2], r4 = o3[C4 + 220 >> 2], B4 = o3[C4 + 124 >> 2], i4 = o3[C4 + 224 >> 2], g6 = o3[C4 + 128 >> 2], I7 = o3[C4 + 228 >> 2], o3[C4 + 228 >> 2] = t4 & (I7 ^ o3[C4 + 132 >> 2]) ^ I7, o3[C4 + 224 >> 2] = i4 ^ t4 & (g6 ^ i4), o3[C4 + 220 >> 2] = r4 ^ t4 & (B4 ^ r4), o3[C4 + 216 >> 2] = s4 ^ t4 & (Q4 ^ s4), o3[C4 + 212 >> 2] = l4 ^ t4 & (f4 ^ l4), o3[C4 + 208 >> 2] = k4 ^ t4 & (n4 ^ k4), o3[C4 + 204 >> 2] = M4 ^ t4 & (e4 ^ M4), o3[C4 + 200 >> 2] = u4 ^ t4 & (y4 ^ u4), o3[C4 + 196 >> 2] = p4 ^ t4 & (c4 ^ p4), o3[C4 + 192 >> 2] = H4 ^ t4 & (h4 ^ H4), X3(g6 = C4 + 192 | 0, g6), F3(I7 = C4 + 240 | 0, I7, g6), W3(A8, I7), $A(C4 + 336 | 0, 32), B4 = 0;
                      }
                      return D3 = C4 + 368 | 0, 0 | B4;
                    }, function(A8, I7) {
                      var g6, C4, B4, Q4, i4, n4, r4, f4, t4, e4, c4, y4, w4, h4, s4, p4, u4, k4, l4, S4;
                      return I7 |= 0, D3 = g6 = D3 - 304 | 0, E3[0 | (A8 |= 0)] = a3[0 | I7], E3[A8 + 1 | 0] = a3[I7 + 1 | 0], E3[A8 + 2 | 0] = a3[I7 + 2 | 0], E3[A8 + 3 | 0] = a3[I7 + 3 | 0], E3[A8 + 4 | 0] = a3[I7 + 4 | 0], E3[A8 + 5 | 0] = a3[I7 + 5 | 0], E3[A8 + 6 | 0] = a3[I7 + 6 | 0], E3[A8 + 7 | 0] = a3[I7 + 7 | 0], E3[A8 + 8 | 0] = a3[I7 + 8 | 0], E3[A8 + 9 | 0] = a3[I7 + 9 | 0], E3[A8 + 10 | 0] = a3[I7 + 10 | 0], E3[A8 + 11 | 0] = a3[I7 + 11 | 0], E3[A8 + 12 | 0] = a3[I7 + 12 | 0], E3[A8 + 13 | 0] = a3[I7 + 13 | 0], E3[A8 + 14 | 0] = a3[I7 + 14 | 0], E3[A8 + 15 | 0] = a3[I7 + 15 | 0], E3[A8 + 16 | 0] = a3[I7 + 16 | 0], E3[A8 + 17 | 0] = a3[I7 + 17 | 0], E3[A8 + 18 | 0] = a3[I7 + 18 | 0], E3[A8 + 19 | 0] = a3[I7 + 19 | 0], E3[A8 + 20 | 0] = a3[I7 + 20 | 0], E3[A8 + 21 | 0] = a3[I7 + 21 | 0], E3[A8 + 22 | 0] = a3[I7 + 22 | 0], E3[A8 + 23 | 0] = a3[I7 + 23 | 0], E3[A8 + 24 | 0] = a3[I7 + 24 | 0], E3[A8 + 25 | 0] = a3[I7 + 25 | 0], E3[A8 + 26 | 0] = a3[I7 + 26 | 0], E3[A8 + 27 | 0] = a3[I7 + 27 | 0], E3[A8 + 28 | 0] = a3[I7 + 28 | 0], E3[A8 + 29 | 0] = a3[I7 + 29 | 0], E3[A8 + 30 | 0] = a3[I7 + 30 | 0], I7 = a3[I7 + 31 | 0], E3[0 | A8] = 248 & a3[0 | A8], E3[A8 + 31 | 0] = 63 & I7 | 64, v3(g6 + 48 | 0, A8), I7 = o3[g6 + 132 >> 2], C4 = o3[g6 + 92 >> 2], B4 = o3[g6 + 136 >> 2], Q4 = o3[g6 + 96 >> 2], i4 = o3[g6 + 140 >> 2], n4 = o3[g6 + 100 >> 2], r4 = o3[g6 + 144 >> 2], f4 = o3[g6 + 104 >> 2], t4 = o3[g6 + 148 >> 2], e4 = o3[g6 + 108 >> 2], c4 = o3[g6 + 152 >> 2], y4 = o3[g6 + 112 >> 2], w4 = o3[g6 + 156 >> 2], h4 = o3[g6 + 116 >> 2], s4 = o3[g6 + 160 >> 2], p4 = o3[g6 + 120 >> 2], u4 = o3[g6 + 128 >> 2], k4 = o3[g6 + 88 >> 2], l4 = o3[g6 + 124 >> 2], S4 = o3[g6 + 164 >> 2], o3[g6 + 292 >> 2] = l4 + S4, o3[g6 + 288 >> 2] = s4 + p4, o3[g6 + 284 >> 2] = w4 + h4, o3[g6 + 280 >> 2] = c4 + y4, o3[g6 + 276 >> 2] = t4 + e4, o3[g6 + 272 >> 2] = r4 + f4, o3[g6 + 268 >> 2] = i4 + n4, o3[g6 + 264 >> 2] = B4 + Q4, o3[g6 + 260 >> 2] = I7 + C4, o3[g6 + 256 >> 2] = u4 + k4, o3[g6 + 244 >> 2] = S4 - l4, o3[g6 + 240 >> 2] = s4 - p4, o3[g6 + 236 >> 2] = w4 - h4, o3[g6 + 232 >> 2] = c4 - y4, o3[g6 + 228 >> 2] = t4 - e4, o3[g6 + 224 >> 2] = r4 - f4, o3[g6 + 220 >> 2] = i4 - n4, o3[g6 + 216 >> 2] = B4 - Q4, o3[g6 + 212 >> 2] = I7 - C4, o3[g6 + 208 >> 2] = u4 - k4, X3(I7 = g6 + 208 | 0, I7), F3(g6, g6 + 256 | 0, I7), W3(A8, g6), D3 = g6 + 304 | 0, 0;
                    }, function(A8, I7, g6, C4, B4) {
                      A8 |= 0, C4 |= 0, B4 |= 0;
                      var Q4, i4 = 0, n4 = 0, r4 = 0, f4 = 0;
                      if (D3 = Q4 = D3 - 112 | 0, (I7 |= 0) | (g6 |= 0)) {
                        i4 = a3[B4 + 28 | 0] | a3[B4 + 29 | 0] << 8 | a3[B4 + 30 | 0] << 16 | a3[B4 + 31 | 0] << 24, o3[Q4 + 24 >> 2] = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, o3[Q4 + 28 >> 2] = i4, i4 = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, o3[Q4 + 16 >> 2] = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, o3[Q4 + 20 >> 2] = i4, i4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, o3[Q4 >> 2] = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[Q4 + 4 >> 2] = i4, i4 = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, o3[Q4 + 8 >> 2] = a3[B4 + 8 | 0] | a3[B4 + 9 | 0] << 8 | a3[B4 + 10 | 0] << 16 | a3[B4 + 11 | 0] << 24, o3[Q4 + 12 >> 2] = i4, B4 = a3[0 | C4] | a3[C4 + 1 | 0] << 8 | a3[C4 + 2 | 0] << 16 | a3[C4 + 3 | 0] << 24, C4 = a3[C4 + 4 | 0] | a3[C4 + 5 | 0] << 8 | a3[C4 + 6 | 0] << 16 | a3[C4 + 7 | 0] << 24, o3[Q4 + 104 >> 2] = 0, o3[Q4 + 108 >> 2] = 0, o3[Q4 + 96 >> 2] = B4, o3[Q4 + 100 >> 2] = C4;
                        A: {
                          if (!g6 & I7 >>> 0 >= 64 | g6) {
                            for (; J3(A8, Q4 + 96 | 0, Q4), C4 = a3[Q4 + 104 | 0] + 1 | 0, E3[Q4 + 104 | 0] = C4, C4 = a3[Q4 + 105 | 0] + (C4 >>> 8 | 0) | 0, E3[Q4 + 105 | 0] = C4, C4 = a3[Q4 + 106 | 0] + (C4 >>> 8 | 0) | 0, E3[Q4 + 106 | 0] = C4, C4 = a3[Q4 + 107 | 0] + (C4 >>> 8 | 0) | 0, E3[Q4 + 107 | 0] = C4, C4 = a3[Q4 + 108 | 0] + (C4 >>> 8 | 0) | 0, E3[Q4 + 108 | 0] = C4, C4 = a3[Q4 + 109 | 0] + (C4 >>> 8 | 0) | 0, E3[Q4 + 109 | 0] = C4, C4 = a3[Q4 + 110 | 0] + (C4 >>> 8 | 0) | 0, E3[Q4 + 110 | 0] = C4, E3[Q4 + 111 | 0] = a3[Q4 + 111 | 0] + (C4 >>> 8 | 0), A8 = A8 - -64 | 0, g6 = g6 - 1 | 0, !(g6 = (I7 = I7 + -64 | 0) >>> 0 < 4294967232 ? g6 + 1 | 0 : g6) & I7 >>> 0 > 63 | g6; )
                              ;
                            if (!(I7 | g6))
                              break A;
                          }
                          if (C4 = 0, J3(Q4 + 32 | 0, Q4 + 96 | 0, Q4), g6 = 3 & I7, B4 = 0, I7 - 1 >>> 0 >= 3)
                            for (i4 = -4 & I7, I7 = 0; n4 = r4 = Q4 + 32 | 0, E3[A8 + B4 | 0] = a3[n4 + B4 | 0], E3[(f4 = 1 | B4) + A8 | 0] = a3[n4 + f4 | 0], E3[(n4 = 2 | B4) + A8 | 0] = a3[n4 + r4 | 0], E3[(n4 = 3 | B4) + A8 | 0] = a3[n4 + (Q4 + 32 | 0) | 0], B4 = B4 + 4 | 0, (0 | i4) != (0 | (I7 = I7 + 4 | 0)); )
                              ;
                          if (g6)
                            for (; E3[A8 + B4 | 0] = a3[(Q4 + 32 | 0) + B4 | 0], B4 = B4 + 1 | 0, (0 | g6) != (0 | (C4 = C4 + 1 | 0)); )
                              ;
                        }
                        $A(Q4 + 32 | 0, 64), $A(Q4, 32);
                      }
                      return D3 = Q4 + 112 | 0, 0;
                    }, function(A8, I7, g6, C4, B4, Q4, i4, n4) {
                      A8 |= 0, I7 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0, n4 |= 0;
                      var r4, f4 = 0;
                      if (D3 = r4 = D3 - 112 | 0, (g6 |= 0) | (C4 |= 0)) {
                        f4 = a3[n4 + 28 | 0] | a3[n4 + 29 | 0] << 8 | a3[n4 + 30 | 0] << 16 | a3[n4 + 31 | 0] << 24, o3[r4 + 24 >> 2] = a3[n4 + 24 | 0] | a3[n4 + 25 | 0] << 8 | a3[n4 + 26 | 0] << 16 | a3[n4 + 27 | 0] << 24, o3[r4 + 28 >> 2] = f4, f4 = a3[n4 + 20 | 0] | a3[n4 + 21 | 0] << 8 | a3[n4 + 22 | 0] << 16 | a3[n4 + 23 | 0] << 24, o3[r4 + 16 >> 2] = a3[n4 + 16 | 0] | a3[n4 + 17 | 0] << 8 | a3[n4 + 18 | 0] << 16 | a3[n4 + 19 | 0] << 24, o3[r4 + 20 >> 2] = f4, f4 = a3[n4 + 4 | 0] | a3[n4 + 5 | 0] << 8 | a3[n4 + 6 | 0] << 16 | a3[n4 + 7 | 0] << 24, o3[r4 >> 2] = a3[0 | n4] | a3[n4 + 1 | 0] << 8 | a3[n4 + 2 | 0] << 16 | a3[n4 + 3 | 0] << 24, o3[r4 + 4 >> 2] = f4, f4 = a3[n4 + 12 | 0] | a3[n4 + 13 | 0] << 8 | a3[n4 + 14 | 0] << 16 | a3[n4 + 15 | 0] << 24, o3[r4 + 8 >> 2] = a3[n4 + 8 | 0] | a3[n4 + 9 | 0] << 8 | a3[n4 + 10 | 0] << 16 | a3[n4 + 11 | 0] << 24, o3[r4 + 12 >> 2] = f4, n4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, o3[r4 + 96 >> 2] = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, o3[r4 + 100 >> 2] = n4, E3[r4 + 104 | 0] = Q4, E3[r4 + 111 | 0] = i4 >>> 24, E3[r4 + 110 | 0] = i4 >>> 16, E3[r4 + 109 | 0] = i4 >>> 8, E3[r4 + 108 | 0] = i4, E3[r4 + 107 | 0] = (16777215 & i4) << 8 | Q4 >>> 24, E3[r4 + 106 | 0] = (65535 & i4) << 16 | Q4 >>> 16, E3[r4 + 105 | 0] = (255 & i4) << 24 | Q4 >>> 8;
                        A: {
                          if (!C4 & g6 >>> 0 >= 64 | C4) {
                            for (; ; ) {
                              for (n4 = 0, J3(r4 + 32 | 0, r4 + 96 | 0, r4); Q4 = r4 + 32 | 0, E3[A8 + n4 | 0] = a3[Q4 + n4 | 0] ^ a3[I7 + n4 | 0], E3[(B4 = 1 | n4) + A8 | 0] = a3[B4 + Q4 | 0] ^ a3[I7 + B4 | 0], 64 != (0 | (n4 = n4 + 2 | 0)); )
                                ;
                              if (B4 = a3[r4 + 104 | 0] + 1 | 0, E3[r4 + 104 | 0] = B4, B4 = a3[r4 + 105 | 0] + (B4 >>> 8 | 0) | 0, E3[r4 + 105 | 0] = B4, B4 = a3[r4 + 106 | 0] + (B4 >>> 8 | 0) | 0, E3[r4 + 106 | 0] = B4, B4 = a3[r4 + 107 | 0] + (B4 >>> 8 | 0) | 0, E3[r4 + 107 | 0] = B4, B4 = a3[r4 + 108 | 0] + (B4 >>> 8 | 0) | 0, E3[r4 + 108 | 0] = B4, B4 = a3[r4 + 109 | 0] + (B4 >>> 8 | 0) | 0, E3[r4 + 109 | 0] = B4, B4 = a3[r4 + 110 | 0] + (B4 >>> 8 | 0) | 0, E3[r4 + 110 | 0] = B4, E3[r4 + 111 | 0] = a3[r4 + 111 | 0] + (B4 >>> 8 | 0), I7 = I7 - -64 | 0, A8 = A8 - -64 | 0, C4 = C4 - 1 | 0, !(!(C4 = (g6 = g6 + -64 | 0) >>> 0 < 4294967232 ? C4 + 1 | 0 : C4) & g6 >>> 0 > 63 | C4))
                                break;
                            }
                            if (!(g6 | C4))
                              break A;
                          }
                          if (n4 = 0, J3(r4 + 32 | 0, r4 + 96 | 0, r4), C4 = 1 & g6, 1 != (0 | g6))
                            for (Q4 = -2 & g6, B4 = 0; i4 = r4 + 32 | 0, E3[A8 + n4 | 0] = a3[i4 + n4 | 0] ^ a3[I7 + n4 | 0], E3[(g6 = 1 | n4) + A8 | 0] = a3[g6 + i4 | 0] ^ a3[I7 + g6 | 0], n4 = n4 + 2 | 0, (0 | Q4) != (0 | (B4 = B4 + 2 | 0)); )
                              ;
                          C4 && (E3[A8 + n4 | 0] = a3[(r4 + 32 | 0) + n4 | 0] ^ a3[I7 + n4 | 0]);
                        }
                        $A(r4 + 32 | 0, 64), $A(r4, 32);
                      }
                      return D3 = r4 + 112 | 0, 0;
                    }], aI.grow = function(A8) {
                      var I7 = this.length;
                      return this.length = this.length + A8, I7;
                    }, aI.set = function(A8, I7) {
                      this[A8] = I7;
                    }, aI.get = function(A8) {
                      return this[A8];
                    }, aI);
                    function rI() {
                      return i3.byteLength / 65536 | 0;
                    }
                    return { f: function() {
                    }, g: function(A8, I7, g6, C4, B4, Q4, i4, E4, o4, a4, n4, r4) {
                      return 0 | eA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, (A8 = 0) | (B4 |= 0), Q4 |= 0, i4 |= 0, A8 | (E4 |= 0), o4 |= 0, n4 |= 0, r4 |= 0);
                    }, h: function(A8, I7, g6, C4, B4, i4, E4, a4, n4, r4, f4) {
                      return A8 |= 0, I7 |= 0, n4 |= 0, n4 = C4 |= 0, !(C4 = B4 |= 0) & (B4 = 0 | n4) >>> 0 < 4294967280 ? (eA(A8, A8 + B4 | 0, 0, g6 |= 0, B4, C4, i4 |= 0, E4 |= 0, a4 |= 0, r4 |= 0, f4 |= 0), I7 && (C4 = (A8 = B4 + 16 | 0) >>> 0 < 16 ? C4 + 1 | 0 : C4, o3[I7 >> 2] = A8, o3[I7 + 4 >> 2] = C4)) : (mA(), Q3()), 0;
                    }, i: function(A8, I7, g6, C4, B4, Q4, i4, E4, o4, a4, n4, r4) {
                      return 0 | fA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, (A8 = 0) | (B4 |= 0), Q4 |= 0, i4 |= 0, A8 | (E4 |= 0), o4 |= 0, n4 |= 0, r4 |= 0);
                    }, j: function(A8, I7, g6, C4, B4, i4, E4, a4, n4, r4, f4) {
                      return A8 |= 0, I7 |= 0, n4 |= 0, n4 = C4 |= 0, !(C4 = B4 |= 0) & (B4 = 0 | n4) >>> 0 < 4294967280 ? (fA(A8, A8 + B4 | 0, 0, g6 |= 0, B4, C4, i4 |= 0, E4 |= 0, a4 |= 0, r4 |= 0, f4 |= 0), I7 && (C4 = (A8 = B4 + 16 | 0) >>> 0 < 16 ? C4 + 1 | 0 : C4, o3[I7 >> 2] = A8, o3[I7 + 4 >> 2] = C4)) : (mA(), Q3()), 0;
                    }, k: function(A8, I7, g6, C4, B4, Q4, i4, E4, o4, a4, n4) {
                      return 0 | tA(A8 |= 0, g6 |= 0, (A8 = 0) | (C4 |= 0), B4 |= 0, Q4 |= 0, i4 |= 0, A8 | (E4 |= 0), o4 |= 0, a4 |= 0, n4 |= 0);
                    }, l: function(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4, r4) {
                      return I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, E4 |= 0, E4 |= 0, g6 = -1, !(Q4 |= 0) & (B4 |= 0) >>> 0 >= 16 | Q4 && (g6 = tA(A8 |= 0, C4, B4 - 16 | 0, Q4 - (B4 >>> 0 < 16) | 0, (C4 + B4 | 0) - 16 | 0, i4 |= 0, E4, a4 |= 0, n4 |= 0, r4 |= 0)), I7 && (o3[I7 >> 2] = g6 ? 0 : B4 - 16 | 0, o3[I7 + 4 >> 2] = g6 ? 0 : Q4 - (B4 >>> 0 < 16) | 0), 0 | g6;
                    }, m: function(A8, I7, g6, C4, B4, Q4, i4, E4, o4, a4, n4) {
                      return 0 | rA(A8 |= 0, g6 |= 0, (A8 = 0) | (C4 |= 0), B4 |= 0, Q4 |= 0, i4 |= 0, A8 | (E4 |= 0), o4 |= 0, a4 |= 0, n4 |= 0);
                    }, n: function(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4, r4) {
                      return I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, E4 |= 0, E4 |= 0, g6 = -1, !(Q4 |= 0) & (B4 |= 0) >>> 0 >= 16 | Q4 && (g6 = rA(A8 |= 0, C4, B4 - 16 | 0, Q4 - (B4 >>> 0 < 16) | 0, (C4 + B4 | 0) - 16 | 0, i4 |= 0, E4, a4 |= 0, n4 |= 0, r4 |= 0)), I7 && (o3[I7 >> 2] = g6 ? 0 : B4 - 16 | 0, o3[I7 + 4 >> 2] = g6 ? 0 : Q4 - (B4 >>> 0 < 16) | 0), 0 | g6;
                    }, o: II, p: function() {
                      return 12;
                    }, q: oI, r: AI, s: CI, t: ZA, u: II, v: EI, w: oI, x: AI, y: CI, z: ZA, A: function(A8, I7, g6, C4, B4, Q4, i4, E4, o4, a4, n4, r4) {
                      return 0 | BA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, (A8 = 0) | (B4 |= 0), Q4 |= 0, i4 |= 0, A8 | (E4 |= 0), o4 |= 0, n4 |= 0, r4 |= 0);
                    }, B: function(A8, I7, g6, C4, B4, i4, E4, a4, n4, r4, f4) {
                      return A8 |= 0, I7 |= 0, n4 |= 0, n4 = C4 |= 0, !(C4 = B4 |= 0) & (B4 = 0 | n4) >>> 0 < 4294967280 ? (BA(A8, A8 + B4 | 0, 0, g6 |= 0, B4, C4, i4 |= 0, E4 |= 0, a4 |= 0, r4 |= 0, f4 |= 0), I7 && (C4 = (A8 = B4 + 16 | 0) >>> 0 < 16 ? C4 + 1 | 0 : C4, o3[I7 >> 2] = A8, o3[I7 + 4 >> 2] = C4)) : (mA(), Q3()), 0;
                    }, C: function(A8, I7, g6, C4, B4, Q4, i4, E4, o4, a4, n4) {
                      return 0 | CA(A8 |= 0, g6 |= 0, (A8 = 0) | (C4 |= 0), B4 |= 0, Q4 |= 0, i4 |= 0, A8 | (E4 |= 0), o4 |= 0, a4 |= 0, n4 |= 0);
                    }, D: function(A8, I7, g6, C4, B4, Q4, i4, E4, a4, n4, r4) {
                      return I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, E4 |= 0, E4 |= 0, g6 = -1, !(Q4 |= 0) & (B4 |= 0) >>> 0 >= 16 | Q4 && (g6 = CA(A8 |= 0, C4, B4 - 16 | 0, Q4 - (B4 >>> 0 < 16) | 0, (C4 + B4 | 0) - 16 | 0, i4 |= 0, E4, a4 |= 0, n4 |= 0, r4 |= 0)), I7 && (o3[I7 >> 2] = g6 ? 0 : B4 - 16 | 0, o3[I7 + 4 >> 2] = g6 ? 0 : Q4 - (B4 >>> 0 < 16) | 0), 0 | g6;
                    }, E: II, F: gI, G: oI, H: AI, I: CI, J: ZA, K: II, L: II, M: function(A8, I7, g6, C4, B4) {
                      var Q4;
                      return A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, D3 = Q4 = D3 - 480 | 0, AA(Q4, B4 |= 0), WA(Q4, I7, g6, C4), UA(Q4, Q4 + 416 | 0), I7 = o3[Q4 + 444 >> 2], g6 = o3[Q4 + 440 >> 2], E3[A8 + 24 | 0] = g6, E3[A8 + 25 | 0] = g6 >>> 8, E3[A8 + 26 | 0] = g6 >>> 16, E3[A8 + 27 | 0] = g6 >>> 24, E3[A8 + 28 | 0] = I7, E3[A8 + 29 | 0] = I7 >>> 8, E3[A8 + 30 | 0] = I7 >>> 16, E3[A8 + 31 | 0] = I7 >>> 24, I7 = o3[Q4 + 436 >> 2], g6 = o3[Q4 + 432 >> 2], E3[A8 + 16 | 0] = g6, E3[A8 + 17 | 0] = g6 >>> 8, E3[A8 + 18 | 0] = g6 >>> 16, E3[A8 + 19 | 0] = g6 >>> 24, E3[A8 + 20 | 0] = I7, E3[A8 + 21 | 0] = I7 >>> 8, E3[A8 + 22 | 0] = I7 >>> 16, E3[A8 + 23 | 0] = I7 >>> 24, I7 = o3[Q4 + 428 >> 2], g6 = o3[Q4 + 424 >> 2], E3[A8 + 8 | 0] = g6, E3[A8 + 9 | 0] = g6 >>> 8, E3[A8 + 10 | 0] = g6 >>> 16, E3[A8 + 11 | 0] = g6 >>> 24, E3[A8 + 12 | 0] = I7, E3[A8 + 13 | 0] = I7 >>> 8, E3[A8 + 14 | 0] = I7 >>> 16, E3[A8 + 15 | 0] = I7 >>> 24, I7 = o3[Q4 + 420 >> 2], g6 = o3[Q4 + 416 >> 2], E3[0 | A8] = g6, E3[A8 + 1 | 0] = g6 >>> 8, E3[A8 + 2 | 0] = g6 >>> 16, E3[A8 + 3 | 0] = g6 >>> 24, E3[A8 + 4 | 0] = I7, E3[A8 + 5 | 0] = I7 >>> 8, E3[A8 + 6 | 0] = I7 >>> 16, E3[A8 + 7 | 0] = I7 >>> 24, D3 = Q4 + 480 | 0, 0;
                    }, N: function(A8, I7, g6, C4, B4) {
                      var Q4, i4;
                      return A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, D3 = Q4 = D3 - 512 | 0, AA(i4 = Q4 + 32 | 0, B4 |= 0), WA(i4, I7, g6, C4), UA(i4, Q4 + 448 | 0), I7 = o3[Q4 + 476 >> 2], o3[Q4 + 24 >> 2] = o3[Q4 + 472 >> 2], o3[Q4 + 28 >> 2] = I7, I7 = o3[Q4 + 468 >> 2], o3[Q4 + 16 >> 2] = o3[Q4 + 464 >> 2], o3[Q4 + 20 >> 2] = I7, I7 = o3[Q4 + 460 >> 2], o3[Q4 + 8 >> 2] = o3[Q4 + 456 >> 2], o3[Q4 + 12 >> 2] = I7, I7 = o3[Q4 + 452 >> 2], o3[Q4 >> 2] = o3[Q4 + 448 >> 2], o3[Q4 + 4 >> 2] = I7, I7 = cA(A8, Q4), g6 = oA(Q4, A8, 32), D3 = Q4 + 512 | 0, g6 | ((0 | A8) == (0 | Q4) ? -1 : I7);
                    }, O: ZA, P: II, Q: II, R: II, S: II, T: gI, U: AI, V: CI, W: function(A8, I7, g6) {
                      A8 |= 0, I7 |= 0;
                      var C4, B4 = 0;
                      return D3 = C4 = D3 + -64 | 0, QA(C4, g6 |= 0, 32, 0), g6 = o3[C4 + 28 >> 2], B4 = o3[C4 + 24 >> 2], E3[I7 + 24 | 0] = B4, E3[I7 + 25 | 0] = B4 >>> 8, E3[I7 + 26 | 0] = B4 >>> 16, E3[I7 + 27 | 0] = B4 >>> 24, E3[I7 + 28 | 0] = g6, E3[I7 + 29 | 0] = g6 >>> 8, E3[I7 + 30 | 0] = g6 >>> 16, E3[I7 + 31 | 0] = g6 >>> 24, g6 = o3[C4 + 20 >> 2], B4 = o3[C4 + 16 >> 2], E3[I7 + 16 | 0] = B4, E3[I7 + 17 | 0] = B4 >>> 8, E3[I7 + 18 | 0] = B4 >>> 16, E3[I7 + 19 | 0] = B4 >>> 24, E3[I7 + 20 | 0] = g6, E3[I7 + 21 | 0] = g6 >>> 8, E3[I7 + 22 | 0] = g6 >>> 16, E3[I7 + 23 | 0] = g6 >>> 24, g6 = o3[C4 + 12 >> 2], B4 = o3[C4 + 8 >> 2], E3[I7 + 8 | 0] = B4, E3[I7 + 9 | 0] = B4 >>> 8, E3[I7 + 10 | 0] = B4 >>> 16, E3[I7 + 11 | 0] = B4 >>> 24, E3[I7 + 12 | 0] = g6, E3[I7 + 13 | 0] = g6 >>> 8, E3[I7 + 14 | 0] = g6 >>> 16, E3[I7 + 15 | 0] = g6 >>> 24, g6 = o3[C4 + 4 >> 2], B4 = o3[C4 >> 2], E3[0 | I7] = B4, E3[I7 + 1 | 0] = B4 >>> 8, E3[I7 + 2 | 0] = B4 >>> 16, E3[I7 + 3 | 0] = B4 >>> 24, E3[I7 + 4 | 0] = g6, E3[I7 + 5 | 0] = g6 >>> 8, E3[I7 + 6 | 0] = g6 >>> 16, E3[I7 + 7 | 0] = g6 >>> 24, $A(C4, 64), A8 = VA(A8, I7), D3 = C4 - -64 | 0, 0 | A8;
                    }, X: dA, Y: SA, Z: JA, _: function(A8, I7, g6, C4, B4, Q4, i4, E4) {
                      var o4, a4;
                      return A8 |= 0, I7 |= 0, g6 |= 0, Q4 |= 0, a4 = C4 |= 0, C4 = B4 |= 0, D3 = o4 = D3 - 32 | 0, B4 = -1, SA(o4, i4 |= 0, E4 |= 0) || (B4 = IA(A8, I7, g6, a4, C4, Q4, o4), $A(o4, 32)), D3 = o4 + 32 | 0, 0 | B4;
                    }, $: function(A8, I7, g6, C4, B4, i4) {
                      return A8 |= 0, I7 |= 0, B4 |= 0, i4 |= 0, !(C4 |= 0) & (g6 |= 0) >>> 0 >= 4294967280 | C4 && (mA(), Q3()), 0 | IA(A8 + 16 | 0, A8, I7, g6, C4, B4, i4);
                    }, aa: function(A8, I7, g6, C4, B4, Q4, i4) {
                      return 0 | FA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0);
                    }, ba: NA, ca: function(A8, I7, g6, C4, B4, Q4, i4, E4) {
                      var o4, a4;
                      return A8 |= 0, I7 |= 0, g6 |= 0, Q4 |= 0, a4 = C4 |= 0, C4 = B4 |= 0, D3 = o4 = D3 - 32 | 0, B4 = -1, SA(o4, i4 |= 0, E4 |= 0) || (B4 = gA(A8, I7, g6, a4, C4, Q4, o4), $A(o4, 32)), D3 = o4 + 32 | 0, 0 | B4;
                    }, da: lA, ea: function(A8, I7, g6, C4, B4, Q4, i4) {
                      return 0 | sA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0);
                    }, fa: function(A8, I7, g6, C4, B4) {
                      A8 |= 0, I7 |= 0, B4 |= 0;
                      var Q4, i4, a4, n4 = 0, r4 = 0;
                      return i4 = g6 |= 0, g6 = C4 |= 0, a4 = C4 = D3, D3 = Q4 = C4 - 512 & -64, C4 = -1, dA(Q4 - -64 | 0, Q4 + 32 | 0) || (Y3(C4 = Q4 + 128 | 0, 0, 0, 24), z3(C4, r4 = Q4 - -64 | 0, 32, 0), z3(C4, B4, 32, 0), GA(C4, n4 = Q4 + 96 | 0, 24), C4 = FA(A8 + 32 | 0, I7, i4, g6, n4, C4 = B4, B4 = Q4 + 32 | 0), I7 = o3[Q4 + 92 >> 2], g6 = o3[Q4 + 88 >> 2], E3[A8 + 24 | 0] = g6, E3[A8 + 25 | 0] = g6 >>> 8, E3[A8 + 26 | 0] = g6 >>> 16, E3[A8 + 27 | 0] = g6 >>> 24, E3[A8 + 28 | 0] = I7, E3[A8 + 29 | 0] = I7 >>> 8, E3[A8 + 30 | 0] = I7 >>> 16, E3[A8 + 31 | 0] = I7 >>> 24, I7 = o3[Q4 + 84 >> 2], g6 = o3[Q4 + 80 >> 2], E3[A8 + 16 | 0] = g6, E3[A8 + 17 | 0] = g6 >>> 8, E3[A8 + 18 | 0] = g6 >>> 16, E3[A8 + 19 | 0] = g6 >>> 24, E3[A8 + 20 | 0] = I7, E3[A8 + 21 | 0] = I7 >>> 8, E3[A8 + 22 | 0] = I7 >>> 16, E3[A8 + 23 | 0] = I7 >>> 24, I7 = o3[Q4 + 76 >> 2], g6 = o3[Q4 + 72 >> 2], E3[A8 + 8 | 0] = g6, E3[A8 + 9 | 0] = g6 >>> 8, E3[A8 + 10 | 0] = g6 >>> 16, E3[A8 + 11 | 0] = g6 >>> 24, E3[A8 + 12 | 0] = I7, E3[A8 + 13 | 0] = I7 >>> 8, E3[A8 + 14 | 0] = I7 >>> 16, E3[A8 + 15 | 0] = I7 >>> 24, I7 = o3[Q4 + 68 >> 2], g6 = o3[Q4 + 64 >> 2], E3[0 | A8] = g6, E3[A8 + 1 | 0] = g6 >>> 8, E3[A8 + 2 | 0] = g6 >>> 16, E3[A8 + 3 | 0] = g6 >>> 24, E3[A8 + 4 | 0] = I7, E3[A8 + 5 | 0] = I7 >>> 8, E3[A8 + 6 | 0] = I7 >>> 16, E3[A8 + 7 | 0] = I7 >>> 24, $A(B4, 32), $A(r4, 32), $A(n4, 24)), D3 = a4, 0 | C4;
                    }, ga: function(A8, I7, g6, C4, B4, Q4) {
                      A8 |= 0, I7 |= 0, B4 |= 0, Q4 |= 0;
                      var i4, E4, o4 = 0, a4 = 0;
                      return i4 = o4 = D3, D3 = o4 = o4 - 448 & -64, a4 = -1, E4 = C4 |= 0, !C4 & (g6 |= 0) >>> 0 >= 48 | C4 && (Y3(C4 = o4 - -64 | 0, 0, 0, 24), z3(C4, I7, 32, 0), z3(C4, B4, 32, 0), GA(B4 = C4, C4 = o4 + 32 | 0, 24), a4 = sA(A8, I7 + 32 | 0, g6 - 32 | 0, E4 - (g6 >>> 0 < 32) | 0, C4, I7, Q4)), D3 = i4, 0 | a4;
                    }, ha: function() {
                      return 48;
                    }, ia: AI, ja: BI, ka: II, la: AI, ma: BI, na: II, oa: function() {
                      return 384;
                    }, pa: function(A8, I7, g6, C4, B4, Q4, i4) {
                      return 0 | R3(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0);
                    }, qa: Y3, ra: function(A8, I7, g6, C4) {
                      return 0 | z3(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0);
                    }, sa: GA, ta: ZA, ua: BI, va: function(A8, I7, g6, C4) {
                      return 0 | QA(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0);
                    }, wa: AI, xa: BI, ya: EI, za: II, Aa: function(A8, I7, g6, C4, B4, i4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, i4 |= 0;
                      var E4, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0;
                      return D3 = E4 = D3 - 32 | 0, n4 = a3[0 | (B4 |= 0)] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, B4 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, o3[E4 + 24 >> 2] = 0, o3[E4 + 28 >> 2] = 0, o3[E4 + 16 >> 2] = n4, o3[E4 + 20 >> 2] = B4, o3[E4 + 8 >> 2] = 0, o3[E4 + 12 >> 2] = 0, o3[(B4 = E4) >> 2] = g6, o3[B4 + 4 >> 2] = C4, I7 - 65 >>> 0 <= 4294967246 ? (o3[8916] = 28, A8 = -1) : I7 - 65 >>> 0 < 4294967232 ? A8 = -1 : (D3 = B4 = (f4 = D3) - 512 & -64, !i4 | !A8 | ((r4 = 255 & I7) - 65 & 255) >>> 0 <= 191 ? (mA(), Q3()) : (C4 = E4 + 16 | 0, E4 ? (t4 = 725511199 ^ (a3[E4 + 8 | 0] | a3[E4 + 9 | 0] << 8 | a3[E4 + 10 | 0] << 16 | a3[E4 + 11 | 0] << 24), e4 = -1694144372 ^ (a3[E4 + 12 | 0] | a3[E4 + 13 | 0] << 8 | a3[E4 + 14 | 0] << 16 | a3[E4 + 15 | 0] << 24), g6 = -1377402159 ^ (a3[0 | E4] | a3[E4 + 1 | 0] << 8 | a3[E4 + 2 | 0] << 16 | a3[E4 + 3 | 0] << 24), I7 = 1359893119 ^ (a3[E4 + 4 | 0] | a3[E4 + 5 | 0] << 8 | a3[E4 + 6 | 0] << 16 | a3[E4 + 7 | 0] << 24)) : (t4 = 725511199, e4 = -1694144372, g6 = -1377402159, I7 = 1359893119), C4 ? (c4 = 327033209 ^ (a3[C4 + 8 | 0] | a3[C4 + 9 | 0] << 8 | a3[C4 + 10 | 0] << 16 | a3[C4 + 11 | 0] << 24), y4 = 1541459225 ^ (a3[C4 + 12 | 0] | a3[C4 + 13 | 0] << 8 | a3[C4 + 14 | 0] << 16 | a3[C4 + 15 | 0] << 24), n4 = -79577749 ^ (a3[0 | C4] | a3[C4 + 1 | 0] << 8 | a3[C4 + 2 | 0] << 16 | a3[C4 + 3 | 0] << 24), C4 = 528734635 ^ (a3[C4 + 4 | 0] | a3[C4 + 5 | 0] << 8 | a3[C4 + 6 | 0] << 16 | a3[C4 + 7 | 0] << 24)) : (c4 = 327033209, y4 = 1541459225, n4 = -79577749, C4 = 528734635), MA(B4 - -64 | 0, 0, 293), o3[B4 + 56 >> 2] = c4, o3[B4 + 60 >> 2] = y4, o3[B4 + 48 >> 2] = n4, o3[B4 + 52 >> 2] = C4, o3[B4 + 40 >> 2] = t4, o3[B4 + 44 >> 2] = e4, o3[B4 + 32 >> 2] = g6, o3[B4 + 36 >> 2] = I7, o3[B4 + 24 >> 2] = 1595750129, o3[B4 + 28 >> 2] = -1521486534, o3[B4 + 16 >> 2] = -23791573, o3[B4 + 20 >> 2] = 1013904242, o3[B4 + 8 >> 2] = -2067093701, o3[B4 + 12 >> 2] = -1150833019, o3[B4 >> 2] = -222443256 ^ (8192 | r4), o3[B4 + 4 >> 2] = 1779033703, MA(32 + (I7 = B4 + 384 | 0) | 0, 0, 96), HA(I7, i4, 32), HA(B4 + 96 | 0, I7, 128), o3[B4 + 352 >> 2] = 128, $A(I7, 128), G3(B4, A8, r4), D3 = f4), A8 = 0), D3 = E4 + 32 | 0, 0 | A8;
                    }, Ba: ZA, Ca: function(A8, I7, g6) {
                      return A8 |= 0, R3(I7 |= 0, 32, g6 |= 0, 32, 0, 0, 0), 0 | jA(A8, I7);
                    }, Da: function(A8, I7) {
                      return A8 |= 0, hA(I7 |= 0, 32), 0 | jA(A8, I7);
                    }, Ea: function(A8, I7, g6, C4, B4) {
                      I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0;
                      var i4, o4, n4 = 0, r4 = 0;
                      if (o4 = n4 = D3, D3 = n4 = n4 - 512 & -64, i4 = (A8 |= 0) || I7) {
                        if (r4 = -1, !PA(n4 + 96 | 0, C4, B4)) {
                          for (C4 = I7 || A8, A8 = 0, Y3(I7 = n4 + 128 | 0, 0, 0, 64), z3(I7, r4 = n4 + 96 | 0, 32, 0), $A(r4, 32), z3(I7, g6, 32, 0), z3(I7, B4, 32, 0), GA(I7, n4 + 32 | 0, 64), $A(I7, 384); I7 = (B4 = n4 + 32 | 0) + A8 | 0, E3[A8 + i4 | 0] = a3[0 | I7], E3[A8 + C4 | 0] = a3[I7 + 32 | 0], E3[(g6 = 1 | A8) + i4 | 0] = a3[g6 + B4 | 0], E3[g6 + C4 | 0] = a3[I7 + 33 | 0], 32 != (0 | (A8 = A8 + 2 | 0)); )
                            ;
                          $A(n4 + 32 | 0, 64), r4 = 0;
                        }
                        return D3 = o4, 0 | r4;
                      }
                      mA(), Q3();
                    }, Fa: function(A8, I7, g6, C4, B4) {
                      I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0;
                      var i4, o4, n4 = 0, r4 = 0;
                      if (o4 = n4 = D3, D3 = n4 = n4 - 512 & -64, i4 = (A8 |= 0) || I7) {
                        if (r4 = -1, !PA(n4 + 96 | 0, C4, B4)) {
                          for (C4 = I7 || A8, A8 = 0, Y3(I7 = n4 + 128 | 0, 0, 0, 64), z3(I7, r4 = n4 + 96 | 0, 32, 0), $A(r4, 32), z3(I7, B4, 32, 0), z3(I7, g6, 32, 0), GA(I7, n4 + 32 | 0, 64), $A(I7, 384); I7 = (B4 = n4 + 32 | 0) + A8 | 0, E3[A8 + C4 | 0] = a3[0 | I7], E3[A8 + i4 | 0] = a3[I7 + 32 | 0], E3[(g6 = 1 | A8) + C4 | 0] = a3[g6 + B4 | 0], E3[g6 + i4 | 0] = a3[I7 + 33 | 0], 32 != (0 | (A8 = A8 + 2 | 0)); )
                            ;
                          $A(n4 + 32 | 0, 64), r4 = 0;
                        }
                        return D3 = o4, 0 | r4;
                      }
                      mA(), Q3();
                    }, Ga: II, Ha: II, Ia: II, Ja: II, Ka: jA, La: PA, Ma: II, Na: II, Oa: II, Pa: gI, Qa: AI, Ra: CI, Sa: ZA, Ta: JA, Ua: function(A8, I7, g6, C4, B4, i4) {
                      return A8 |= 0, I7 |= 0, B4 |= 0, i4 |= 0, !(C4 |= 0) & (g6 |= 0) >>> 0 >= 4294967280 | C4 && (mA(), Q3()), IA(A8 + 16 | 0, A8, I7, g6, C4, B4, i4), 0;
                    }, Va: NA, Wa: lA, Xa: ZA, Ya: function(A8, I7, g6) {
                      return A8 |= 0, g6 |= 0, hA(I7 |= 0, 24), d3(A8, I7, g6), E3[A8 + 32 | 0] = 1, E3[A8 + 33 | 0] = 0, E3[A8 + 34 | 0] = 0, E3[A8 + 35 | 0] = 0, g6 = a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24, I7 = a3[I7 + 20 | 0] | a3[I7 + 21 | 0] << 8 | a3[I7 + 22 | 0] << 16 | a3[I7 + 23 | 0] << 24, E3[A8 + 44 | 0] = 0, E3[A8 + 45 | 0] = 0, E3[A8 + 46 | 0] = 0, E3[A8 + 47 | 0] = 0, E3[A8 + 48 | 0] = 0, E3[A8 + 49 | 0] = 0, E3[A8 + 50 | 0] = 0, E3[A8 + 51 | 0] = 0, E3[A8 + 36 | 0] = g6, E3[A8 + 37 | 0] = g6 >>> 8, E3[A8 + 38 | 0] = g6 >>> 16, E3[A8 + 39 | 0] = g6 >>> 24, E3[A8 + 40 | 0] = I7, E3[A8 + 41 | 0] = I7 >>> 8, E3[A8 + 42 | 0] = I7 >>> 16, E3[A8 + 43 | 0] = I7 >>> 24, 0;
                    }, Za: function(A8, I7, g6) {
                      return d3(A8 |= 0, I7 |= 0, g6 |= 0), E3[A8 + 32 | 0] = 1, E3[A8 + 33 | 0] = 0, E3[A8 + 34 | 0] = 0, E3[A8 + 35 | 0] = 0, g6 = a3[I7 + 16 | 0] | a3[I7 + 17 | 0] << 8 | a3[I7 + 18 | 0] << 16 | a3[I7 + 19 | 0] << 24, I7 = a3[I7 + 20 | 0] | a3[I7 + 21 | 0] << 8 | a3[I7 + 22 | 0] << 16 | a3[I7 + 23 | 0] << 24, E3[A8 + 44 | 0] = 0, E3[A8 + 45 | 0] = 0, E3[A8 + 46 | 0] = 0, E3[A8 + 47 | 0] = 0, E3[A8 + 48 | 0] = 0, E3[A8 + 49 | 0] = 0, E3[A8 + 50 | 0] = 0, E3[A8 + 51 | 0] = 0, E3[A8 + 36 | 0] = g6, E3[A8 + 37 | 0] = g6 >>> 8, E3[A8 + 38 | 0] = g6 >>> 16, E3[A8 + 39 | 0] = g6 >>> 24, E3[A8 + 40 | 0] = I7, E3[A8 + 41 | 0] = I7 >>> 8, E3[A8 + 42 | 0] = I7 >>> 16, E3[A8 + 43 | 0] = I7 >>> 24, 0;
                    }, _a: function(A8) {
                      var I7, g6 = 0, C4 = 0;
                      D3 = I7 = D3 - 48 | 0, g6 = a3[28 + (A8 |= 0) | 0] | a3[A8 + 29 | 0] << 8 | a3[A8 + 30 | 0] << 16 | a3[A8 + 31 | 0] << 24, o3[I7 + 24 >> 2] = a3[A8 + 24 | 0] | a3[A8 + 25 | 0] << 8 | a3[A8 + 26 | 0] << 16 | a3[A8 + 27 | 0] << 24, o3[I7 + 28 >> 2] = g6, g6 = a3[A8 + 20 | 0] | a3[A8 + 21 | 0] << 8 | a3[A8 + 22 | 0] << 16 | a3[A8 + 23 | 0] << 24, o3[I7 + 16 >> 2] = a3[A8 + 16 | 0] | a3[A8 + 17 | 0] << 8 | a3[A8 + 18 | 0] << 16 | a3[A8 + 19 | 0] << 24, o3[I7 + 20 >> 2] = g6, g6 = a3[A8 + 4 | 0] | a3[A8 + 5 | 0] << 8 | a3[A8 + 6 | 0] << 16 | a3[A8 + 7 | 0] << 24, o3[I7 >> 2] = a3[0 | A8] | a3[A8 + 1 | 0] << 8 | a3[A8 + 2 | 0] << 16 | a3[A8 + 3 | 0] << 24, o3[I7 + 4 >> 2] = g6, g6 = a3[A8 + 12 | 0] | a3[A8 + 13 | 0] << 8 | a3[A8 + 14 | 0] << 16 | a3[A8 + 15 | 0] << 24, o3[I7 + 8 >> 2] = a3[A8 + 8 | 0] | a3[A8 + 9 | 0] << 8 | a3[A8 + 10 | 0] << 16 | a3[A8 + 11 | 0] << 24, o3[I7 + 12 >> 2] = g6, g6 = a3[A8 + 40 | 0] | a3[A8 + 41 | 0] << 8 | a3[A8 + 42 | 0] << 16 | a3[A8 + 43 | 0] << 24, o3[I7 + 32 >> 2] = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24, o3[I7 + 36 >> 2] = g6, xA(I7, I7, A8 + 32 | 0, A8), g6 = o3[I7 + 28 >> 2], C4 = o3[I7 + 24 >> 2], E3[A8 + 24 | 0] = C4, E3[A8 + 25 | 0] = C4 >>> 8, E3[A8 + 26 | 0] = C4 >>> 16, E3[A8 + 27 | 0] = C4 >>> 24, E3[A8 + 28 | 0] = g6, E3[A8 + 29 | 0] = g6 >>> 8, E3[A8 + 30 | 0] = g6 >>> 16, E3[A8 + 31 | 0] = g6 >>> 24, g6 = o3[I7 + 20 >> 2], C4 = o3[I7 + 16 >> 2], E3[A8 + 16 | 0] = C4, E3[A8 + 17 | 0] = C4 >>> 8, E3[A8 + 18 | 0] = C4 >>> 16, E3[A8 + 19 | 0] = C4 >>> 24, E3[A8 + 20 | 0] = g6, E3[A8 + 21 | 0] = g6 >>> 8, E3[A8 + 22 | 0] = g6 >>> 16, E3[A8 + 23 | 0] = g6 >>> 24, g6 = o3[I7 + 12 >> 2], C4 = o3[I7 + 8 >> 2], E3[A8 + 8 | 0] = C4, E3[A8 + 9 | 0] = C4 >>> 8, E3[A8 + 10 | 0] = C4 >>> 16, E3[A8 + 11 | 0] = C4 >>> 24, E3[A8 + 12 | 0] = g6, E3[A8 + 13 | 0] = g6 >>> 8, E3[A8 + 14 | 0] = g6 >>> 16, E3[A8 + 15 | 0] = g6 >>> 24, g6 = o3[I7 + 4 >> 2], C4 = o3[I7 >> 2], E3[0 | A8] = C4, E3[A8 + 1 | 0] = C4 >>> 8, E3[A8 + 2 | 0] = C4 >>> 16, E3[A8 + 3 | 0] = C4 >>> 24, E3[A8 + 4 | 0] = g6, E3[A8 + 5 | 0] = g6 >>> 8, E3[A8 + 6 | 0] = g6 >>> 16, E3[A8 + 7 | 0] = g6 >>> 24, C4 = o3[I7 + 36 >> 2], g6 = o3[I7 + 32 >> 2], E3[A8 + 32 | 0] = 1, E3[A8 + 33 | 0] = 0, E3[A8 + 34 | 0] = 0, E3[A8 + 35 | 0] = 0, E3[A8 + 36 | 0] = g6, E3[A8 + 37 | 0] = g6 >>> 8, E3[A8 + 38 | 0] = g6 >>> 16, E3[A8 + 39 | 0] = g6 >>> 24, E3[A8 + 40 | 0] = C4, E3[A8 + 41 | 0] = C4 >>> 8, E3[A8 + 42 | 0] = C4 >>> 16, E3[A8 + 43 | 0] = C4 >>> 24, D3 = I7 + 48 | 0;
                    }, $a: function(A8, I7, g6, C4, B4, i4, n4, r4, f4, t4) {
                      A8 |= 0, I7 |= 0, C4 |= 0, n4 |= 0, f4 |= 0, t4 |= 0;
                      var e4, c4 = 0, y4 = 0, w4 = 0;
                      return c4 = B4 |= 0, B4 = i4 |= 0, c4 |= i4 = 0, e4 = i4 | (r4 |= 0), D3 = i4 = D3 - 384 | 0, (g6 |= 0) && (o3[g6 >> 2] = 0, o3[g6 + 4 >> 2] = 0), !B4 & c4 >>> 0 < 4294967279 ? (XA(y4 = i4 + 16 | 0, 64, w4 = A8 + 32 | 0, A8), OA(r4 = i4 + 80 | 0, y4), $A(y4, 64), zA(r4, n4, e4, f4), zA(r4, 33904, 0 - e4 & 15, 0), o3[i4 + 72 >> 2] = 0, o3[i4 + 76 >> 2] = 0, o3[(n4 = i4 - -64 | 0) >> 2] = 0, o3[n4 + 4 >> 2] = 0, o3[i4 + 56 >> 2] = 0, o3[i4 + 60 >> 2] = 0, o3[i4 + 48 >> 2] = 0, o3[i4 + 52 >> 2] = 0, o3[i4 + 40 >> 2] = 0, o3[i4 + 44 >> 2] = 0, o3[i4 + 32 >> 2] = 0, o3[i4 + 36 >> 2] = 0, o3[i4 + 16 >> 2] = 0, o3[i4 + 20 >> 2] = 0, o3[i4 + 24 >> 2] = 0, o3[i4 + 28 >> 2] = 0, E3[i4 + 16 | 0] = t4, wA(y4, y4, 64, 0, w4, 1, A8), zA(r4, y4, 64, 0), E3[0 | I7] = a3[i4 + 16 | 0], wA(I7 = I7 + 1 | 0, C4, c4, B4, w4, 2, A8), zA(r4, I7, c4, B4), zA(r4, 33904, 15 & c4, 0), o3[i4 + 8 >> 2] = e4, o3[i4 + 12 >> 2] = f4, zA(r4, C4 = i4 + 8 | 0, 8, 0), o3[i4 + 8 >> 2] = c4 - -64, o3[i4 + 12 >> 2] = B4 - ((c4 >>> 0 < 4294967232) - 1 | 0), zA(r4, C4, 8, 0), TA(r4, I7 = I7 + c4 | 0), $A(r4, 256), E3[A8 + 36 | 0] = a3[A8 + 36 | 0] ^ a3[0 | I7], E3[A8 + 37 | 0] = a3[A8 + 37 | 0] ^ a3[I7 + 1 | 0], E3[A8 + 38 | 0] = a3[A8 + 38 | 0] ^ a3[I7 + 2 | 0], E3[A8 + 39 | 0] = a3[A8 + 39 | 0] ^ a3[I7 + 3 | 0], E3[A8 + 40 | 0] = a3[A8 + 40 | 0] ^ a3[I7 + 4 | 0], E3[A8 + 41 | 0] = a3[A8 + 41 | 0] ^ a3[I7 + 5 | 0], E3[A8 + 42 | 0] = a3[A8 + 42 | 0] ^ a3[I7 + 6 | 0], E3[A8 + 43 | 0] = a3[A8 + 43 | 0] ^ a3[I7 + 7 | 0], yA(w4), (2 & t4 || iA(w4, 4)) && (I7 = a3[A8 + 28 | 0] | a3[A8 + 29 | 0] << 8 | a3[A8 + 30 | 0] << 16 | a3[A8 + 31 | 0] << 24, o3[i4 + 360 >> 2] = a3[A8 + 24 | 0] | a3[A8 + 25 | 0] << 8 | a3[A8 + 26 | 0] << 16 | a3[A8 + 27 | 0] << 24, o3[i4 + 364 >> 2] = I7, I7 = a3[A8 + 20 | 0] | a3[A8 + 21 | 0] << 8 | a3[A8 + 22 | 0] << 16 | a3[A8 + 23 | 0] << 24, o3[i4 + 352 >> 2] = a3[A8 + 16 | 0] | a3[A8 + 17 | 0] << 8 | a3[A8 + 18 | 0] << 16 | a3[A8 + 19 | 0] << 24, o3[i4 + 356 >> 2] = I7, I7 = a3[A8 + 4 | 0] | a3[A8 + 5 | 0] << 8 | a3[A8 + 6 | 0] << 16 | a3[A8 + 7 | 0] << 24, o3[i4 + 336 >> 2] = a3[0 | A8] | a3[A8 + 1 | 0] << 8 | a3[A8 + 2 | 0] << 16 | a3[A8 + 3 | 0] << 24, o3[i4 + 340 >> 2] = I7, I7 = a3[A8 + 12 | 0] | a3[A8 + 13 | 0] << 8 | a3[A8 + 14 | 0] << 16 | a3[A8 + 15 | 0] << 24, o3[i4 + 344 >> 2] = a3[A8 + 8 | 0] | a3[A8 + 9 | 0] << 8 | a3[A8 + 10 | 0] << 16 | a3[A8 + 11 | 0] << 24, o3[i4 + 348 >> 2] = I7, I7 = a3[A8 + 40 | 0] | a3[A8 + 41 | 0] << 8 | a3[A8 + 42 | 0] << 16 | a3[A8 + 43 | 0] << 24, o3[i4 + 368 >> 2] = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24, o3[i4 + 372 >> 2] = I7, xA(I7 = i4 + 336 | 0, I7, w4, A8), I7 = o3[i4 + 364 >> 2], C4 = o3[i4 + 360 >> 2], E3[A8 + 24 | 0] = C4, E3[A8 + 25 | 0] = C4 >>> 8, E3[A8 + 26 | 0] = C4 >>> 16, E3[A8 + 27 | 0] = C4 >>> 24, E3[A8 + 28 | 0] = I7, E3[A8 + 29 | 0] = I7 >>> 8, E3[A8 + 30 | 0] = I7 >>> 16, E3[A8 + 31 | 0] = I7 >>> 24, I7 = o3[i4 + 356 >> 2], C4 = o3[i4 + 352 >> 2], E3[A8 + 16 | 0] = C4, E3[A8 + 17 | 0] = C4 >>> 8, E3[A8 + 18 | 0] = C4 >>> 16, E3[A8 + 19 | 0] = C4 >>> 24, E3[A8 + 20 | 0] = I7, E3[A8 + 21 | 0] = I7 >>> 8, E3[A8 + 22 | 0] = I7 >>> 16, E3[A8 + 23 | 0] = I7 >>> 24, I7 = o3[i4 + 348 >> 2], C4 = o3[i4 + 344 >> 2], E3[A8 + 8 | 0] = C4, E3[A8 + 9 | 0] = C4 >>> 8, E3[A8 + 10 | 0] = C4 >>> 16, E3[A8 + 11 | 0] = C4 >>> 24, E3[A8 + 12 | 0] = I7, E3[A8 + 13 | 0] = I7 >>> 8, E3[A8 + 14 | 0] = I7 >>> 16, E3[A8 + 15 | 0] = I7 >>> 24, I7 = o3[i4 + 340 >> 2], C4 = o3[i4 + 336 >> 2], E3[0 | A8] = C4, E3[A8 + 1 | 0] = C4 >>> 8, E3[A8 + 2 | 0] = C4 >>> 16, E3[A8 + 3 | 0] = C4 >>> 24, E3[A8 + 4 | 0] = I7, E3[A8 + 5 | 0] = I7 >>> 8, E3[A8 + 6 | 0] = I7 >>> 16, E3[A8 + 7 | 0] = I7 >>> 24, I7 = o3[i4 + 368 >> 2], C4 = o3[i4 + 372 >> 2], E3[A8 + 32 | 0] = 1, E3[A8 + 33 | 0] = 0, E3[A8 + 34 | 0] = 0, E3[A8 + 35 | 0] = 0, E3[A8 + 36 | 0] = I7, E3[A8 + 37 | 0] = I7 >>> 8, E3[A8 + 38 | 0] = I7 >>> 16, E3[A8 + 39 | 0] = I7 >>> 24, E3[A8 + 40 | 0] = C4, E3[A8 + 41 | 0] = C4 >>> 8, E3[A8 + 42 | 0] = C4 >>> 16, E3[A8 + 43 | 0] = C4 >>> 24), g6 && (B4 = (A8 = c4 + 17 | 0) >>> 0 < 17 ? B4 + 1 | 0 : B4, o3[g6 >> 2] = A8, o3[g6 + 4 >> 2] = B4), D3 = i4 + 384 | 0) : (mA(), Q3()), 0;
                    }, ab: function(A8, I7, g6, C4, B4, i4, n4, r4, f4, t4) {
                      A8 |= 0, I7 |= 0, C4 |= 0, B4 |= 0, r4 |= 0, t4 |= 0;
                      var e4, c4 = 0, y4 = 0, w4 = 0, h4 = 0, s4 = 0, p4 = 0;
                      c4 = i4 |= 0, i4 = n4 |= 0, y4 = 0 | c4, e4 = f4 |= 0, D3 = n4 = D3 - 400 | 0, (g6 |= 0) && (o3[g6 >> 2] = 0, o3[g6 + 4 >> 2] = 0), C4 && (E3[0 | C4] = 255), p4 = -1;
                      A: {
                        I: {
                          if (!(!i4 & y4 >>> 0 < 17)) {
                            if (s4 = c4 = i4 - (y4 >>> 0 < 17) | 0, !c4 & (f4 = y4 - 17 | 0) >>> 0 >= 4294967279 | c4)
                              break I;
                            XA(w4 = n4 + 32 | 0, 64, h4 = A8 + 32 | 0, A8), OA(c4 = n4 + 96 | 0, w4), $A(w4, 64), zA(c4, r4, e4, t4), zA(c4, 33904, 0 - e4 & 15, 0), o3[n4 + 88 >> 2] = 0, o3[n4 + 92 >> 2] = 0, o3[n4 + 80 >> 2] = 0, o3[n4 + 84 >> 2] = 0, o3[n4 + 72 >> 2] = 0, o3[n4 + 76 >> 2] = 0, o3[(r4 = n4 - -64 | 0) >> 2] = 0, o3[r4 + 4 >> 2] = 0, o3[n4 + 56 >> 2] = 0, o3[n4 + 60 >> 2] = 0, o3[n4 + 48 >> 2] = 0, o3[n4 + 52 >> 2] = 0, o3[n4 + 40 >> 2] = 0, o3[n4 + 44 >> 2] = 0, o3[n4 + 32 >> 2] = 0, o3[n4 + 36 >> 2] = 0, E3[n4 + 32 | 0] = a3[0 | B4], wA(w4, w4, 64, 0, h4, 1, A8), r4 = a3[n4 + 32 | 0], E3[n4 + 32 | 0] = a3[0 | B4], zA(c4, w4, 64, 0), zA(c4, B4 = B4 + 1 | 0, f4, s4), zA(c4, 33904, y4 - 1 & 15, 0), o3[n4 + 24 >> 2] = e4, o3[n4 + 28 >> 2] = t4, zA(c4, t4 = n4 + 24 | 0, 8, 0), i4 = (y4 = y4 + 47 | 0) >>> 0 < 47 ? i4 + 1 | 0 : i4, o3[n4 + 24 >> 2] = y4, o3[n4 + 28 >> 2] = i4, zA(c4, t4, 8, 0), TA(c4, n4), $A(c4, 256), oA(n4, B4 + f4 | 0, 16) ? $A(n4, 16) : (wA(I7, B4, f4, s4, h4, 2, A8), E3[A8 + 36 | 0] = a3[A8 + 36 | 0] ^ a3[0 | n4], E3[A8 + 37 | 0] = a3[A8 + 37 | 0] ^ a3[n4 + 1 | 0], E3[A8 + 38 | 0] = a3[A8 + 38 | 0] ^ a3[n4 + 2 | 0], E3[A8 + 39 | 0] = a3[A8 + 39 | 0] ^ a3[n4 + 3 | 0], E3[A8 + 40 | 0] = a3[A8 + 40 | 0] ^ a3[n4 + 4 | 0], E3[A8 + 41 | 0] = a3[A8 + 41 | 0] ^ a3[n4 + 5 | 0], E3[A8 + 42 | 0] = a3[A8 + 42 | 0] ^ a3[n4 + 6 | 0], E3[A8 + 43 | 0] = a3[A8 + 43 | 0] ^ a3[n4 + 7 | 0], yA(h4), (2 & r4 || iA(h4, 4)) && (I7 = a3[A8 + 28 | 0] | a3[A8 + 29 | 0] << 8 | a3[A8 + 30 | 0] << 16 | a3[A8 + 31 | 0] << 24, o3[n4 + 376 >> 2] = a3[A8 + 24 | 0] | a3[A8 + 25 | 0] << 8 | a3[A8 + 26 | 0] << 16 | a3[A8 + 27 | 0] << 24, o3[n4 + 380 >> 2] = I7, I7 = a3[A8 + 20 | 0] | a3[A8 + 21 | 0] << 8 | a3[A8 + 22 | 0] << 16 | a3[A8 + 23 | 0] << 24, o3[n4 + 368 >> 2] = a3[A8 + 16 | 0] | a3[A8 + 17 | 0] << 8 | a3[A8 + 18 | 0] << 16 | a3[A8 + 19 | 0] << 24, o3[n4 + 372 >> 2] = I7, I7 = a3[A8 + 4 | 0] | a3[A8 + 5 | 0] << 8 | a3[A8 + 6 | 0] << 16 | a3[A8 + 7 | 0] << 24, o3[n4 + 352 >> 2] = a3[0 | A8] | a3[A8 + 1 | 0] << 8 | a3[A8 + 2 | 0] << 16 | a3[A8 + 3 | 0] << 24, o3[n4 + 356 >> 2] = I7, I7 = a3[A8 + 12 | 0] | a3[A8 + 13 | 0] << 8 | a3[A8 + 14 | 0] << 16 | a3[A8 + 15 | 0] << 24, o3[n4 + 360 >> 2] = a3[A8 + 8 | 0] | a3[A8 + 9 | 0] << 8 | a3[A8 + 10 | 0] << 16 | a3[A8 + 11 | 0] << 24, o3[n4 + 364 >> 2] = I7, I7 = a3[A8 + 40 | 0] | a3[A8 + 41 | 0] << 8 | a3[A8 + 42 | 0] << 16 | a3[A8 + 43 | 0] << 24, o3[n4 + 384 >> 2] = a3[A8 + 36 | 0] | a3[A8 + 37 | 0] << 8 | a3[A8 + 38 | 0] << 16 | a3[A8 + 39 | 0] << 24, o3[n4 + 388 >> 2] = I7, xA(I7 = n4 + 352 | 0, I7, h4, A8), I7 = o3[n4 + 380 >> 2], B4 = o3[n4 + 376 >> 2], E3[A8 + 24 | 0] = B4, E3[A8 + 25 | 0] = B4 >>> 8, E3[A8 + 26 | 0] = B4 >>> 16, E3[A8 + 27 | 0] = B4 >>> 24, E3[A8 + 28 | 0] = I7, E3[A8 + 29 | 0] = I7 >>> 8, E3[A8 + 30 | 0] = I7 >>> 16, E3[A8 + 31 | 0] = I7 >>> 24, I7 = o3[n4 + 372 >> 2], B4 = o3[n4 + 368 >> 2], E3[A8 + 16 | 0] = B4, E3[A8 + 17 | 0] = B4 >>> 8, E3[A8 + 18 | 0] = B4 >>> 16, E3[A8 + 19 | 0] = B4 >>> 24, E3[A8 + 20 | 0] = I7, E3[A8 + 21 | 0] = I7 >>> 8, E3[A8 + 22 | 0] = I7 >>> 16, E3[A8 + 23 | 0] = I7 >>> 24, I7 = o3[n4 + 364 >> 2], B4 = o3[n4 + 360 >> 2], E3[A8 + 8 | 0] = B4, E3[A8 + 9 | 0] = B4 >>> 8, E3[A8 + 10 | 0] = B4 >>> 16, E3[A8 + 11 | 0] = B4 >>> 24, E3[A8 + 12 | 0] = I7, E3[A8 + 13 | 0] = I7 >>> 8, E3[A8 + 14 | 0] = I7 >>> 16, E3[A8 + 15 | 0] = I7 >>> 24, I7 = o3[n4 + 356 >> 2], B4 = o3[n4 + 352 >> 2], E3[0 | A8] = B4, E3[A8 + 1 | 0] = B4 >>> 8, E3[A8 + 2 | 0] = B4 >>> 16, E3[A8 + 3 | 0] = B4 >>> 24, E3[A8 + 4 | 0] = I7, E3[A8 + 5 | 0] = I7 >>> 8, E3[A8 + 6 | 0] = I7 >>> 16, E3[A8 + 7 | 0] = I7 >>> 24, I7 = o3[n4 + 384 >> 2], B4 = o3[n4 + 388 >> 2], E3[A8 + 32 | 0] = 1, E3[A8 + 33 | 0] = 0, E3[A8 + 34 | 0] = 0, E3[A8 + 35 | 0] = 0, E3[A8 + 36 | 0] = I7, E3[A8 + 37 | 0] = I7 >>> 8, E3[A8 + 38 | 0] = I7 >>> 16, E3[A8 + 39 | 0] = I7 >>> 24, E3[A8 + 40 | 0] = B4, E3[A8 + 41 | 0] = B4 >>> 8, E3[A8 + 42 | 0] = B4 >>> 16, E3[A8 + 43 | 0] = B4 >>> 24), g6 && (o3[g6 >> 2] = f4, o3[g6 + 4 >> 2] = s4), p4 = 0, C4 && (E3[0 | C4] = r4));
                          }
                          D3 = n4 + 400 | 0;
                          break A;
                        }
                        mA(), Q3();
                      }
                      return 0 | p4;
                    }, bb: function() {
                      return 52;
                    }, cb: function() {
                      return 17;
                    }, db: gI, eb: II, fb: function() {
                      return -18;
                    }, gb: oI, hb: QI, ib: function() {
                      return 2;
                    }, jb: iI, kb: EI, lb: AI, mb: function(A8, I7, g6, C4, B4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0;
                      var Q4, i4 = 0, o4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, F4 = 0;
                      if (p4 = 1886610805 ^ (B4 = a3[0 | (i4 = B4 |= 0)] | a3[i4 + 1 | 0] << 8 | a3[i4 + 2 | 0] << 16 | a3[i4 + 3 | 0] << 24), u4 = 1936682341 ^ (o4 = a3[i4 + 4 | 0] | a3[i4 + 5 | 0] << 8 | a3[i4 + 6 | 0] << 16 | a3[i4 + 7 | 0] << 24), B4 ^= 1852142177, n4 = 1819895653 ^ o4, k4 = 1852075885 ^ (o4 = a3[i4 + 8 | 0] | a3[i4 + 9 | 0] << 8 | a3[i4 + 10 | 0] << 16 | a3[i4 + 11 | 0] << 24), F4 = 1685025377 ^ (i4 = a3[i4 + 12 | 0] | a3[i4 + 13 | 0] << 8 | a3[i4 + 14 | 0] << 16 | a3[i4 + 15 | 0] << 24), r4 = 2037671283 ^ o4, o4 = 1952801890 ^ i4, D4 = g6, (0 | (c4 = (I7 + g6 | 0) - (Q4 = 7 & g6) | 0)) != (0 | I7)) {
                        for (; g6 = (h4 = o4 ^ (s4 = a3[I7 + 4 | 0] | a3[I7 + 5 | 0] << 8 | a3[I7 + 6 | 0] << 16 | a3[I7 + 7 | 0] << 24)) + n4 | 0, r4 = B4 = (i4 = C4 = r4 ^ (y4 = a3[0 | I7] | a3[I7 + 1 | 0] << 8 | a3[I7 + 2 | 0] << 16 | a3[I7 + 3 | 0] << 24)) + B4 | 0, e4 = g6 = B4 >>> 0 < i4 >>> 0 ? g6 + 1 | 0 : g6, g6 = u4 + F4 | 0, g6 = (n4 = p4 + k4 | 0) >>> 0 < k4 >>> 0 ? g6 + 1 | 0 : g6, i4 = nA(k4, F4, 13) ^ n4, o4 = g6, g6 = e4 + (B4 = g6 ^ w3) | 0, g6 = i4 >>> 0 > (f4 = r4 + i4 | 0) >>> 0 ? g6 + 1 | 0 : g6, i4 = nA(i4, B4, 17) ^ f4, t4 = g6, p4 = nA(i4, B4 = g6 ^ w3, 13), u4 = w3, g6 = nA(C4, h4, 16), C4 = e4 ^ w3, h4 = g6 ^ r4, o4 = nA(n4, o4, 32), g6 = w3 + C4 | 0, g6 = (o4 = (n4 = h4 + o4 | 0) >>> 0 < o4 >>> 0 ? g6 + 1 | 0 : g6) + B4 | 0, e4 = g6 = (r4 = i4 + n4 | 0) >>> 0 < n4 >>> 0 ? g6 + 1 | 0 : g6, p4 = nA(i4 = r4 ^ p4, B4 = g6 ^ u4, 17), u4 = w3, g6 = nA(h4, C4, 21), C4 = o4 ^ w3, h4 = g6 ^ n4, o4 = nA(f4, t4, 32), g6 = w3 + C4 | 0, g6 = (o4 = (n4 = h4 + o4 | 0) >>> 0 < o4 >>> 0 ? g6 + 1 | 0 : g6) + B4 | 0, k4 = (i4 = i4 + n4 | 0) ^ p4, B4 = g6 = i4 >>> 0 < n4 >>> 0 ? g6 + 1 | 0 : g6, F4 = g6 ^ u4, g6 = nA(h4, C4, 16), f4 = o4 ^= w3, t4 = nA(g6 ^= n4, o4, 21), n4 = w3, e4 = (o4 = nA(r4, e4, 32)) + g6 | 0, g6 = w3 + f4 | 0, r4 = t4 ^ e4, o4 = (g6 = o4 >>> 0 > e4 >>> 0 ? g6 + 1 | 0 : g6) ^ n4, B4 = nA(i4, B4, 32), n4 = w3, p4 = e4 ^ y4, u4 = g6 ^ s4, (0 | c4) != (0 | (I7 = I7 + 8 | 0)); )
                          ;
                        I7 = c4;
                      }
                      switch (s4 = 0, t4 = D4 << 24, Q4 - 1 | 0) {
                        case 6:
                          t4 |= a3[I7 + 6 | 0] << 16;
                        case 5:
                          t4 |= a3[I7 + 5 | 0] << 8;
                        case 4:
                          t4 |= a3[I7 + 4 | 0];
                        case 3:
                          s4 |= (C4 = a3[I7 + 3 | 0]) << 24, t4 |= g6 = C4 >>> 8 | 0;
                        case 2:
                          s4 |= (C4 = a3[I7 + 2 | 0]) << 16, t4 |= g6 = C4 >>> 16 | 0;
                        case 1:
                          s4 |= (C4 = a3[I7 + 1 | 0]) << 8, t4 |= g6 = C4 >>> 24 | 0;
                        case 0:
                          s4 = a3[0 | I7] | s4;
                      }
                      return I7 = A8, C4 = nA(i4 = r4 ^ s4, A8 = o4 ^ t4, 16), A8 = A8 + n4 | 0, e4 = A8 = (r4 = B4 + i4 | 0) >>> 0 < B4 >>> 0 ? A8 + 1 | 0 : A8, f4 = nA(B4 = C4 ^ r4, A8 ^= g6 = w3, 21), o4 = w3, g6 = u4 + F4 | 0, C4 = g6 = (i4 = p4 + k4 | 0) >>> 0 < k4 >>> 0 ? g6 + 1 | 0 : g6, c4 = B4, B4 = nA(i4, g6, 32), g6 = w3 + A8 | 0, A8 = o4, o4 = g6 = B4 >>> 0 > (n4 = c4 + B4 | 0) >>> 0 ? g6 + 1 | 0 : g6, D4 = nA(B4 = n4 ^ f4, A8 ^= g6, 16), y4 = w3, i4 = (g6 = r4) + (r4 = c4 = nA(k4, F4, 13) ^ i4) | 0, g6 = (f4 = w3 ^ C4) + e4 | 0, C4 = i4, e4 = B4, B4 = nA(i4, g6 = i4 >>> 0 < r4 >>> 0 ? g6 + 1 | 0 : g6, 32), A8 = w3 + A8 | 0, h4 = nA(i4 = (r4 = e4 + B4 | 0) ^ D4, B4 = (e4 = B4 >>> 0 > r4 >>> 0 ? A8 + 1 | 0 : A8) ^ y4, 21), y4 = w3, c4 = nA(c4, f4, 17) ^ C4, g6 = (f4 = w3 ^ g6) + o4 | 0, A8 = g6 = (A8 = c4) >>> 0 > (C4 = A8 + n4 | 0) >>> 0 ? g6 + 1 | 0 : g6, o4 = i4, i4 = nA(C4, g6, 32), g6 = w3 + B4 | 0, D4 = g6 = (o4 = i4 >>> 0 > (n4 = o4 + i4 | 0) >>> 0 ? g6 + 1 | 0 : g6) ^ y4, y4 = nA(h4 ^= n4, g6, 16), i4 = w3, c4 = nA(c4, f4, 13) ^ C4, A8 = (f4 = A8 ^ w3) + e4 | 0, C4 = A8 = (g6 = c4) >>> 0 > (B4 = g6 + r4 | 0) >>> 0 ? A8 + 1 | 0 : A8, A8 = nA(B4, A8, 32), g6 = D4 + w3 | 0, D4 = g6 = (r4 = i4) ^ (i4 = (A8 = h4 + (255 ^ A8) | 0) >>> 0 < h4 >>> 0 ? g6 + 1 | 0 : g6), r4 = A8, y4 = nA(h4 = y4 ^ A8, g6, 21), e4 = w3, c4 = nA(c4, f4, 17) ^ B4, g6 = (f4 = C4 ^ w3) + (o4 ^ t4) | 0, C4 = g6 = (A8 = n4 ^ s4) >>> 0 > (B4 = c4 + A8 | 0) >>> 0 ? g6 + 1 | 0 : g6, A8 = nA(B4, g6, 32), g6 = D4 + w3 | 0, g6 = (o4 = (A8 = A8 + h4 | 0) >>> 0 < h4 >>> 0 ? g6 + 1 | 0 : g6) ^ e4, e4 = A8, y4 = nA(D4 = y4 ^ A8, g6, 16), n4 = w3, f4 = nA(c4, f4, 13) ^ B4, A8 = i4 + (t4 = w3 ^ C4) | 0, C4 = A8 = (B4 = r4 + f4 | 0) >>> 0 < r4 >>> 0 ? A8 + 1 | 0 : A8, A8 = nA(B4, A8, 32), g6 = g6 + w3 | 0, c4 = g6 = (i4 = (A8 = A8 + D4 | 0) >>> 0 < D4 >>> 0 ? g6 + 1 | 0 : g6) ^ n4, n4 = A8, y4 = nA(D4 = y4 ^ A8, g6, 21), r4 = w3, A8 = nA(f4, t4, 17), g6 = o4 + (f4 = C4 ^ w3) | 0, C4 = g6 = (B4 = e4 + (t4 = A8 ^ B4) | 0) >>> 0 < e4 >>> 0 ? g6 + 1 | 0 : g6, A8 = nA(B4, g6, 32), g6 = c4 + w3 | 0, r4 = g6 = (o4 = (A8 = A8 + D4 | 0) >>> 0 < D4 >>> 0 ? g6 + 1 | 0 : g6) ^ r4, e4 = A8, c4 = nA(D4 = y4 ^ A8, g6, 16), y4 = w3, A8 = nA(t4, f4, 13), g6 = i4 + (f4 = C4 ^ w3) | 0, C4 = g6 = (i4 = n4 + (t4 = A8 ^ B4) | 0) >>> 0 < n4 >>> 0 ? g6 + 1 | 0 : g6, A8 = nA(i4, g6, 32), g6 = r4 + w3 | 0, r4 = A8 = A8 + D4 | 0, n4 = g6 = A8 >>> 0 < D4 >>> 0 ? g6 + 1 | 0 : g6, D4 = nA(B4 = c4 ^ A8, A8 = g6 ^ y4, 21), c4 = w3, t4 = nA(t4, f4, 17), g6 = o4 + (y4 = C4 ^ w3) | 0, f4 = i4 ^ t4, i4 = B4, B4 = nA(C4 = e4 + f4 | 0, g6 = C4 >>> 0 < e4 >>> 0 ? g6 + 1 | 0 : g6, 32), A8 = w3 + A8 | 0, c4 = nA(i4 = (e4 = i4 + B4 | 0) ^ D4, B4 = (o4 = B4 >>> 0 > e4 >>> 0 ? A8 + 1 | 0 : A8) ^ c4, 16), t4 = w3, A8 = nA(f4, y4, 13), g6 = n4 + (y4 = g6 ^ w3) | 0, A8 = g6 = (C4 = r4 + (f4 = A8 ^ C4) | 0) >>> 0 < r4 >>> 0 ? g6 + 1 | 0 : g6, n4 = nA(C4, g6, 32), g6 = w3 + B4 | 0, B4 = i4 = n4 + i4 | 0, t4 = nA(i4 ^ c4, (g6 = i4 >>> 0 < n4 >>> 0 ? g6 + 1 | 0 : g6) ^ t4, 21), r4 = w3, C4 = nA(f4, y4, 17) ^ C4, n4 = nA(C4, A8 ^= w3, 13), A8 = A8 + o4 | 0, o4 = A8 = w3 ^ ((C4 = C4 + e4 | 0) >>> 0 < e4 >>> 0 ? A8 + 1 | 0 : A8), C4 = nA(i4 = C4 ^ n4, A8, 17) ^ t4, A8 = w3 ^ r4, g6 = g6 + o4 | 0, r4 = B4, C4 = nA(B4 = B4 + i4 | 0, g6 = r4 >>> 0 > B4 >>> 0 ? g6 + 1 | 0 : g6, 32) ^ C4 ^ B4, E3[0 | I7] = C4, E3[I7 + 1 | 0] = C4 >>> 8, E3[I7 + 2 | 0] = C4 >>> 16, E3[I7 + 3 | 0] = C4 >>> 24, A8 ^= g6 ^ w3, E3[I7 + 4 | 0] = A8, E3[I7 + 5 | 0] = A8 >>> 8, E3[I7 + 6 | 0] = A8 >>> 16, E3[I7 + 7 | 0] = A8 >>> 24, 0;
                    }, nb: function(A8) {
                      hA(A8 |= 0, 16);
                    }, ob: function() {
                      return 208;
                    }, pb: BI, qb: II, rb: II, sb: BI, tb: function() {
                      return -65;
                    }, ub: function(A8, I7, g6) {
                      A8 |= 0;
                      var C4, B4, Q4, i4, o4 = 0, n4 = 0, r4 = 0, f4 = 0, t4 = 0;
                      return D3 = Q4 = D3 - 160 | 0, QA(I7 |= 0, g6 |= 0, 32, 0), E3[0 | I7] = 248 & a3[0 | I7], E3[I7 + 31 | 0] = 63 & a3[I7 + 31 | 0] | 64, v3(Q4, I7), uA(A8, Q4), n4 = a3[(B4 = g6) + 8 | 0] | a3[B4 + 9 | 0] << 8 | a3[B4 + 10 | 0] << 16 | a3[B4 + 11 | 0] << 24, o4 = a3[B4 + 12 | 0] | a3[B4 + 13 | 0] << 8 | a3[B4 + 14 | 0] << 16 | a3[B4 + 15 | 0] << 24, r4 = a3[B4 + 16 | 0] | a3[B4 + 17 | 0] << 8 | a3[B4 + 18 | 0] << 16 | a3[B4 + 19 | 0] << 24, f4 = a3[B4 + 20 | 0] | a3[B4 + 21 | 0] << 8 | a3[B4 + 22 | 0] << 16 | a3[B4 + 23 | 0] << 24, t4 = a3[0 | B4] | a3[B4 + 1 | 0] << 8 | a3[B4 + 2 | 0] << 16 | a3[B4 + 3 | 0] << 24, g6 = a3[B4 + 4 | 0] | a3[B4 + 5 | 0] << 8 | a3[B4 + 6 | 0] << 16 | a3[B4 + 7 | 0] << 24, i4 = a3[B4 + 28 | 0] | a3[B4 + 29 | 0] << 8 | a3[B4 + 30 | 0] << 16 | a3[B4 + 31 | 0] << 24, C4 = I7, I7 = a3[B4 + 24 | 0] | a3[B4 + 25 | 0] << 8 | a3[B4 + 26 | 0] << 16 | a3[B4 + 27 | 0] << 24, E3[C4 + 24 | 0] = I7, E3[C4 + 25 | 0] = I7 >>> 8, E3[C4 + 26 | 0] = I7 >>> 16, E3[C4 + 27 | 0] = I7 >>> 24, E3[C4 + 28 | 0] = i4, E3[C4 + 29 | 0] = i4 >>> 8, E3[C4 + 30 | 0] = i4 >>> 16, E3[C4 + 31 | 0] = i4 >>> 24, E3[C4 + 16 | 0] = r4, E3[C4 + 17 | 0] = r4 >>> 8, E3[C4 + 18 | 0] = r4 >>> 16, E3[C4 + 19 | 0] = r4 >>> 24, E3[C4 + 20 | 0] = f4, E3[C4 + 21 | 0] = f4 >>> 8, E3[C4 + 22 | 0] = f4 >>> 16, E3[C4 + 23 | 0] = f4 >>> 24, E3[C4 + 8 | 0] = n4, E3[C4 + 9 | 0] = n4 >>> 8, E3[C4 + 10 | 0] = n4 >>> 16, E3[C4 + 11 | 0] = n4 >>> 24, E3[C4 + 12 | 0] = o4, E3[C4 + 13 | 0] = o4 >>> 8, E3[C4 + 14 | 0] = o4 >>> 16, E3[C4 + 15 | 0] = o4 >>> 24, E3[0 | C4] = t4, E3[C4 + 1 | 0] = t4 >>> 8, E3[C4 + 2 | 0] = t4 >>> 16, E3[C4 + 3 | 0] = t4 >>> 24, E3[C4 + 4 | 0] = g6, E3[C4 + 5 | 0] = g6 >>> 8, E3[C4 + 6 | 0] = g6 >>> 16, E3[C4 + 7 | 0] = g6 >>> 24, r4 = a3[(o4 = A8) + 8 | 0] | a3[o4 + 9 | 0] << 8 | a3[o4 + 10 | 0] << 16 | a3[o4 + 11 | 0] << 24, f4 = a3[o4 + 12 | 0] | a3[o4 + 13 | 0] << 8 | a3[o4 + 14 | 0] << 16 | a3[o4 + 15 | 0] << 24, t4 = a3[o4 + 16 | 0] | a3[o4 + 17 | 0] << 8 | a3[o4 + 18 | 0] << 16 | a3[o4 + 19 | 0] << 24, g6 = a3[o4 + 20 | 0] | a3[o4 + 21 | 0] << 8 | a3[o4 + 22 | 0] << 16 | a3[o4 + 23 | 0] << 24, I7 = a3[0 | o4] | a3[o4 + 1 | 0] << 8 | a3[o4 + 2 | 0] << 16 | a3[o4 + 3 | 0] << 24, A8 = a3[o4 + 4 | 0] | a3[o4 + 5 | 0] << 8 | a3[o4 + 6 | 0] << 16 | a3[o4 + 7 | 0] << 24, n4 = a3[o4 + 28 | 0] | a3[o4 + 29 | 0] << 8 | a3[o4 + 30 | 0] << 16 | a3[o4 + 31 | 0] << 24, o4 = a3[o4 + 24 | 0] | a3[o4 + 25 | 0] << 8 | a3[o4 + 26 | 0] << 16 | a3[o4 + 27 | 0] << 24, E3[C4 + 56 | 0] = o4, E3[C4 + 57 | 0] = o4 >>> 8, E3[C4 + 58 | 0] = o4 >>> 16, E3[C4 + 59 | 0] = o4 >>> 24, E3[C4 + 60 | 0] = n4, E3[C4 + 61 | 0] = n4 >>> 8, E3[C4 + 62 | 0] = n4 >>> 16, E3[C4 + 63 | 0] = n4 >>> 24, E3[C4 + 48 | 0] = t4, E3[C4 + 49 | 0] = t4 >>> 8, E3[C4 + 50 | 0] = t4 >>> 16, E3[C4 + 51 | 0] = t4 >>> 24, E3[C4 + 52 | 0] = g6, E3[C4 + 53 | 0] = g6 >>> 8, E3[C4 + 54 | 0] = g6 >>> 16, E3[C4 + 55 | 0] = g6 >>> 24, E3[C4 + 40 | 0] = r4, E3[C4 + 41 | 0] = r4 >>> 8, E3[C4 + 42 | 0] = r4 >>> 16, E3[C4 + 43 | 0] = r4 >>> 24, E3[C4 + 44 | 0] = f4, E3[C4 + 45 | 0] = f4 >>> 8, E3[C4 + 46 | 0] = f4 >>> 16, E3[C4 + 47 | 0] = f4 >>> 24, E3[C4 + 32 | 0] = I7, E3[C4 + 33 | 0] = I7 >>> 8, E3[C4 + 34 | 0] = I7 >>> 16, E3[C4 + 35 | 0] = I7 >>> 24, E3[C4 + 36 | 0] = A8, E3[C4 + 37 | 0] = A8 >>> 8, E3[C4 + 38 | 0] = A8 >>> 16, E3[C4 + 39 | 0] = A8 >>> 24, D3 = Q4 + 160 | 0, 0;
                    }, vb: function(A8, I7) {
                      A8 |= 0, I7 |= 0;
                      var g6, C4, B4, Q4, i4, n4 = 0, r4 = 0, f4 = 0;
                      return D3 = r4 = D3 - 192 | 0, hA(r4, 32), QA(I7, r4, 32, 0), E3[0 | I7] = 248 & a3[0 | I7], E3[I7 + 31 | 0] = 63 & a3[I7 + 31 | 0] | 64, v3(f4 = r4 + 32 | 0, I7), uA(A8, f4), g6 = r4, f4 = o3[r4 + 28 >> 2], r4 = o3[r4 + 24 >> 2], E3[I7 + 24 | 0] = r4, E3[I7 + 25 | 0] = r4 >>> 8, E3[I7 + 26 | 0] = r4 >>> 16, E3[I7 + 27 | 0] = r4 >>> 24, E3[I7 + 28 | 0] = f4, E3[I7 + 29 | 0] = f4 >>> 8, E3[I7 + 30 | 0] = f4 >>> 16, E3[I7 + 31 | 0] = f4 >>> 24, f4 = o3[g6 + 20 >> 2], r4 = o3[g6 + 16 >> 2], E3[I7 + 16 | 0] = r4, E3[I7 + 17 | 0] = r4 >>> 8, E3[I7 + 18 | 0] = r4 >>> 16, E3[I7 + 19 | 0] = r4 >>> 24, E3[I7 + 20 | 0] = f4, E3[I7 + 21 | 0] = f4 >>> 8, E3[I7 + 22 | 0] = f4 >>> 16, E3[I7 + 23 | 0] = f4 >>> 24, f4 = o3[g6 + 12 >> 2], r4 = o3[g6 + 8 >> 2], E3[I7 + 8 | 0] = r4, E3[I7 + 9 | 0] = r4 >>> 8, E3[I7 + 10 | 0] = r4 >>> 16, E3[I7 + 11 | 0] = r4 >>> 24, E3[I7 + 12 | 0] = f4, E3[I7 + 13 | 0] = f4 >>> 8, E3[I7 + 14 | 0] = f4 >>> 16, E3[I7 + 15 | 0] = f4 >>> 24, f4 = o3[g6 + 4 >> 2], r4 = o3[g6 >> 2], E3[0 | I7] = r4, E3[I7 + 1 | 0] = r4 >>> 8, E3[I7 + 2 | 0] = r4 >>> 16, E3[I7 + 3 | 0] = r4 >>> 24, E3[I7 + 4 | 0] = f4, E3[I7 + 5 | 0] = f4 >>> 8, E3[I7 + 6 | 0] = f4 >>> 16, E3[I7 + 7 | 0] = f4 >>> 24, C4 = a3[(n4 = A8) + 8 | 0] | a3[n4 + 9 | 0] << 8 | a3[n4 + 10 | 0] << 16 | a3[n4 + 11 | 0] << 24, B4 = a3[n4 + 12 | 0] | a3[n4 + 13 | 0] << 8 | a3[n4 + 14 | 0] << 16 | a3[n4 + 15 | 0] << 24, Q4 = a3[n4 + 16 | 0] | a3[n4 + 17 | 0] << 8 | a3[n4 + 18 | 0] << 16 | a3[n4 + 19 | 0] << 24, f4 = a3[n4 + 20 | 0] | a3[n4 + 21 | 0] << 8 | a3[n4 + 22 | 0] << 16 | a3[n4 + 23 | 0] << 24, r4 = a3[0 | n4] | a3[n4 + 1 | 0] << 8 | a3[n4 + 2 | 0] << 16 | a3[n4 + 3 | 0] << 24, A8 = a3[n4 + 4 | 0] | a3[n4 + 5 | 0] << 8 | a3[n4 + 6 | 0] << 16 | a3[n4 + 7 | 0] << 24, i4 = a3[n4 + 28 | 0] | a3[n4 + 29 | 0] << 8 | a3[n4 + 30 | 0] << 16 | a3[n4 + 31 | 0] << 24, n4 = a3[n4 + 24 | 0] | a3[n4 + 25 | 0] << 8 | a3[n4 + 26 | 0] << 16 | a3[n4 + 27 | 0] << 24, E3[I7 + 56 | 0] = n4, E3[I7 + 57 | 0] = n4 >>> 8, E3[I7 + 58 | 0] = n4 >>> 16, E3[I7 + 59 | 0] = n4 >>> 24, E3[I7 + 60 | 0] = i4, E3[I7 + 61 | 0] = i4 >>> 8, E3[I7 + 62 | 0] = i4 >>> 16, E3[I7 + 63 | 0] = i4 >>> 24, E3[I7 + 48 | 0] = Q4, E3[I7 + 49 | 0] = Q4 >>> 8, E3[I7 + 50 | 0] = Q4 >>> 16, E3[I7 + 51 | 0] = Q4 >>> 24, E3[I7 + 52 | 0] = f4, E3[I7 + 53 | 0] = f4 >>> 8, E3[I7 + 54 | 0] = f4 >>> 16, E3[I7 + 55 | 0] = f4 >>> 24, E3[I7 + 40 | 0] = C4, E3[I7 + 41 | 0] = C4 >>> 8, E3[I7 + 42 | 0] = C4 >>> 16, E3[I7 + 43 | 0] = C4 >>> 24, E3[I7 + 44 | 0] = B4, E3[I7 + 45 | 0] = B4 >>> 8, E3[I7 + 46 | 0] = B4 >>> 16, E3[I7 + 47 | 0] = B4 >>> 24, E3[I7 + 32 | 0] = r4, E3[I7 + 33 | 0] = r4 >>> 8, E3[I7 + 34 | 0] = r4 >>> 16, E3[I7 + 35 | 0] = r4 >>> 24, E3[I7 + 36 | 0] = A8, E3[I7 + 37 | 0] = A8 >>> 8, E3[I7 + 38 | 0] = A8 >>> 16, E3[I7 + 39 | 0] = A8 >>> 24, $A(g6, 32), D3 = g6 + 192 | 0, 0;
                    }, wb: function(A8, I7, g6, C4, B4, Q4) {
                      I7 |= 0, B4 |= 0, Q4 |= 0;
                      var i4, E4 = 0;
                      return D3 = i4 = D3 - 16 | 0, s3(A8 |= 0, i4 + 8 | 0, kA(A8 - -64 | 0, g6 |= 0, C4 |= 0), C4, B4, Q4, 0), 64 != o3[i4 + 8 >> 2] | o3[i4 + 12 >> 2] ? (I7 && (o3[I7 >> 2] = 0, o3[I7 + 4 >> 2] = 0), MA(A8, 0, C4 - -64 | 0), E4 = -1) : I7 && (o3[I7 >> 2] = C4 - -64, o3[I7 + 4 >> 2] = B4 - ((C4 >>> 0 < 4294967232) - 1 | 0)), D3 = i4 + 16 | 0, 0 | E4;
                    }, xb: function(A8, I7, g6, C4, B4, Q4) {
                      A8 |= 0, I7 |= 0, g6 |= 0;
                      var i4 = 0;
                      A: {
                        I: {
                          if (!(!(B4 |= 0) & (C4 |= 0) >>> 0 < 64 || (B4 = B4 - 1 | 0, !(B4 = (C4 = C4 + -64 | 0) >>> 0 < 4294967232 ? B4 + 1 | 0 : B4) & C4 >>> 0 > 4294967231 | B4))) {
                            if (!k3(g6, i4 = g6 - -64 | 0, C4, B4, Q4 |= 0, 0))
                              break I;
                            A8 && MA(A8, 0, C4);
                          }
                          if (g6 = -1, !I7)
                            break A;
                          o3[I7 >> 2] = 0, o3[I7 + 4 >> 2] = 0;
                          break A;
                        }
                        I7 && (o3[I7 >> 2] = C4, o3[I7 + 4 >> 2] = B4), g6 = 0, A8 && kA(A8, i4, C4);
                      }
                      return 0 | g6;
                    }, yb: function(A8, I7, g6, C4, B4, Q4) {
                      return s3(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, Q4 |= 0, 0), 0;
                    }, zb: function(A8, I7, g6, C4, B4) {
                      return 0 | k3(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, 0);
                    }, Ab: function(A8) {
                      return EA(A8 |= 0), 0;
                    }, Bb: function(A8, I7, g6, C4) {
                      return 0 | m3(A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0);
                    }, Cb: function(A8, I7, g6, C4) {
                      var B4;
                      return I7 |= 0, g6 |= 0, C4 |= 0, D3 = B4 = D3 + -64 | 0, M3(A8 |= 0, B4), A8 = s3(I7, g6, B4, 64, 0, C4, 1), D3 = B4 - -64 | 0, 0 | A8;
                    }, Db: function(A8, I7, g6) {
                      var C4;
                      return I7 |= 0, g6 |= 0, D3 = C4 = D3 + -64 | 0, M3(A8 |= 0, C4), A8 = k3(I7, C4, 64, 0, g6, 1), D3 = C4 - -64 | 0, 0 | A8;
                    }, Eb: function(A8, I7) {
                      A8 |= 0;
                      var g6, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, a4 = 0, n4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, h4 = 0, s4 = 0, p4 = 0, u4 = 0, k4 = 0, S4 = 0, H4 = 0, M4 = 0, G4 = 0, J4 = 0, N4 = 0, Y4 = 0, K4 = 0, P4 = 0, v4 = 0, m4 = 0, d4 = 0, L4 = 0, R4 = 0, x4 = 0, j4 = 0, q4 = 0, z4 = 0, O4 = 0, T4 = 0, Z3 = 0, $3 = 0, AA2 = 0, IA2 = 0, gA2 = 0, CA2 = 0, BA2 = 0, QA2 = 0, EA2 = 0, oA2 = 0, nA2 = 0, rA2 = 0, fA2 = 0, tA2 = 0, eA2 = 0, cA2 = 0, yA2 = 0, wA2 = 0, hA2 = 0, sA2 = 0, pA2 = 0, uA2 = 0, kA2 = 0, FA2 = 0, lA2 = 0, SA2 = 0, HA2 = 0, GA2 = 0, UA2 = 0, JA2 = 0, NA2 = 0, YA2 = 0, bA2 = 0, _A2 = 0, KA2 = 0, PA2 = 0, vA2 = 0, mA2 = 0, dA2 = 0, LA2 = 0, RA2 = 0, xA2 = 0, jA2 = 0, XA2 = 0;
                      if (D3 = g6 = D3 - 256 | 0, PA2 = -1, !aA(I7 |= 0) && !U3(g6 + 96 | 0, I7)) {
                        for (D3 = C4 = D3 - 2048 | 0, V3(s4 = C4 + 640 | 0, I7 = g6 + 96 | 0), B4 = o3[I7 + 8 >> 2], i4 = o3[I7 + 12 >> 2], Q4 = o3[I7 + 16 >> 2], a4 = o3[I7 + 20 >> 2], e4 = o3[I7 + 24 >> 2], c4 = o3[I7 + 28 >> 2], n4 = o3[I7 >> 2], f4 = o3[I7 + 4 >> 2], p4 = o3[I7 + 36 >> 2], o3[C4 + 352 >> 2] = o3[I7 + 32 >> 2], o3[C4 + 356 >> 2] = p4, o3[C4 + 344 >> 2] = e4, o3[C4 + 348 >> 2] = c4, o3[C4 + 336 >> 2] = Q4, o3[C4 + 340 >> 2] = a4, o3[C4 + 328 >> 2] = B4, o3[C4 + 332 >> 2] = i4, o3[C4 + 320 >> 2] = n4, o3[C4 + 324 >> 2] = f4, B4 = o3[I7 + 40 >> 2], i4 = o3[I7 + 44 >> 2], Q4 = o3[I7 + 48 >> 2], a4 = o3[I7 + 52 >> 2], e4 = o3[I7 + 56 >> 2], c4 = o3[I7 + 60 >> 2], f4 = o3[(n4 = I7 - -64 | 0) >> 2], n4 = o3[n4 + 4 >> 2], p4 = o3[I7 + 76 >> 2], o3[C4 + 392 >> 2] = o3[I7 + 72 >> 2], o3[C4 + 396 >> 2] = p4, o3[C4 + 384 >> 2] = f4, o3[C4 + 388 >> 2] = n4, o3[C4 + 376 >> 2] = e4, o3[C4 + 380 >> 2] = c4, o3[C4 + 368 >> 2] = Q4, o3[C4 + 372 >> 2] = a4, o3[C4 + 360 >> 2] = B4, o3[C4 + 364 >> 2] = i4, B4 = o3[I7 + 80 >> 2], i4 = o3[I7 + 84 >> 2], Q4 = o3[I7 + 88 >> 2], a4 = o3[I7 + 92 >> 2], e4 = o3[I7 + 96 >> 2], c4 = o3[I7 + 100 >> 2], n4 = o3[I7 + 104 >> 2], f4 = o3[I7 + 108 >> 2], p4 = o3[I7 + 116 >> 2], o3[C4 + 432 >> 2] = o3[I7 + 112 >> 2], o3[C4 + 436 >> 2] = p4, o3[C4 + 424 >> 2] = n4, o3[C4 + 428 >> 2] = f4, o3[C4 + 416 >> 2] = e4, o3[C4 + 420 >> 2] = c4, o3[C4 + 408 >> 2] = Q4, o3[C4 + 412 >> 2] = a4, o3[C4 + 400 >> 2] = B4, o3[C4 + 404 >> 2] = i4, l3(I7 = C4 + 480 | 0, B4 = C4 + 320 | 0), F3(n4 = C4 + 160 | 0, I7, i4 = C4 + 600 | 0), F3(C4 + 200 | 0, Q4 = C4 + 520 | 0, a4 = C4 + 560 | 0), F3(C4 + 240 | 0, a4, i4), F3(C4 + 280 | 0, I7, Q4), _3(I7, n4, s4), F3(B4, I7, i4), F3(s4 = C4 + 360 | 0, Q4, a4), F3(e4 = C4 + 400 | 0, a4, i4), F3(c4 = C4 + 440 | 0, I7, Q4), V3(f4 = C4 + 800 | 0, B4), _3(I7, n4, f4), F3(B4, I7, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, I7, Q4), V3(f4 = C4 + 960 | 0, B4), _3(I7, n4, f4), F3(B4, I7, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, I7, Q4), V3(f4 = C4 + 1120 | 0, B4), _3(I7, n4, f4), F3(B4, I7, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, I7, Q4), V3(f4 = C4 + 1280 | 0, B4), _3(I7, n4, f4), F3(B4, I7, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, I7, Q4), V3(f4 = C4 + 1440 | 0, B4), _3(I7, n4, f4), F3(B4, I7, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, I7, Q4), V3(f4 = C4 + 1600 | 0, B4), _3(I7, n4, f4), F3(B4, I7, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, I7, Q4), V3(C4 + 1760 | 0, B4), o3[C4 + 32 >> 2] = 0, o3[C4 + 36 >> 2] = 0, o3[C4 + 24 >> 2] = 0, o3[C4 + 28 >> 2] = 0, o3[C4 + 16 >> 2] = 0, o3[C4 + 20 >> 2] = 0, o3[C4 + 8 >> 2] = 0, o3[C4 + 12 >> 2] = 0, o3[C4 + 44 >> 2] = 0, o3[C4 + 48 >> 2] = 0, o3[C4 + 52 >> 2] = 0, o3[C4 + 56 >> 2] = 0, o3[C4 + 60 >> 2] = 0, o3[C4 + 64 >> 2] = 0, o3[C4 + 68 >> 2] = 0, o3[C4 + 72 >> 2] = 0, o3[C4 + 76 >> 2] = 0, o3[C4 + 80 >> 2] = 1, o3[C4 >> 2] = 0, o3[C4 + 4 >> 2] = 0, o3[C4 + 40 >> 2] = 1, MA(C4 + 84 | 0, 0, 76), f4 = C4 + 120 | 0, p4 = C4 + 80 | 0, M4 = C4 + 40 | 0, I7 = 252; B4 = o3[C4 + 36 >> 2], o3[C4 + 1960 >> 2] = o3[C4 + 32 >> 2], o3[C4 + 1964 >> 2] = B4, B4 = o3[C4 + 28 >> 2], o3[C4 + 1952 >> 2] = o3[C4 + 24 >> 2], o3[C4 + 1956 >> 2] = B4, B4 = o3[C4 + 20 >> 2], o3[C4 + 1944 >> 2] = o3[C4 + 16 >> 2], o3[C4 + 1948 >> 2] = B4, B4 = o3[C4 + 12 >> 2], o3[C4 + 1936 >> 2] = o3[C4 + 8 >> 2], o3[C4 + 1940 >> 2] = B4, B4 = o3[C4 + 4 >> 2], o3[C4 + 1928 >> 2] = o3[C4 >> 2], o3[C4 + 1932 >> 2] = B4, B4 = o3[C4 + 76 >> 2], o3[C4 + 2e3 >> 2] = o3[C4 + 72 >> 2], o3[C4 + 2004 >> 2] = B4, B4 = o3[C4 + 68 >> 2], o3[C4 + 1992 >> 2] = o3[C4 + 64 >> 2], o3[C4 + 1996 >> 2] = B4, B4 = o3[C4 + 60 >> 2], o3[C4 + 1984 >> 2] = o3[C4 + 56 >> 2], o3[C4 + 1988 >> 2] = B4, B4 = o3[C4 + 52 >> 2], o3[C4 + 1976 >> 2] = o3[C4 + 48 >> 2], o3[C4 + 1980 >> 2] = B4, B4 = o3[C4 + 44 >> 2], o3[C4 + 1968 >> 2] = o3[C4 + 40 >> 2], o3[C4 + 1972 >> 2] = B4, B4 = o3[C4 + 84 >> 2], o3[C4 + 2008 >> 2] = o3[C4 + 80 >> 2], o3[C4 + 2012 >> 2] = B4, B4 = o3[C4 + 92 >> 2], o3[C4 + 2016 >> 2] = o3[C4 + 88 >> 2], o3[C4 + 2020 >> 2] = B4, B4 = o3[C4 + 100 >> 2], o3[C4 + 2024 >> 2] = o3[C4 + 96 >> 2], o3[C4 + 2028 >> 2] = B4, B4 = o3[C4 + 108 >> 2], o3[C4 + 2032 >> 2] = o3[C4 + 104 >> 2], o3[C4 + 2036 >> 2] = B4, B4 = o3[C4 + 116 >> 2], o3[C4 + 2040 >> 2] = o3[C4 + 112 >> 2], o3[C4 + 2044 >> 2] = B4, B4 = I7, I7 = E3[I7 + 33424 | 0], l3(C4 + 480 | 0, C4 + 1928 | 0), (0 | I7) > 0 ? (F3(k4 = C4 + 320 | 0, n4 = C4 + 480 | 0, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, n4, Q4), _3(n4, k4, (C4 + 640 | 0) + r3((254 & I7) >>> 1 | 0, 160) | 0)) : (0 | I7) >= 0 || (F3(k4 = C4 + 320 | 0, n4 = C4 + 480 | 0, i4), F3(s4, Q4, a4), F3(e4, a4, i4), F3(c4, n4, Q4), b3(n4, k4, (C4 + 640 | 0) + r3((0 - I7 & 254) >>> 1 | 0, 160) | 0)), F3(C4, I7 = C4 + 480 | 0, i4), F3(M4, Q4, a4), F3(p4, a4, i4), F3(f4, I7, Q4), I7 = B4 - 1 | 0, B4; )
                          ;
                        W3(I7 = C4 + 640 | 0, C4), I7 = iA(I7, 32), D3 = C4 + 2048 | 0, I7 && (Q4 = o3[g6 + 136 >> 2], o3[g6 >> 2] = 1 - Q4, PA2 = 0, j4 = o3[g6 + 172 >> 2], o3[g6 + 36 >> 2] = 0 - j4, f4 = o3[g6 + 168 >> 2], o3[g6 + 32 >> 2] = 0 - f4, q4 = o3[g6 + 164 >> 2], o3[g6 + 28 >> 2] = 0 - q4, s4 = o3[g6 + 160 >> 2], o3[g6 + 24 >> 2] = 0 - s4, z4 = o3[g6 + 156 >> 2], o3[g6 + 20 >> 2] = 0 - z4, e4 = o3[g6 + 152 >> 2], o3[g6 + 16 >> 2] = 0 - e4, O4 = o3[g6 + 148 >> 2], o3[g6 + 12 >> 2] = 0 - O4, c4 = o3[g6 + 144 >> 2], o3[g6 + 8 >> 2] = 0 - c4, T4 = o3[g6 + 140 >> 2], o3[g6 + 4 >> 2] = 0 - T4, X3(g6, g6), I7 = DA(M4 = o3[g6 + 4 >> 2], L4 = M4 >> 31, G4 = z4 << 1, fA2 = G4 >> 31), B4 = w3, C4 = DA(a4 = o3[g6 >> 2], N4 = a4 >> 31, s4, Y4 = s4 >> 31), B4 = w3 + B4 | 0, B4 = (I7 = C4 + I7 | 0) >>> 0 < C4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (i4 = DA(K4 = o3[g6 + 8 >> 2], Z3 = K4 >> 31, e4, P4 = e4 >> 31)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(R4 = o3[g6 + 12 >> 2], IA2 = R4 >> 31, BA2 = O4 << 1, tA2 = BA2 >> 31), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA($3 = o3[g6 + 16 >> 2], QA2 = $3 >> 31, c4, v4 = c4 >> 31), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, JA2 = i4 = o3[g6 + 20 >> 2], n4 = DA(i4, eA2 = i4 >> 31, EA2 = T4 << 1, cA2 = EA2 >> 31), C4 = w3 + I7 | 0, C4 = (B4 = n4 + B4 | 0) >>> 0 < n4 >>> 0 ? C4 + 1 | 0 : C4, NA2 = S4 = o3[g6 + 24 >> 2], I7 = (Q4 = DA(S4, HA2 = S4 >> 31, n4 = Q4 + 1 | 0, m4 = n4 >> 31)) + B4 | 0, B4 = w3 + C4 | 0, B4 = I7 >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, yA2 = o3[g6 + 28 >> 2], C4 = (Q4 = DA(y4 = r3(yA2, 19), gA2 = y4 >> 31, oA2 = j4 << 1, wA2 = oA2 >> 31)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, vA2 = o3[g6 + 32 >> 2], C4 = DA(k4 = r3(vA2, 19), AA2 = k4 >> 31, f4, d4 = f4 >> 31), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, mA2 = o3[g6 + 36 >> 2], C4 = DA(p4 = r3(mA2, 19), x4 = p4 >> 31, nA2 = q4 << 1, hA2 = nA2 >> 31), I7 = w3 + I7 | 0, h4 = B4 = C4 + B4 | 0, Q4 = C4 >>> 0 > B4 >>> 0 ? I7 + 1 | 0 : I7, I7 = DA(e4, P4, M4, L4), B4 = w3, t4 = DA(a4, N4, z4, sA2 = z4 >> 31), C4 = w3 + B4 | 0, C4 = (I7 = t4 + I7 | 0) >>> 0 < t4 >>> 0 ? C4 + 1 | 0 : C4, t4 = DA(K4, Z3, O4, pA2 = O4 >> 31), B4 = w3 + C4 | 0, B4 = (I7 = t4 + I7 | 0) >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (t4 = DA(c4, v4, R4, IA2)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA($3, QA2, T4, uA2 = T4 >> 31), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(n4, m4, i4, eA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, t4 = DA(S4 = r3(S4, 19), rA2 = S4 >> 31, j4, kA2 = j4 >> 31), C4 = w3 + I7 | 0, C4 = (B4 = t4 + B4 | 0) >>> 0 < t4 >>> 0 ? C4 + 1 | 0 : C4, I7 = (t4 = DA(f4, d4, y4, gA2)) + B4 | 0, B4 = w3 + C4 | 0, B4 = I7 >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (t4 = DA(k4, AA2, q4, FA2 = q4 >> 31)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(s4, Y4, p4, x4), I7 = w3 + I7 | 0, YA2 = B4 = B4 + C4 | 0, CA2 = C4 >>> 0 > B4 >>> 0 ? I7 + 1 | 0 : I7, I7 = DA(M4, L4, BA2, tA2), C4 = w3, B4 = (t4 = DA(a4, N4, e4, P4)) + I7 | 0, I7 = w3 + C4 | 0, I7 = B4 >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7, t4 = DA(c4, v4, K4, Z3), C4 = w3 + I7 | 0, C4 = (B4 = t4 + B4 | 0) >>> 0 < t4 >>> 0 ? C4 + 1 | 0 : C4, I7 = (t4 = DA(R4, IA2, EA2, cA2)) + B4 | 0, B4 = w3 + C4 | 0, B4 = I7 >>> 0 < t4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (t4 = DA(n4, m4, $3, QA2)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < t4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(t4 = r3(i4, 19), lA2 = t4 >> 31, oA2, wA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(f4, d4, S4, rA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, i4 = DA(y4, gA2, nA2, hA2), C4 = w3 + I7 | 0, C4 = (B4 = i4 + B4 | 0) >>> 0 < i4 >>> 0 ? C4 + 1 | 0 : C4, I7 = (i4 = DA(s4, Y4, k4, AA2)) + B4 | 0, B4 = w3 + C4 | 0, B4 = I7 >>> 0 < i4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (i4 = DA(p4, x4, G4, fA2)) + I7 | 0, I7 = w3 + B4 | 0, dA2 = C4, LA2 = I7 = C4 >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, RA2 = C4 = C4 + 33554432 | 0, xA2 = I7 = C4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, C4 = (67108863 & I7) << 6 | C4 >>> 26, I7 = (I7 >> 26) + CA2 | 0, YA2 = i4 = C4 + YA2 | 0, C4 = I7 = C4 >>> 0 > i4 >>> 0 ? I7 + 1 | 0 : I7, jA2 = I7 = i4 + 16777216 | 0, i4 = (33554431 & (C4 = I7 >>> 0 < 16777216 ? C4 + 1 | 0 : C4)) << 7 | I7 >>> 25, I7 = (B4 = C4 >> 25) + Q4 | 0, I7 = (C4 = i4 + h4 | 0) >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, bA2 = B4 = C4 + 33554432 | 0, i4 = I7 = B4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, o3[g6 + 72 >> 2] = C4 - (-67108864 & B4), I7 = DA(M4, L4, EA2, cA2), B4 = w3, Q4 = DA(a4, N4, c4, v4), C4 = w3 + B4 | 0, C4 = (I7 = Q4 + I7 | 0) >>> 0 < Q4 >>> 0 ? C4 + 1 | 0 : C4, B4 = (Q4 = DA(n4, m4, K4, Z3)) + I7 | 0, I7 = w3 + C4 | 0, I7 = B4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(Q4 = r3(R4, 19), SA2 = Q4 >> 31, oA2, wA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = (h4 = DA(CA2 = r3($3, 19), GA2 = CA2 >> 31, f4, d4)) + B4 | 0, B4 = w3 + I7 | 0, B4 = C4 >>> 0 < h4 >>> 0 ? B4 + 1 | 0 : B4, h4 = DA(nA2, hA2, t4, lA2), I7 = w3 + B4 | 0, I7 = (C4 = h4 + C4 | 0) >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, B4 = (h4 = DA(s4, Y4, S4, rA2)) + C4 | 0, C4 = w3 + I7 | 0, C4 = B4 >>> 0 < h4 >>> 0 ? C4 + 1 | 0 : C4, h4 = DA(y4, gA2, G4, fA2), I7 = w3 + C4 | 0, I7 = (B4 = h4 + B4 | 0) >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(e4, P4, k4, AA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = (h4 = DA(p4, x4, BA2, tA2)) + B4 | 0, B4 = w3 + I7 | 0, H4 = C4, _A2 = C4 >>> 0 < h4 >>> 0 ? B4 + 1 | 0 : B4, I7 = DA(n4, m4, M4, L4), B4 = w3, C4 = (h4 = DA(a4, N4, T4, uA2)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7, h4 = B4 = r3(K4, 19), B4 = (u4 = DA(B4, UA2 = B4 >> 31, j4, kA2)) + C4 | 0, C4 = w3 + I7 | 0, C4 = B4 >>> 0 < u4 >>> 0 ? C4 + 1 | 0 : C4, u4 = DA(f4, d4, Q4, SA2), I7 = w3 + C4 | 0, I7 = (B4 = u4 + B4 | 0) >>> 0 < u4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(CA2, GA2, q4, FA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = (u4 = DA(s4, Y4, t4, lA2)) + B4 | 0, B4 = w3 + I7 | 0, B4 = C4 >>> 0 < u4 >>> 0 ? B4 + 1 | 0 : B4, u4 = DA(S4, rA2, z4, sA2), I7 = w3 + B4 | 0, I7 = (C4 = u4 + C4 | 0) >>> 0 < u4 >>> 0 ? I7 + 1 | 0 : I7, B4 = (u4 = DA(e4, P4, y4, gA2)) + C4 | 0, C4 = w3 + I7 | 0, C4 = B4 >>> 0 < u4 >>> 0 ? C4 + 1 | 0 : C4, u4 = DA(k4, AA2, O4, pA2), I7 = w3 + C4 | 0, I7 = (B4 = u4 + B4 | 0) >>> 0 < u4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(c4, v4, p4, x4), I7 = w3 + I7 | 0, KA2 = B4 = C4 + B4 | 0, u4 = C4 >>> 0 > B4 >>> 0 ? I7 + 1 | 0 : I7, I7 = DA(I7 = r3(M4, 19), I7 >> 31, oA2, wA2), B4 = w3, C4 = DA(a4, N4, n4, m4), B4 = w3 + B4 | 0, B4 = (I7 = C4 + I7 | 0) >>> 0 < C4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (h4 = DA(f4, d4, h4, UA2)) + I7 | 0, I7 = w3 + B4 | 0, B4 = (Q4 = DA(Q4, SA2, nA2, hA2)) + C4 | 0, C4 = w3 + (C4 >>> 0 < h4 >>> 0 ? I7 + 1 | 0 : I7) | 0, C4 = B4 >>> 0 < Q4 >>> 0 ? C4 + 1 | 0 : C4, Q4 = DA(s4, Y4, CA2, GA2), I7 = w3 + C4 | 0, I7 = (B4 = Q4 + B4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(G4, fA2, t4, lA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = (Q4 = DA(e4, P4, S4, rA2)) + B4 | 0, B4 = w3 + I7 | 0, B4 = C4 >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = DA(y4, gA2, BA2, tA2), I7 = w3 + B4 | 0, I7 = (C4 = Q4 + C4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, B4 = (Q4 = DA(c4, v4, k4, AA2)) + C4 | 0, C4 = w3 + I7 | 0, C4 = B4 >>> 0 < Q4 >>> 0 ? C4 + 1 | 0 : C4, Q4 = DA(p4, x4, EA2, cA2), I7 = w3 + C4 | 0, h4 = B4 = Q4 + B4 | 0, SA2 = I7 = B4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, UA2 = B4 = B4 + 33554432 | 0, XA2 = I7 = B4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, C4 = I7 >> 26, I7 = (67108863 & I7) << 6 | B4 >>> 26, B4 = C4 + u4 | 0, u4 = Q4 = I7 + KA2 | 0, I7 = B4 = I7 >>> 0 > Q4 >>> 0 ? B4 + 1 | 0 : B4, KA2 = B4 = Q4 + 16777216 | 0, Q4 = (33554431 & (I7 = B4 >>> 0 < 16777216 ? I7 + 1 | 0 : I7)) << 7 | B4 >>> 25, I7 = (I7 >> 25) + _A2 | 0, I7 = (B4 = Q4 + H4 | 0) >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, _A2 = B4 = (C4 = B4) + 33554432 | 0, Q4 = I7 = B4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, o3[g6 + 56 >> 2] = C4 - (-67108864 & B4), I7 = DA(s4, Y4, M4, L4), C4 = w3, B4 = (H4 = DA(a4, N4, q4, FA2)) + I7 | 0, I7 = w3 + C4 | 0, I7 = B4 >>> 0 < H4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(K4, Z3, z4, sA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(e4, P4, R4, IA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, H4 = DA($3, QA2, O4, pA2), C4 = w3 + I7 | 0, C4 = (B4 = H4 + B4 | 0) >>> 0 < H4 >>> 0 ? C4 + 1 | 0 : C4, I7 = (H4 = DA(c4, v4, JA2, eA2)) + B4 | 0, B4 = w3 + C4 | 0, B4 = I7 >>> 0 < H4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (H4 = DA(T4, uA2, NA2, HA2)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < H4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(yA2, H4 = yA2 >> 31, n4, m4), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(k4, AA2, j4, kA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, J4 = (C4 = B4) + (B4 = DA(p4, x4, f4, d4)) | 0, C4 = w3 + I7 | 0, B4 = (I7 = i4 >> 26) + (B4 = B4 >>> 0 > J4 >>> 0 ? C4 + 1 | 0 : C4) | 0, I7 = (C4 = (i4 = (67108863 & i4) << 6 | bA2 >>> 26) + J4 | 0) >>> 0 < i4 >>> 0 ? B4 + 1 | 0 : B4, bA2 = B4 = C4 + 16777216 | 0, i4 = I7 = B4 >>> 0 < 16777216 ? I7 + 1 | 0 : I7, o3[g6 + 76 >> 2] = C4 - (-33554432 & B4), I7 = DA(c4, v4, M4, L4), B4 = w3, J4 = DA(a4, N4, O4, pA2), C4 = w3 + B4 | 0, C4 = (I7 = J4 + I7 | 0) >>> 0 < J4 >>> 0 ? C4 + 1 | 0 : C4, J4 = DA(K4, Z3, T4, uA2), B4 = w3 + C4 | 0, B4 = (I7 = J4 + I7 | 0) >>> 0 < J4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (J4 = DA(n4, m4, R4, IA2)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < J4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(CA2, GA2, j4, kA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(f4, d4, t4, lA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, B4 = (S4 = DA(S4, rA2, q4, FA2)) + B4 | 0, C4 = w3 + I7 | 0, I7 = (y4 = DA(s4, Y4, y4, gA2)) + B4 | 0, B4 = w3 + (B4 >>> 0 < S4 >>> 0 ? C4 + 1 | 0 : C4) | 0, C4 = (k4 = DA(k4, AA2, z4, sA2)) + I7 | 0, I7 = w3 + (I7 >>> 0 < y4 >>> 0 ? B4 + 1 | 0 : B4) | 0, I7 = C4 >>> 0 < k4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(e4, P4, p4, x4), I7 = w3 + I7 | 0, y4 = B4 = B4 + C4 | 0, I7 = (I7 = C4 >>> 0 > B4 >>> 0 ? I7 + 1 | 0 : I7) + (B4 = Q4 >> 26) | 0, C4 = (B4 = Q4 = y4 + (C4 = (67108863 & Q4) << 6 | _A2 >>> 26) | 0) >>> 0 < C4 >>> 0 ? I7 + 1 | 0 : I7, k4 = I7 = B4 + 16777216 | 0, Q4 = C4 = I7 >>> 0 < 16777216 ? C4 + 1 | 0 : C4, o3[g6 + 60 >> 2] = B4 - (-33554432 & I7), I7 = DA(M4, L4, nA2, hA2), C4 = w3, B4 = (y4 = DA(a4, N4, f4, d4)) + I7 | 0, I7 = w3 + C4 | 0, I7 = B4 >>> 0 < y4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(s4, Y4, K4, Z3), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, y4 = DA(R4, IA2, G4, fA2), C4 = w3 + I7 | 0, C4 = (B4 = y4 + B4 | 0) >>> 0 < y4 >>> 0 ? C4 + 1 | 0 : C4, I7 = (y4 = DA(e4, P4, $3, QA2)) + B4 | 0, B4 = w3 + C4 | 0, B4 = I7 >>> 0 < y4 >>> 0 ? B4 + 1 | 0 : B4, C4 = (y4 = DA(BA2, tA2, JA2, eA2)) + I7 | 0, I7 = w3 + B4 | 0, I7 = C4 >>> 0 < y4 >>> 0 ? I7 + 1 | 0 : I7, B4 = C4, C4 = DA(c4, v4, NA2, HA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = B4 + C4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = B4, B4 = DA(yA2, H4, EA2, cA2), I7 = w3 + I7 | 0, I7 = (C4 = C4 + B4 | 0) >>> 0 < B4 >>> 0 ? I7 + 1 | 0 : I7, y4 = B4 = vA2, B4 = (G4 = DA(B4, S4 = B4 >> 31, n4, m4)) + C4 | 0, C4 = w3 + I7 | 0, I7 = (p4 = DA(p4, x4, oA2, wA2)) + B4 | 0, B4 = w3 + (B4 >>> 0 < G4 >>> 0 ? C4 + 1 | 0 : C4) | 0, C4 = I7 >>> 0 < p4 >>> 0 ? B4 + 1 | 0 : B4, B4 = I7, I7 = (I7 = i4 >> 25) + C4 | 0, I7 = (B4 = B4 + (i4 = (33554431 & i4) << 7 | bA2 >>> 25) | 0) >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, p4 = B4 = (C4 = B4) + 33554432 | 0, i4 = I7 = B4 >>> 0 < 33554432 ? I7 + 1 | 0 : I7, o3[g6 + 80 >> 2] = C4 - (-67108864 & B4), B4 = Q4 >> 25, C4 = (Q4 = (33554431 & Q4) << 7 | k4 >>> 25) + (dA2 - (I7 = -67108864 & RA2) | 0) | 0, I7 = B4 + (LA2 - ((I7 >>> 0 > dA2 >>> 0) + xA2 | 0) | 0) | 0, I7 = C4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, Q4 = I7 = (67108863 & (I7 = (B4 = C4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7)) << 6 | B4 >>> 26, I7 = I7 + (G4 = YA2 - (-33554432 & jA2) | 0) | 0, o3[g6 + 68 >> 2] = I7, o3[g6 + 64 >> 2] = C4 - (-67108864 & B4), I7 = DA(f4, d4, M4, L4), C4 = w3, B4 = (Q4 = DA(a4, N4, j4, kA2)) + I7 | 0, I7 = w3 + C4 | 0, I7 = B4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, C4 = (Q4 = DA(K4, Z3, q4, FA2)) + B4 | 0, B4 = w3 + I7 | 0, B4 = C4 >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, I7 = (Q4 = DA(s4, Y4, R4, IA2)) + C4 | 0, C4 = w3 + B4 | 0, C4 = I7 >>> 0 < Q4 >>> 0 ? C4 + 1 | 0 : C4, B4 = (Q4 = DA($3, QA2, z4, sA2)) + I7 | 0, I7 = w3 + C4 | 0, I7 = B4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(e4, P4, JA2, eA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = DA(O4, pA2, NA2, HA2), I7 = w3 + I7 | 0, I7 = C4 >>> 0 > (B4 = C4 + B4 | 0) >>> 0 ? I7 + 1 | 0 : I7, C4 = (Q4 = DA(c4, v4, yA2, H4)) + B4 | 0, B4 = w3 + I7 | 0, B4 = C4 >>> 0 < Q4 >>> 0 ? B4 + 1 | 0 : B4, Q4 = (I7 = DA(y4, S4, T4, uA2)) + C4 | 0, C4 = w3 + B4 | 0, C4 = I7 >>> 0 > Q4 >>> 0 ? C4 + 1 | 0 : C4, B4 = Q4, Q4 = DA(I7 = mA2, I7 >> 31, n4, m4), I7 = w3 + C4 | 0, C4 = B4 = B4 + Q4 | 0, I7 = (I7 = B4 >>> 0 < Q4 >>> 0 ? I7 + 1 | 0 : I7) + (B4 = i4 >> 26) | 0, I7 = (C4 = C4 + (i4 = (67108863 & i4) << 6 | p4 >>> 26) | 0) >>> 0 < i4 >>> 0 ? I7 + 1 | 0 : I7, I7 = (B4 = C4 + 16777216 | 0) >>> 0 < 16777216 ? I7 + 1 | 0 : I7, o3[g6 + 84 >> 2] = C4 - (-33554432 & B4), i4 = u4 - (-33554432 & KA2) | 0, Q4 = h4 - (C4 = -67108864 & UA2) | 0, a4 = SA2 - ((C4 >>> 0 > h4 >>> 0) + XA2 | 0) | 0, I7 = DA((33554431 & (C4 = I7)) << 7 | B4 >>> 25, I7 = C4 >> 25, 19, 0), B4 = w3 + a4 | 0, I7 = I7 >>> 0 > (C4 = I7 + Q4 | 0) >>> 0 ? B4 + 1 | 0 : B4, Q4 = I7 = (67108863 & (I7 = (B4 = C4 + 33554432 | 0) >>> 0 < 33554432 ? I7 + 1 | 0 : I7)) << 6 | B4 >>> 26, I7 = I7 + i4 | 0, o3[g6 + 52 >> 2] = I7, o3[g6 + 48 >> 2] = C4 - (-67108864 & B4), W3(A8, g6 + 48 | 0));
                      }
                      return D3 = g6 + 256 | 0, 0 | PA2;
                    }, Fb: function(A8, I7) {
                      A8 |= 0;
                      var g6, C4 = 0;
                      return D3 = g6 = D3 + -64 | 0, QA(g6, I7 |= 0, 32, 0), E3[0 | g6] = 248 & a3[0 | g6], E3[g6 + 31 | 0] = 63 & a3[g6 + 31 | 0] | 64, I7 = o3[g6 + 20 >> 2], C4 = o3[g6 + 16 >> 2], E3[A8 + 16 | 0] = C4, E3[A8 + 17 | 0] = C4 >>> 8, E3[A8 + 18 | 0] = C4 >>> 16, E3[A8 + 19 | 0] = C4 >>> 24, E3[A8 + 20 | 0] = I7, E3[A8 + 21 | 0] = I7 >>> 8, E3[A8 + 22 | 0] = I7 >>> 16, E3[A8 + 23 | 0] = I7 >>> 24, I7 = o3[g6 + 12 >> 2], C4 = o3[g6 + 8 >> 2], E3[A8 + 8 | 0] = C4, E3[A8 + 9 | 0] = C4 >>> 8, E3[A8 + 10 | 0] = C4 >>> 16, E3[A8 + 11 | 0] = C4 >>> 24, E3[A8 + 12 | 0] = I7, E3[A8 + 13 | 0] = I7 >>> 8, E3[A8 + 14 | 0] = I7 >>> 16, E3[A8 + 15 | 0] = I7 >>> 24, I7 = o3[g6 + 4 >> 2], C4 = o3[g6 >> 2], E3[0 | A8] = C4, E3[A8 + 1 | 0] = C4 >>> 8, E3[A8 + 2 | 0] = C4 >>> 16, E3[A8 + 3 | 0] = C4 >>> 24, E3[A8 + 4 | 0] = I7, E3[A8 + 5 | 0] = I7 >>> 8, E3[A8 + 6 | 0] = I7 >>> 16, E3[A8 + 7 | 0] = I7 >>> 24, I7 = o3[g6 + 28 >> 2], C4 = o3[g6 + 24 >> 2], E3[A8 + 24 | 0] = C4, E3[A8 + 25 | 0] = C4 >>> 8, E3[A8 + 26 | 0] = C4 >>> 16, E3[A8 + 27 | 0] = C4 >>> 24, E3[A8 + 28 | 0] = I7, E3[A8 + 29 | 0] = I7 >>> 8, E3[A8 + 30 | 0] = I7 >>> 16, E3[A8 + 31 | 0] = I7 >>> 24, $A(g6, 64), D3 = g6 - -64 | 0, 0;
                    }, Gb: function() {
                      var A8, I7;
                      return D3 = A8 = D3 - 16 | 0, E3[A8 + 15 | 0] = 0, I7 = 0 | t3(34904, A8 + 15 | 0, 0), D3 = A8 + 16 | 0, 0 | I7;
                    }, Hb: KA, Ib: function(A8) {
                      var I7, g6 = 0, C4 = 0;
                      if (D3 = I7 = D3 - 16 | 0, (A8 |= 0) >>> 0 >= 2) {
                        for (g6 = (0 - A8 >>> 0) % (A8 >>> 0) | 0; E3[I7 + 15 | 0] = 0, g6 >>> 0 > (C4 = 0 | t3(34904, I7 + 15 | 0, 0)) >>> 0; )
                          ;
                        g6 = (C4 >>> 0) % (A8 >>> 0) | 0;
                      }
                      return D3 = I7 + 16 | 0, 0 | g6;
                    }, Jb: hA, Kb: function(A8, I7, g6) {
                      XA(A8 |= 0, I7 |= 0, 1024, g6 |= 0);
                    }, Lb: II, Mb: function() {
                      var A8 = 0, I7 = 0;
                      return (A8 = o3[9048]) && (A8 = o3[A8 + 20 >> 2]) && (I7 = 0 | nI[0 | A8]()), 0 | I7;
                    }, Nb: function(A8, I7, g6) {
                      A8 |= 0, I7 |= 0;
                      var C4, B4 = 0, i4 = 0, o4 = 0;
                      if (D3 = C4 = D3 - 16 | 0, g6 |= 0)
                        e3(1240, 1100, 197, 1036), Q3();
                      else {
                        if (I7)
                          for (; E3[C4 + 15 | 0] = 0, i4 = A8 + B4 | 0, o4 = 0 | t3(34904, C4 + 15 | 0, 0), E3[0 | i4] = o4, (0 | I7) != (0 | (B4 = B4 + 1 | 0)); )
                            ;
                        D3 = C4 + 16 | 0;
                      }
                    }, Ob: function(A8, I7, g6, C4) {
                      A8 |= 0, g6 |= 0;
                      var B4 = 0, i4 = 0, o4 = 0;
                      if (!((C4 |= 0) >>> 0 > 2147483646 | C4 << 1 >>> 0 >= (I7 |= 0) >>> 0)) {
                        if (I7 = 0, C4) {
                          for (; B4 = (I7 << 1) + A8 | 0, i4 = 15 & (o4 = a3[I7 + g6 | 0]), E3[B4 + 1 | 0] = 22272 + ((i4 << 8) + (i4 + 65526 & 55552) | 0) >>> 8, i4 = B4, B4 = o4 >>> 4 | 0, E3[0 | i4] = 87 + ((B4 + 65526 >>> 8 & 217) + B4 | 0), (0 | C4) != (0 | (I7 = I7 + 1 | 0)); )
                            ;
                          I7 = C4 << 1;
                        } else
                          I7 = 0;
                        return E3[I7 + A8 | 0] = 0, 0 | A8;
                      }
                      mA(), Q3();
                    }, Pb: function(A8, I7, g6, C4, B4, Q4, i4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, B4 |= 0, Q4 |= 0, i4 |= 0;
                      var n4 = 0, r4 = 0, f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0;
                      A:
                        if (C4 |= 0) {
                          I: {
                            g: {
                              C: {
                                B: {
                                  if (!B4) {
                                    for (r4 = 1, B4 = 0; ; ) {
                                      if (!(255 & ((y4 = (65526 + (f4 = (223 & (e4 = a3[g6 + n4 | 0])) - 55 & 255) ^ f4 + 65520) >>> 8 | 0) | (D4 = 65526 + (e4 ^= 48) >>> 8 | 0))))
                                        break C;
                                      if (I7 >>> 0 <= c4 >>> 0)
                                        break B;
                                      if (f4 = f4 & y4 | e4 & D4, 255 & t4 ? (E3[A8 + c4 | 0] = B4 | f4, c4 = c4 + 1 | 0) : B4 = f4 << 4, t4 ^= -1, (0 | (n4 = n4 + 1 | 0)) == (0 | C4))
                                        break;
                                    }
                                    n4 = C4;
                                    break C;
                                  }
                                  for (; ; ) {
                                    Q: {
                                      i: {
                                        E: {
                                          o: {
                                            a: {
                                              if (!(255 & ((e4 = (65526 + (f4 = (223 & (r4 = a3[g6 + n4 | 0])) - 55 & 255) ^ f4 + 65520) >>> 8 | 0) | (D4 = 65526 + (y4 = 48 ^ r4) >>> 8 | 0)))) {
                                                if (255 & t4)
                                                  break g;
                                                if (!$2(B4, r4))
                                                  break A;
                                                if ((n4 = t4 = n4 + 1 | 0) >>> 0 < C4 >>> 0)
                                                  break a;
                                                break A;
                                              }
                                              if (I7 >>> 0 <= c4 >>> 0)
                                                break B;
                                              if (r4 = f4 & e4 | y4 & D4, !(255 & t4))
                                                break o;
                                              E3[A8 + c4 | 0] = r4 | h4, c4 = c4 + 1 | 0;
                                              break Q;
                                            }
                                            for (; ; ) {
                                              if (!(255 & ((e4 = (65526 + (f4 = (223 & (r4 = a3[g6 + n4 | 0])) - 55 & 255) ^ f4 + 65520) >>> 8 | 0) | (D4 = 65526 + (y4 = 48 ^ r4) >>> 8 | 0)))) {
                                                if (!$2(B4, r4))
                                                  break A;
                                                if ((n4 = n4 + 1 | 0) >>> 0 < C4 >>> 0)
                                                  continue;
                                                break E;
                                              }
                                              break;
                                            }
                                            if (I7 >>> 0 <= c4 >>> 0)
                                              break i;
                                            r4 = f4 & e4 | y4 & D4;
                                          }
                                          h4 = r4 << 4, t4 = 0;
                                          break Q;
                                        }
                                        n4 = C4 >>> 0 > t4 >>> 0 ? C4 : t4;
                                        break A;
                                      }
                                      t4 = 0;
                                      break B;
                                    }
                                    if (t4 ^= -1, r4 = 1, !((n4 = n4 + 1 | 0) >>> 0 < C4 >>> 0))
                                      break;
                                  }
                                  break C;
                                }
                                o3[8916] = 68, r4 = 0;
                              }
                              if (!(255 & t4))
                                break I;
                            }
                            o3[8916] = 28, w4 = -1, n4 = n4 - 1 | 0, c4 = 0;
                            break A;
                          }
                          r4 || (c4 = 0, w4 = -1);
                        }
                      return i4 ? o3[i4 >> 2] = g6 + n4 : (0 | C4) != (0 | n4) && (o3[8916] = 28, w4 = -1), Q4 && (o3[Q4 >> 2] = c4), 0 | w4;
                    }, Qb: function(A8, I7) {
                      A8 |= 0;
                      var g6 = 0;
                      return 1 != (-7 & (I7 |= 0)) && (mA(), Q3()), 1 + ((3 & (g6 = (g6 = A8) + r3(A8 = (A8 >>> 0) / 3 | 0, -3) | 0) ? 2 & I7 ? g6 + 1 | 0 : 4 : 0) + (A8 << 2) | 0) | 0;
                    }, Rb: function(A8, I7, g6, C4, B4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0;
                      var i4 = 0, o4 = 0, n4 = 0, f4 = 0, t4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0;
                      A: {
                        I: {
                          g: {
                            if (1 == (-7 & (B4 |= 0)) && (f4 = (i4 = (C4 >>> 0) / 3 | 0) << 2, (i4 = r3(i4, -3) + C4 | 0) && (f4 = 2 & B4 ? (2 | f4) + (i4 >>> 1 | 0) | 0 : f4 + 4 | 0), !(I7 >>> 0 <= f4 >>> 0))) {
                              if (!(4 & B4)) {
                                if (i4 = 0, !C4)
                                  break A;
                                break g;
                              }
                              if (i4 = 0, !C4)
                                break A;
                              for (; ; ) {
                                for (c4 = (D4 = a3[g6 + y4 | 0]) | c4 << 8, t4 = i4, i4 = 1 + ((((n4 |= 8) - 6 >>> 0) / 6 | 0) + i4 | 0) | 0; w4 = 65510 + (o4 = c4 >>> (n4 = (B4 = n4) - 6 | 0) & 63) >>> 8 | 0, h4 = o4 + 65484 >>> 8 | 0, E3[A8 + t4 | 0] = (1 + (16321 ^ o4) ^ -1) >>> 8 & 45 | o4 + 252 & o4 + 65474 >>> 8 & (-1 ^ h4) | (o4 + 32705 ^ -1) >>> 8 & 95 | w4 & o4 + 65 | h4 & o4 + 71 & (-1 ^ w4), (0 | (t4 = t4 + 1 | 0)) != (0 | i4); )
                                  ;
                                if ((0 | (y4 = y4 + 1 | 0)) == (0 | C4))
                                  break;
                              }
                              if (!n4)
                                break A;
                              t4 = (C4 = 65510 + (g6 = D4 << 12 - B4 & 63) >>> 8 | 0) & g6 + 65, c4 = g6 + 252 & g6 + 65474 >>> 8 & (-1 ^ (B4 = g6 + 65484 >>> 8 | 0)), n4 = B4 & g6 + 71 & (-1 ^ C4), C4 = g6 + 32705 | 0, B4 = (1 + (16321 ^ g6) ^ -1) >>> 8 & 45, g6 = 95;
                              break I;
                            }
                            mA(), Q3();
                          }
                          for (; ; ) {
                            for (c4 = (D4 = a3[g6 + y4 | 0]) | c4 << 8, t4 = i4, i4 = 1 + ((((n4 |= 8) - 6 >>> 0) / 6 | 0) + i4 | 0) | 0; w4 = 65510 + (o4 = c4 >>> (n4 = (B4 = n4) - 6 | 0) & 63) >>> 8 | 0, h4 = o4 + 65484 >>> 8 | 0, E3[A8 + t4 | 0] = (1 + (16321 ^ o4) ^ -1) >>> 8 & 43 | o4 + 252 & o4 + 65474 >>> 8 & (-1 ^ h4) | (o4 + 16321 ^ -1) >>> 8 & 47 | w4 & o4 + 65 | h4 & o4 + 71 & (-1 ^ w4), (0 | (t4 = t4 + 1 | 0)) != (0 | i4); )
                              ;
                            if ((0 | (y4 = y4 + 1 | 0)) == (0 | C4))
                              break;
                          }
                          if (!n4)
                            break A;
                          t4 = (C4 = 65510 + (g6 = D4 << 12 - B4 & 63) >>> 8 | 0) & g6 + 65, c4 = g6 + 252 & g6 + 65474 >>> 8 & (-1 ^ (B4 = g6 + 65484 >>> 8 | 0)), n4 = B4 & g6 + 71 & (-1 ^ C4), C4 = g6 + 16321 | 0, B4 = (1 + (16321 ^ g6) ^ -1) >>> 8 & 43, g6 = 47;
                        }
                        E3[A8 + i4 | 0] = g6 & (-1 ^ C4) >>> 8 | t4 | c4 | B4 | n4, i4 = i4 + 1 | 0;
                      }
                      A: {
                        I: {
                          if (i4 >>> 0 <= f4 >>> 0) {
                            if (i4 >>> 0 < f4 >>> 0)
                              break I;
                            f4 = i4;
                            break A;
                          }
                          e3(1048, 1126, 230, 1319), Q3();
                        }
                        MA(A8 + i4 | 0, 61, f4 - i4 | 0);
                      }
                      return MA(A8 + f4 | 0, 0, (I7 >>> 0 > (g6 = f4 + 1 | 0) >>> 0 ? I7 : g6) - f4 | 0), 0 | A8;
                    }, Sb: function(A8, I7, g6, C4, B4, i4, n4, r4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0, B4 |= 0, i4 |= 0, n4 |= 0;
                      var f4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, D4 = 0, w4 = 0, h4 = 0;
                      A: {
                        I: {
                          g: {
                            C: {
                              B: {
                                Q: {
                                  i: {
                                    E: {
                                      o: {
                                        a: {
                                          n: {
                                            if (1 == (-7 & (r4 |= 0))) {
                                              if (e4 = 0, !C4)
                                                break E;
                                              if (4 & r4)
                                                break n;
                                              for (; ; ) {
                                                e4 = t4;
                                                r: {
                                                  f: {
                                                    t: {
                                                      e: {
                                                        for (; ; ) {
                                                          if (f4 = (f4 = (c4 = E3[g6 + e4 | 0]) - 65 | 0) & ((90 - c4 ^ -1) & (-1 ^ f4)) >>> 8 & 255 | c4 + 4 & ((c4 + 65488 ^ -1) & (57 - c4 ^ -1)) >>> 8 & 255 | c4 + 185 & ((c4 + 65439 ^ -1) & (122 - c4 ^ -1)) >>> 8 & 255 | (1 + (16336 ^ c4) ^ -1) >>> 8 & 63 | (1 + (16340 ^ c4) ^ -1) >>> 8 & 62, 255 != (0 | (f4 |= (f4 - 1 & 1 + (65470 ^ c4)) >>> 8 & 255)))
                                                            break e;
                                                          if (f4 = 0, !B4)
                                                            break o;
                                                          if (!$2(B4, c4))
                                                            break;
                                                          if ((e4 = e4 + 1 | 0) >>> 0 >= C4 >>> 0)
                                                            break t;
                                                        }
                                                        t4 = e4;
                                                        break o;
                                                      }
                                                      if (w4 = f4 + (w4 << 6) | 0, y4 >>> 0 > 1)
                                                        break f;
                                                      y4 = y4 + 6 | 0;
                                                      break r;
                                                    }
                                                    t4 = (A8 = t4 + 1 | 0) >>> 0 < C4 >>> 0 ? C4 : A8;
                                                    break o;
                                                  }
                                                  if (y4 = y4 - 2 | 0, I7 >>> 0 <= D4 >>> 0)
                                                    break a;
                                                  E3[A8 + D4 | 0] = w4 >>> y4, D4 = D4 + 1 | 0;
                                                }
                                                if (f4 = 0, !((t4 = e4 + 1 | 0) >>> 0 < C4 >>> 0))
                                                  break;
                                              }
                                              break o;
                                            }
                                            mA(), Q3();
                                          }
                                          n:
                                            for (; ; ) {
                                              for (e4 = t4; ; ) {
                                                r: {
                                                  if (f4 = (f4 = (c4 = E3[g6 + e4 | 0]) - 65 | 0) & ((90 - c4 ^ -1) & (-1 ^ f4)) >>> 8 & 255 | c4 + 4 & ((c4 + 65488 ^ -1) & (57 - c4 ^ -1)) >>> 8 & 255 | c4 + 185 & ((c4 + 65439 ^ -1) & (122 - c4 ^ -1)) >>> 8 & 255 | (1 + (16288 ^ c4) ^ -1) >>> 8 & 63 | (1 + (16338 ^ c4) ^ -1) >>> 8 & 62, 255 == (0 | (f4 |= (f4 - 1 & 1 + (65470 ^ c4)) >>> 8 & 255))) {
                                                    if (f4 = 0, !B4)
                                                      break o;
                                                    if ($2(B4, c4))
                                                      break r;
                                                    t4 = e4;
                                                    break o;
                                                  }
                                                  if (w4 = f4 + (w4 << 6) | 0, y4 >>> 0 < 2)
                                                    y4 = y4 + 6 | 0;
                                                  else {
                                                    if (y4 = y4 - 2 | 0, I7 >>> 0 <= D4 >>> 0)
                                                      break a;
                                                    E3[A8 + D4 | 0] = w4 >>> y4, D4 = D4 + 1 | 0;
                                                  }
                                                  if (f4 = 0, (t4 = e4 + 1 | 0) >>> 0 < C4 >>> 0)
                                                    continue n;
                                                  break o;
                                                }
                                                if (!((e4 = e4 + 1 | 0) >>> 0 < C4 >>> 0))
                                                  break;
                                              }
                                              break;
                                            }
                                          t4 = (A8 = t4 + 1 | 0) >>> 0 < C4 >>> 0 ? C4 : A8;
                                          break o;
                                        }
                                        t4 = e4, o3[8916] = 68, f4 = 1;
                                      }
                                      if (y4 >>> 0 > 4)
                                        break i;
                                      e4 = t4;
                                    }
                                    if (A8 = e4, I7 = -1, f4) {
                                      t4 = A8;
                                      break A;
                                    }
                                    if ((-1 << y4 ^ -1) & w4) {
                                      t4 = A8;
                                      break A;
                                    }
                                    if (2 & r4) {
                                      r4 = A8;
                                      break B;
                                    }
                                    if (y4 >>> 0 < 2) {
                                      r4 = A8;
                                      break B;
                                    }
                                    if (t4 = A8 >>> 0 > C4 >>> 0 ? A8 : C4, e4 = y4 >>> 1 | 0, !B4)
                                      break Q;
                                    for (r4 = A8; ; ) {
                                      if ((0 | r4) == (0 | t4)) {
                                        f4 = 68;
                                        break C;
                                      }
                                      if (61 != (0 | (A8 = E3[g6 + r4 | 0]))) {
                                        if (!$2(B4, A8)) {
                                          f4 = 28, t4 = r4;
                                          break C;
                                        }
                                      } else
                                        e4 = e4 - 1 | 0;
                                      if (r4 = r4 + 1 | 0, !e4)
                                        break;
                                    }
                                    break B;
                                  }
                                  I7 = -1;
                                  break A;
                                }
                                if (f4 = 68, A8 >>> 0 >= C4 >>> 0)
                                  break C;
                                if (61 != a3[A8 + g6 | 0]) {
                                  t4 = A8, f4 = 28;
                                  break C;
                                }
                                if (r4 = A8 + e4 | 0, 1 != (0 | e4)) {
                                  if ((0 | (y4 = A8 + 1 | 0)) == (0 | t4))
                                    break C;
                                  if (61 != a3[g6 + y4 | 0]) {
                                    t4 = y4, f4 = 28;
                                    break C;
                                  }
                                  if (2 != (0 | e4)) {
                                    if ((0 | (A8 = A8 + 2 | 0)) == (0 | t4))
                                      break C;
                                    if (f4 = 28, t4 = A8, 61 != a3[A8 + g6 | 0])
                                      break C;
                                  }
                                }
                              }
                              if (I7 = 0, B4)
                                break g;
                              break I;
                            }
                            o3[8916] = f4;
                            break A;
                          }
                          if (!(C4 >>> 0 <= r4 >>> 0)) {
                            for (; ; ) {
                              if (!$2(B4, E3[g6 + r4 | 0]))
                                break I;
                              if ((0 | (r4 = r4 + 1 | 0)) == (0 | C4))
                                break;
                            }
                            r4 = C4;
                          }
                        }
                        t4 = r4, h4 = D4;
                      }
                      return n4 ? o3[n4 >> 2] = g6 + t4 : (0 | C4) != (0 | t4) && (o3[8916] = 28, I7 = -1), i4 && (o3[i4 >> 2] = h4), 0 | I7;
                    }, Tb: function() {
                      var A8 = 0;
                      return o3[9049] ? A8 = 1 : (KA(), hA(36176, 16), o3[9049] = 1, A8 = 0), 0 | A8;
                    }, Ub: function(A8, I7, g6, C4, B4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, B4 |= 0;
                      var i4, n4 = 0, r4 = 0, f4 = 0;
                      D3 = i4 = D3 - 16 | 0;
                      A: {
                        if (C4 |= 0) {
                          if (f4 = -1, (n4 = (n4 = C4 - 1 | 0) - (r4 = n4 & C4 ? (g6 >>> 0) % (C4 >>> 0) | 0 : g6 & n4) | 0) >>> 0 >= (-1 ^ g6) >>> 0)
                            break A;
                          if (!((g6 = g6 + n4 | 0) >>> 0 >= B4 >>> 0))
                            for (A8 && (o3[A8 >> 2] = g6 + 1), A8 = I7 + g6 | 0, f4 = 0, E3[i4 + 15 | 0] = 0, g6 = 0; B4 = I7 = A8 - g6 | 0, r4 = a3[0 | I7] & a3[i4 + 15 | 0], I7 = (g6 ^ n4) - 1 >>> 24 | 0, E3[0 | B4] = r4 | 128 & I7, E3[i4 + 15 | 0] = I7 | a3[i4 + 15 | 0], (0 | C4) != (0 | (g6 = g6 + 1 | 0)); )
                              ;
                        } else
                          f4 = -1;
                        return D3 = i4 + 16 | 0, 0 | f4;
                      }
                      mA(), Q3();
                    }, Vb: function(A8, I7, g6, C4) {
                      A8 |= 0, I7 |= 0, g6 |= 0, C4 |= 0;
                      var B4, Q4 = 0, i4 = 0, E4 = 0, n4 = 0, r4 = 0;
                      if (o3[12 + (B4 = D3 - 16 | 0) >> 2] = 0, C4 - 1 >>> 0 < g6 >>> 0) {
                        for (r4 = (i4 = g6 - 1 | 0) + I7 | 0, g6 = 0, I7 = 0; I7 &= 255, n4 = (128 ^ (E4 = a3[r4 - Q4 | 0])) - 1 & o3[B4 + 12 >> 2] - 1 & I7 - 1, o3[B4 + 12 >> 2] = o3[B4 + 12 >> 2] | n4 << 23 >> 31 & Q4, I7 |= E4, g6 |= n4 >>> 8 & 1, (0 | (Q4 = Q4 + 1 | 0)) != (0 | C4); )
                          ;
                        o3[A8 >> 2] = i4 - o3[B4 + 12 >> 2], A8 = (255 & g6) - 1 | 0;
                      } else
                        A8 = -1;
                      return 0 | A8;
                    }, Wb: function() {
                      return 1312;
                    }, Xb: function() {
                      return 10;
                    }, Yb: iI, Zb: QI, _b: function(A8) {
                      var I7, g6 = 0, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, E4 = 0, r4 = 0, t4 = 0, e4 = 0, c4 = 0, y4 = 0, w4 = 0;
                      D3 = I7 = D3 - 16 | 0;
                      A: {
                        I: {
                          g: {
                            C: {
                              B: {
                                Q: {
                                  i: {
                                    E: {
                                      o: {
                                        if ((A8 |= 0) >>> 0 <= 244) {
                                          if (3 & (g6 = (E4 = o3[8917]) >>> (C4 = (r4 = A8 >>> 0 < 11 ? 16 : A8 + 11 & -8) >>> 3 | 0) | 0)) {
                                            g6 = 35708 + (A8 = (C4 = C4 + (1 & (-1 ^ g6)) | 0) << 3) | 0, B4 = o3[A8 + 35716 >> 2], (0 | g6) != (0 | (A8 = o3[B4 + 8 >> 2])) ? (o3[A8 + 12 >> 2] = g6, o3[g6 + 8 >> 2] = A8) : (y4 = 35668, w4 = YA(-2, C4) & E4, o3[y4 >> 2] = w4), A8 = B4 + 8 | 0, g6 = C4 << 3, o3[B4 + 4 >> 2] = 3 | g6, o3[4 + (g6 = g6 + B4 | 0) >> 2] = 1 | o3[g6 + 4 >> 2];
                                            break A;
                                          }
                                          if ((c4 = o3[8919]) >>> 0 >= r4 >>> 0)
                                            break o;
                                          if (g6) {
                                            g6 = 35708 + (A8 = (B4 = RA(0 - (A8 = (0 - (A8 = 2 << C4) | A8) & g6 << C4) & A8)) << 3) | 0, Q4 = o3[A8 + 35716 >> 2], (0 | g6) != (0 | (A8 = o3[Q4 + 8 >> 2])) ? (o3[A8 + 12 >> 2] = g6, o3[g6 + 8 >> 2] = A8) : (E4 = YA(-2, B4) & E4, o3[8917] = E4), o3[Q4 + 4 >> 2] = 3 | r4, B4 = (A8 = B4 << 3) - r4 | 0, o3[4 + (C4 = Q4 + r4 | 0) >> 2] = 1 | B4, o3[A8 + Q4 >> 2] = B4, c4 && (g6 = 35708 + (-8 & c4) | 0, i4 = o3[8922], (A8 = 1 << (c4 >>> 3)) & E4 ? A8 = o3[g6 + 8 >> 2] : (o3[8917] = A8 | E4, A8 = g6), o3[g6 + 8 >> 2] = i4, o3[A8 + 12 >> 2] = i4, o3[i4 + 12 >> 2] = g6, o3[i4 + 8 >> 2] = A8), A8 = Q4 + 8 | 0, o3[8922] = C4, o3[8919] = B4;
                                            break A;
                                          }
                                          if (!(e4 = o3[8918]))
                                            break o;
                                          for (C4 = o3[35972 + (RA(0 - e4 & e4) << 2) >> 2], i4 = (-8 & o3[C4 + 4 >> 2]) - r4 | 0, g6 = C4; (A8 = o3[g6 + 16 >> 2]) || (A8 = o3[g6 + 20 >> 2]); )
                                            i4 = (B4 = (g6 = (-8 & o3[A8 + 4 >> 2]) - r4 | 0) >>> 0 < i4 >>> 0) ? g6 : i4, C4 = B4 ? A8 : C4, g6 = A8;
                                          if (t4 = o3[C4 + 24 >> 2], (0 | (B4 = o3[C4 + 12 >> 2])) != (0 | C4)) {
                                            A8 = o3[C4 + 8 >> 2], o3[A8 + 12 >> 2] = B4, o3[B4 + 8 >> 2] = A8;
                                            break I;
                                          }
                                          if (!(A8 = o3[(g6 = C4 + 20 | 0) >> 2])) {
                                            if (!(A8 = o3[C4 + 16 >> 2]))
                                              break E;
                                            g6 = C4 + 16 | 0;
                                          }
                                          for (; Q4 = g6, B4 = A8, (A8 = o3[(g6 = A8 + 20 | 0) >> 2]) || (g6 = B4 + 16 | 0, A8 = o3[B4 + 16 >> 2]); )
                                            ;
                                          o3[Q4 >> 2] = 0;
                                          break I;
                                        }
                                        if (r4 = -1, !(A8 >>> 0 > 4294967231) && (r4 = -8 & (A8 = A8 + 11 | 0), e4 = o3[8918])) {
                                          i4 = 0 - r4 | 0, E4 = 0, r4 >>> 0 < 256 || (E4 = 31, r4 >>> 0 > 16777215 || (E4 = 62 + ((r4 >>> 38 - (A8 = f3(A8 >>> 8 | 0)) & 1) - (A8 << 1) | 0) | 0));
                                          a: {
                                            n: {
                                              if (g6 = o3[35972 + (E4 << 2) >> 2])
                                                for (A8 = 0, C4 = r4 << (31 != (0 | E4) ? 25 - (E4 >>> 1 | 0) | 0 : 0); ; ) {
                                                  if (!((Q4 = (-8 & o3[g6 + 4 >> 2]) - r4 | 0) >>> 0 >= i4 >>> 0 || (B4 = g6, i4 = Q4, Q4))) {
                                                    i4 = 0, A8 = g6;
                                                    break n;
                                                  }
                                                  if (Q4 = o3[g6 + 20 >> 2], g6 = o3[16 + ((C4 >>> 29 & 4) + g6 | 0) >> 2], A8 = Q4 ? (0 | Q4) == (0 | g6) ? A8 : Q4 : A8, C4 <<= 1, !g6)
                                                    break;
                                                }
                                              else
                                                A8 = 0;
                                              if (!(A8 | B4)) {
                                                if (B4 = 0, !(A8 = (0 - (A8 = 2 << E4) | A8) & e4))
                                                  break o;
                                                A8 = o3[35972 + (RA(A8 & 0 - A8) << 2) >> 2];
                                              }
                                              if (!A8)
                                                break a;
                                            }
                                            for (; i4 = (C4 = (g6 = (-8 & o3[A8 + 4 >> 2]) - r4 | 0) >>> 0 < i4 >>> 0) ? g6 : i4, B4 = C4 ? A8 : B4, A8 = (g6 = o3[A8 + 16 >> 2]) || o3[A8 + 20 >> 2]; )
                                              ;
                                          }
                                          if (!(!B4 | o3[8919] - r4 >>> 0 <= i4 >>> 0)) {
                                            if (E4 = o3[B4 + 24 >> 2], (0 | B4) != (0 | (C4 = o3[B4 + 12 >> 2]))) {
                                              A8 = o3[B4 + 8 >> 2], o3[A8 + 12 >> 2] = C4, o3[C4 + 8 >> 2] = A8;
                                              break g;
                                            }
                                            if (!(A8 = o3[(g6 = B4 + 20 | 0) >> 2])) {
                                              if (!(A8 = o3[B4 + 16 >> 2]))
                                                break i;
                                              g6 = B4 + 16 | 0;
                                            }
                                            for (; Q4 = g6, C4 = A8, (A8 = o3[(g6 = A8 + 20 | 0) >> 2]) || (g6 = C4 + 16 | 0, A8 = o3[C4 + 16 >> 2]); )
                                              ;
                                            o3[Q4 >> 2] = 0;
                                            break g;
                                          }
                                        }
                                      }
                                      if ((A8 = o3[8919]) >>> 0 >= r4 >>> 0) {
                                        B4 = o3[8922], (g6 = A8 - r4 | 0) >>> 0 >= 16 ? (o3[4 + (C4 = B4 + r4 | 0) >> 2] = 1 | g6, o3[A8 + B4 >> 2] = g6, o3[B4 + 4 >> 2] = 3 | r4) : (o3[B4 + 4 >> 2] = 3 | A8, o3[4 + (A8 = A8 + B4 | 0) >> 2] = 1 | o3[A8 + 4 >> 2], C4 = 0, g6 = 0), o3[8919] = g6, o3[8922] = C4, A8 = B4 + 8 | 0;
                                        break A;
                                      }
                                      if ((t4 = o3[8920]) >>> 0 > r4 >>> 0) {
                                        g6 = t4 - r4 | 0, o3[8920] = g6, A8 = (C4 = o3[8923]) + r4 | 0, o3[8923] = A8, o3[A8 + 4 >> 2] = 1 | g6, o3[C4 + 4 >> 2] = 3 | r4, A8 = C4 + 8 | 0;
                                        break A;
                                      }
                                      if (A8 = 0, e4 = r4 + 47 | 0, o3[9035] ? C4 = o3[9037] : (o3[9038] = -1, o3[9039] = -1, o3[9036] = 4096, o3[9037] = 4096, o3[9035] = I7 + 12 & -16 ^ 1431655768, o3[9040] = 0, o3[9028] = 0, C4 = 4096), (g6 = (Q4 = e4 + C4 | 0) & (i4 = 0 - C4 | 0)) >>> 0 <= r4 >>> 0)
                                        break A;
                                      if ((B4 = o3[9027]) && B4 >>> 0 < (E4 = (C4 = o3[9025]) + g6 | 0) >>> 0 | C4 >>> 0 >= E4 >>> 0)
                                        break A;
                                      o: {
                                        if (!(4 & a3[36112])) {
                                          a: {
                                            n: {
                                              r: {
                                                f: {
                                                  if (B4 = o3[8923])
                                                    for (A8 = 36116; ; ) {
                                                      if ((C4 = o3[A8 >> 2]) >>> 0 <= B4 >>> 0 & B4 >>> 0 < C4 + o3[A8 + 4 >> 2] >>> 0)
                                                        break f;
                                                      if (!(A8 = o3[A8 + 8 >> 2]))
                                                        break;
                                                    }
                                                  if (-1 == (0 | (C4 = pA(0))))
                                                    break a;
                                                  if (E4 = g6, (A8 = (B4 = o3[9036]) - 1 | 0) & C4 && (E4 = (g6 - C4 | 0) + (A8 + C4 & 0 - B4) | 0), E4 >>> 0 <= r4 >>> 0)
                                                    break a;
                                                  if ((B4 = o3[9027]) && B4 >>> 0 < (i4 = (A8 = o3[9025]) + E4 | 0) >>> 0 | A8 >>> 0 >= i4 >>> 0)
                                                    break a;
                                                  if ((0 | C4) != (0 | (A8 = pA(E4))))
                                                    break r;
                                                  break o;
                                                }
                                                if ((0 | (C4 = pA(E4 = i4 & Q4 - t4))) == (o3[A8 >> 2] + o3[A8 + 4 >> 2] | 0))
                                                  break n;
                                                A8 = C4;
                                              }
                                              if (-1 == (0 | A8))
                                                break a;
                                              if (r4 + 48 >>> 0 <= E4 >>> 0) {
                                                C4 = A8;
                                                break o;
                                              }
                                              if (-1 == (0 | pA(C4 = (C4 = o3[9037]) + (e4 - E4 | 0) & 0 - C4)))
                                                break a;
                                              E4 = C4 + E4 | 0, C4 = A8;
                                              break o;
                                            }
                                            if (-1 != (0 | C4))
                                              break o;
                                          }
                                          o3[9028] = 4 | o3[9028];
                                        }
                                        if (-1 == (0 | (C4 = pA(g6))) | -1 == (0 | (A8 = pA(0))) | A8 >>> 0 <= C4 >>> 0)
                                          break C;
                                        if ((E4 = A8 - C4 | 0) >>> 0 <= r4 + 40 >>> 0)
                                          break C;
                                      }
                                      A8 = o3[9025] + E4 | 0, o3[9025] = A8, A8 >>> 0 > n3[9026] && (o3[9026] = A8);
                                      o: {
                                        if (Q4 = o3[8923]) {
                                          for (A8 = 36116; ; ) {
                                            if (((B4 = o3[A8 >> 2]) + (g6 = o3[A8 + 4 >> 2]) | 0) == (0 | C4))
                                              break o;
                                            if (!(A8 = o3[A8 + 8 >> 2]))
                                              break;
                                          }
                                          break Q;
                                        }
                                        for ((A8 = o3[8921]) >>> 0 <= C4 >>> 0 && A8 || (o3[8921] = C4), A8 = 0, o3[9030] = E4, o3[9029] = C4, o3[8925] = -1, o3[8926] = o3[9035], o3[9032] = 0; g6 = 35708 + (B4 = A8 << 3) | 0, o3[B4 + 35716 >> 2] = g6, o3[B4 + 35720 >> 2] = g6, 32 != (0 | (A8 = A8 + 1 | 0)); )
                                          ;
                                        g6 = (B4 = E4 - 40 | 0) - (A8 = C4 + 8 & 7 ? -8 - C4 & 7 : 0) | 0, o3[8920] = g6, A8 = A8 + C4 | 0, o3[8923] = A8, o3[A8 + 4 >> 2] = 1 | g6, o3[4 + (C4 + B4 | 0) >> 2] = 40, o3[8924] = o3[9039];
                                        break B;
                                      }
                                      if (8 & a3[A8 + 12 | 0] | B4 >>> 0 > Q4 >>> 0 | C4 >>> 0 <= Q4 >>> 0)
                                        break Q;
                                      o3[A8 + 4 >> 2] = g6 + E4, C4 = (A8 = Q4 + 8 & 7 ? -8 - Q4 & 7 : 0) + Q4 | 0, o3[8923] = C4, A8 = (g6 = o3[8920] + E4 | 0) - A8 | 0, o3[8920] = A8, o3[C4 + 4 >> 2] = 1 | A8, o3[4 + (g6 + Q4 | 0) >> 2] = 40, o3[8924] = o3[9039];
                                      break B;
                                    }
                                    B4 = 0;
                                    break I;
                                  }
                                  C4 = 0;
                                  break g;
                                }
                                n3[8921] > C4 >>> 0 && (o3[8921] = C4), g6 = C4 + E4 | 0, A8 = 36116;
                                Q: {
                                  i: {
                                    E: {
                                      o: {
                                        a: {
                                          n: {
                                            for (; ; ) {
                                              if ((0 | g6) != o3[A8 >> 2]) {
                                                if (A8 = o3[A8 + 8 >> 2])
                                                  continue;
                                                break n;
                                              }
                                              break;
                                            }
                                            if (!(8 & a3[A8 + 12 | 0]))
                                              break a;
                                          }
                                          for (A8 = 36116; ; ) {
                                            if ((g6 = o3[A8 >> 2]) >>> 0 <= Q4 >>> 0 && (i4 = g6 + o3[A8 + 4 >> 2] | 0) >>> 0 > Q4 >>> 0)
                                              break o;
                                            A8 = o3[A8 + 8 >> 2];
                                          }
                                        }
                                        if (o3[A8 >> 2] = C4, o3[A8 + 4 >> 2] = o3[A8 + 4 >> 2] + E4, o3[4 + (e4 = (C4 + 8 & 7 ? -8 - C4 & 7 : 0) + C4 | 0) >> 2] = 3 | r4, A8 = (E4 = g6 + (g6 + 8 & 7 ? -8 - g6 & 7 : 0) | 0) - (t4 = r4 + e4 | 0) | 0, (0 | Q4) == (0 | E4)) {
                                          o3[8923] = t4, A8 = o3[8920] + A8 | 0, o3[8920] = A8, o3[t4 + 4 >> 2] = 1 | A8;
                                          break i;
                                        }
                                        if (o3[8922] == (0 | E4)) {
                                          o3[8922] = t4, A8 = o3[8919] + A8 | 0, o3[8919] = A8, o3[t4 + 4 >> 2] = 1 | A8, o3[A8 + t4 >> 2] = A8;
                                          break i;
                                        }
                                        if (1 == (3 & (i4 = o3[E4 + 4 >> 2]))) {
                                          Q4 = -8 & i4;
                                          a:
                                            if (i4 >>> 0 <= 255) {
                                              if (B4 = o3[E4 + 8 >> 2], g6 = i4 >>> 3 | 0, (0 | (C4 = o3[E4 + 12 >> 2])) == (0 | B4)) {
                                                y4 = 35668, w4 = o3[8917] & YA(-2, g6), o3[y4 >> 2] = w4;
                                                break a;
                                              }
                                              o3[B4 + 12 >> 2] = C4, o3[C4 + 8 >> 2] = B4;
                                            } else {
                                              if (r4 = o3[E4 + 24 >> 2], (0 | E4) == (0 | (C4 = o3[E4 + 12 >> 2])))
                                                if ((g6 = o3[(i4 = E4 + 20 | 0) >> 2]) || (g6 = o3[(i4 = E4 + 16 | 0) >> 2])) {
                                                  for (; B4 = i4, (g6 = o3[(i4 = (C4 = g6) + 20 | 0) >> 2]) || (i4 = C4 + 16 | 0, g6 = o3[C4 + 16 >> 2]); )
                                                    ;
                                                  o3[B4 >> 2] = 0;
                                                } else
                                                  C4 = 0;
                                              else
                                                g6 = o3[E4 + 8 >> 2], o3[g6 + 12 >> 2] = C4, o3[C4 + 8 >> 2] = g6;
                                              if (r4) {
                                                B4 = o3[E4 + 28 >> 2];
                                                n: {
                                                  if (o3[(g6 = 35972 + (B4 << 2) | 0) >> 2] == (0 | E4)) {
                                                    if (o3[g6 >> 2] = C4, C4)
                                                      break n;
                                                    y4 = 35672, w4 = o3[8918] & YA(-2, B4), o3[y4 >> 2] = w4;
                                                    break a;
                                                  }
                                                  if (o3[r4 + (o3[r4 + 16 >> 2] == (0 | E4) ? 16 : 20) >> 2] = C4, !C4)
                                                    break a;
                                                }
                                                o3[C4 + 24 >> 2] = r4, (g6 = o3[E4 + 16 >> 2]) && (o3[C4 + 16 >> 2] = g6, o3[g6 + 24 >> 2] = C4), (g6 = o3[E4 + 20 >> 2]) && (o3[C4 + 20 >> 2] = g6, o3[g6 + 24 >> 2] = C4);
                                              }
                                            }
                                          i4 = o3[4 + (E4 = Q4 + E4 | 0) >> 2], A8 = A8 + Q4 | 0;
                                        }
                                        if (o3[E4 + 4 >> 2] = -2 & i4, o3[t4 + 4 >> 2] = 1 | A8, o3[A8 + t4 >> 2] = A8, A8 >>> 0 <= 255) {
                                          g6 = 35708 + (-8 & A8) | 0, (C4 = o3[8917]) & (A8 = 1 << (A8 >>> 3)) ? A8 = o3[g6 + 8 >> 2] : (o3[8917] = A8 | C4, A8 = g6), o3[g6 + 8 >> 2] = t4, o3[A8 + 12 >> 2] = t4, o3[t4 + 12 >> 2] = g6, o3[t4 + 8 >> 2] = A8;
                                          break i;
                                        }
                                        if (i4 = 31, A8 >>> 0 <= 16777215 && (i4 = 62 + ((A8 >>> 38 - (g6 = f3(A8 >>> 8 | 0)) & 1) - (g6 << 1) | 0) | 0), o3[t4 + 28 >> 2] = i4, o3[t4 + 16 >> 2] = 0, o3[t4 + 20 >> 2] = 0, g6 = 35972 + (i4 << 2) | 0, (B4 = o3[8918]) & (C4 = 1 << i4)) {
                                          for (i4 = A8 << (31 != (0 | i4) ? 25 - (i4 >>> 1 | 0) | 0 : 0), C4 = o3[g6 >> 2]; ; ) {
                                            if (g6 = C4, (-8 & o3[C4 + 4 >> 2]) == (0 | A8))
                                              break E;
                                            if (C4 = i4 >>> 29 | 0, i4 <<= 1, !(C4 = o3[16 + (B4 = (4 & C4) + g6 | 0) >> 2]))
                                              break;
                                          }
                                          o3[B4 + 16 >> 2] = t4;
                                        } else
                                          o3[8918] = C4 | B4, o3[g6 >> 2] = t4;
                                        o3[t4 + 24 >> 2] = g6, o3[t4 + 12 >> 2] = t4, o3[t4 + 8 >> 2] = t4;
                                        break i;
                                      }
                                      for (g6 = (B4 = E4 - 40 | 0) - (A8 = C4 + 8 & 7 ? -8 - C4 & 7 : 0) | 0, o3[8920] = g6, A8 = A8 + C4 | 0, o3[8923] = A8, o3[A8 + 4 >> 2] = 1 | g6, o3[4 + (C4 + B4 | 0) >> 2] = 40, o3[8924] = o3[9039], o3[(B4 = (A8 = (i4 + (i4 - 39 & 7 ? 39 - i4 & 7 : 0) | 0) - 47 | 0) >>> 0 < Q4 + 16 >>> 0 ? Q4 : A8) + 4 >> 2] = 27, A8 = o3[9032], o3[B4 + 16 >> 2] = o3[9031], o3[B4 + 20 >> 2] = A8, A8 = o3[9030], o3[B4 + 8 >> 2] = o3[9029], o3[B4 + 12 >> 2] = A8, o3[9031] = B4 + 8, o3[9030] = E4, o3[9029] = C4, o3[9032] = 0, A8 = B4 + 24 | 0; o3[A8 + 4 >> 2] = 7, g6 = A8 + 8 | 0, A8 = A8 + 4 | 0, g6 >>> 0 < i4 >>> 0; )
                                        ;
                                      if ((0 | B4) == (0 | Q4))
                                        break B;
                                      if (o3[B4 + 4 >> 2] = -2 & o3[B4 + 4 >> 2], i4 = B4 - Q4 | 0, o3[Q4 + 4 >> 2] = 1 | i4, o3[B4 >> 2] = i4, i4 >>> 0 <= 255) {
                                        g6 = 35708 + (-8 & i4) | 0, (C4 = o3[8917]) & (A8 = 1 << (i4 >>> 3)) ? A8 = o3[g6 + 8 >> 2] : (o3[8917] = A8 | C4, A8 = g6), o3[g6 + 8 >> 2] = Q4, o3[A8 + 12 >> 2] = Q4, o3[Q4 + 12 >> 2] = g6, o3[Q4 + 8 >> 2] = A8;
                                        break B;
                                      }
                                      if (A8 = 31, i4 >>> 0 <= 16777215 && (A8 = 62 + ((i4 >>> 38 - (A8 = f3(i4 >>> 8 | 0)) & 1) - (A8 << 1) | 0) | 0), o3[Q4 + 28 >> 2] = A8, o3[Q4 + 16 >> 2] = 0, o3[Q4 + 20 >> 2] = 0, g6 = 35972 + (A8 << 2) | 0, (B4 = o3[8918]) & (C4 = 1 << A8)) {
                                        for (A8 = i4 << (31 != (0 | A8) ? 25 - (A8 >>> 1 | 0) | 0 : 0), B4 = o3[g6 >> 2]; ; ) {
                                          if ((0 | i4) == (-8 & o3[(g6 = B4) + 4 >> 2]))
                                            break Q;
                                          if (C4 = A8 >>> 29 | 0, A8 <<= 1, !(B4 = o3[16 + (C4 = (4 & C4) + g6 | 0) >> 2]))
                                            break;
                                        }
                                        o3[C4 + 16 >> 2] = Q4;
                                      } else
                                        o3[8918] = C4 | B4, o3[g6 >> 2] = Q4;
                                      o3[Q4 + 24 >> 2] = g6, o3[Q4 + 12 >> 2] = Q4, o3[Q4 + 8 >> 2] = Q4;
                                      break B;
                                    }
                                    A8 = o3[g6 + 8 >> 2], o3[A8 + 12 >> 2] = t4, o3[g6 + 8 >> 2] = t4, o3[t4 + 24 >> 2] = 0, o3[t4 + 12 >> 2] = g6, o3[t4 + 8 >> 2] = A8;
                                  }
                                  A8 = e4 + 8 | 0;
                                  break A;
                                }
                                A8 = o3[g6 + 8 >> 2], o3[A8 + 12 >> 2] = Q4, o3[g6 + 8 >> 2] = Q4, o3[Q4 + 24 >> 2] = 0, o3[Q4 + 12 >> 2] = g6, o3[Q4 + 8 >> 2] = A8;
                              }
                              if (!((A8 = o3[8920]) >>> 0 <= r4 >>> 0)) {
                                g6 = A8 - r4 | 0, o3[8920] = g6, A8 = (C4 = o3[8923]) + r4 | 0, o3[8923] = A8, o3[A8 + 4 >> 2] = 1 | g6, o3[C4 + 4 >> 2] = 3 | r4, A8 = C4 + 8 | 0;
                                break A;
                              }
                            }
                            o3[8916] = 48, A8 = 0;
                            break A;
                          }
                          g:
                            if (E4) {
                              g6 = o3[B4 + 28 >> 2];
                              C: {
                                if (o3[(A8 = 35972 + (g6 << 2) | 0) >> 2] == (0 | B4)) {
                                  if (o3[A8 >> 2] = C4, C4)
                                    break C;
                                  e4 = YA(-2, g6) & e4, o3[8918] = e4;
                                  break g;
                                }
                                if (o3[E4 + (o3[E4 + 16 >> 2] == (0 | B4) ? 16 : 20) >> 2] = C4, !C4)
                                  break g;
                              }
                              o3[C4 + 24 >> 2] = E4, (A8 = o3[B4 + 16 >> 2]) && (o3[C4 + 16 >> 2] = A8, o3[A8 + 24 >> 2] = C4), (A8 = o3[B4 + 20 >> 2]) && (o3[C4 + 20 >> 2] = A8, o3[A8 + 24 >> 2] = C4);
                            }
                          g:
                            if (i4 >>> 0 <= 15)
                              A8 = i4 + r4 | 0, o3[B4 + 4 >> 2] = 3 | A8, o3[4 + (A8 = A8 + B4 | 0) >> 2] = 1 | o3[A8 + 4 >> 2];
                            else if (o3[B4 + 4 >> 2] = 3 | r4, o3[4 + (Q4 = B4 + r4 | 0) >> 2] = 1 | i4, o3[Q4 + i4 >> 2] = i4, i4 >>> 0 <= 255)
                              g6 = 35708 + (-8 & i4) | 0, (C4 = o3[8917]) & (A8 = 1 << (i4 >>> 3)) ? A8 = o3[g6 + 8 >> 2] : (o3[8917] = A8 | C4, A8 = g6), o3[g6 + 8 >> 2] = Q4, o3[A8 + 12 >> 2] = Q4, o3[Q4 + 12 >> 2] = g6, o3[Q4 + 8 >> 2] = A8;
                            else {
                              A8 = 31, i4 >>> 0 <= 16777215 && (A8 = 62 + ((i4 >>> 38 - (A8 = f3(i4 >>> 8 | 0)) & 1) - (A8 << 1) | 0) | 0), o3[Q4 + 28 >> 2] = A8, o3[Q4 + 16 >> 2] = 0, o3[Q4 + 20 >> 2] = 0, g6 = 35972 + (A8 << 2) | 0;
                              C: {
                                if ((C4 = 1 << A8) & e4) {
                                  for (A8 = i4 << (31 != (0 | A8) ? 25 - (A8 >>> 1 | 0) | 0 : 0), r4 = o3[g6 >> 2]; ; ) {
                                    if ((-8 & o3[(g6 = r4) + 4 >> 2]) == (0 | i4))
                                      break C;
                                    if (C4 = A8 >>> 29 | 0, A8 <<= 1, !(r4 = o3[16 + (C4 = (4 & C4) + g6 | 0) >> 2]))
                                      break;
                                  }
                                  o3[C4 + 16 >> 2] = Q4;
                                } else
                                  o3[8918] = C4 | e4, o3[g6 >> 2] = Q4;
                                o3[Q4 + 24 >> 2] = g6, o3[Q4 + 12 >> 2] = Q4, o3[Q4 + 8 >> 2] = Q4;
                                break g;
                              }
                              A8 = o3[g6 + 8 >> 2], o3[A8 + 12 >> 2] = Q4, o3[g6 + 8 >> 2] = Q4, o3[Q4 + 24 >> 2] = 0, o3[Q4 + 12 >> 2] = g6, o3[Q4 + 8 >> 2] = A8;
                            }
                          A8 = B4 + 8 | 0;
                          break A;
                        }
                        I:
                          if (t4) {
                            g6 = o3[C4 + 28 >> 2];
                            g: {
                              if (o3[(A8 = 35972 + (g6 << 2) | 0) >> 2] == (0 | C4)) {
                                if (o3[A8 >> 2] = B4, B4)
                                  break g;
                                y4 = 35672, w4 = YA(-2, g6) & e4, o3[y4 >> 2] = w4;
                                break I;
                              }
                              if (o3[t4 + (o3[t4 + 16 >> 2] == (0 | C4) ? 16 : 20) >> 2] = B4, !B4)
                                break I;
                            }
                            o3[B4 + 24 >> 2] = t4, (A8 = o3[C4 + 16 >> 2]) && (o3[B4 + 16 >> 2] = A8, o3[A8 + 24 >> 2] = B4), (A8 = o3[C4 + 20 >> 2]) && (o3[B4 + 20 >> 2] = A8, o3[A8 + 24 >> 2] = B4);
                          }
                        i4 >>> 0 <= 15 ? (A8 = i4 + r4 | 0, o3[C4 + 4 >> 2] = 3 | A8, o3[4 + (A8 = A8 + C4 | 0) >> 2] = 1 | o3[A8 + 4 >> 2]) : (o3[C4 + 4 >> 2] = 3 | r4, o3[4 + (B4 = C4 + r4 | 0) >> 2] = 1 | i4, o3[B4 + i4 >> 2] = i4, c4 && (g6 = 35708 + (-8 & c4) | 0, Q4 = o3[8922], (A8 = 1 << (c4 >>> 3)) & E4 ? A8 = o3[g6 + 8 >> 2] : (o3[8917] = A8 | E4, A8 = g6), o3[g6 + 8 >> 2] = Q4, o3[A8 + 12 >> 2] = Q4, o3[Q4 + 12 >> 2] = g6, o3[Q4 + 8 >> 2] = A8), o3[8922] = B4, o3[8919] = i4), A8 = C4 + 8 | 0;
                      }
                      return D3 = I7 + 16 | 0, 0 | A8;
                    }, $b: function(A8) {
                      var I7 = 0, g6 = 0, C4 = 0, B4 = 0, Q4 = 0, i4 = 0, E4 = 0, a4 = 0, r4 = 0;
                      A:
                        if (A8 |= 0) {
                          Q4 = (C4 = A8 - 8 | 0) + (A8 = -8 & (I7 = o3[A8 - 4 >> 2])) | 0;
                          I:
                            if (!(1 & I7)) {
                              if (!(3 & I7))
                                break A;
                              if ((C4 = C4 - (I7 = o3[C4 >> 2]) | 0) >>> 0 < n3[8921])
                                break A;
                              if (A8 = A8 + I7 | 0, o3[8922] == (0 | C4)) {
                                if (3 == (3 & (I7 = o3[Q4 + 4 >> 2])))
                                  return o3[8919] = A8, o3[Q4 + 4 >> 2] = -2 & I7, o3[C4 + 4 >> 2] = 1 | A8, void (o3[A8 + C4 >> 2] = A8);
                              } else {
                                if (I7 >>> 0 <= 255) {
                                  if (B4 = o3[C4 + 8 >> 2], I7 = I7 >>> 3 | 0, (0 | (g6 = o3[C4 + 12 >> 2])) == (0 | B4)) {
                                    a4 = 35668, r4 = o3[8917] & YA(-2, I7), o3[a4 >> 2] = r4;
                                    break I;
                                  }
                                  o3[B4 + 12 >> 2] = g6, o3[g6 + 8 >> 2] = B4;
                                  break I;
                                }
                                if (E4 = o3[C4 + 24 >> 2], (0 | C4) == (0 | (I7 = o3[C4 + 12 >> 2])))
                                  if ((g6 = o3[(B4 = C4 + 20 | 0) >> 2]) || (g6 = o3[(B4 = C4 + 16 | 0) >> 2])) {
                                    for (; i4 = B4, (g6 = o3[(B4 = (I7 = g6) + 20 | 0) >> 2]) || (B4 = I7 + 16 | 0, g6 = o3[I7 + 16 >> 2]); )
                                      ;
                                    o3[i4 >> 2] = 0;
                                  } else
                                    I7 = 0;
                                else
                                  g6 = o3[C4 + 8 >> 2], o3[g6 + 12 >> 2] = I7, o3[I7 + 8 >> 2] = g6;
                                if (!E4)
                                  break I;
                                B4 = o3[C4 + 28 >> 2];
                                g: {
                                  if (o3[(g6 = 35972 + (B4 << 2) | 0) >> 2] == (0 | C4)) {
                                    if (o3[g6 >> 2] = I7, I7)
                                      break g;
                                    a4 = 35672, r4 = o3[8918] & YA(-2, B4), o3[a4 >> 2] = r4;
                                    break I;
                                  }
                                  if (o3[E4 + (o3[E4 + 16 >> 2] == (0 | C4) ? 16 : 20) >> 2] = I7, !I7)
                                    break I;
                                }
                                if (o3[I7 + 24 >> 2] = E4, (g6 = o3[C4 + 16 >> 2]) && (o3[I7 + 16 >> 2] = g6, o3[g6 + 24 >> 2] = I7), !(g6 = o3[C4 + 20 >> 2]))
                                  break I;
                                o3[I7 + 20 >> 2] = g6, o3[g6 + 24 >> 2] = I7;
                              }
                            }
                          if (!(C4 >>> 0 >= Q4 >>> 0) && 1 & (I7 = o3[Q4 + 4 >> 2])) {
                            I: {
                              if (!(2 & I7)) {
                                if (o3[8923] == (0 | Q4)) {
                                  if (o3[8923] = C4, A8 = o3[8920] + A8 | 0, o3[8920] = A8, o3[C4 + 4 >> 2] = 1 | A8, o3[8922] != (0 | C4))
                                    break A;
                                  return o3[8919] = 0, void (o3[8922] = 0);
                                }
                                if (o3[8922] == (0 | Q4))
                                  return o3[8922] = C4, A8 = o3[8919] + A8 | 0, o3[8919] = A8, o3[C4 + 4 >> 2] = 1 | A8, void (o3[A8 + C4 >> 2] = A8);
                                A8 = (-8 & I7) + A8 | 0;
                                g:
                                  if (I7 >>> 0 <= 255) {
                                    if (B4 = o3[Q4 + 8 >> 2], I7 = I7 >>> 3 | 0, (0 | (g6 = o3[Q4 + 12 >> 2])) == (0 | B4)) {
                                      a4 = 35668, r4 = o3[8917] & YA(-2, I7), o3[a4 >> 2] = r4;
                                      break g;
                                    }
                                    o3[B4 + 12 >> 2] = g6, o3[g6 + 8 >> 2] = B4;
                                  } else {
                                    if (E4 = o3[Q4 + 24 >> 2], (0 | Q4) == (0 | (I7 = o3[Q4 + 12 >> 2])))
                                      if ((g6 = o3[(B4 = Q4 + 20 | 0) >> 2]) || (g6 = o3[(B4 = Q4 + 16 | 0) >> 2])) {
                                        for (; i4 = B4, (g6 = o3[(B4 = (I7 = g6) + 20 | 0) >> 2]) || (B4 = I7 + 16 | 0, g6 = o3[I7 + 16 >> 2]); )
                                          ;
                                        o3[i4 >> 2] = 0;
                                      } else
                                        I7 = 0;
                                    else
                                      g6 = o3[Q4 + 8 >> 2], o3[g6 + 12 >> 2] = I7, o3[I7 + 8 >> 2] = g6;
                                    if (E4) {
                                      B4 = o3[Q4 + 28 >> 2];
                                      C: {
                                        if (o3[(g6 = 35972 + (B4 << 2) | 0) >> 2] == (0 | Q4)) {
                                          if (o3[g6 >> 2] = I7, I7)
                                            break C;
                                          a4 = 35672, r4 = o3[8918] & YA(-2, B4), o3[a4 >> 2] = r4;
                                          break g;
                                        }
                                        if (o3[E4 + (o3[E4 + 16 >> 2] == (0 | Q4) ? 16 : 20) >> 2] = I7, !I7)
                                          break g;
                                      }
                                      o3[I7 + 24 >> 2] = E4, (g6 = o3[Q4 + 16 >> 2]) && (o3[I7 + 16 >> 2] = g6, o3[g6 + 24 >> 2] = I7), (g6 = o3[Q4 + 20 >> 2]) && (o3[I7 + 20 >> 2] = g6, o3[g6 + 24 >> 2] = I7);
                                    }
                                  }
                                if (o3[C4 + 4 >> 2] = 1 | A8, o3[A8 + C4 >> 2] = A8, o3[8922] != (0 | C4))
                                  break I;
                                return void (o3[8919] = A8);
                              }
                              o3[Q4 + 4 >> 2] = -2 & I7, o3[C4 + 4 >> 2] = 1 | A8, o3[A8 + C4 >> 2] = A8;
                            }
                            if (A8 >>> 0 <= 255)
                              return I7 = 35708 + (-8 & A8) | 0, (g6 = o3[8917]) & (A8 = 1 << (A8 >>> 3)) ? A8 = o3[I7 + 8 >> 2] : (o3[8917] = A8 | g6, A8 = I7), o3[I7 + 8 >> 2] = C4, o3[A8 + 12 >> 2] = C4, o3[C4 + 12 >> 2] = I7, void (o3[C4 + 8 >> 2] = A8);
                            B4 = 31, A8 >>> 0 <= 16777215 && (B4 = 62 + ((A8 >>> 38 - (I7 = f3(A8 >>> 8 | 0)) & 1) - (I7 << 1) | 0) | 0), o3[C4 + 28 >> 2] = B4, o3[C4 + 16 >> 2] = 0, o3[C4 + 20 >> 2] = 0, i4 = 35972 + (B4 << 2) | 0;
                            I: {
                              g: {
                                if ((g6 = o3[8918]) & (I7 = 1 << B4)) {
                                  for (B4 = A8 << (31 != (0 | B4) ? 25 - (B4 >>> 1 | 0) | 0 : 0), I7 = o3[i4 >> 2]; ; ) {
                                    if (g6 = I7, (-8 & o3[I7 + 4 >> 2]) == (0 | A8))
                                      break g;
                                    if (I7 = B4 >>> 29 | 0, B4 <<= 1, !(I7 = o3[16 + (i4 = g6 + (4 & I7) | 0) >> 2]))
                                      break;
                                  }
                                  o3[i4 + 16 >> 2] = C4, o3[C4 + 24 >> 2] = g6;
                                } else
                                  o3[8918] = I7 | g6, o3[i4 >> 2] = C4, o3[C4 + 24 >> 2] = i4;
                                o3[C4 + 12 >> 2] = C4, o3[C4 + 8 >> 2] = C4;
                                break I;
                              }
                              A8 = o3[g6 + 8 >> 2], o3[A8 + 12 >> 2] = C4, o3[g6 + 8 >> 2] = C4, o3[C4 + 24 >> 2] = 0, o3[C4 + 12 >> 2] = g6, o3[C4 + 8 >> 2] = A8;
                            }
                            A8 = o3[8925] - 1 | 0, o3[8925] = A8 || -1;
                          }
                        }
                    }, ac: nI };
                  }(A6);
                }(I5);
              }, instantiate: function(A5, I5) {
                return { then: function(g4) {
                  var C2 = new D2.Module(A5);
                  g4({ instance: new D2.Instance(C2, I5) });
                } };
              }, RuntimeError: Error };
              e2 = [], "object" != typeof D2 && K2("no native wasm support detected");
              var w2, h2, s2, p2, u2, k2, F2, l2 = false, S2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
              function H2(A5, I5) {
                return A5 ? function(A6, I6, g4) {
                  for (var C2 = I6 + g4, B3 = I6; A6[B3] && !(B3 >= C2); )
                    ++B3;
                  if (B3 - I6 > 16 && A6.buffer && S2)
                    return S2.decode(A6.subarray(I6, B3));
                  for (var Q3 = ""; I6 < B3; ) {
                    var i3 = A6[I6++];
                    if (128 & i3) {
                      var E3 = 63 & A6[I6++];
                      if (192 != (224 & i3)) {
                        var o3 = 63 & A6[I6++];
                        if ((i3 = 224 == (240 & i3) ? (15 & i3) << 12 | E3 << 6 | o3 : (7 & i3) << 18 | E3 << 12 | o3 << 6 | 63 & A6[I6++]) < 65536)
                          Q3 += String.fromCharCode(i3);
                        else {
                          var a3 = i3 - 65536;
                          Q3 += String.fromCharCode(55296 | a3 >> 10, 56320 | 1023 & a3);
                        }
                      } else
                        Q3 += String.fromCharCode((31 & i3) << 6 | E3);
                    } else
                      Q3 += String.fromCharCode(i3);
                  }
                  return Q3;
                }(h2, A5, I5) : "";
              }
              function M2() {
                var A5 = y2.buffer;
                i2.HEAP8 = w2 = new Int8Array(A5), i2.HEAP16 = s2 = new Int16Array(A5), i2.HEAP32 = p2 = new Int32Array(A5), i2.HEAPU8 = h2 = new Uint8Array(A5), i2.HEAPU16 = new Uint16Array(A5), i2.HEAPU32 = u2 = new Uint32Array(A5), i2.HEAPF32 = k2 = new Float32Array(A5), i2.HEAPF64 = F2 = new Float64Array(A5);
              }
              var G2 = i2.INITIAL_MEMORY || 16777216;
              G2 >= 65536 || K2("INITIAL_MEMORY should be larger than STACK_SIZE, was " + G2 + "! (STACK_SIZE=65536)"), y2 = i2.wasmMemory ? i2.wasmMemory : new D2.Memory({ initial: G2 / 65536, maximum: 32768 }), M2(), G2 = y2.buffer.byteLength;
              var U2 = [], J2 = [], N2 = [], Y2 = 0, b2 = null, _2 = null;
              function K2(A5) {
                throw i2.onAbort && i2.onAbort(A5), c2(A5 = "Aborted(" + A5 + ")"), l2 = true, A5 += ". Build with -sASSERTIONS for more info.", new D2.RuntimeError(A5);
              }
              var P2, v2, m2, d2, L2 = "data:application/octet-stream;base64,";
              function R2(A5) {
                return A5.startsWith(L2);
              }
              function x2(A5) {
                return A5.startsWith("file://");
              }
              function j2(A5) {
                try {
                  if (A5 == P2 && e2)
                    return new Uint8Array(e2);
                  var I5 = T2(A5);
                  if (I5)
                    return I5;
                  if (Q2)
                    return Q2(A5);
                  throw "both async and sync fetching of the wasm failed";
                } catch (A6) {
                  K2(A6);
                }
              }
              R2(P2 = "<<< WASM_BINARY_FILE >>>") || (v2 = P2, P2 = i2.locateFile ? i2.locateFile(v2, r2) : r2 + v2);
              var X2 = { 34904: () => i2.getRandomValue(), 34940: () => {
                if (void 0 === i2.getRandomValue)
                  try {
                    var A5 = "object" == typeof window ? window : self, I5 = void 0 !== A5.crypto ? A5.crypto : A5.msCrypto, g4 = function() {
                      var A6 = new Uint32Array(1);
                      return I5.getRandomValues(A6), A6[0] >>> 0;
                    };
                    g4(), i2.getRandomValue = g4;
                  } catch (A6) {
                    try {
                      var C2 = require("crypto"), B3 = function() {
                        var A7 = C2.randomBytes(4);
                        return (A7[0] << 24 | A7[1] << 16 | A7[2] << 8 | A7[3]) >>> 0;
                      };
                      B3(), i2.getRandomValue = B3;
                    } catch (A7) {
                      throw "No secure random number generator found";
                    }
                  }
              } };
              function q2(A5) {
                for (; A5.length > 0; )
                  A5.shift()(i2);
              }
              var z2 = [];
              function V2(A5) {
                var I5 = y2.buffer;
                try {
                  return y2.grow(A5 - I5.byteLength + 65535 >>> 16), M2(), 1;
                } catch (A6) {
                }
              }
              var O2 = "function" == typeof atob ? atob : function(A5) {
                var I5, g4, C2, B3, Q3, i3, E3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o3 = "", a3 = 0;
                A5 = A5.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                do {
                  I5 = E3.indexOf(A5.charAt(a3++)) << 2 | (B3 = E3.indexOf(A5.charAt(a3++))) >> 4, g4 = (15 & B3) << 4 | (Q3 = E3.indexOf(A5.charAt(a3++))) >> 2, C2 = (3 & Q3) << 6 | (i3 = E3.indexOf(A5.charAt(a3++))), o3 += String.fromCharCode(I5), 64 !== Q3 && (o3 += String.fromCharCode(g4)), 64 !== i3 && (o3 += String.fromCharCode(C2));
                } while (a3 < A5.length);
                return o3;
              };
              function T2(A5) {
                if (R2(A5))
                  return function(A6) {
                    if ("boolean" == typeof n2 && n2) {
                      var I5 = Buffer.from(A6, "base64");
                      return new Uint8Array(I5.buffer, I5.byteOffset, I5.byteLength);
                    }
                    try {
                      for (var g4 = O2(A6), C2 = new Uint8Array(g4.length), B3 = 0; B3 < g4.length; ++B3)
                        C2[B3] = g4.charCodeAt(B3);
                      return C2;
                    } catch (A7) {
                      throw new Error("Converting base64 string to bytes failed.");
                    }
                  }(A5.slice(L2.length));
              }
              var W2, Z = { c: function(A5, I5, g4, C2) {
                K2("Assertion failed: " + H2(A5) + ", at: " + [I5 ? H2(I5) : "unknown filename", g4, C2 ? H2(C2) : "unknown function"]);
              }, d: function() {
                K2("");
              }, b: function(A5, I5, g4) {
                return function(A6, I6, g5) {
                  var C2 = function(A7, I7) {
                    var g6;
                    for (z2.length = 0, I7 >>= 2; g6 = h2[A7++]; )
                      I7 += 105 != g6 & I7, z2.push(105 == g6 ? p2[I7] : F2[I7++ >> 1]), ++I7;
                    return z2;
                  }(I6, g5);
                  return X2[A6].apply(null, C2);
                }(A5, I5, g4);
              }, e: function(A5) {
                var I5, g4 = h2.length, C2 = 2147483648;
                if ((A5 >>>= 0) > C2)
                  return false;
                for (var B3 = 1; B3 <= 4; B3 *= 2) {
                  var Q3 = g4 * (1 + 0.2 / B3);
                  if (Q3 = Math.min(Q3, A5 + 100663296), V2(Math.min(C2, (I5 = Math.max(A5, Q3)) + (65536 - I5 % 65536) % 65536)))
                    return true;
                }
                return false;
              }, a: y2 };
              function $() {
                function A5() {
                  W2 || (W2 = true, i2.calledRun = true, l2 || (q2(J2), i2.onRuntimeInitialized && i2.onRuntimeInitialized(), function() {
                    if (i2.postRun)
                      for ("function" == typeof i2.postRun && (i2.postRun = [i2.postRun]); i2.postRun.length; )
                        A6 = i2.postRun.shift(), N2.unshift(A6);
                    var A6;
                    q2(N2);
                  }()));
                }
                Y2 > 0 || (function() {
                  if (i2.preRun)
                    for ("function" == typeof i2.preRun && (i2.preRun = [i2.preRun]); i2.preRun.length; )
                      A6 = i2.preRun.shift(), U2.unshift(A6);
                  var A6;
                  q2(U2);
                }(), Y2 > 0 || (i2.setStatus ? (i2.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    i2.setStatus("");
                  }, 1), A5();
                }, 1)) : A5()));
              }
              if (function() {
                var A5 = { a: Z };
                function I5(A6, I6) {
                  var g5, C3 = A6.exports;
                  i2.asm = C3, i2.asm.ac, g5 = i2.asm.f, J2.unshift(g5), function(A7) {
                    if (Y2--, i2.monitorRunDependencies && i2.monitorRunDependencies(Y2), 0 == Y2 && (null !== b2 && (clearInterval(b2), b2 = null), _2)) {
                      var I7 = _2;
                      _2 = null, I7();
                    }
                  }();
                }
                function g4(A6) {
                  I5(A6.instance);
                }
                function C2(I6) {
                  return function() {
                    if (!e2 && (o2 || a2)) {
                      if ("function" == typeof fetch && !x2(P2))
                        return fetch(P2, { credentials: "same-origin" }).then(function(A6) {
                          if (!A6.ok)
                            throw "failed to load wasm binary file at '" + P2 + "'";
                          return A6.arrayBuffer();
                        }).catch(function() {
                          return j2(P2);
                        });
                      if (B2)
                        return new Promise(function(A6, I7) {
                          B2(P2, function(I8) {
                            A6(new Uint8Array(I8));
                          }, I7);
                        });
                    }
                    return Promise.resolve().then(function() {
                      return j2(P2);
                    });
                  }().then(function(I7) {
                    return D2.instantiate(I7, A5);
                  }).then(function(A6) {
                    return A6;
                  }).then(I6, function(A6) {
                    c2("failed to asynchronously prepare wasm: " + A6), K2(A6);
                  });
                }
                if (Y2++, i2.monitorRunDependencies && i2.monitorRunDependencies(Y2), i2.instantiateWasm)
                  try {
                    return i2.instantiateWasm(A5, I5);
                  } catch (A6) {
                    return c2("Module.instantiateWasm callback failed with error: " + A6), false;
                  }
                e2 || "function" != typeof D2.instantiateStreaming || R2(P2) || x2(P2) || n2 || "function" != typeof fetch ? C2(g4) : fetch(P2, { credentials: "same-origin" }).then(function(I6) {
                  return D2.instantiateStreaming(I6, A5).then(g4, function(A6) {
                    return c2("wasm streaming compile failed: " + A6), c2("falling back to ArrayBuffer instantiation"), C2(g4);
                  });
                });
              }(), i2._crypto_aead_chacha20poly1305_encrypt_detached = function() {
                return (i2._crypto_aead_chacha20poly1305_encrypt_detached = i2.asm.g).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_encrypt = function() {
                return (i2._crypto_aead_chacha20poly1305_encrypt = i2.asm.h).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_encrypt_detached = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_encrypt_detached = i2.asm.i).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_encrypt = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_encrypt = i2.asm.j).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_decrypt_detached = function() {
                return (i2._crypto_aead_chacha20poly1305_decrypt_detached = i2.asm.k).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_decrypt = function() {
                return (i2._crypto_aead_chacha20poly1305_decrypt = i2.asm.l).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_decrypt_detached = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_decrypt_detached = i2.asm.m).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_decrypt = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_decrypt = i2.asm.n).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_keybytes = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_keybytes = i2.asm.o).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_npubbytes = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_npubbytes = i2.asm.p).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_nsecbytes = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_nsecbytes = i2.asm.q).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_abytes = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_abytes = i2.asm.r).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_messagebytes_max = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_messagebytes_max = i2.asm.s).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_ietf_keygen = function() {
                return (i2._crypto_aead_chacha20poly1305_ietf_keygen = i2.asm.t).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_keybytes = function() {
                return (i2._crypto_aead_chacha20poly1305_keybytes = i2.asm.u).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_npubbytes = function() {
                return (i2._crypto_aead_chacha20poly1305_npubbytes = i2.asm.v).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_nsecbytes = function() {
                return (i2._crypto_aead_chacha20poly1305_nsecbytes = i2.asm.w).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_abytes = function() {
                return (i2._crypto_aead_chacha20poly1305_abytes = i2.asm.x).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_messagebytes_max = function() {
                return (i2._crypto_aead_chacha20poly1305_messagebytes_max = i2.asm.y).apply(null, arguments);
              }, i2._crypto_aead_chacha20poly1305_keygen = function() {
                return (i2._crypto_aead_chacha20poly1305_keygen = i2.asm.z).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_encrypt_detached = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_encrypt_detached = i2.asm.A).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_encrypt = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_encrypt = i2.asm.B).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_decrypt_detached = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_decrypt_detached = i2.asm.C).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_decrypt = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_decrypt = i2.asm.D).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_keybytes = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_keybytes = i2.asm.E).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_npubbytes = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_npubbytes = i2.asm.F).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_nsecbytes = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_nsecbytes = i2.asm.G).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_abytes = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_abytes = i2.asm.H).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_messagebytes_max = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_messagebytes_max = i2.asm.I).apply(null, arguments);
              }, i2._crypto_aead_xchacha20poly1305_ietf_keygen = function() {
                return (i2._crypto_aead_xchacha20poly1305_ietf_keygen = i2.asm.J).apply(null, arguments);
              }, i2._crypto_auth_bytes = function() {
                return (i2._crypto_auth_bytes = i2.asm.K).apply(null, arguments);
              }, i2._crypto_auth_keybytes = function() {
                return (i2._crypto_auth_keybytes = i2.asm.L).apply(null, arguments);
              }, i2._crypto_auth = function() {
                return (i2._crypto_auth = i2.asm.M).apply(null, arguments);
              }, i2._crypto_auth_verify = function() {
                return (i2._crypto_auth_verify = i2.asm.N).apply(null, arguments);
              }, i2._crypto_auth_keygen = function() {
                return (i2._crypto_auth_keygen = i2.asm.O).apply(null, arguments);
              }, i2._crypto_box_seedbytes = function() {
                return (i2._crypto_box_seedbytes = i2.asm.P).apply(null, arguments);
              }, i2._crypto_box_publickeybytes = function() {
                return (i2._crypto_box_publickeybytes = i2.asm.Q).apply(null, arguments);
              }, i2._crypto_box_secretkeybytes = function() {
                return (i2._crypto_box_secretkeybytes = i2.asm.R).apply(null, arguments);
              }, i2._crypto_box_beforenmbytes = function() {
                return (i2._crypto_box_beforenmbytes = i2.asm.S).apply(null, arguments);
              }, i2._crypto_box_noncebytes = function() {
                return (i2._crypto_box_noncebytes = i2.asm.T).apply(null, arguments);
              }, i2._crypto_box_macbytes = function() {
                return (i2._crypto_box_macbytes = i2.asm.U).apply(null, arguments);
              }, i2._crypto_box_messagebytes_max = function() {
                return (i2._crypto_box_messagebytes_max = i2.asm.V).apply(null, arguments);
              }, i2._crypto_box_seed_keypair = function() {
                return (i2._crypto_box_seed_keypair = i2.asm.W).apply(null, arguments);
              }, i2._crypto_box_keypair = function() {
                return (i2._crypto_box_keypair = i2.asm.X).apply(null, arguments);
              }, i2._crypto_box_beforenm = function() {
                return (i2._crypto_box_beforenm = i2.asm.Y).apply(null, arguments);
              }, i2._crypto_box_detached_afternm = function() {
                return (i2._crypto_box_detached_afternm = i2.asm.Z).apply(null, arguments);
              }, i2._crypto_box_detached = function() {
                return (i2._crypto_box_detached = i2.asm._).apply(null, arguments);
              }, i2._crypto_box_easy_afternm = function() {
                return (i2._crypto_box_easy_afternm = i2.asm.$).apply(null, arguments);
              }, i2._crypto_box_easy = function() {
                return (i2._crypto_box_easy = i2.asm.aa).apply(null, arguments);
              }, i2._crypto_box_open_detached_afternm = function() {
                return (i2._crypto_box_open_detached_afternm = i2.asm.ba).apply(null, arguments);
              }, i2._crypto_box_open_detached = function() {
                return (i2._crypto_box_open_detached = i2.asm.ca).apply(null, arguments);
              }, i2._crypto_box_open_easy_afternm = function() {
                return (i2._crypto_box_open_easy_afternm = i2.asm.da).apply(null, arguments);
              }, i2._crypto_box_open_easy = function() {
                return (i2._crypto_box_open_easy = i2.asm.ea).apply(null, arguments);
              }, i2._crypto_box_seal = function() {
                return (i2._crypto_box_seal = i2.asm.fa).apply(null, arguments);
              }, i2._crypto_box_seal_open = function() {
                return (i2._crypto_box_seal_open = i2.asm.ga).apply(null, arguments);
              }, i2._crypto_box_sealbytes = function() {
                return (i2._crypto_box_sealbytes = i2.asm.ha).apply(null, arguments);
              }, i2._crypto_generichash_bytes_min = function() {
                return (i2._crypto_generichash_bytes_min = i2.asm.ia).apply(null, arguments);
              }, i2._crypto_generichash_bytes_max = function() {
                return (i2._crypto_generichash_bytes_max = i2.asm.ja).apply(null, arguments);
              }, i2._crypto_generichash_bytes = function() {
                return (i2._crypto_generichash_bytes = i2.asm.ka).apply(null, arguments);
              }, i2._crypto_generichash_keybytes_min = function() {
                return (i2._crypto_generichash_keybytes_min = i2.asm.la).apply(null, arguments);
              }, i2._crypto_generichash_keybytes_max = function() {
                return (i2._crypto_generichash_keybytes_max = i2.asm.ma).apply(null, arguments);
              }, i2._crypto_generichash_keybytes = function() {
                return (i2._crypto_generichash_keybytes = i2.asm.na).apply(null, arguments);
              }, i2._crypto_generichash_statebytes = function() {
                return (i2._crypto_generichash_statebytes = i2.asm.oa).apply(null, arguments);
              }, i2._crypto_generichash = function() {
                return (i2._crypto_generichash = i2.asm.pa).apply(null, arguments);
              }, i2._crypto_generichash_init = function() {
                return (i2._crypto_generichash_init = i2.asm.qa).apply(null, arguments);
              }, i2._crypto_generichash_update = function() {
                return (i2._crypto_generichash_update = i2.asm.ra).apply(null, arguments);
              }, i2._crypto_generichash_final = function() {
                return (i2._crypto_generichash_final = i2.asm.sa).apply(null, arguments);
              }, i2._crypto_generichash_keygen = function() {
                return (i2._crypto_generichash_keygen = i2.asm.ta).apply(null, arguments);
              }, i2._crypto_hash_bytes = function() {
                return (i2._crypto_hash_bytes = i2.asm.ua).apply(null, arguments);
              }, i2._crypto_hash = function() {
                return (i2._crypto_hash = i2.asm.va).apply(null, arguments);
              }, i2._crypto_kdf_bytes_min = function() {
                return (i2._crypto_kdf_bytes_min = i2.asm.wa).apply(null, arguments);
              }, i2._crypto_kdf_bytes_max = function() {
                return (i2._crypto_kdf_bytes_max = i2.asm.xa).apply(null, arguments);
              }, i2._crypto_kdf_contextbytes = function() {
                return (i2._crypto_kdf_contextbytes = i2.asm.ya).apply(null, arguments);
              }, i2._crypto_kdf_keybytes = function() {
                return (i2._crypto_kdf_keybytes = i2.asm.za).apply(null, arguments);
              }, i2._crypto_kdf_derive_from_key = function() {
                return (i2._crypto_kdf_derive_from_key = i2.asm.Aa).apply(null, arguments);
              }, i2._crypto_kdf_keygen = function() {
                return (i2._crypto_kdf_keygen = i2.asm.Ba).apply(null, arguments);
              }, i2._crypto_kx_seed_keypair = function() {
                return (i2._crypto_kx_seed_keypair = i2.asm.Ca).apply(null, arguments);
              }, i2._crypto_kx_keypair = function() {
                return (i2._crypto_kx_keypair = i2.asm.Da).apply(null, arguments);
              }, i2._crypto_kx_client_session_keys = function() {
                return (i2._crypto_kx_client_session_keys = i2.asm.Ea).apply(null, arguments);
              }, i2._crypto_kx_server_session_keys = function() {
                return (i2._crypto_kx_server_session_keys = i2.asm.Fa).apply(null, arguments);
              }, i2._crypto_kx_publickeybytes = function() {
                return (i2._crypto_kx_publickeybytes = i2.asm.Ga).apply(null, arguments);
              }, i2._crypto_kx_secretkeybytes = function() {
                return (i2._crypto_kx_secretkeybytes = i2.asm.Ha).apply(null, arguments);
              }, i2._crypto_kx_seedbytes = function() {
                return (i2._crypto_kx_seedbytes = i2.asm.Ia).apply(null, arguments);
              }, i2._crypto_kx_sessionkeybytes = function() {
                return (i2._crypto_kx_sessionkeybytes = i2.asm.Ja).apply(null, arguments);
              }, i2._crypto_scalarmult_base = function() {
                return (i2._crypto_scalarmult_base = i2.asm.Ka).apply(null, arguments);
              }, i2._crypto_scalarmult = function() {
                return (i2._crypto_scalarmult = i2.asm.La).apply(null, arguments);
              }, i2._crypto_scalarmult_bytes = function() {
                return (i2._crypto_scalarmult_bytes = i2.asm.Ma).apply(null, arguments);
              }, i2._crypto_scalarmult_scalarbytes = function() {
                return (i2._crypto_scalarmult_scalarbytes = i2.asm.Na).apply(null, arguments);
              }, i2._crypto_secretbox_keybytes = function() {
                return (i2._crypto_secretbox_keybytes = i2.asm.Oa).apply(null, arguments);
              }, i2._crypto_secretbox_noncebytes = function() {
                return (i2._crypto_secretbox_noncebytes = i2.asm.Pa).apply(null, arguments);
              }, i2._crypto_secretbox_macbytes = function() {
                return (i2._crypto_secretbox_macbytes = i2.asm.Qa).apply(null, arguments);
              }, i2._crypto_secretbox_messagebytes_max = function() {
                return (i2._crypto_secretbox_messagebytes_max = i2.asm.Ra).apply(null, arguments);
              }, i2._crypto_secretbox_keygen = function() {
                return (i2._crypto_secretbox_keygen = i2.asm.Sa).apply(null, arguments);
              }, i2._crypto_secretbox_detached = function() {
                return (i2._crypto_secretbox_detached = i2.asm.Ta).apply(null, arguments);
              }, i2._crypto_secretbox_easy = function() {
                return (i2._crypto_secretbox_easy = i2.asm.Ua).apply(null, arguments);
              }, i2._crypto_secretbox_open_detached = function() {
                return (i2._crypto_secretbox_open_detached = i2.asm.Va).apply(null, arguments);
              }, i2._crypto_secretbox_open_easy = function() {
                return (i2._crypto_secretbox_open_easy = i2.asm.Wa).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_keygen = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_keygen = i2.asm.Xa).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_init_push = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_init_push = i2.asm.Ya).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_init_pull = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_init_pull = i2.asm.Za).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_rekey = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_rekey = i2.asm._a).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_push = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_push = i2.asm.$a).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_pull = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_pull = i2.asm.ab).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_statebytes = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_statebytes = i2.asm.bb).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_abytes = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_abytes = i2.asm.cb).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_headerbytes = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_headerbytes = i2.asm.db).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_keybytes = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_keybytes = i2.asm.eb).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_messagebytes_max = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_messagebytes_max = i2.asm.fb).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_tag_message = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_tag_message = i2.asm.gb).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_tag_push = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_tag_push = i2.asm.hb).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_tag_rekey = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_tag_rekey = i2.asm.ib).apply(null, arguments);
              }, i2._crypto_secretstream_xchacha20poly1305_tag_final = function() {
                return (i2._crypto_secretstream_xchacha20poly1305_tag_final = i2.asm.jb).apply(null, arguments);
              }, i2._crypto_shorthash_bytes = function() {
                return (i2._crypto_shorthash_bytes = i2.asm.kb).apply(null, arguments);
              }, i2._crypto_shorthash_keybytes = function() {
                return (i2._crypto_shorthash_keybytes = i2.asm.lb).apply(null, arguments);
              }, i2._crypto_shorthash = function() {
                return (i2._crypto_shorthash = i2.asm.mb).apply(null, arguments);
              }, i2._crypto_shorthash_keygen = function() {
                return (i2._crypto_shorthash_keygen = i2.asm.nb).apply(null, arguments);
              }, i2._crypto_sign_statebytes = function() {
                return (i2._crypto_sign_statebytes = i2.asm.ob).apply(null, arguments);
              }, i2._crypto_sign_bytes = function() {
                return (i2._crypto_sign_bytes = i2.asm.pb).apply(null, arguments);
              }, i2._crypto_sign_seedbytes = function() {
                return (i2._crypto_sign_seedbytes = i2.asm.qb).apply(null, arguments);
              }, i2._crypto_sign_publickeybytes = function() {
                return (i2._crypto_sign_publickeybytes = i2.asm.rb).apply(null, arguments);
              }, i2._crypto_sign_secretkeybytes = function() {
                return (i2._crypto_sign_secretkeybytes = i2.asm.sb).apply(null, arguments);
              }, i2._crypto_sign_messagebytes_max = function() {
                return (i2._crypto_sign_messagebytes_max = i2.asm.tb).apply(null, arguments);
              }, i2._crypto_sign_seed_keypair = function() {
                return (i2._crypto_sign_seed_keypair = i2.asm.ub).apply(null, arguments);
              }, i2._crypto_sign_keypair = function() {
                return (i2._crypto_sign_keypair = i2.asm.vb).apply(null, arguments);
              }, i2._crypto_sign = function() {
                return (i2._crypto_sign = i2.asm.wb).apply(null, arguments);
              }, i2._crypto_sign_open = function() {
                return (i2._crypto_sign_open = i2.asm.xb).apply(null, arguments);
              }, i2._crypto_sign_detached = function() {
                return (i2._crypto_sign_detached = i2.asm.yb).apply(null, arguments);
              }, i2._crypto_sign_verify_detached = function() {
                return (i2._crypto_sign_verify_detached = i2.asm.zb).apply(null, arguments);
              }, i2._crypto_sign_init = function() {
                return (i2._crypto_sign_init = i2.asm.Ab).apply(null, arguments);
              }, i2._crypto_sign_update = function() {
                return (i2._crypto_sign_update = i2.asm.Bb).apply(null, arguments);
              }, i2._crypto_sign_final_create = function() {
                return (i2._crypto_sign_final_create = i2.asm.Cb).apply(null, arguments);
              }, i2._crypto_sign_final_verify = function() {
                return (i2._crypto_sign_final_verify = i2.asm.Db).apply(null, arguments);
              }, i2._crypto_sign_ed25519_pk_to_curve25519 = function() {
                return (i2._crypto_sign_ed25519_pk_to_curve25519 = i2.asm.Eb).apply(null, arguments);
              }, i2._crypto_sign_ed25519_sk_to_curve25519 = function() {
                return (i2._crypto_sign_ed25519_sk_to_curve25519 = i2.asm.Fb).apply(null, arguments);
              }, i2._randombytes_random = function() {
                return (i2._randombytes_random = i2.asm.Gb).apply(null, arguments);
              }, i2._randombytes_stir = function() {
                return (i2._randombytes_stir = i2.asm.Hb).apply(null, arguments);
              }, i2._randombytes_uniform = function() {
                return (i2._randombytes_uniform = i2.asm.Ib).apply(null, arguments);
              }, i2._randombytes_buf = function() {
                return (i2._randombytes_buf = i2.asm.Jb).apply(null, arguments);
              }, i2._randombytes_buf_deterministic = function() {
                return (i2._randombytes_buf_deterministic = i2.asm.Kb).apply(null, arguments);
              }, i2._randombytes_seedbytes = function() {
                return (i2._randombytes_seedbytes = i2.asm.Lb).apply(null, arguments);
              }, i2._randombytes_close = function() {
                return (i2._randombytes_close = i2.asm.Mb).apply(null, arguments);
              }, i2._randombytes = function() {
                return (i2._randombytes = i2.asm.Nb).apply(null, arguments);
              }, i2._sodium_bin2hex = function() {
                return (i2._sodium_bin2hex = i2.asm.Ob).apply(null, arguments);
              }, i2._sodium_hex2bin = function() {
                return (i2._sodium_hex2bin = i2.asm.Pb).apply(null, arguments);
              }, i2._sodium_base64_encoded_len = function() {
                return (i2._sodium_base64_encoded_len = i2.asm.Qb).apply(null, arguments);
              }, i2._sodium_bin2base64 = function() {
                return (i2._sodium_bin2base64 = i2.asm.Rb).apply(null, arguments);
              }, i2._sodium_base642bin = function() {
                return (i2._sodium_base642bin = i2.asm.Sb).apply(null, arguments);
              }, i2._sodium_init = function() {
                return (i2._sodium_init = i2.asm.Tb).apply(null, arguments);
              }, i2._sodium_pad = function() {
                return (i2._sodium_pad = i2.asm.Ub).apply(null, arguments);
              }, i2._sodium_unpad = function() {
                return (i2._sodium_unpad = i2.asm.Vb).apply(null, arguments);
              }, i2._sodium_version_string = function() {
                return (i2._sodium_version_string = i2.asm.Wb).apply(null, arguments);
              }, i2._sodium_library_version_major = function() {
                return (i2._sodium_library_version_major = i2.asm.Xb).apply(null, arguments);
              }, i2._sodium_library_version_minor = function() {
                return (i2._sodium_library_version_minor = i2.asm.Yb).apply(null, arguments);
              }, i2._sodium_library_minimal = function() {
                return (i2._sodium_library_minimal = i2.asm.Zb).apply(null, arguments);
              }, i2._malloc = function() {
                return (i2._malloc = i2.asm._b).apply(null, arguments);
              }, i2._free = function() {
                return (i2._free = i2.asm.$b).apply(null, arguments);
              }, i2.UTF8ToString = H2, i2.setValue = function(A5, I5, g4 = "i8") {
                switch (g4.endsWith("*") && (g4 = "*"), g4) {
                  case "i1":
                  case "i8":
                    w2[A5 >> 0] = I5;
                    break;
                  case "i16":
                    s2[A5 >> 1] = I5;
                    break;
                  case "i32":
                    p2[A5 >> 2] = I5;
                    break;
                  case "i64":
                    d2 = [I5 >>> 0, (m2 = I5, +Math.abs(m2) >= 1 ? m2 > 0 ? (0 | Math.min(+Math.floor(m2 / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((m2 - +(~~m2 >>> 0)) / 4294967296) >>> 0 : 0)], p2[A5 >> 2] = d2[0], p2[A5 + 4 >> 2] = d2[1];
                    break;
                  case "float":
                    k2[A5 >> 2] = I5;
                    break;
                  case "double":
                    F2[A5 >> 3] = I5;
                    break;
                  case "*":
                    u2[A5 >> 2] = I5;
                    break;
                  default:
                    K2("invalid type for setValue: " + g4);
                }
              }, i2.getValue = function(A5, I5 = "i8") {
                switch (I5.endsWith("*") && (I5 = "*"), I5) {
                  case "i1":
                  case "i8":
                    return w2[A5 >> 0];
                  case "i16":
                    return s2[A5 >> 1];
                  case "i32":
                  case "i64":
                    return p2[A5 >> 2];
                  case "float":
                    return k2[A5 >> 2];
                  case "double":
                    return F2[A5 >> 3];
                  case "*":
                    return u2[A5 >> 2];
                  default:
                    K2("invalid type for getValue: " + I5);
                }
                return null;
              }, _2 = function A5() {
                W2 || $(), W2 || (_2 = A5);
              }, i2.preInit)
                for ("function" == typeof i2.preInit && (i2.preInit = [i2.preInit]); i2.preInit.length > 0; )
                  i2.preInit.pop()();
              $();
            });
          };
          var g2, B, Q, i = void 0 !== i ? i : {}, E = Object.assign({}, i), o = "object" == typeof window, a = "function" == typeof importScripts, n = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, r = "";
          if (n) {
            var f = require("fs"), t = require("path");
            r = a ? t.dirname(r) + "/" : __dirname + "/", g2 = (A4, I4) => {
              var g3 = V(A4);
              return g3 ? I4 ? g3 : g3.toString() : (A4 = L(A4) ? new URL(A4) : t.normalize(A4), f.readFileSync(A4, I4 ? void 0 : "utf8"));
            }, Q = (A4) => {
              var I4 = g2(A4, true);
              return I4.buffer || (I4 = new Uint8Array(I4)), I4;
            }, B = (A4, I4, g3) => {
              var C2 = V(A4);
              C2 && I4(C2), A4 = L(A4) ? new URL(A4) : t.normalize(A4), f.readFile(A4, function(A5, C3) {
                A5 ? g3(A5) : I4(C3.buffer);
              });
            }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), "undefined" != typeof module2 && (module2.exports = i), i.inspect = function() {
              return "[Emscripten Module object]";
            };
          } else
            (o || a) && (a ? r = self.location.href : "undefined" != typeof document && document.currentScript && (r = document.currentScript.src), r = 0 !== r.indexOf("blob:") ? r.substr(0, r.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", g2 = (A4) => {
              try {
                var I4 = new XMLHttpRequest();
                return I4.open("GET", A4, false), I4.send(null), I4.responseText;
              } catch (I5) {
                var g3 = V(A4);
                if (g3)
                  return function(A5) {
                    for (var I6 = [], g4 = 0; g4 < A5.length; g4++) {
                      var C2 = A5[g4];
                      C2 > 255 && (C2 &= 255), I6.push(String.fromCharCode(C2));
                    }
                    return I6.join("");
                  }(g3);
                throw I5;
              }
            }, a && (Q = (A4) => {
              try {
                var I4 = new XMLHttpRequest();
                return I4.open("GET", A4, false), I4.responseType = "arraybuffer", I4.send(null), new Uint8Array(I4.response);
              } catch (I5) {
                var g3 = V(A4);
                if (g3)
                  return g3;
                throw I5;
              }
            }), B = (A4, I4, g3) => {
              var C2 = new XMLHttpRequest();
              C2.open("GET", A4, true), C2.responseType = "arraybuffer", C2.onload = () => {
                if (200 == C2.status || 0 == C2.status && C2.response)
                  I4(C2.response);
                else {
                  var B2 = V(A4);
                  B2 ? I4(B2.buffer) : g3();
                }
              }, C2.onerror = g3, C2.send(null);
            });
          i.print;
          var e, c, y = i.printErr || void 0;
          Object.assign(i, E), E = null, i.arguments && i.arguments, i.thisProgram && i.thisProgram, i.quit && i.quit, i.wasmBinary && (e = i.wasmBinary), i.noExitRuntime, "object" != typeof WebAssembly && b("no native wasm support detected");
          var D, w, h, s, p, u, k, F = false, l = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
          function S(A4, I4) {
            return A4 ? function(A5, I5, g3) {
              for (var C2 = I5 + g3, B2 = I5; A5[B2] && !(B2 >= C2); )
                ++B2;
              if (B2 - I5 > 16 && A5.buffer && l)
                return l.decode(A5.subarray(I5, B2));
              for (var Q2 = ""; I5 < B2; ) {
                var i2 = A5[I5++];
                if (128 & i2) {
                  var E2 = 63 & A5[I5++];
                  if (192 != (224 & i2)) {
                    var o2 = 63 & A5[I5++];
                    if ((i2 = 224 == (240 & i2) ? (15 & i2) << 12 | E2 << 6 | o2 : (7 & i2) << 18 | E2 << 12 | o2 << 6 | 63 & A5[I5++]) < 65536)
                      Q2 += String.fromCharCode(i2);
                    else {
                      var a2 = i2 - 65536;
                      Q2 += String.fromCharCode(55296 | a2 >> 10, 56320 | 1023 & a2);
                    }
                  } else
                    Q2 += String.fromCharCode((31 & i2) << 6 | E2);
                } else
                  Q2 += String.fromCharCode(i2);
              }
              return Q2;
            }(w, A4, I4) : "";
          }
          function H() {
            var A4 = c.buffer;
            i.HEAP8 = D = new Int8Array(A4), i.HEAP16 = h = new Int16Array(A4), i.HEAP32 = s = new Int32Array(A4), i.HEAPU8 = w = new Uint8Array(A4), i.HEAPU16 = new Uint16Array(A4), i.HEAPU32 = p = new Uint32Array(A4), i.HEAPF32 = u = new Float32Array(A4), i.HEAPF64 = k = new Float64Array(A4);
          }
          var M = [], G = [], U = [], J = 0, N = null, Y = null;
          function b(A4) {
            throw i.onAbort && i.onAbort(A4), y(A4 = "Aborted(" + A4 + ")"), F = true, A4 += ". Build with -sASSERTIONS for more info.", new WebAssembly.RuntimeError(A4);
          }
          var _, K, P, v, m = "data:application/octet-stream;base64,";
          function d(A4) {
            return A4.startsWith(m);
          }
          function L(A4) {
            return A4.startsWith("file://");
          }
          function R(A4) {
            try {
              if (A4 == _ && e)
                return new Uint8Array(e);
              var I4 = V(A4);
              if (I4)
                return I4;
              if (Q)
                return Q(A4);
              throw "both async and sync fetching of the wasm failed";
            } catch (A5) {
              b(A5);
            }
          }
          d(_ = "data:application/octet-stream;base64,AGFzbQEAAAABiwIfYAN/f34Bf2ACf38Bf2AAAX9gA39/fwF/YAJ/fwBgA39/fwBgBX9/f39/AX9gC39/f39/f39/f39/AX9gBn9/fn9/fwF/YAZ/f35/fn8Bf2AGf39/f39/AX9gAX8AYAR/fn9/AX9gBH9/f38Bf2ABfwF/YAd/f39/f39/AX9gAABgBn9/f35/fwF/YAR/f35/AX9gA39/fgBgCH9/fn9/fn9/AX9gCX9/f39+f35/fwF/YAh/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2AEf39/fwBgBX9/fn9/AGAKf39/f39/f39/fwF/YAR/fn9/AGAGf39+f39/AGAEf39/fgBgBX9/fn9/AX8CHwUBYQFhAAMBYQFiABgBYQFjABABYQFkAAUBYQFlAA4DsAGuAQQFBAMQAgMABAUAAgUEBAsEBBsACwIcDgECAREDAw0DGAIFBAUEBAQBAh0RHhEDAgMLDgUTBBMDAQMLFBQVFQICAwUFAQQBEBkZCg8PCAgEEwQUFREDAgIBAQICAgICCwMDAgkMAQMLDgEAARISAgUOAgUNBgoKCgYaGgoKDQ0PCgYPCBYPChYGBgcHCQcXBwcHBwcXBxcMBgYDAQICCwIDDAINFgYBDw0DDQ4BBgQEAXAADgUGAQFAgIACBggBfwFB8JoGCweWBp4BAWYCAAFnAJsBAWgAmgEBaQCZAQFqAJgBAWsAlwEBbACWAQFtAJUBAW4AlAEBbwAKAXAAXwFxAC4BcgAQAXMAHgF0ABQBdQAKAXYANAF3AC4BeAAQAXkAHgF6ABQBQQCTAQFCAJIBAUMAkAEBRACPAQFFAAoBRgAmAUcALgFIABABSQAeAUoAFAFLAAoBTAAKAU0AjgEBTgCNAQFPABQBUAAKAVEACgFSAAoBUwAKAVQAJgFVABABVgAeAVcApQEBWAA9AVkAIQFaAFEBXwCMAQEkAIsBAmFhAIoBAmJhAFACY2EAiQECZGEATwJlYQCHAQJmYQCGAQJnYQCFAQJoYQCkAQJpYQAQAmphABoCa2EACgJsYQAQAm1hABoCbmEACgJvYQCnAQJwYQCEAQJxYQAjAnJhAIMBAnNhACICdGEAFAJ1YQAaAnZhAIIBAndhABACeGEAGgJ5YQA0AnphAAoCQWEAgQECQmEAFAJDYQCfAQJEYQA9AkVhAJ4B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NgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALGAEBf0HomgIoAgAiAARAIAAREAALEAIACwQAQSALgAQBA38gAkGABE8EQCAAIAEgAhADIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAAC6EGAgd+BH8jAEHABWsiDCQAAkAgAlANACAAIAApA0giAyACQgOGfCIENwNIIABBQGsiCiAKKQMAIAMgBFatfCACQj2IfDcDACACQoABIANCA4hC/wCDIgR9IghaBEBCACEDIARC/wCFQgNaBEAgCEL8AYMhByAAQdAAaiEKA0AgCiADIAR8p2ogASADp2otAAA6AAAgCiADQgGEIgkgBHynaiABIAmnai0AADoAACAKIANCAoQiCSAEfKdqIAEgCadqLQAAOgAAIAogA0IDhCIJIAR8p2ogASAJp2otAAA6AAAgA0IEfCEDIAVCBHwiBSAHUg0ACwsgCEIDgyIFQgBSBEADQCAAIAMgBHynaiABIAOnai0AADoAUCADQgF8IQMgBkIBfCIGIAVSDQALCyAAIABB0ABqIAwgDEGABWoiChAlIAEgCKdqIQEgAiAIfSICQv8AVgRAA0AgACABIAwgChAlIAFBgAFqIQEgAkKAAX0iAkL/AFYNAAsLAkAgAlANACACQgODIQRCACEGQgAhAyACQgRaBEAgAkJ8gyEFIABB0ABqIQpCACECA0AgCiADpyILaiABIAtqLQAAOgAAIAogC0EBciINaiABIA1qLQAAOgAAIAogC0ECciINaiABIA1qLQAAOgAAIAogC0EDciILaiABIAtqLQAAOgAAIANCBHwhAyACQgR8IgIgBVINAAsLIARQDQADQCAAIAOnIgpqIAEgCmotAAA6AFAgA0IBfCEDIAZCAXwiBiAEUg0ACwsgDEHABRAHDAELQgAhAyACQgRaBEAgAkJ8gyEIIABB0ABqIQoDQCAKIAMgBHynaiABIAOnai0AADoAACAKIANCAYQiByAEfKdqIAEgB6dqLQAAOgAAIAogA0IChCIHIAR8p2ogASAHp2otAAA6AAAgCiADQgOEIgcgBHynaiABIAenai0AADoAACADQgR8IQMgBUIEfCIFIAhSDQALCyACQgODIgJQDQADQCAAIAMgBHynaiABIAOnai0AADoAUCADQgF8IQMgBkIBfCIGIAJSDQALCyAMQcAFaiQAQQALsQQCE38EfiABKAIoIQIgASgCBCEDIAEoAiwhBCABKAIIIQUgASgCMCEGIAEoAgwhByABKAI0IQggASgCECEJIAEoAjghCiABKAIUIQsgASgCPCEMIAEoAhghDSABQUBrIg4oAgAhDyABKAIcIRAgASgCRCERIAEoAiAhEiABKAJIIRMgASgCACEUIAAgASgCJCABKAJMajYCJCAAIBIgE2o2AiAgACAQIBFqNgIcIAAgDSAPajYCGCAAIAsgDGo2AhQgACAJIApqNgIQIAAgByAIajYCDCAAIAUgBmo2AgggACADIARqNgIEIAAgAiAUajYCACABKAIoIQIgASgCBCEDIAEoAiwhBCABKAIIIQUgASgCMCEGIAEoAgwhByABKAI0IQggASgCECEJIAEo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ACABKAJMIAEoAiRqNgJMIAAgLiAvajYCSCAAICwgLWo2AkQgAEFAayIyICogK2o2AgAgACAoIClqNgI8IAAgJiAnajYCOCAAICQgJWo2AjQgACAiICNqNgIwIAAgICAhajYCLCAAQShqIgEgHyAwajYCACAeIAEQBSAAKAJQIR8gACgCBCEgIAAoAlQhISAAKAIIISIgACgCWCEjIAAoAgwhJCAAKAJcISUgACgCECEmIAAoAmAhJyAAKAIUISggACgCZCEpIAAoAhghKiAAKAJoISsgACgCHCEsIAAoAmwhLSAAKAIgIS4gACgCcCEvIAAoAgAhMCAAIAAoAnQiMSAAKAIkIjNrIjQ2AnQgACAvIC5rIjU2AnAgACAtICxrIjY2AmwgACArICprIjc2AmggACApIChrIjg2AmQgACAnICZrIjk2AmAgACAlICRrIjo2AlwgACAjICJrIjs2AlggACAhICBrIjw2AlQgACAfIDBrIj02AlAgACAxIDNqIjE2AkwgACAuIC9qIi42AkggACAsIC1qIiw2AkQgMiAqICtqIio2AgAgACAoIClqIig2AjwgACAmICdqIiY2AjggACAkICVqIiQ2AjQgACAiICNqIiI2AjAgACAgICFqIiA2AiwgASAfIDBqIgE2AgAgHigCACEfIB4oAgQhISAeKAIIISMgHigCDCElIB4oAhAhJyAeKAIUISkgHigCGCErIB4oAhwhLSAeKAIgIS8gACAeKAIkIDFrNgIkIAAgLyAuazYCICAAIC0gLGs2AhwgACArICprNgIYIAAgKSAoazYCFCAAICcgJms2AhAgACAlICRrNgIMIAAgIyAiazYCCCAAICEgIGs2AgQgACAfIAFrNgIAIAAoAnghASAAKAJ8IR8gACgCgAEhICAAKAKEASEhIAAoAogBISIgACgCjAEhIyAAKAKQASEkIAAoApQBISUgACgCmAEhJiAAIAAoApwBIDRrNgKcASAAICYgNWs2ApgBIAAgJSA2azYClAEgACAkIDdrNgKQASAAICMgOGs2AowBIAAgIiA5azYCiAEgACAhIDprNgKEASAAICAgO2s2AoABIAAgHyA8azYCfCAAIAEgPWs2AnggHkEwaiQAC0QBAn8jAEEQayICJAAgAQRAA0AgAkEAOgAPIAAgA2pB2JACIAJBD2pBABAAOgAA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IAUgBhAGQQAhAwNAIAJBCGoiByADQQF2IAJBoAJqIANqLAAAEEcgAkGAAWoiBSAAIAcQOCAAIAUgBBAGIAggBiABEAYgCyABIAQQBiAKIAUgBhAGIANBPkkhByADQQJqIQMgBw0ACyACQeADaiQAC2IBA38jAEGwAWsiAiQAIAJB4ABqIgMgAUHQAGoQLCACQTBqIgQgASADEAYgAiABQShqIAMQBiAAIAIQEiACQZABaiAEEBIgACAALQAfIAItAJABQQd0czoAHyACQbABaiQAC8oIAQN/IwBBwAFrIgIkACACQZABaiIEIAEQBSACQeAAaiIDIAQQBSADIAMQBSADIAEgAxAGIAQgBCADEAYgAkEwaiIBIAQQBSADIAMgARAGIAEgAxAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAMgASADEAYgASADEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABIAMQBiACIAEQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSABIAIgARAGIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAEgARAFIAMgASADEAYgASADEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABEAUgASABIAMQBiACIAEQBUEBIQEDQCACIAIQBSABQQFqIgFB5ABHDQALIAJBMGoiASACIAEQBiABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSABIAEQBSACQeAAaiIDIAEgAxAGIAMgAxAFIAMgAxAFIAMgAxAFIAMgAxAFIAMgAxAFIAAgAyACQZABahAGIAJBwAFqJAAL7wMBAX8jAEEQayICIAA2AgwgAiABNgIIIAJBADYCBCACIAIoAgQgAigCDC0AACACKAIILQAAc3I2AgQgAiACKAIEIAIoAgwtAAEgAigCCC0AAXNyNgIEIAIgAigCBCACKAIMLQACIAIoAggtAAJzcjYCBCACIAIoAgQgAigCDC0AAyACKAIILQADc3I2AgQgAiACKAIEIAIoAgwtAAQgAigCCC0ABHNyNgIEIAIgAigCBCACKAIMLQAFIAIoAggtAAVzcjYCBCACIAIoAgQgAigCDC0ABiACKAIILQAGc3I2AgQgAiACKAIEIAIoAgwtAAcgAigCCC0AB3NyNgIEIAIgAigCBCACKAIMLQAIIAIoAggtAAhzcjYCBCACIAIoAgQgAigCDC0ACSACKAIILQAJc3I2AgQgAiACKAIEIAIoAgwtAAogAigCCC0ACnNyNgIEIAIgAigCBCACKAIMLQALIAIoAggtAAtzcjYCBCACIAIoAgQgAigCDC0ADCACKAIILQAMc3I2AgQgAiACKAIEIAIoAgwtAA0gAigCCC0ADXNyNgIEIAIgAigCBCACKAIMLQAOIAIoAggtAA5zcjYCBCACIAIoAgQgAigCDC0ADyACKAIILQAPc3I2AgQgAigCBEEBa0EI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fiARIBN+fCASIBZ+fCIDIANCgIBAfSIDQoCAgP////8Ag318IixCmNocfiARIBZ+IBIgFX58IANCFYh8IgMgA0KAgEB9IipCgICA/////wCDfSItQpPYKH58IAcgBkKAgIB/g30iLkLn9id+fCAJIAhCgICAf4N9IBIgGH4gBUEGdkH///8Aca0iGiARfnwgEyAUfnwgECAXfnwgFSACQQZ2Qf///wBxrSIbfnwgFiAZfnwgQCgACiJCQRh2rSBAMQAOQgiGhCBAMQAPQhCGhEIBiEL///8AgyIcIBF+IBIgGn58IBcgGH58IBMgGX58IBAgFH58IAAoAAoiQUEYdq0gADEADkIIhoQgADEAD0IQhoRCAYhC////AIMiHSAVfnwgFiAbfnwiDEKAgEB9IgpCFYh8IglCgIBAfSIIQhWIfCIvQtOMQ358ID9B4AFqIj4oABciBUEFdkH///8Aca0gQDMAACBAMQACQhCGQoCA/ACDhCIeIBd+IBQgQCgAAiICQQV2Qf///wBxrSIffnwgQDUAB0IHiEL///8AgyIgIBt+fCAdIEJBBHZB////AHGtIiF+fCACQRh2rSBAMQAGQgiGhCBAMQAHQhCGhEICiEL///8AgyIiIBl+fCAaIAA1AAdCB4hC////AIMiI358IBwgQUEEdkH///8Aca0iJH58IBggACgAAiICQRh2rSAAMQAGQgiGhCAAMQAHQhCGhEICiEL///8AgyIlfnwgADMAACAAMQACQhCGQoCA/ACDhCImIBN+fCAQIAJBBXZB////AHGtIid+fHwgPjMAFSAUIB5+IBkgH358IB0gIH58ICEgJH58IBsgIn58IBogJX58IBwgI358IBggJ358IBAgJn58fCA+MQAXQhCGQoCA/ACDfCIHQoCAQH0iBkIViHwiA3wgA0KAgEB9IgtCgICAf4N9IAcgLkKY2hx+ICxCk9gofnwgL0Ln9id+fCAZIB5+IBsgH358ICAgJH58ICEgI358IB0gIn58IBogJ358IBwgJX58IBggJn58ID4oAA8iAEEYdq0gPjEAE0IIhoQgPjEAFEIQhoRCA4h8IABBBnZB////AHGtIBsgHn4gHSAffnwgICAjfnwgISAlfnwgIiAkfnwgGiAmfnwgHCAnfnx8IjZCgIBAfSIwQhWIfCIoQoCAQH0iN0IViHx8IAZC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9id+IAVC////AIN8IAFCFYd8IgNCBog8AAYgACADQgKGIAFCgIDgAINCE4iEPAAFIAAgAkLTjEN+IAZC////AIN8IANCFYd8IgFCCYg8AAkgACABQgGIPAAIIAAgAUIHhiADQoCA/wCDQg6IhDwAByAAIAJC0asIfiAKQv///wCDfCABQhWHfCIDQgyIPAAMIAAgA0IEiDwACyAAIANCBIYgAUKAgPgAg0IRiIQ8AAogACACQoOhVn4gCUL///8Ag3wgA0IVh3wiAUIHiDwADiAAIAFCAYYgA0KAgMAAg0IUiIQ8AA0gACAHQv///wCDIAFCFYd8IgJCCog8ABEgACACQgKIPAAQIAAgAkIGhiABQoCA/gCDQg+IhDwADyAAIAtC////AIMgAkIVh3wiAUINiDwAFCAAIAFCBYg8ABMgACAQQv///wCDIAFCFYd8IgM8ABUgACABQgOGIAJCgIDwAINCEoiEPAASIAAgA0IIiDwAFiAAIAxC////AIMgA0IVh3wiAkILiDwAGSAAIAJCA4g8ABggACADQhCIQh+DIAJCBYaEPAAXIAAgDUL///8AgyACQhWHfCIBQgaIPAAbIAAgAUIChiACQoCA4ACDQhOIhDwAGiAAIAhC////AIMgAUIVh3wiAkIRiDwAHyAAIAJCCYg8AB4gACACQgGIPAAdIAAgAkIHhiABQoCA/wCDQg6IhDwAHAv4AQEKfwNAIAQgACADai0AACIBIANBkBNqIgItAABzciEEIAogASACLQDAAXNyIQogCSABIAItAKABc3IhCSAIIAEgAi0AgAFzciEIIAcgASACLQBgc3IhByAGIAEgAkFAay0AAHNyIQYgBSABIAItACBzciEFIANBAWoiA0EfRw0ACyAKIAAtAB9B/wBxIgBB/wBzIgFyQf8BcUEBayABIAlyQf8BcUEBayABIAhyQf8BcUEBayAHIABB+gBzckH/AXFBAWsgBiAAQQVzckH/AXFBAWsgACAFckH/AXFBAWsgACAEckH/AXFBAWtycnJycnJBCHZBAXEL4AkBHn8gASgCKCEDIAEoAgQhBCABKAIsIQUgASgCCCEGIAEoAjAhByABKAIMIQggASgCNCEJIAEoAhAhCiABKAI4IQsgASgCFCEMIAEoAjwhDSABKAIYIQ4gAUFAayIPKAIAIRAgASgCHCERIAEo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ACAIEAYjAEGQAWsiBCQAIARB4ABqIgUgABAFIARBMGoiAiAFEAUgAiACEAUgAiAAIAIQBiAFIAUgAhAGIAUgBRAFIAUgAiAFEAYgAiAFEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgBSACIAUQBiACIAUQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIgBRAGIAQgAhAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAQgBBAFIAIgBCACEAYgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgAiACEAUgBSACIAUQBiACIAUQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIQBSACIAIgBRAGIAQgAhAFQQEhAgNAIAQgBBAFIAJBAWoiAkHkAEcNAAsgBEEwaiICIAQgAhAGIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIAIgAhAFIARB4ABqIgUgAiAFEAYgBSAFEAUgBSAFEAUgACAFIAAQBiAEQZABaiQAIAAgACAHEAYgACAAIAgQBiADQeAAaiICIAAQBSACIAIgBhAGIAMgAygChAEiAiAUazYCVCADIAMoAoABIgQgE2s2AlAgAyADKAJ8IgUgEms2AkwgAyADKAJ4IgYgEWs2AkggAyADKAJ0IgcgEGs2AkQgAyADKAJwIgggD2s2AkAgAyADKAJsIhUgDms2AjwgAyADKAJoIhYgDWs2AjggAyADKAJkIhcgDGs2AjQgAyADKAJgIhggC2s2AjAgAyADQTBqEBICQCADQSAQH0UEQCADIAIgFGo2AiQgAyAEIBNqNgIgIAMgBSASajYCHCADIAYgEWo2AhggAyAHIBBqNgIUIAMgCCAPajYCECADIA4gFWo2AgwgAyANIBZqNgIIIAMgDCAXajYCBCADIAsgGGo2AgAgA0GgAmoiAiADEBIgAkEgEB9FDQEgACAAQfAKEAYLIANBoAJqIAAQEiADLQCgAkEBcSABLQAfQQd2RgRAIABBACAAKAIAazYCACAAQQAgACgCJGs2AiQgAEEAIAAoAiBrNgIgIABBACAAKAIcazYCHCAAQQAgACgCGGs2AhggAEEAIAAoAhRrNgIUIABBACAAKAIQazYCECAAQQAgACgCDGs2AgwgAEEAIAAoAghrNgIIIABBACAAKAIEazYCBAsgAEH4AGogACAJEAZBACEKCyADQcACaiQAIAoL9AQBGX4gATEAHyECIAExAB4hBiABMQAdIQ4gATEABiEHIAExAAUhCCABMQAEIQMgATEACSEPIAExAAghECABMQAHIREgATEADCEJIAExAAshCiABMQAKIQsgATEADyEMIAExAA4hEiABMQANIRMgATEAHCEEIAExABshFCABMQAaIRUgATEAGSEFIAExABghFiABMQAXIRcgATUAACEYIAAgATEAFUIPhiABMQAUQgeGhCABMQAWQheGhCABNQAQIhlCgICACHwiGkIZiHwiDSANQoCAgBB8Ig1CgICA4A+DfT4CGCAAIBZCDYYgF0IFhoQgBUIVhoQiBSANQhqIfCAFQoCAgAh8IgVCgICA8AODfT4CHCAAIBRCDIYgFUIEhoQgBEIUhoQgBUIZiHwiBCAEQoCAgBB8IgRCgICA4A+DfT4CICAAIBkgGkKAgIDwD4N9IBJCCoYgE0IChoQgDEIShoQgCkILhiALQgOGhCAJQhOGhCIJQoCAgAh8IgpCGYh8IgtCgICAEHwiDEIaiHw+AhQgACALIAxCgICA4A+DfT4CECAAIBBCDYYgEUIFhoQgD0IVhoQgCEIOhiADQgaGhCAHQhaGhCIHQoCAgAh8IghCGYh8IgMgA0KAgIAQfCIDQoCAgOAPg30+AgggACACQhKGQoCA8A+DIAZCCoYgDkIChoSEIgIgBEIaiHwgAkKAgIAIfCICQoCAgBCDfT4CJCAAIANCGoggCXwgCkKAgIDwAIN9PgIMIAAgByAIQoCAgPAHg30gGCACQhmIQhN+fCICQoCAgBB8IgZCGoh8PgIEIAAgAiAGQoCAgOAPg30+AgALiwEBAX8jAEEQayICIAA2AgwgAiABNgIIQQAhACACQQA2AgQDQCACIAIoAgQgAigCDCAAai0AACACKAIIIABqLQAAc3I2AgQgAiACKAIEIABBAXIiASACKAIMai0AACACKAIIIAFqLQAAc3I2AgQgAEECaiIAQSBHDQALIAIoAgRBAWtBCHZBAXFBAWsLKQEBfyMAQRBrIgAkACAAQQA6AA9B/JACIABBD2pBABAAGiAAQRBqJAALKAAgAkKAgICAEFoEQBAJAAsgACABIAIgA0EBIARBsJACKAIAEQgAGgsoACACQoCAgIAQWgRAEAkACyAAIAEgAiADQgEgBEGskAIoAgARCQAaCy0BAX4gAq0gA61CIIaEIgZCEFoEfyAAIAFBEGogASAGQhB9IAQgBRAwBUF/CwsYACAAIAEgAiADrSAErUIghoQgBSAGEDALGAAgACABIAIgA60gBK1CIIaEIAUgBhAgC0oBAn8jAEEgayIGJABBfyEHAkAgAkIQVA0AIAYgBCAFECENACAAIAFBEGogASACQhB9IAMgBhAwIQcgBkEgEAcLIAZBIGokACAHC08BAn8jAEEgayIGJAAgAkLw////D1QEQEF/IQcgBiAEIAUQIUUEQCAAQRBqIAAgASACIAMgBhAgIQcgBkEgEAcLIAZBIGokACAHDwsQCQALNwEBfyMAQUBqIgIkACAAIAIQEyAAQdABaiIAIAJCwAAQDBogACABEBMgAkHAABAHIAJBQGskAAsLACAAIAEgAhAMGguEAwEGfyMAQcABayIEJAAgABAZIARBQGtBNkGAARAIGgNAIARBQGsiBSACaiIDIAMtAAAgASACai0AAHM6AAAgBSACQQFyIgNqIgYgBi0AACABIANqLQAAczoAACAFIAJBAnIiA2oiBiAGLQAAIAEgA2otAABzOgAAIAUgAkEDciIDaiIFIAUtAAAgASADai0AAHM6AAAgAkEEaiECIAdBBGoiB0EgRw0ACyAAIARBQGsiAkKAARAMGiAAQdABaiIFEBkgAkHcAEGAARAIGkEAIQJBACEHA0AgBEFAayIAIAJqIgMgAy0AACABIAJqLQAAczoAACAAIAJBAXIiA2oiBiAGLQAAIAEgA2otAABzOgAAIAAgAkECciIDaiIGIAYtAAAgASADai0AAHM6AAAgACACQQNyIgNqIgAgAC0AACABIANqLQAAczoAACACQQRqIQIgB0EEaiIHQSBHDQALIAUgBEFAayIAQoABEAwaIABBgAEQByAEQcAAEAcgBEHAAWokAAvVAgECfyMAQZADayIIJAAgCEEANgIEIAhBEGoiCSAGIAcQJyAIIAYpABA3AgggCEHQAGoiB0LAACAIQQRqIAkQFyAIQZABaiIGIAdBvJACKAIAEQEAGiAHQcAAEAcgBiAEIAVBwJACKAIAEQAAGiAGQYCQAkIAIAV9Qg+DQcCQAigCABEAABogBiABIAJBwJACKAIAEQAAGiAGQYCQAkIAIAJ9Qg+DQcCQAigCABEAABogCCAFNwNIIAYgCEHIAGoiBEIIQcCQAigCABEAABogCCACNwNIIAYgBEIIQcCQAigCABEAABogBiAIQTBqIgRBxJACKAIAEQEAGiAGQYACEAcgBCADEC0hBiAEQRAQBwJAIABFDQAgBgRAIABBACACpxAIGkF/IQYMAQsgACABIAIgCEEEaiAIQRBqEE1BACEGCyAIQRBqQSAQByAIQZADaiQAIAYLpwIBA38jAEGAA2siCSQAIAlBADYCBCAJQRBqIgogByAIECcgCSAHKQAQNwIIIAlBQGsiCELAACAJQQRqIgsgChAXIAlBgAFqIgcgCEG8kAIoAgARAQAaIAhBwAAQByAHIAUgBkHAkAIoAgARAAAaIAdBgJACQgAgBn1CD4NBwJACKAIAEQAAGiAAIAMgBCALIAoQTSAHIAAgBEHAkAIoAgARAAAaIAdBgJACQgAgBH1CD4NBwJACKAIAEQAAGiAJIAY3AzggByAJQThqIgBCCEHAkAIoAgARAAAaIAkgBDcDOCAHIABCCEHAkAIoAgARAAAaIAcgAUHEkAIoAgARAQAaIAdBgAIQByACBEAgAkIQNwMACyAJQRBqQSAQByAJQYADaiQAQQALygUCBX8CfkF/IQYCQCABQcEAa0FASQ0AIAVBwABLDQACfyABQf8BcSEGIAVB/wFxIQUjACIBIQkgAUGABGtBQHEiASQAAkAgAkUgA0IAUnENACAARQ0AIAZBwQBrQf8BcUG/AU0NACAEQQEgBRtFDQAgBUHBAE8NAAJ/IAUEQCAERQ0CIAFBQGtBAEGlAhAIGiABQvnC+JuRo7Pw2wA3AzggAULr+obav7X2wR83AzAgAUKf2PnZwpHagpt/NwMoIAFC0YWa7/rPlIfRADcDICABQvHt9Pilp/2npX83AxggAUKr8NP0r+68tzw3AxAgAUK7zqqm2NDrs7t/NwMIIAEgBq0gBa1CCIaEQoiS95X/zPmE6gCFNwMAIAFBgANqIgcgBWpBAEGAASAFaxAIGiAHIAQgBRALGiABQeAAaiAHQYABEAsaIAFBgAE2AuACIAdBgAEQB0GAAQwBCyABQUBrQQBBpQIQCBogAUL5wvibkaOz8NsANwM4IAFC6/qG2r+19sEfNwMwIAFCn9j52cKR2oKbfzcDKCABQtGFmu/6z5SH0QA3AyAgAULx7fT4paf9p6V/NwMYIAFCq/DT9K/uvLc8NwMQIAFCu86qptjQ67O7fzcDCCABIAatQoiS95X/zPmE6gCFNwMAQQALIQQCQCADUA0AIAFB4AFqIQogAUHgAGohBQNAIAQgBWohCEGAAiAEayIHrSILIANaBEAgCCACIAOnIgIQCxogASABKALgAiACajYC4AIMAgsgCCACIAcQCxogASABKALgAiAHajYC4AIgASABKQNAIgxCgAF8NwNAIAEgASkDSCAMQv9+Vq18NwNIIAEgBRAoIAUgCkGAARALGiABIAEoAuACQYABayIENgLgAiACIAdqIQIgAyALfSIDQgBSDQALCyABIAAgBhA1GiAJJABBAAwBCxAJAAshBgsgBgu2AQIBfwN+IwBBoAFrIgMkACABIAJCIBAYGiABIAEtAABB+AFxOgAAIAEgAS0AH0E/cUHAAHI6AB8gAyABECogACADECsgAikACCEEIAIpABAhBSACKQAAIQYgASACKQAYNwAYIAEgBTcAECABIAQ3AAggASAGNwAAIAApAAghBCAAKQAQIQUgACkAACEGIAEgACkAGDcAOCABIAU3ADAgASAENwAoIAEgBjcAICADQaABaiQAQQALBQBBv38LBQBB0AELbQEBfyMAQUBqIgIkACACIAFCIBAYGiACIAItAABB+AFxOgAAIAIgAi0AH0E/cUHAAHI6AB8gACACKQMQNwAQIAAgAikDCDcACCAAIAIpAwA3AAAgACACKQMYNwAYIAJBwAAQByACQUBrJABBAAvXFAIPfyd+IwBBgAJrIgMkAEF/IRACQCABEDcNACADQeAAaiABEEkNACMAQYAQayICJAAgAkGABWoiCiADQeAAaiIBEA0gASkCCCERIAEpAhAhEiABKQIYIRMgASkCACEUIAIgASkCIDcD4AIgAiATNwPYAiACIBI3A9ACIAIgETcDyAIgAiAUNwPAAiABKQIoIREgASkCMCESIAEpAjghEyABQUBrKQIAIRQgAiABKQJINwOIAyACIBQ3A4ADIAIgEzcD+AIgAiASNwPwAiACIBE3A+gCIAEpAlAhESABKQJYIRIgASkCYCETIAEpAmghFCACIAEpAnA3A7ADIAIgFDcDqAMgAiATNwOgAyACIBI3A5gDIAIgETcDkAMgAkHgA2oiASACQcACaiIHEBUgAkGgAWoiCCABIAJB2ARqIgUQBiACQcgBaiACQYgEaiIGIAJBsARqIgQQBiACQfABaiAEIAUQBiACQZgCaiABIAYQBiABIAggChAOIAcgASAFEAYgAkHoAmoiCiAGIAQQBiACQZADaiILIAQgBRAGIAJBuANqIgwgASAGEAYgAkGgBmoiCSAHEA0gASAIIAkQDiAHIAEgBRAGIAogBiAEEAYgCyAEIAUQBiAMIAEgBhAGIAJBwAdqIgkgBxANIAEgCCAJEA4gByABIAUQBiAKIAYgBBAGIAsgBCAFEAYgDCABIAYQBiAC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IAAgAS0AAjoAAiAAIAEtAAM6AAMgACABLQAEOgAEIAAgAS0ABToABSAAIAEtAAY6AAYgACABLQAHOgAHIAAgAS0ACDoACCAAIAEtAAk6AAkgACABLQAKOgAKIAAgAS0ACzoACyAAIAEtAAw6AAwgACABLQANOgANIAAgAS0ADjoADiAAIAEtAA86AA8gACABLQAQOgAQIAAgAS0AEToAESAAIAEtABI6ABIgACABLQATOgATIAAgAS0AFDoAFCAAIAEtABU6ABUgACABLQAWOgAWIAAgAS0AFzoAFyAAIAEtABg6ABggACABLQAZOgAZIAAgAS0AGjoAGiAAIAEtABs6ABsgACABLQAcOgAcIAAgAS0AHToAHSAAIAEtAB46AB4gAS0AHyEBIAAgAC0AAEH4AXE6AAAgACABQT9xQcAAcjoAHyACQTBqIAAQKiACKAKEASEBIAIoAlwhAyACKAKIASEEIAIoAmAhBSACKAKMASEGIAIoAmQhByACKAKQASEIIAIoAmghCSACKAKUASEKIAIoAmwhCyACKAKYASEMIAIoAnAhDSACKAKcASEOIAIoAnQhDyACKAKgASEQIAIoAnghESACKAKAASESIAIoAlghEyACIAIoAnwiFCACKAKkASIVajYCpAIgAiAQIBFqNgKgAiACIA4gD2o2ApwCIAIgDCANajYCmAIgAiAKIAtqNgKUAiACIAggCWo2ApACIAIgBiAHajYCjAIgAiAEIAVqNgKIAiACIAEgA2o2AoQCIAIgEiATajYCgAIgAiAVIBRrNgL0ASACIBAgEWs2AvABIAIgDiAPazYC7AEgAiAMIA1rNgLoASACIAogC2s2AuQBIAIgCCAJazYC4AEgAiAGIAdrNgLcASACIAQgBWs2AtgBIAIgASADazYC1AEgAiASIBNrNgLQASACQdABaiIBIAEQLCACIAJBgAJqIAEQBiAAIAIQEiACQbACaiQAQQAL+RwCPX8MfiMAQfACayIDJAADQCACIAZqLQAAIgQgBkGQhwJqIgktAABzIAdyIQcgBCAJLQDAAXMgBXIhBSAEIAktAKABcyAMciEMIAQgCS0AgAFzIAhyIQggBCAJLQBgcyANciENIAQgCUFAay0AAHMgC3IhCyAEIAktACBzIApyIQogBkEBaiIGQR9HDQALQX8hCSACLQAfQf8AcSIEIApyQf8BcUEBayAEIAdyQf8BcUEBa3IgBCALckH/AXFBAWtyIARB1wBzIA1yQf8BcUEBa3IgBEH/AHMiBCAIckH/AXFBAWtyIAQgDHJB/wFxQQFrciAEIAVyQf8BcUEBa3JBgAJxRQRAIAMgASkAGDcD6AIgAyABKQAQNwPgAiADIAEpAAAiQjcD0AIgAyABKQAINwPYAiADIEKnQfgBcToA0AIgAyADLQDvAkE/cUHAAHI6AO8CIANBoAJqIAIQSiADQgA3AoQCIANCADcCjAIgA0EANgKUAiADQgA3A9ABIANCADcD2AEgA0IANwPgASADQgA3AvQBIANBATYC8AEgA0IANwL8ASADQgA3A8ABIANCADcDyAEgAyADKQO4AjcDqAEgAyADKQOwAjcDoAEgAyADKQOoAjcDmAEgAyADKQOgAjcDkAEgAyADKQPAAjcDsAEgA0IANwJ0IANCADcCfCADQQA2AoQBIANCADcCZCADQQE2AmAgA0IANwJsQf4BIQJBACEEA0AgAygClAIhCSADKAK0ASEGIAMoAmAhByADKALAASEKIAMoApABIQsgAygC8AEhDSADKAJkIQggAygCxAEhDCADKAKUASEFIAMoAvQBIRAgAygCaCEOIAMoAsgBIREgAygCmAEhEiADKAL4ASETIAMoAmwhDyADKALMASEUIAMoApwBIRUgAygC/AEhFiADKAJwIRggAygC0AEhHCADKAKgASEdIAMoAoACIR4gAygCdCEaIAMoAtQBIR8gAygCpAEhICADKAKEAiEhIAMoAnghGSADKALYASEiIAMoAqgBISMgAygCiAIhJCADKAJ8IRsgAygC3AEhJSADKAKsASEmIAMoAowCIScgAygCgAEhFyADKALgASEoIAMoArABISkgAygCkAIhLCADQQAgBCADQdACaiACIgFBA3ZqLQAAIAJBB3F2QQFxIgRzayICIAMoAoQBIiogAygC5AEiK3NxIi0gKnMiKjYChAEgAyAGIAYgCXMgAnEiLnMiLyAqazYCVCADIBcgFyAocyACcSIwcyIGNgKAASADICkgKSAscyACcSIXcyIpIAZrNgJQIAMgGyAbICVzIAJxIjFzIhs2AnwgAyAmICYgJ3MgAnEiMnMiJiAbazYCTCADIBkgGSAicyACcSIzcyIZNgJ4IAMgIyAjICRzIAJxIjRzIiMgGWs2AkggAyAaIBogH3MgAnEiNXMiGjYCdCADICAgICAhcyACcSI2cyIgIBprNgJEIAMgGCAYIBxzIAJxIjdzIhg2AnAgAyAdIB0gHnMgAnEiOHMiHSAYazYCQCADIA8gDyAUcyACcSI5cyIPNgJsIAMgFSAVIBZzIAJxIjpzIhUgD2s2AjwgAyAOIA4gEXMgAnEiO3MiDjYCaCADIBIgEiATcyACcSI8cyISIA5rNgI4IAMgCCAIIAxzIAJxIj1zIgg2AmQgAyAFIAUgEHMgAnEiPnMiBSAIazYCNCADIAcgByAKcyACcSI/cyIHNgJgIAMgCyALIA1zIAJxIgJzIgsgB2s2AjAgAyAJIC5zIgkgKyAtcyIrazYCJCADIBcgLHMiFyAoIDBzIihrNgIgIAMgJyAycyInICUgMXMiJWs2AhwgAyAkIDRzIiQgIiAzcyIiazYCGCADICEgNnMiISAfIDVzIh9rNgIUIAMgHiA4cyIeIBwgN3MiHGs2AhAgAyAWIDpzIhYgFCA5cyIUazYCDCADIBMgPHMiEyARIDtzIhFrNgIIIAMgECA+cyIQIAwgPXMiDGs2AgQgAyACIA1zIgIgCiA/cyIKazYCACADIAkgK2o2ApQCIAMgFyAoajYCkAIgAyAlICdqNgKMAiADICIgJGo2AogCIAMgHyAhajYChAIgAyAcIB5qNgKAAiADIBEgE2o2AvgBIAMgDCAQajYC9AEgAyACIApqNgLwASADIBQgFmo2AvwBIAMgKiAvajYC5AEgAyAGIClqNgLgASADIBsgJmo2AtwBIAMgGSAjajYC2AEgAyAaICBqNgLUASADIBggHWo2AtABIAMgDyAVajYCzAEgAyAOIBJqNgLIASADIAUgCGo2AsQBIAMgByALajYCwAEgA0HgAGoiGyADQTBqIhogA0HwAWoiGRAGIANBwAFqIhcgFyADEAYgGiADEAUgAyAZEAUgAygCwAEhAiADKAJgIQkgAygCxAEhBiADKAJkIQcgAygCyAEhCiADKAJoIQsgAygCzAEhDSADKAJsIQggAygC0AEhDCADKAJwIQUgAygC1AEhECADKAJ0IQ4gAygC2AEhESADKAJ4IRIgAygC3AEhEyADKAJ8IQ8gAygC4AEhFCADKAKAASEVIAMgAygC5AEiFiADKAKEASIYajYCtAEgAyAUIBVqNgKwASADIA8gE2o2AqwBIAMgESASajYCqAEgAyAOIBBqNgKkASADIAUgDGo2AqABIAMgCCANajYCnAEgAyAKIAtqNgKYASADIAYgB2o2ApQBIAMgAiAJajYCkAEgAyAYIBZrNgLkASADIBUgFGs2AuABIAMgDyATazYC3AEgAyASIBFrNgLYASADIA4gEGs2AtQBIAMgBSAMazYC0AEgAyAIIA1rNgLMASADIAsgCms2AsgBIAMgByAGazYCxAEgAyAJIAJrNgLAASAZIAMgGhAGIAMoAjQhAiADKAIEIQUgAygCOCEJIAMoAgghECADKAJAIQYgAygCECEOIAMoAjwhByADKAIMIREgAygCSCEKIAMoAhghEiADKAJEIQsgAygCFCETIAMoAlAhDSADKAIgIQ8gAygCTCEIIAMoAhwhFCADKAJUIQwgAygCJCEVIAMgAygCACADKAIwIhZrIhg2AgAgAyAVIAxrIhU2AiQgAyAUIAhrIhQ2AhwgAyAPIA1rIg82AiAgAyATIAtrIhM2AhQgAyASIAprIhI2AhggAyARIAdrIhE2AgwgAyAOIAZrIg42AhAgAyAQIAlrIhA2AgggAyAFIAJrIgU2AgQgFyAXEAUgAyAVrELCtgd+IkJCgICACHwiRkIZh0ITfiAYrELCtgd+fCJAIEBCgICAEHwiQEKAgIDgD4N9pyIVNgJgIAMgBaxCwrYHfiJBIEFCgICACHwiQUKAgIDwD4N9IEBCGoh8pyIFNgJkIAMgEKxCwrYHfiBBQhmHfCJAIEBCgICAEHwiQEKAgIDgD4N9pyIQNgJoIAMgDqxCwrYHfiARrELCtgd+IkFCgICACHwiR0IZh3wiQyBDQoCAgBB8IkNCgICA4A+DfaciDjYCcCADIBKsQsK2B34gE6xCwrYHfiJIQoCAgAh8IklCGYd8IkQgREKAgIAQfCJEQoCAgOAPg32nIhE2AnggAyAPrELCtgd+IBSsQsK2B34iSkKAgIAIfCJLQhmHfCJFIEVCgICAEHwiRUKAgIDgD4N9pyISNgKAASADIEBCGoggQXwgR0KAgIDwD4N9pyITNgJsIAMgQ0IaiCBIfCBJQoCAgPAPg32nIg82AnQgAyBEQhqIIEp8IEtCgICA8A+DfaciFDYCfCADIEVCGoggQnwgRkKAgIDwD4N9pyIYNgKEASADQZABaiIZIBkQBSADIAwgGGo2AlQgAyANIBJqNgJQIAMgCCAUajYCTCADIAogEWo2AkggAyALIA9qNgJEIAMgBiAOajYCQCADIAcgE2o2AjwgAyAJIBBqNgI4IAMgAiAFajYCNCADIBUgFmo2AjAgAUEBayECIBsgA0GgAmogFxAGIBcgAyAaEAYgAQ0ACyADKAKQASEQIAMoAvABIQIgAygClAEhDiADKAL0ASEGIAMoApgBIREgAygC+AEhByADKAKcASESIAMoAvwBIQogAygCoAEhEyADKAKAAiELIAMoAqQBIQ8gAygChAIhDSADKAKoASEUIAMoAogCIQggAygCrAEhFSADKAKMAiEMIAMoArABIRYgAygCkAIhBSADQQAgBGsiASADKAKUAiIEIAMoArQBc3EgBHM2ApQCIAMgBSAFIBZzIAFxczYCkAIgAyAMIAwgFXMgAXFzNgKMAiADIAggCCAUcyABcXM2AogCIAMgDSANIA9zIAFxczYChAIgAyALIAsgE3MgAXFzNgKAAiADIAogCiAScyABcXM2AvwBIAMgByAHIBFzIAFxczYC+AEgAyAGIAYgDnMgAXFzNgL0ASADIAIgAiAQcyABcXM2AvABIAMoAsABIQIgAygCYCEFIAMoAsQBIQQgAygCZCEQIAMoAsgBIQYgAygCaCEOIAMoAswBIQcgAygCbCERIAMoAtABIQogAygCcCESIAMoAtQBIQsgAygCdCETIAMoAtgBIQ0gAygCeCEPIAMoAtwBIQggAygCfCEUIAMoAuABIQwgAygCgAEhFSADIAMoAuQBIhYgAygChAFzIAFxIBZzNgLkASADIAwgDCAVcyABcXM2AuABIAMgCCAIIBRzIAFxczYC3AEgAyANIA0gD3MgAXFzNgLYASADIAsgCyATcyABcXM2AtQBIAMgCiAKIBJzIAFxczYC0AEgAyAHIAcgEXMgAXFzNgLMASADIAYgBiAOcyABcXM2AsgBIAMgBCAEIBBzIAFxczYCxAEgAyACIAIgBXMgAXFzNgLAASADQcABaiIBIAEQLCADQfABaiICIAIgARAGIAAgAhASIANB0AJqQSAQB0EAIQkLIANB8AJqJAAgCQuJDAEHfwJAIABFDQAgAEEIayICIABBBGsoAgAiAUF4cSIAaiEFAkAgAUEBcQ0AIAFBA3FF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YgDpiWABfzHLAAWblAAXlAn/03oMACKGGv/bzIgAhggp/+BTK/5VGfcAbX8A/qmIMADud9v/563VAM4S/v4Iugf/fgkHAW8qSABvNOz+YD+NAJO/f/7NTsD/DmrtAbvbTACv87v+aVmtAFUZWQGi85QAAnbR/iGeCQCLoy7/XUYoAGwqjv5v/I7/m9+QADPlp/9J/Jv/XnQM/5ig2v+c7iX/s+rP/8UAs/+apI0A4cRoAAojGf7R1PL/Yf3e/rhl5QDeEn8BpIiH/x7PjP6SYfMAgcAa/slUIf9vCk7/k1Gy/wQEGACh7tf/Bo0hADXXDv8ptdD/54udALPL3f//uXEAveKs/3FC1v/KPi3/ZkAI/06uEP6FdUT/AEGwEwsBAQBB0BMLsAEm6JWPwrInsEXD9Iny75jw1d+sBdPGMzmxOAKIbVP8BccXanA9TdhPujwLdg0QZw8qIFP6LDnMxk7H/XeSrAN67P///////////////////////////////////////3/t////////////////////////////////////////f+7///////////////////////////////////////9/7dP1XBpjEljWnPei3vneFABBjxUL/PABEIU7jAG98ST/+CXDAWDcNwC3TD7/w0I9ADJMpAHhpEz/TD2j/3U+HwBRkUD/dkEOAKJz1v8Gii4AfOb0/wqKjwA0GsIAuPRMAIGPKQG+9BP/e6p6/2KBRAB51ZMAVmUe/6FnmwCMWUP/7+W+AUMLtQDG8In+7kW8/+pxPP8l/zn/RbK2/oDQswB2Gn3+AwfW//EyTf9Vy8X/04f6/xkwZP+71bT+EVhpAFPRngEFc2IABK48/qs3bv/ZtRH/FLyqAJKcZv5X1q7/cnqbAeksqgB/CO8B1uzqAK8F2wAxaj3/BkLQ/wJqbv9R6hP/12vA/0OX7gATKmz/5VVxATJEh/8RagkAMmcB/1ABqAEjmB7/EKi5AThZ6P9l0vwAKfpHAMyqT/8OLu//UE3vAL3WS/8RjfkAJlBM/75VdQBW5KoAnNjQAcPPpP+WQkz/r+EQ/41QYgFM2/IAxqJyAC7amACbK/H+m6Bo/7IJ/P5kbtQADgWnAOnvo/8cl50BZZIK//6eRv5H+eQAWB4yAEQ6oP+/GGgBgUKB/8AyVf8Is4r/JvrJAHNQoACD5nEAfViTAFpExwD9TJ4AHP92AHH6/gBCSy4A5torAOV4ugGURCsAiHzuAbtrxf9UNfb/M3T+/zO7pQACEa8AQlSgAfc6HgAjQTX+Rey/AC2G9QGje90AIG4U/zQXpQC61kcA6bBgAPLvNgE5WYoAUwBU/4igZABcjnj+aHy+ALWxPv/6KVUAmIIqAWD89gCXlz/+74U+ACA4nAAtp73/joWzAYNW0wC7s5b++qoO/0RxFf/eujv/QgfxAUUGSABWnGz+N6dZAG002/4NsBf/xCxq/++VR/+kjH3/n60BADMp5wCRPiEAim9dAblTRQCQcy4AYZcQ/xjkGgAx2eIAcUvq/sGZDP+2MGD/Dg0aAIDD+f5FwTsAhCVR/n1qPADW8KkBpONCANKjTgAlNJcAY00aAO6c1f/VwNEBSS5UABRBKQE2zk8AyYOS/qpvGP+xITL+qybL/073dADR3ZkAhYCyATosGQDJJzsBvRP8ADHl0gF1u3UAtbO4AQBy2wAwXpMA9Sk4AH0NzP70rXcALN0g/lTqFAD5oMYB7H7q/48+3QCBWdb/N4sF/kQUv/8OzLIBI8PZAC8zzgEm9qUAzhsG/p5XJADZNJL/fXvX/1U8H/+rDQcA2vVY/vwjPAA31qD/hWU4AOAgE/6TQOoAGpGiAXJ2fQD4/PoAZV7E/8aN4v4zKrYAhwwJ/m2s0v/F7MIB8UGaADCcL/+ZQzf/2qUi/kq0swDaQkcBWHpjANS12/9cKuf/7wCaAPVNt/9eUaoBEtXYAKtdRwA0XvgAEpeh/sXRQv+u9A/+ojC3ADE98P62XcMAx+QGAcgFEf+JLe3/bJQEAFpP7f8nP03/NVLPAY4Wdv9l6BIBXBpDAAXIWP8hqIr/leFIAALRG/8s9agB3O0R/x7Taf6N7t0AgFD1/m/+DgDeX74B3wnxAJJM1P9szWj/P3WZAJBFMAAj5G8AwCHB/3DWvv5zmJcAF2ZYADNK+ADix4/+zKJl/9BhvQH1aBIA5vYe/xeURQBuWDT+4rVZ/9AvWv5yoVD/IXT4ALOYV/9FkLEBWO4a/zogcQEBTUUAO3k0/5juUwA0CMEA5yfp/8ciigDeRK0AWzny/tzSf//AB/b+lyO7AMPspQBvXc4A1PeFAZqF0f+b5woAQE4mAHr5ZAEeE2H/Plv5AfiFTQDFP6j+dApSALjscf7Uy8L/PWT8/iQFyv93W5n/gU8dAGdnq/7t12//2DVFAO/wFwDCld3/JuHeAOj/tP52UoX/OdGxAYvohQCesC7+wnMuAFj35QEcZ78A3d6v/pXrLACX5Bn+2mlnAI5V0gCVgb7/1UFe/nWG4P9SxnUAnd3cAKNlJADFciUAaKym/gu2AABRSLz/YbwQ/0UGCgDHk5H/CAlzAUHWr//ZrdEAUH+mAPflBP6nt3z/WhzM/q878P8LKfgBbCgz/5Cxw/6W+n4AiltBAXg83v/1we8AHda9/4ACGQBQmqIATdxrAerNSv82pmf/dEgJAOReL/8eyBn/I9ZZ/z2wjP9T4qP/S4KsAIAmEQBfiZj/13yfAU9dAACUUp3+w4L7/yjKTP/7fuAAnWM+/s8H4f9gRMMAjLqd/4MT5/8qgP4ANNs9/mbLSACNBwv/uqTVAB96dwCF8pEA0Pzo/1vVtv+PBPr++ddKAKUebwGrCd8A5XsiAVyCGv9Nmy0Bw4sc/zvgTgCIEfcAbHkgAE/6vf9g4/z+JvE+AD6uff+bb13/CubOAWHFKP8AMTn+QfoNABL7lv/cbdL/Ba6m/iyBvQDrI5P/JfeN/0iNBP9na/8A91oEADUsKgACHvAABDs/AFhOJABxp7QAvkfB/8eepP86CKwATSEMAEE/AwCZTSH/rP5mAeTdBP9XHv4BkilW/4rM7/5sjRH/u/KHANLQfwBELQ7+SWA+AFE8GP+qBiT/A/kaACPVbQAWgTb/FSPh/+o9OP862QYAj3xYAOx+QgDRJrf/Iu4G/66RZgBfFtMAxA+Z/i5U6P91IpIB5/pK/xuGZAFcu8P/qsZwAHgcKgDRRkMAHVEfAB2oZAGpraAAayN1AD5gO/9RDEUBh+++/9z8EgCj3Dr/iYm8/1NmbQBgBkwA6t7S/7muzQE8ntX/DfHWAKyBjABdaPIAwJz7ACt1HgDhUZ4Af+jaAOIcywDpG5f/dSsF//IOL/8hFAYAifss/hsf9f+31n3+KHmVALqe1f9ZCOMARVgA/suH4QDJrssAk0e4ABJ5Kf5eBU4A4Nbw/iQFtAD7h+cBo4rUANL5dP5YgbsAEwgx/j4OkP+fTNMA1jNSAG115P5n38v/S/wPAZpH3P8XDVsBjahg/7W2hQD6MzcA6urU/q8/ngAn8DQBnr0k/9UoVQEgtPf/E2YaAVQYYf9FFd4AlIt6/9zV6wHoy/8AeTmTAOMHmgA1FpMBSAHhAFKGMP5TPJ3/kUipACJn7wDG6S8AdBME/7hqCf+3gVMAJLDmASJnSADbooYA9SqeACCVYP6lLJAAyu9I/teWBQAqQiQBhNevAFauVv8axZz/MeiH/me2UgD9gLABmbJ6APX6CgDsGLIAiWqEACgdKQAyHpj/fGkmAOa/SwCPK6oALIMU/ywNF//t/5sBn21k/3C1GP9o3GwAN9ODAGMM1f+Yl5H/7gWfAGGbCAAhbFEAAQNnAD5tIv/6m7QAIEfD/yZGkQGfX/UAReVlAYgc8ABP4BkATm55//iofAC7gPcAApPr/k8LhABGOgwBtQij/0+Jhf8lqgv/jfNV/7Dn1//MlqT/79cn/y5XnP4Io1j/rCLoAEIsZv8bNin+7GNX/yl7qQE0cisAdYYoAJuGGgDnz1v+I4Qm/xNmff4k44X/dgNx/x0NfACYYEoBWJLO/6e/3P6iElj/tmQXAB91NABRLmoBDAIHAEVQyQHR9qwADDCNAeDTWAB04p8AemKCAEHs6gHh4gn/z+J7AVnWOwBwh1gBWvTL/zELJgGBbLoAWXAPAWUuzP9/zC3+T//d/zNJEv9/KmX/8RXKAKDjBwBpMuwATzTF/2jK0AG0DxAAZcVO/2JNywApufEBI8F8ACObF//PNcAAC32jAfmeuf8EgzAAFV1v/z155wFFyCT/uTC5/2/uFf8nMhn/Y9ej/1fUHv+kkwX/gAYjAWzfbv/CTLIASmW0APMvMACuGSv/Uq39ATZywP8oN1sA12yw/ws4BwDg6UwA0WLK/vIZfQAswV3+ywixAIewEwBwR9X/zjuwAQRDGgAOj9X+KjfQ/zxDeADBFaMAY6RzAAoUdgCc1N7+oAfZ/3L1TAF1O3sAsMJW/tUPsABOzs/+1YE7AOn7FgFgN5j/7P8P/8VZVP9dlYUArqBxAOpjqf+YdFgAkKRT/18dxv8iLw//Y3iG/wXswQD5937/k7seADLmdf9s2dv/o1Gm/0gZqf6beU//HJtZ/gd+EQCTQSEBL+r9ABozEgBpU8f/o8TmAHH4pADi/toAvdHL/6T33v7/I6UABLzzAX+zRwAl7f7/ZLrwAAU5R/5nSEn/9BJR/uXShP/uBrT/C+Wu/+PdwAERMRwAo9fE/gl2BP8z8EcAcYFt/0zw5wC8sX8AfUcsARqv8wBeqRn+G+YdAA+LdwGoqrr/rMVM//xLvACJfMQASBZg/y2X+QHckWQAQMCf/3jv4gCBspIAAMB9AOuK6gC3nZIAU8fA/7isSP9J4YAATQb6/7pBQwBo9s8AvCCK/9oY8gBDilH+7YF5/xTPlgEpxxD/BhSAAJ92BQC1EI//3CYPABdAk/5JGg0AV+Q5Acx8gAArGN8A22PHABZLFP8TG34AnT7XAG4d5gCzp/8BNvy+AN3Mtv6znkH/UZ0DAMLanwCq3wAA4Asg/ybFYgCopCUAF1gHAaS6bgBgJIYA6vLlAPp5EwDy/nD/Ay9eAQnvBv9Rhpn+1v2o/0N84AD1X0oAHB4s/gFt3P+yWVkA/CRMABjGLv9MTW8AhuqI/ydeHQC5SOr/RkSH/+dmB/5N54wApy86AZRhdv8QG+EBps6P/26y1v+0g6IAj43hAQ3aTv9ymSEBYmjMAK9ydQGnzksAysRTATpAQwCKL28BxPeA/4ng4P6ecM8AmmT/AYYlawDGgE//f9Gb/6P+uf48DvMAH9tw/h3ZQQDIDXT+ezzE/+A7uP7yWcQAexBL/pUQzgBF/jAB53Tf/9GgQQHIUGIAJcK4/pQ/IgCL8EH/2ZCE/zgmLf7HeNIAbLGm/6DeBADcfnf+pWug/1Lc+AHxr4gAkI0X/6mKVACgiU7/4nZQ/zQbhP8/YIv/mPonALybDwDoM5b+KA/o//DlCf+Jrxv/S0lhAdrUCwCHBaIBa7nVAAL5a/8o8kYA28gZABmdDQBDUlD/xPkX/5EUlQAySJIAXkyUARj7QQAfwBcAuNTJ/3vpogH3rUgAolfb/n6GWQCfCwz+pmkdAEkb5AFxeLf/QqNtAdSPC/+f56gB/4BaADkOOv5ZNAr//QijAQCR0v8KgVUBLrUbAGeIoP5+vNH/IiNvANfbGP/UC9b+ZQV2AOjFhf/fp23/7VBW/0aLXgCewb8Bmw8z/w++cwBOh8//+QobAbV96QBfrA3+qtWh/yfsiv9fXVf/voBfAH0PzgCmlp8A4w+e/86eeP8qjYAAZbJ4AZxtgwDaDiz+96jO/9RwHABwEeT/WhAlAcXebAD+z1P/CVrz//P0rAAaWHP/zXR6AL/mwQC0ZAsB2SVg/5pOnADr6h//zrKy/5XA+wC2+ocA9hZpAHzBbf8C0pX/qRGqAABgbv91CQgBMnso/8G9YwAi46AAMFBG/tMz7AAtevX+LK4IAK0l6f+eQasAekXX/1pQAv+DamD+43KHAM0xd/6wPkD/UjMR//EU8/+CDQj+gNnz/6IbAf5advEA9sb2/zcQdv/In50AoxEBAIxreQBVoXb/JgCVAJwv7gAJpqYBS2K1/zJKGQBCDy8Ai+GfAEwDjv8O7rgAC881/7fAugGrIK7/v0zdAfeq2wAZrDL+2QnpAMt+RP+3XDAAf6e3AUEx/gAQP38B/hWq/zvgf/4WMD//G06C/ijDHQD6hHD+I8uQAGipqADP/R7/aCgm/l7kWADOEID/1Dd6/98W6gDfxX8A/bW1AZFmdgDsmST/1NlI/xQmGP6KPj4AmIwEAObcY/8BFdT/lMnnAPR7Cf4Aq9IAMzol/wH/Dv/0t5H+APKmABZKhAB52CkAX8Ny/oUYl/+c4uf/9wVN//aUc/7hXFH/3lD2/qp7Wf9Kx40AHRQI/4qIRv9dS1wA3ZMx/jR+4gDlfBcALgm1AM1ANAGD/hwAl57UAINATgDOGasAAOaLAL/9bv5n96cAQCgoASql8f87S+T+fPO9/8Rcsv+CjFb/jVk4AZPGBf/L+J7+kKKNAAus4gCCKhX/AaeP/5AkJP8wWKT+qKrcAGJH1gBb0E8An0zJAaYq1v9F/wD/BoB9/74BjACSU9r/1+5IAXp/NQC9dKX/VAhC/9YD0P/VboUAw6gsAZ7nRQCiQMj+WzpoALY6u/755IgAy4ZM/mPd6QBL/tb+UEWaAECY+P7siMr/nWmZ/pWvFAAWIxP/fHnpALr6xv6E5YsAiVCu/6V9RACQypT+6+/4AIe4dgBlXhH/ekhG/kWCkgB/3vgBRX92/x5S1/68ShP/5afC/nUZQv9B6jj+1RacAJc7Xf4tHBv/un6k/yAG7wB/cmMB2zQC/2Ngpv4+vn7/bN6oAUvirgDm4scAPHXa//z4FAHWvMwAH8KG/ntFwP+prST+N2JbAN8qZv6JAWYAnVoZAO96QP/8BukABzYU/1J0rgCHJTb/D7p9AONwr/9ktOH/Ku30//St4v74EiEAq2OW/0rrMv91UiD+aqjtAM9t0AHkCboAhzyp/rNcjwD0qmj/6y18/0ZjugB1ibcA4B/XACgJZAAaEF8BRNlXAAiXFP8aZDr/sKXLATR2RgAHIP7+9P71/6eQwv99cRf/sHm1AIhU0QCKBh7/WTAcACGbDv8Z8JoAjc1tAUZzPv8UKGv+iprH/17f4v+dqyYAo7EZ/i12A/8O3hcB0b5R/3Z76AEN1WX/ezd7/hv2pQAyY0z/jNYg/2FBQ/8YDBwArlZOAUD3YACgh0MAQjfz/5PMYP8aBiH/YjNTAZnV0P8CuDb/GdoLADFD9v4SlUj/DRlIACpP1gAqBCYBG4uQ/5W7FwASpIQA9VS4/njGaP9+2mAAOHXq/w0d1v5ELwr/p5qE/pgmxgBCsln/yC6r/w1jU//Su/3/qi0qAYrRfADWoo0ADOacAGYkcP4Dk0MANNd7/+mrNv9iiT4A99on/+fa7AD3v38Aw5JUAKWwXP8T1F7/EUrjAFgomQHGkwH/zkP1/vAD2v89jdX/YbdqAMPo6/5fVpoA0TDN/nbR8f/weN8B1R2fAKN/k/8N2l0AVRhE/kYUUP+9BYwBUmH+/2Njv/+EVIX/a9p0/3B6LgBpESAAwqA//0TeJwHY/VwAsWnN/5XJwwAq4Qv/KKJzAAkHUQCl2tsAtBYA/h2S/P+Sz+EBtIdgAB+jcACxC9v/hQzB/itOMgBBcXkBO9kG/25eGAFwrG8ABw9gACRVewBHlhX/0Em8AMALpwHV9SIACeZcAKKOJ//XWhsAYmFZAF5P0wBanfAAX9x+AWaw4gAkHuD+Ix9/AOfocwFVU4IA0kn1/y+Pcv9EQcUAO0g+/7eFrf5deXb/O7FR/+pFrf/NgLEA3PQzABr00QFJ3k3/owhg/paV0wCe/ssBNn+LAKHgOwAEbRb/3iot/9CSZv/sjrsAMs31/wpKWf4wT44A3kyC/x6mPwDsDA3/Mbj0ALtxZgDaZf0AmTm2/iCWKgAZxpIB7fE4AIxEBQBbpKz/TpG6/kM0zQDbz4EBbXMRADaPOgEV+Hj/s/8eAMHsQv8B/wf//cAw/xNF2QED1gD/QGWSAd99I//rSbP/+afiAOGvCgFhojoAanCrAVSsBf+FjLL/hvWOAGFaff+6y7n/300X/8BcagAPxnP/2Zj4AKuyeP/khjUAsDbBAfr7NQDVCmQBIsdqAJcf9P6s4Ff/Du0X//1VGv9/J3T/rGhkAPsORv/U0Ir//dP6ALAxpQAPTHv/Jdqg/1yHEAEKfnL/RgXg//f5jQBEFDwB8dK9/8PZuwGXA3EAl1yuAOc+sv/bt+EAFxch/821UAA5uPj/Q7QB/1p7Xf8nAKL/YPg0/1RCjAAif+T/wooHAaZuvAAVEZsBmr7G/9ZQO/8SB48ASB3iAcfZ+QDooUcBlb7JANmvX/5xk0P/io/H/3/MAQAdtlMBzuab/7rMPAAKfVX/6GAZ//9Z9//V/q8B6MFRABwrnP4MRQgAkxj4ABLGMQCGPCMAdvYS/zFY/v7kFbr/tkFwAdsWAf8WfjT/vTUx/3AZjwAmfzf/4mWj/tCFPf+JRa4BvnaR/zxi2//ZDfX/+ogKAFT+4gDJH30B8DP7/x+Dgv8CijL/19exAd8M7v/8lTj/fFtE/0h+qv53/2QAgofo/w5PsgD6g8UAisbQAHnYi/53EiT/HcF6ABAqLf/V8OsB5r6p/8Yj5P5urUgA1t3x/ziUhwDAdU7+jV3P/49BlQAVEmL/Xyz0AWq/TQD+VQj+1m6w/0mtE/6gxMf/7VqQAMGscf/Im4j+5FrdAIkxSgGk3df/0b0F/2nsN/8qH4EBwf/sAC7ZPACKWLv/4lLs/1FFl/+OvhABDYYIAH96MP9RQJwAq/OLAO0j9gB6j8H+1HqSAF8p/wFXhE0ABNQfABEfTgAnLa3+GI7Z/18JBv/jUwYAYjuC/j4eIQAIc9MBomGA/we4F/50HKj/+IqX/2L08AC6doIAcvjr/2mtyAGgfEf/XiSkAa9Bkv/u8ar+ysbFAORHiv4t9m3/wjSeAIW7sABT/Jr+Wb3d/6pJ/ACUOn0AJEQz/ipFsf+oTFb/JmTM/yY1IwCvE2EA4e79/1FRhwDSG//+60lrAAjPcwBSf4gAVGMV/s8TiABkpGUAUNBN/4TP7f8PAw//IaZuAJxfVf8luW8Blmoj/6aXTAByV4f/n8JAAAx6H//oB2X+rXdiAJpH3P6/OTX/qOig/+AgY//anKUAl5mjANkNlAHFcVkAlRyh/s8XHgBphOP/NuZe/4WtzP9ct53/WJD8/mYhWgCfYQMAtdqb//BydwBq1jX/pb5zAZhb4f9Yaiz/0D1xAJc0fAC/G5z/bjbsAQ4epv8nf88B5cccALzkvP5knesA9tq3AWsWwf/OoF8ATO+TAM+hdQAzpgL/NHUK/kk44/+YweEAhF6I/2W/0QAga+X/xiu0AWTSdgByQ5n/F1ga/1maXAHceIz/kHLP//xz+v8izkgAioV//wiyfAFXS2EAD+Vc/vBDg/92e+P+knho/5HV/wGBu0b/23c2AAETrQAtlpQB+FNIAMvpqQGOazgA9/kmAS3yUP8e6WcAYFJGABfJbwBRJx7/obdO/8LqIf9E44z+2M50AEYb6/9okE8ApOZd/taHnACau/L+vBSD/yRtrgCfcPEABW6VASSl2gCmHRMBsi5JAF0rIP74ve0AZpuNAMldw//xi/3/D29i/2xBo/6bT77/Sa7B/vYoMP9rWAv+ymFV//3MEv9x8kIAbqDC/tASugBRFTwAvGin/3ymYf7ShY4AOPKJ/ilvggBvlzoBb9WN/7es8f8mBsT/uQd7/y4L9gD1aXcBDwKh/wjOLf8Sykr/U3xzAdSNnQBTCNH+iw/o/6w2rf4y94QA1r3VAJC4aQDf/vgA/5Pw/xe8SAAHMzYAvBm0/ty0AP9ToBQAo73z/zrRwv9XSTwAahgxAPX53AAWracAdgvD/xN+7QBunyX/O1IvALS7VgC8lNABZCWF/wdwwQCBvJz/VGqB/4XhygAO7G//KBRlAKysMf4zNkr/+7m4/12b4P+0+eAB5rKSAEg5Nv6yPrgAd81IALnv/f89D9oAxEM4/+ogqwEu2+QA0Gzq/xQ/6P+lNccBheQF/zTNawBK7oz/lpzb/u+ssv/7vd/+II7T/9oPigHxxFAAHCRi/hbqxwA97dz/9jklAI4Rjv+dPhoAK+5f/gPZBv/VGfABJ9yu/5rNMP4TDcD/9CI2/owQmwDwtQX+m8E8AKaABP8kkTj/lvDbAHgzkQBSmSoBjOySAGtc+AG9CgMAP4jyANMnGAATyqEBrRu6/9LM7/4p0aL/tv6f/6x0NADDZ97+zUU7ADUWKQHaMMIAUNLyANK8zwC7oaH+2BEBAIjhcQD6uD8A3x5i/k2oogA7Na8AE8kK/4vgwgCTwZr/1L0M/gHIrv8yhXEBXrNaAK22hwBesXEAK1nX/4j8av97hlP+BfVC/1IxJwHcAuAAYYGxAE07WQA9HZsBy6vc/1xOiwCRIbX/qRiNATeWswCLPFD/2idhAAKTa/88+EgAreYvAQZTtv8QaaL+idRR/7S4hgEn3qT/3Wn7Ae9wfQA/B2EAP2jj/5Q6DABaPOD/VNT8AE/XqAD43ccBc3kBACSseAAgorv/OWsx/5MqFQBqxisBOUpXAH7LUf+Bh8MAjB+xAN2LwgAD3tcAg0TnALFWsv58l7QAuHwmAUajEQD5+7UBKjfjAOKhLAAX7G4AM5WOAV0F7ADat2r+QxhNACj10f/eeZkApTkeAFN9PABGJlIB5Qa8AG3enf83dj//zZe6AOMhlf/+sPYB47HjACJqo/6wK08Aal9OAbnxev+5Dj0AJAHKAA2yov/3C4QAoeZcAUEBuf/UMqUBjZJA/57y2gAVpH0A1Yt6AUNHVwDLnrIBl1wrAJhvBf8nA+//2f/6/7A/R/9K9U0B+q4S/yIx4//2Lvv/miMwAX2dPf9qJE7/YeyZAIi7eP9xhqv/E9XZ/the0f/8BT0AXgPKAAMat/9Avyv/HhcVAIGNTf9meAcBwkyMALyvNP8RUZQA6FY3AeEwrACGKir/7jIvAKkS/gAUk1f/DsPv/0X3FwDu5YD/sTFwAKhi+/95R/gA8wiR/vbjmf/bqbH++4ul/wyjuf+kKKv/mZ8b/vNtW//eGHABEtbnAGudtf7DkwD/wmNo/1mMvv+xQn7+arlCADHaHwD8rp4AvE/mAe4p4ADU6ggBiAu1AKZ1U/9Ew14ALoTJAPCYWACkOUX+oOAq/zvXQ/93w43/JLR5/s8vCP+u0t8AZcVE//9SjQH6iekAYVaFARBQRQCEg58AdF1kAC2NiwCYrJ3/WitbAEeZLgAnEHD/2Yhh/9zGGf6xNTEA3liG/4APPADPwKn/wHTR/2pO0wHI1bf/Bwx6/t7LPP8hbsf++2p1AOThBAF4Ogf/3cFU/nCFGwC9yMn/i4eWAOo3sP89MkEAmGyp/9xVAf9wh+MAohq6AM9guf70iGsAXZkyAcZhlwBuC1b/j3Wu/3PUyAAFyrcA7aQK/rnvPgDseBL+Yntj/6jJwv4u6tYAv4Ux/2OpdwC+uyMBcxUt//mDSABwBnv/1jG1/qbpIgBcxWb+/eTN/wM7yQEqYi4A2yUj/6nDJgBefMEBnCvfAF9Ihf54zr8AesXv/7G7T//+LgIB+qe+AFSBEwDLcab/+R+9/kidyv/QR0n/zxhIAAoQEgHSUUz/WNDA/37za//ujXj/x3nq/4kMO/8k3Hv/lLM8/vAMHQBCAGEBJB4m/3MBXf9gZ+f/xZ47AcCk8ADKyjn/GK4wAFlNmwEqTNcA9JfpABcwUQDvfzT+44Il//h0XQF8hHYArf7AAQbrU/9ur+cB+xy2AIH5Xf5UuIAATLU+AK+AugBkNYj+bR3iAN3pOgEUY0oAABagAIYNFQAJNDf/EVmMAK8iOwBUpXf/4OLq/wdIpv97c/8BEtb2APoHRwHZ3LkA1CNM/yZ9rwC9YdIAcu4s/ym8qf4tupoAUVwWAISgwQB50GL/DVEs/8ucUgBHOhX/0HK//jImkwCa2MMAZRkSADz61//phOv/Z6+OARAOXACNH27+7vEt/5nZ7wFhqC//+VUQARyvPv85/jYA3ud+AKYtdf4SvWD/5EwyAMj0XgDGmHgBRCJF/wxBoP5lE1oAp8V4/0Q2uf8p2rwAcagwAFhpvQEaUiD/uV2kAeTw7f9CtjUAq8Vc/2sJ6QHHeJD/TjEK/22qaf9aBB//HPRx/0o6CwA+3Pb/eZrI/pDSsv9+OYEBK/oO/2VvHAEvVvH/PUaW/zVJBf8eGp4A0RpWAIrtSgCkX7wAjjwd/qJ0+P+7r6AAlxIQANFvQf7Lhif/WGwx/4MaR//dG9f+aGld/x/sH/6HANP/j39uAdRJ5QDpQ6f+wwHQ/4QR3f8z2VoAQ+sy/9/SjwCzNYIB6WrGANmt3P9w5Rj/r5pd/kfL9v8wQoX/A4jm/xfdcf7rb9UAqnhf/vvdAgAtgp7+aV7Z//I0tP7VRC3/aCYcAPSeTAChyGD/zzUN/7tDlACqNvgAd6Ky/1MUCwAqKsABkp+j/7fobwBN5RX/RzWPABtMIgD2iC//2ye2/1zgyQETjg7/Rbbx/6N29QAJbWoBqrX3/04v7v9U0rD/1WuLACcmCwBIFZYASIJFAM1Nm/6OhRUAR2+s/uIqO/+zANcBIYDxAOr8DQG4TwgAbh5J//aNvQCqz9oBSppF/4r2Mf+bIGQAfUpp/1pVPf8j5bH/Pn3B/5lWvAFJeNQA0Xv2/ofRJv+XOiwBXEXW/w4MWP/8mab//c9w/zxOU//jfG4AtGD8/zV1If6k3FL/KQEb/yakpv+kY6n+PZBG/8CmEgBr+kIAxUEyAAGzEv//aAH/K5kj/1BvqABur6gAKWkt/9sOzf+k6Yz+KwF2AOlDwwCyUp//ild6/9TuWv+QI3z+GYykAPvXLP6FRmv/ZeNQ/lypNwDXKjEAcrRV/yHoGwGs1RkAPrB7/iCFGP/hvz4AXUaZALUqaAEWv+D/yMiM//nqJQCVOY0AwzjQ//6CRv8grfD/HdzHAG5kc/+E5fkA5Onf/yXY0f6ysdH/ty2l/uBhcgCJYaj/4d6sAKUNMQHS68z//AQc/kaglwDovjT+U/hd/z7XTQGvr7P/oDJCAHkw0AA/qdH/ANLIAOC7LAFJolIACbCP/xNMwf8dO6cBGCuaABy+vgCNvIEA6OvL/+oAbf82QZ8APFjo/3n9lv786YP/xm4pAVNNR//IFjv+av3y/xUMz//tQr0AWsbKAeGsfwA1FsoAOOaEAAFWtwBtvioA80SuAW3kmgDIsXoBI6C3/7EwVf9a2qn/+JhOAMr+bgAGNCsAjmJB/z+RFgBGal0A6IprAW6zPf/TgdoB8tFcACNa2QG2j2r/dGXZ/3L63f+tzAYAPJajAEmsLP/vblD/7UyZ/qGM+QCV6OUAhR8o/66kdwBxM9YAgeQC/kAi8wBr4/T/rmrI/1SZRgEyIxAA+krY/uy9Qv+Z+Q0A5rIE/90p7gB243n/XleM/v53XABJ7/b+dVeAABPTkf+xLvwA5Vv2AUWA9//KTTYBCAsJ/5lgpgDZ1q3/hsACAQDPAAC9rmsBjIZkAJ7B8wG2ZqsA65ozAI4Fe/88qFkB2Q5c/xPWBQHTp/4ALAbK/ngS7P8Pcbj/uN+LACixd/62e1r/sKWwAPdNwgAb6ngA5wDW/zsnHgB9Y5H/lkREAY3e+ACZe9L/bn+Y/+Uh1gGH3cUAiWECAAyPzP9RKbwAc0+C/14DhACYr7v/fI0K/37As/8LZ8YAlQYtANtVuwHmErL/SLaYAAPGuP+AcOABYaHmAP5jJv86n8UAl0LbADtFj/+5cPkAd4gv/3uChACoR1//cbAoAei5rQDPXXUBRJ1s/2YFk/4xYSEAWUFv/vceo/982d0BZvrYAMauS/45NxIA4wXsAeXVrQDJbdoBMenvAB43ngEZsmoAm2+8AV5+jADXH+4BTfAQANXyGQEmR6gAzbpd/jHTjP/bALT/hnalAKCThv9uuiP/xvMqAPOSdwCG66MBBPGH/8Euwf5ntE//4QS4/vJ2ggCSh7AB6m8eAEVC1f4pYHsAeV4q/7K/w/8ugioAdVQI/+kx1v7uem0ABkdZAezTewD0DTD+d5QOAHIcVv9L7Rn/keUQ/oFkNf+Glnj+qJ0yABdIaP/gMQ4A/3sW/5e5l/+qULgBhrYUAClkZQGZIRAATJpvAVbO6v/AoKT+pXtd/wHYpP5DEa//qQs7/54pPf9JvA7/wwaJ/xaTHf8UZwP/9oLj/3oogADiLxj+IyQgAJi6t/9FyhQAw4XDAN4z9wCpq14BtwCg/0DNEgGcUw//xTr5/vtZbv8yClj+MyvYAGLyxgH1l3EAq+zCAcUfx//lUSYBKTsUAP1o5gCYXQ7/9vKS/tap8P/wZmz+oKfsAJravACW6cr/GxP6AQJHhf+vDD8BkbfGAGh4c/+C+/cAEdSn/z57hP/3ZL0Am9+YAI/FIQCbOyz/ll3wAX8DV/9fR88Bp1UB/7yYdP8KFxcAicNdATZiYQDwAKj/lLx/AIZrlwBM/asAWoTAAJIWNgDgQjb+5rrl/ye2xACU+4L/QYNs/oABoACpMaf+x/6U//sGgwC7/oH/VVI+ALIXOv/+hAUApNUnAIb8kv4lNVH/m4ZSAM2n7v9eLbT/hCihAP5vcAE2S9kAs+bdAetev/8X8zABypHL/yd2Kv91jf0A/gDeACv7MgA2qeoBUETQAJTL8/6RB4cABv4AAPy5fwBiCIH/JiNI/9Mk3AEoGlkAqEDF/gPe7/8CU9f+tJ9pADpzwgC6dGr/5ffb/4F2wQDKrrcBpqFIAMlrk/7tiEoA6eZqAWlvqABA4B4BAeUDAGaXr//C7uT//vrUALvteQBD+2ABxR4LALdfzADNWYoAQN0lAf/fHv+yMNP/8cha/6fRYP85gt0ALnLI/z24QgA3thj+brYhAKu+6P9yXh8AEt0IAC/n/gD/cFMAdg/X/60ZKP7AwR//7hWS/6vBdv9l6jX+g9RwAFnAawEI0BsAtdkP/+eV6ACM7H4AkAnH/wxPtf6Ttsr/E222/zHU4QBKo8sAr+mUABpwMwDBwQn/D4f5AJbjggDMANsBGPLNAO7Qdf8W9HAAGuUiACVQvP8mLc7+8Frh/x0DL/8q4EwAuvOnACCED/8FM30Ai4cYAAbx2wCs5YX/9tYyAOcLz/+/flMBtKOq//U4GAGypNP/AxDKAWI5dv+Ng1n+ITMYAPOVW//9NA4AI6lD/jEeWP+zGyT/pYy3ADq9lwBYHwAAS6lCAEJlx/8Y2McBecQa/w5Py/7w4lH/XhwK/1PB8P/MwYP/Xg9WANoonQAzwdEAAPKxAGa59wCebXQAJodbAN+vlQDcQgH/VjzoABlgJf/heqIB17uo/56dLgA4q6IA6PBlAXoWCQAzCRX/NRnu/9ke6P59qZQADehmAJQJJQClYY0B5IMpAN4P8//+EhEABjztAWoDcQA7hL0AXHAeAGnQ1QAwVLP/u3nn/hvYbf+i3Wv+Se/D//ofOf+Vh1n/uRdzAQOjnf8ScPoAGTm7/6FgpAAvEPMADI37/kPquP8pEqEArwZg/6CsNP4YsLf/xsFVAXx5if+XMnL/3Ms8/8/vBQEAJmv/N+5e/kaYXgDV3E0BeBFF/1Wkvv/L6lEAJjEl/j2QfACJTjH+qPcwAF+k/ABpqYcA/eSGAECmSwBRSRT/z9IKAOpqlv9eIlr//p85/tyFYwCLk7T+GBe5ACk5Hv+9YUwAQbvf/+CsJf8iPl8B55DwAE1qfv5AmFsAHWKbAOL7Nf/q0wX/kMve/6Sw3f4F5xgAs3rNACQBhv99Rpf+YeT8AKyBF/4wWtH/luBSAVSGHgDxxC4AZ3Hq/y5lef4ofPr/hy3y/gn5qP+MbIP/j6OrADKtx/9Y3o7/yF+eAI7Ao/8HdYcAb3wWAOwMQf5EJkH/467+APT1JgDwMtD/oT/6ADzR7wB6IxMADiHm/gKfcQBqFH//5M1gAInSrv601JD/WWKaASJYiwCnonABQW7FAPElqQBCOIP/CslT/oX9u/+xcC3+xPsAAMT6l//u6Nb/ltHNABzwdgBHTFMB7GNbACr6gwFgEkD/dt4jAHHWy/96d7j/QhMkAMxA+QCSWYsAhj6HAWjpZQC8VBoAMfmBANDWS//Pgk3/c6/rAKsCif+vkboBN/WH/5pWtQFkOvb/bcc8/1LMhv/XMeYBjOXA/97B+/9RiA//s5Wi/xcnHf8HX0v+v1HeAPFRWv9rMcn/9NOdAN6Mlf9B2zj+vfZa/7I7nQEw2zQAYiLXABwRu/+vqRgAXE+h/+zIwgGTj+oA5eEHAcWoDgDrMzUB/XiuAMUGqP/KdasAoxXOAHJVWv8PKQr/whNjAEE32P6iknQAMs7U/0CSHf+enoMBZKWC/6wXgf99NQn/D8ESARoxC/+1rskBh8kO/2QTlQDbYk8AKmOP/mAAMP/F+VP+aJVP/+tuiP5SgCz/QSkk/ljTCgC7ebsAYobHAKu8s/7SC+7/QnuC/jTqPQAwcRf+BlZ4/3ey9QBXgckA8o3RAMpyVQCUFqEAZ8MwABkxq/+KQ4IAtkl6/pQYggDT5ZoAIJueAFRpPQCxwgn/pllWATZTuwD5KHX/bQPX/zWSLAE/L7MAwtgD/g5UiACIsQ3/SPO6/3URff/TOtP/XU/fAFpY9f+L0W//Rt4vAAr2T//G2bIA4+ELAU5+s/8+K34AZ5QjAIEIpf718JQAPTOOAFHQhgAPiXP/03fs/5/1+P8Choj/5os6AaCk/gByVY3/Maa2/5BGVAFVtgcALjVdAAmmof83orL/Lbi8AJIcLP6pWjEAeLLxAQ57f/8H8ccBvUIy/8aPZf6984f/jRgY/kthVwB2+5oB7TacAKuSz/+DxPb/iEBxAZfoOQDw2nMAMT0b/0CBSQH8qRv/KIQKAVrJwf/8efABus4pACvGYQCRZLcAzNhQ/qyWQQD55cT+aHtJ/01oYP6CtAgAaHs5ANzK5f9m+dMAVg7o/7ZO0QDv4aQAag0g/3hJEf+GQ+kAU/61ALfscAEwQIP/8djz/0HB4gDO8WT+ZIam/+3KxQA3DVEAIHxm/yjksQB2tR8B56CG/3e7ygAAjjz/gCa9/6bJlgDPeBoBNrisAAzyzP6FQuYAIiYfAbhwUAAgM6X+v/M3ADpJkv6bp83/ZGiY/8X+z/+tE/cA7grKAO+X8gBeOyf/8B1m/wpcmv/lVNv/oYFQANBazAHw267/nmaRATWyTP80bKgBU95rANMkbQB2OjgACB0WAO2gxwCq0Z0AiUcvAI9WIADG8gIA1DCIAVysugDml2kBYL/lAIpQv/7w2IL/YisG/qjEMQD9ElsBkEl5AD2SJwE/aBj/uKVw/n7rYgBQ1WL/ezxX/1KM9QHfeK3/D8aGAc487wDn6lz/Ie4T/6VxjgGwdyYAoCum/u9baQBrPcIBGQREAA+LMwCkhGr/InQu/qhfxQCJ1BcASJw6AIlwRf6WaZr/7MmdABfUmv+IUuP+4jvd/1+VwABRdjT/ISvXAQ6TS/9ZnHn+DhJPAJPQiwGX2j7/nFgIAdK4Yv8Ur3v/ZlPlANxBdAGW+gT/XI7c/yL3Qv/M4bP+l1GXAEco7P+KPz4ABk/w/7e5tQB2MhsAP+PAAHtjOgEy4Jv/EeHf/tzgTf8OLHsBjYCvAPjUyACWO7f/k2EdAJbMtQD9JUcAkVV3AJrIugACgPn/Uxh8AA5XjwCoM/UBfJfn/9DwxQF8vrkAMDr2ABTp6AB9EmL/Df4f//Wxgv9sjiMAq33y/owMIv+loaIAzs1lAPcZIgFkkTkAJ0Y5AHbMy//yAKIApfQeAMZ04gCAb5n/jDa2ATx6D/+bOjkBNjLGAKvTHf9riqf/rWvH/22hwQBZSPL/znNZ//r+jv6xyl7/UVkyAAdpQv8Z/v/+y0AX/0/ebP8n+UsA8XwyAO+YhQDd8WkAk5diANWhef7yMYkA6SX5/iq3GwC4d+b/2SCj/9D75AGJPoP/T0AJ/l4wcQARijL+wf8WAPcSxQFDN2gAEM1f/zAlQgA3nD8BQFJK/8g1R/7vQ30AGuDeAN+JXf8e4Mr/CdyEAMYm6wFmjVYAPCtRAYgcGgDpJAj+z/KUAKSiPwAzLuD/cjBP/wmv4gDeA8H/L6Do//9daf4OKuYAGopSAdAr9AAbJyb/YtB//0CVtv8F+tEAuzwc/jEZ2v+pdM3/dxJ4AJx0k/+ENW3/DQrKAG5TpwCd24n/BgOC/zKnHv88ny//gYCd/l4DvQADpkQAU9/XAJZawgEPqEEA41Mz/82rQv82uzwBmGYt/3ea4QDw94gAZMWy/4tH3//MUhABKc4q/5zA3f/Ye/T/2tq5/7u67//8rKD/wzQWAJCutf67ZHP/006w/xsHwQCT1Wj/WskK/1B7QgEWIboAAQdj/h7OCgDl6gUANR7SAIoI3P5HN6cASOFWAXa+vAD+wWUBq/ms/16et/5dAmz/sF1M/0ljT/9KQIH+9i5BAGPxf/72l2b/LDXQ/jtm6gCar6T/WPIgAG8mAQD/tr7/c7AP/qk8gQB67fEAWkw/AD5KeP96w24AdwSyAN7y0gCCIS7+nCgpAKeScAExo2//ebDrAEzPDv8DGcYBKevVAFUk1gExXG3/yBge/qjswwCRJ3wB7MOVAFokuP9DVar/JiMa/oN8RP/vmyP/NsmkAMQWdf8xD80AGOAdAX5xkAB1FbYAy5+NAN+HTQCw5rD/vuXX/2Mltf8zFYr/Gb1Z/zEwpf6YLfcAqmzeAFDKBQAbRWf+zBaB/7T8Pv7SAVv/km7+/9uiHADf/NUBOwghAM4Q9ACB0zAAa6DQAHA70QBtTdj+IhW5//ZjOP+zixP/uR0y/1RZEwBK+mL/4SrI/8DZzf/SEKcAY4RfASvmOQD+C8v/Y7w//3fB+/5QaTYA6LW9AbdFcP/Qq6X/L220/3tTpQCSojT/mgsE/5fjWv+SiWH+Pekp/14qN/9spOwAmET+AAqMg/8Kak/+856JAEOyQv6xe8b/Dz4iAMVYKv+VX7H/mADG/5X+cf/hWqP/fdn3ABIR4ACAQnj+wBkJ/zLdzQAx1EYA6f+kAALRCQDdNNv+rOD0/144zgHyswL/H1ukAeYuiv+95twAOS89/28LnQCxW5gAHOZiAGFXfgDGWZH/p09rAPlNoAEd6eb/lhVW/jwLwQCXJST+uZbz/+TUUwGsl7QAyambAPQ86gCO6wQBQ9o8AMBxSwF088//QaybAFEenP9QSCH+Eudt/45rFf59GoT/sBA7/5bJOgDOqckA0HniACisDv+WPV7/ODmc/408kf8tbJX/7pGb/9FVH/7ADNIAY2Jd/pgQlwDhudwAjess/6CsFf5HGh//DUBd/hw4xgCxPvgBtgjxAKZllP9OUYX/gd7XAbypgf/oB2EAMXA8/9nl+wB3bIoAJxN7/oMx6wCEVJEAguaU/xlKuwAF9Tb/udvxARLC5P/xymYAaXHKAJvrTwAVCbL/nAHvAMiUPQBz99L/Md2HADq9CAEjLgkAUUEF/zSeuf99dC7/SowN/9JcrP6TF0cA2eD9/nNstP+ROjD+27EY/5z/PAGak/IA/YZXADVL5QAww97/H68y/5zSeP/QI97/EvizAQIKZf+dwvj/nsxl/2j+xf9PPgQAsqxlAWCS+/9BCpwAAoml/3QE5wDy1wEAEyMd/yuhTwA7lfYB+0KwAMghA/9Qbo7/w6ERAeQ4Qv97L5H+hASkAEOurAAZ/XIAV2FXAfrcVABgW8j/JX07ABNBdgChNPH/7awG/7C///8BQYL+377mAGX95/+SI20A+h1NATEAEwB7WpsBFlYg/9rVQQBvXX8APF2p/wh/tgARug7+/Yn2/9UZMP5M7gD/+FxG/2PgiwC4Cf8BB6TQAM2DxgFX1scAgtZfAN2V3gAXJqv+xW7VACtzjP7XsXYAYDRCAXWe7QAOQLb/Lj+u/55fvv/hzbH/KwWO/6xj1P/0u5MAHTOZ/+R0GP4eZc8AE/aW/4bnBQB9huIBTUFiAOyCIf8Fbj4ARWx//wdxFgCRFFP+wqHn/4O1PADZ0bH/5ZTU/gODuAB1sbsBHA4f/7BmUAAyVJf/fR82/xWdhf8Ts4sB4OgaACJ1qv+n/Kv/SY3O/oH6IwBIT+wB3OUU/ynKrf9jTO7/xhbg/2zGw/8kjWAB7J47/2pkVwBu4gIA4+reAJpdd/9KcKT/Q1sC/xWRIf9m1on/r+Zn/qP2pgBd93T+p+Ac/9wCOQGrzlQAe+QR/xt4dwB3C5MBtC/h/2jIuf6lAnIATU7UAC2asf8YxHn+Up22AFoQvgEMk8UAX++Y/wvrRwBWknf/rIbWADyDxACh4YEAH4J4/l/IMwBp59L/OgmU/yuo3f987Y4AxtMy/i71ZwCk+FQAmEbQ/7R1sQBGT7kA80ogAJWczwDFxKEB9TXvAA9d9v6L8DH/xFgk/6ImewCAyJ0Brkxn/62pIv7YAav/cjMRAIjkwgBuljj+avafABO4T/+WTfD/m1CiAAA1qf8dl1YARF4QAFwHbv5idZX/+U3m//0KjADWfFz+I3brAFkwOQEWNaYAuJA9/7P/wgDW+D3+O272AHkVUf6mA+QAakAa/0Xohv/y3DX+LtxVAHGV9/9hs2f/vn8LAIfRtgBfNIEBqpDO/3rIzP+oZJIAPJCV/kY8KAB6NLH/9tNl/67tCAAHM3gAEx+tAH7vnP+PvcsAxIBY/+mF4v8efa3/yWwyAHtkO//+owMB3ZS1/9aIOf7etIn/z1g2/xwh+/9D1jQB0tBkAFGqXgCRKDUA4G/n/iMc9P/ix8P+7hHmANnZpP6pnd0A2i6iAcfPo/9sc6IBDmC7/3Y8TAC4n5gA0edH/iqkuv+6mTP+3au2/6KOrQDrL8EAB4sQAV+kQP8Q3aYA28UQAIQdLP9kRXX/POtY/ihRrQBHvj3/u1idAOcLFwDtdaQA4ajf/5pydP+jmPIBGCCqAH1icf6oE0wAEZ3c/ps0BQATb6H/R1r8/61u8AAKxnn//f/w/0J70gDdwtf+eaMR/+EHYwC+MbYAcwmFAegaiv/VRIQALHd6/7NiMwCVWmoARzLm/wqZdv+xRhkApVfNADeK6gDuHmEAcZvPAGKZfwAia9v+dXKs/0y0//7yObP/3SKs/jiiMf9TA///cd29/7wZ5P4QWFn/RxzG/hYRlf/zef7/a8pj/wnODgHcL5kAa4knAWExwv+VM8X+ujoL/2sr6AHIBg7/tYVB/t3kq/97PucB4+qz/yK91P70u/kAvg1QAYJZAQDfha0ACd7G/0J/SgCn2F3/m6jGAUKRAABEZi4BrFqaANiAS/+gKDMAnhEbAXzwMQDsyrD/l3zA/ybBvgBftj0Ao5N8//+lM/8cKBH+12BOAFaR2v4fJMr/VgkFAG8pyP/tbGEAOT4sAHW4DwEt8XQAmAHc/52lvAD6D4MBPCx9/0Hc+/9LMrgANVqA/+dQwv+IgX8BFRK7/y06of9HkyIArvkL/iONHQDvRLH/c246AO6+sQFX9ab/vjH3/5JTuP+tDif/ktdoAI7feACVyJv/1M+RARC12QCtIFf//yO1AHffoQHI317/Rga6/8BDVf8yqZgAkBp7/zjzs/4URIgAJ4y8/v3QBf/Ic4cBK6zl/5xouwCX+6cANIcXAJeZSACTxWv+lJ4F/+6PzgB+mYn/WJjF/gdEpwD8n6X/7042/xg/N/8m3l4A7bcM/87M0gATJ/b+HkrnAIdsHQGzcwAAdXZ0AYQG/P+RgaEBaUONAFIl4v/u4uT/zNaB/qJ7ZP+5eeoALWznAEIIOP+EiIAArOBC/q+dvADm3+L+8ttFALgOdwFSojgAcnsUAKJnVf8x72P+nIfXAG//p/4nxNYAkCZPAfmofQCbYZz/FzTb/5YWkAAslaX/KH+3AMRN6f92gdL/qofm/9Z3xgDp8CMA/TQH/3VmMP8VzJr/s4ix/xcCAwGVgln//BGfAUY8GgCQaxEAtL48/zi2O/9uRzb/xhKB/5XgV//fFZj/iha2//qczQDsLdD/T5TyAWVG0QBnTq4AZZCs/5iI7QG/wogAcVB9AZgEjQCbljX/xHT1AO9ySf4TUhH/fH3q/yg0vwAq0p7/m4SlALIFKgFAXCj/JFVN/7LkdgCJQmD+c+JCAG7wRf6Xb1AAp67s/+Nsa/+88kH/t1H/ADnOtf8vIrX/1fCeAUdLXwCcKBj/ZtJRAKvH5P+aIikA469LABXvwwCK5V8BTMAxAHV7VwHj4YIAfT4//wLGqwD+JA3+kbrOAJT/9P8jAKYAHpbbAVzk1ABcxjz+PoXI/8kpOwB97m3/tKPuAYx6UgAJFlj/xZ0v/5leOQBYHrYAVKFVALKSfACmpgf/FdDfAJy28gCbebkAU5yu/poQdv+6U+gB3zp5/x0XWAAjfX//qgWV/qQMgv+bxB0AoWCIAAcjHQGiJfsAAy7y/wDZvAA5ruIBzukCADm7iP57vQn/yXV//7okzADnGdgAUE5pABOGgf+Uy0QAjVF9/vilyP/WkIcAlzem/ybrWwAVLpoA3/6W/yOZtP99sB0BK2Ie/9h65v/poAwAObkM/vBxB/8FCRD+GltsAG3GywAIkygAgYbk/3y6KP9yYoT+poQXAGNFLAAJ8u7/uDU7AISBZv80IPP+k9/I/3tTs/6HkMn/jSU4AZc84/9aSZwBy6y7AFCXL/9eief/JL87/+HRtf9K19X+Bnaz/5k2wQEyAOcAaJ1IAYzjmv+24hD+YOFc/3MUqv4G+k4A+Eut/zVZBv8AtHYASK0BAEAIzgGuhd8AuT6F/9YLYgDFH9AAq6f0/xbntQGW2rkA96lhAaWL9/8veJUBZ/gzADxFHP4Zs8QAfAfa/jprUQC46Zz//EokAHa8QwCNXzX/3l6l/i49NQDOO3P/L+z6/0oFIAGBmu7/aiDiAHm7Pf8DpvH+Q6qs/x3Ysv8XyfwA/W7zAMh9OQBtwGD/NHPuACZ58//JOCEAwnaCAEtgGf+qHub+Jz/9ACQt+v/7Ae8AoNRcAS3R7QDzIVf+7VTJ/9QSnf7UY3//2WIQ/ous7wCoyYL/j8Gp/+6XwQHXaCkA7z2l/gID8gAWy7H+scwWAJWB1f4fCyn/AJ95/qAZcv+iUMgAnZcLAJqGTgHYNvwAMGeFAGncxQD9qE3+NbMXABh58AH/LmD/azyH/mLN+f8/+Xf/eDvT/3K0N/5bVe0AldRNAThJMQBWxpYAXdGgAEXNtv/0WisAFCSwAHp03QAzpycB5wE//w3FhgAD0SL/hzvKAKdkTgAv30wAuTw+ALKmewGEDKH/Pa4rAMNFkAB/L78BIixOADnqNAH/Fij/9l6SAFPkgAA8TuD/AGDS/5mv7ACfFUkAtHPE/oPhagD/p4YAnwhw/3hEwv+wxMb/djCo/12pAQBwyGYBShj+ABONBP6OPj8Ag7O7/02cm/93VqQAqtCS/9CFmv+Umzr/onjo/vzVmwDxDSoAXjKDALOqcACMU5f/N3dUAYwj7/+ZLUMB7K8nADaXZ/+eKkH/xO+H/lY1ywCVYS/+2CMR/0YDRgFnJFr/KBqtALgwDQCj29n/UQYB/92qbP7p0F0AZMn5/lYkI//Rmh4B48n7/wK9p/5kOQMADYApAMVkSwCWzOv/ka47AHj4lf9VN+EActI1/sfMdwAO90oBP/uBAENolwGHglAAT1k3/3Xmnf8ZYI8A1ZEFAEXxeAGV81//cioUAINIAgCaNRT/ST5tAMRmmAApDMz/eiYLAfoKkQDPfZQA9vTe/ykgVQFw1X4AovlWAUfGf/9RCRUBYicE/8xHLQFLb4kA6jvnACAwX//MH3IBHcS1/zPxp/5dbY4AaJAtAOsMtf80cKQATP7K/64OogA965P/K0C5/ul92QDzWKf+SjEIAJzMQgB81nsAJt12AZJw7AByYrEAl1nHAFfFcAC5laEALGClAPizFP+829j+KD4NAPOOjQDl487/rMoj/3Ww4f9SbiYBKvUO/xRTYQAxqwoA8nd4ABnoPQDU8JP/BHM4/5ER7/7KEfv/+RL1/2N17wC4BLP/9u0z/yXvif+mcKb/Ubwh/7n6jv82u60A0HDJAPYr5AFouFj/1DTE/zN1bP/+dZsALlsP/1cOkP9X48wAUxpTAZ9M4wCfG9UBGJdsAHWQs/6J0VIAJp8KAHOFyQDftpwBbsRd/zk86QAFp2n/msWkAGAiuv+ThSUB3GO+AAGnVP8UkasAwsX7/l9Ohf/8+PP/4V2D/7uGxP/YmaoAFHae/owBdgBWng8BLdMp/5MBZP5xdEz/039sAWcPMADBEGYBRTNf/2uAnQCJq+kAWnyQAWqhtgCvTOwByI2s/6M6aADptDT/8P0O/6Jx/v8m74r+NC6mAPFlIf6DupwAb9A+/3xeoP8frP4AcK44/7xjG/9DivsAfTqAAZyYrv+yDPf//FSeAFLFDv6syFP/JScuAWrPpwAYvSIAg7KQAM7VBACh4tIASDNp/2Etu/9OuN//sB37AE+gVv90JbIAUk3VAVJUjf/iZdQBr1jH//Ve9wGsdm3/prm+AIO1eABX/l3/hvBJ/yD1j/+Lomf/s2IS/tnMcACT33j/NQrzAKaMlgB9UMj/Dm3b/1vaAf/8/C/+bZx0/3MxfwHMV9P/lMrZ/xpV+f8O9YYBTFmp//It5gA7Yqz/ckmE/k6bMf+eflQAMa8r/xC2VP+dZyMAaMFt/0PdmgDJrAH+CKJYAKUBHf99m+X/HprcAWfvXADcAW3/ysYBAF4CjgEkNiwA6+Ke/6r71v+5TQkAYUryANujlf/wI3b/33JY/sDHAwBqJRj/yaF2/2FZYwHgOmf/ZceT/t48YwDqGTsBNIcbAGYDW/6o2OsA5eiIAGg8gQAuqO4AJ79DAEujLwCPYWL/ONioAajp/P8jbxb/XFQrABrIVwFb/ZgAyjhGAI4ITQBQCq8B/MdMABZuUv+BAcIAC4A9AVcOkf/93r4BD0iuAFWjVv46Yyz/LRi8/hrNDwAT5dL++EPDAGNHuACaxyX/l/N5/yYzS//JVYL+LEH6ADmT8/6SKzv/WRw1ACFUGP+zMxL+vUZTAAucswFihncAnm9vAHeaSf/IP4z+LQ0N/5rAAv5RSCoALqC5/ixwBgCS15UBGrBoAEQcVwHsMpn/s4D6/s7Bv/+mXIn+NSjvANIBzP6orSMAjfMtASQybf8P8sL/4596/7Cvyv5GOUgAKN84ANCiOv+3Yl0AD28MAB4ITP+Ef/b/LfJnAEW1D/8K0R4AA7N5APHo2gF7x1j/AtLKAbyCUf9eZdABZyQtAEzBGAFfGvH/paK7ACRyjADKQgX/JTiTAJgL8wF/Vej/+ofUAbmxcQBa3Ev/RfiSADJvMgBcFlAA9CRz/qNkUv8ZwQYBfz0kAP1DHv5B7Kr/oRHX/j+vjAA3fwQAT3DpAG2gKACPUwf/QRru/9mpjP9OXr3/AJO+/5NHuv5qTX//6Z3pAYdX7f/QDewBm20k/7Rk2gC0oxIAvm4JARE/e/+ziLT/pXt7/5C8Uf5H8Gz/GXAL/+PaM/+nMur/ck9s/x8Tc/+38GMA41eP/0jZ+P9mqV8BgZWVAO6FDAHjzCMA0HMaAWYI6gBwWI8BkPkOAPCerP5kcHcAwo2Z/ig4U/95sC4AKjVM/56/mgBb0VwArQ0QAQVI4v/M/pUAULjPAGQJev52Zav//MsA/qDPNgA4SPkBOIwN/wpAa/5bZTT/4bX4AYv/hADmkREA6TgXAHcB8f/VqZf/Y2MJ/rkPv/+tZ20Brg37/7JYB/4bO0T/CiEC//hhOwAaHpIBsJMKAF95zwG8WBgAuV7+/nM3yQAYMkYAeDUGAI5CkgDk4vn/aMDeAa1E2wCiuCT/j2aJ/50LFwB9LWIA613h/jhwoP9GdPMBmfk3/4EnEQHxUPQAV0UVAV7kSf9OQkH/wuPnAD2SV/+tmxf/cHTb/tgmC/+DuoUAXtS7AGQvWwDM/q//3hLX/q1EbP/j5E//Jt3VAKPjlv4fvhIAoLMLAQpaXv/crlgAo9Pl/8eINACCX93/jLzn/otxgP91q+z+MdwU/zsUq//kbbwAFOEg/sMQrgDj/ogBhydpAJZNzv/S7uIAN9SE/u85fACqwl3/+RD3/xiXPv8KlwoAT4uy/3jyygAa29UAPn0j/5ACbP/mIVP/US3YAeA+EQDW2X0AYpmZ/7Owav6DXYr/bT4k/7J5IP94/EYA3PglAMxYZwGA3Pv/7OMHAWoxxv88OGsAY3LuANzMXgFJuwEAWZoiAE7Zpf8Ow/n/Ceb9/82H9QAa/Af/VM0bAYYCcAAlniAA51vt/7+qzP+YB94AbcAxAMGmkv/oE7X/aY40/2cQGwH9yKUAw9kE/zS9kP97m6D+V4I2/054Pf8OOCkAGSl9/1eo9QDWpUYA1KkG/9vTwv5IXaT/xSFn/yuOjQCD4awA9GkcAERE4QCIVA3/gjko/otNOABUljUANl+dAJANsf5fc7oAdRd2//Sm8f8LuocAsmrL/2HaXQAr/S0ApJgEAIt27wBgARj+65nT/6huFP8y77AAcinoAMH6NQD+oG/+iHop/2FsQwDXmBf/jNHUACq9owDKKjL/amq9/75E2f/pOnUA5dzzAcUDBAAleDb+BJyG/yQ9q/6liGT/1OgOAFquCgDYxkH/DANAAHRxc//4ZwgA530S/6AcxQAeuCMB30n5/3sULv6HOCX/rQ3lAXehIv/1PUkAzX1wAIlohgDZ9h7/7Y6PAEGfZv9spL4A23Wt/yIleP7IRVAAH3za/koboP+6msf/R8f8AGhRnwERyCcA0z3AARruWwCU2QwAO1vV/wtRt/+B5nr/csuRAXe0Qv9IirQA4JVqAHdSaP/QjCsAYgm2/81lhv8SZSYAX8Wm/8vxkwA+0JH/hfb7AAKpDgAN97gAjgf+ACTIF/9Yzd8AW4E0/xW6HgCP5NIB9+r4/+ZFH/6wuof/7s00AYtPKwARsNn+IPNDAPJv6QAsIwn/43JRAQRHDP8mab8AB3Uy/1FPEAA/REH/nSRu/03xA//iLfsBjhnOAHh70QEc/u7/BYB+/1ve1/+iD78AVvBJAIe5Uf4s8aMA1NvS/3CimwDPZXYAqEg4/8QFNABIrPL/fhad/5JgO/+ieZj+jBBfAMP+yP5SlqIAdyuR/sysTv+m4J8AaBPt//V+0P/iO9UAddnFAJhI7QDcHxf+Dlrn/7zUQAE8Zfb/VRhWAAGxbQCSUyABS7bAAHfx4AC57Rv/uGVSAeslTf/9hhMA6PZ6ADxqswDDCwwAbULrAX1xOwA9KKQAr2jwAAIvu/8yDI0Awou1/4f6aABhXN7/2ZXJ/8vxdv9Pl0MAeo7a/5X17wCKKsj+UCVh/3xwp/8kilf/gh2T//FXTv/MYRMBsdEW//fjf/5jd1P/1BnGARCzswCRTaz+WZkO/9q9pwBr6Tv/IyHz/ixwcP+hf08BzK8KACgViv5odOQAx1+J/4W+qP+SpeoBt2MnALfcNv7/3oUAott5/j/vBgDhZjb/+xL2AAQigQGHJIMAzjI7AQ9htwCr2If/ZZgr/5b7WwAmkV8AIswm/rKMU/8ZgfP/TJAlAGokGv52kKz/RLrl/2uh1f8uo0T/lar9ALsRDwDaoKX/qyP2AWANEwCly3UA1mvA//R7sQFkA2gAsvJh//tMgv/TTSoB+k9G/z/0UAFpZfYAPYg6Ae5b1QAOO2L/p1RNABGELv45r8X/uT64AExAzwCsr9D+r0olAIob0/6UfcIACllRAKjLZf8r1dEB6/U2AB4j4v8JfkYA4n1e/px1FP85+HAB5jBA/6RcpgHg1ub/JHiPADcIK//7AfUBamKlAEprav41BDb/WrKWAQN4e//0BVkBcvo9//6ZUgFNDxEAOe5aAV/f5gDsNC/+Z5Sk/3nPJAESELn/SxRKALsLZQAuMIH/Fu/S/03sgf9vTcz/PUhh/8fZ+/8q18wAhZHJ/znmkgHrZMYAkkkj/mzGFP+2T9L/UmeIAPZssAAiETz/E0py/qiqTv+d7xT/lSmoADp5HABPs4b/53mH/67RYv/zer4Aq6bNANR0MAAdbEL/ot62AQ53FQDVJ/n//t/k/7elxgCFvjAAfNBt/3evVf8J0XkBMKu9/8NHhgGI2zP/tluN/jGfSAAjdvX/cLrj/zuJHwCJLKMAcmc8/gjVlgCiCnH/wmhIANyDdP+yT1wAy/rV/l3Bvf+C/yL+1LyXAIgRFP8UZVP/1M6mAOXuSf+XSgP/qFfXAJu8hf+mgUkA8E+F/7LTUf/LSKP+wailAA6kx/4e/8wAQUhbAaZKZv/IKgD/wnHj/0IX0ADl2GT/GO8aAArpPv97CrIBGiSu/3fbxwEto74AEKgqAKY5xv8cGhoAfqXnAPtsZP895Xn/OnaKAEzPEQANInD+WRCoACXQaf8jydf/KGpl/gbvcgAoZ+L+9n9u/z+nOgCE8I4ABZ5Y/4FJnv9eWZIA5jaSAAgtrQBPqQEAc7r3AFRAgwBD4P3/z71AAJocUQEtuDb/V9Tg/wBgSf+BIesBNEJQ//uum/8EsyUA6qRd/l2v/QDGRVf/4GouAGMd0gA+vHL/LOoIAKmv9/8XbYn/5bYnAMClXv71ZdkAv1hgAMReY/9q7gv+NX7zAF4BZf8ukwIAyXx8/40M2gANpp0BMPvt/5v6fP9qlJL/tg3KABw9pwDZmAj+3IIt/8jm/wE3QVf/Xb9h/nL7DgAgaVwBGs+NABjPDf4VMjD/upR0/9Mr4QAlIqL+pNIq/0QXYP+21gj/9XWJ/0LDMgBLDFP+UIykAAmlJAHkbuMA8RFaARk01AAG3wz/i/M5AAxxSwH2t7//1b9F/+YPjgABw8T/iqsv/0A/agEQqdb/z644AVhJhf+2hYwAsQ4Z/5O4Nf8K46H/eNj0/0lN6QCd7osBO0HpAEb72AEpuJn/IMtwAJKT/QBXZW0BLFKF//SWNf9emOj/O10n/1iT3P9OUQ0BIC/8/6ATcv9dayf/dhDTAbl30f/j23/+WGns/6JuF/8kpm7/W+zd/0LqdABvE/T+CukaACC3Bv4Cv/IA2pw1/ik8Rv+o7G8Aebl+/+6Oz/83fjQA3IHQ/lDMpP9DF5D+2ihs/3/KpADLIQP/Ap4AACVgvP/AMUoAbQQAAG+nCv5b2of/y0Kt/5bC4gDJ/Qb/rmZ5AM2/bgA1wgQAUSgt/iNmj/8MbMb/EBvo//xHugGwbnIAjgN1AXFNjgATnMUBXC/8ADXoFgE2EusALiO9/+zUgQACYND+yO7H/zuvpP+SK+cAwtk0/wPfDACKNrL+VevPAOjPIgAxNDL/pnFZ/wot2P8+rRwAb6X2AHZzW/+AVDwAp5DLAFcN8wAWHuQBsXGS/4Gq5v78mYH/keErAEbnBf96aX7+VvaU/24lmv7RA1sARJE+AOQQpf833fn+stJbAFOS4v5FkroAXdJo/hAZrQDnuiYAvXqM//sNcP9pbl0A+0iqAMAX3/8YA8oB4V3kAJmTx/5tqhYA+GX2/7J8DP+y/mb+NwRBAH3WtAC3YJMALXUX/oS/+QCPsMv+iLc2/5LqsQCSZVb/LHuPASHRmADAWin+Uw99/9WsUgDXqZAAEA0iACDRZP9UEvkBxRHs/9m65gAxoLD/b3Zh/+1o6wBPO1z+RfkL/yOsSgETdkQA3nyl/7RCI/9WrvYAK0pv/36QVv/k6lsA8tUY/kUs6//ctCMACPgH/2YvXP/wzWb/cearAR+5yf/C9kb/ehG7AIZGx/+VA5b/dT9nAEFoe//UNhMBBo1YAFOG8/+INWcAqRu0ALExGABvNqcAwz3X/x8BbAE8KkYAuQOi/8KVKP/2fyb+vncm/z13CAFgodv/KsvdAbHypP/1nwoAdMQAAAVdzf6Af7MAfe32/5Wi2f9XJRT+jO7AAAkJwQBhAeIAHSYKAACIP//lSNL+JoZc/07a0AFoJFT/DAXB//KvPf+/qS4Bs5OT/3G+i/59rB8AA0v8/tckDwDBGxgB/0WV/26BdgDLXfkAiolA/iZGBgCZdN4AoUp7AMFjT/92O17/PQwrAZKxnQAuk78AEP8mAAszHwE8OmL/b8JNAZpb9ACMKJABrQr7AMvRMv5sgk4A5LRaAK4H+gAfrjwAKaseAHRjUv92wYv/u63G/tpvOAC5e9gA+Z40ADS0Xf/JCVv/OC2m/oSby/866G4ANNNZ//0AogEJV7cAkYgsAV569QBVvKsBk1zGAAAIaAAeX64A3eY0Aff36/+JrjX/IxXM/0fj1gHoUsIACzDj/6pJuP/G+/z+LHAiAINlg/9IqLsAhId9/4poYf/uuKj/82hU/4fY4v+LkO0AvImWAVA4jP9Wqaf/wk4Z/9wRtP8RDcEAdYnU/43glwAx9K8AwWOv/xNjmgH/QT7/nNI3//L0A//6DpUAnljZ/53Phv776BwALpz7/6s4uP/vM+oAjoqD/xn+8wEKycIAP2FLANLvogDAyB8BddbzABhH3v42KOj/TLdv/pAOV//WT4j/2MTUAIQbjP6DBf0AfGwT/xzXSwBM3jf+6bY/AESrv/40b97/CmlN/1Cq6wCPGFj/Led5AJSB4AE99lQA/S7b/+9MIQAxlBL+5iVFAEOGFv6Om14AH53T/tUqHv8E5Pf+/LAN/ycAH/7x9P//qi0K/v3e+QDecoQA/y8G/7SjswFUXpf/WdFS/uU0qf/V7AAB1jjk/4d3l/9wycEAU6A1/gaXQgASohEA6WFbAIMFTgG1eDX/dV8//+11uQC/foj/kHfpALc5YQEvybv/p6V3AS1kfgAVYgb+kZZf/3g2mADRYmgAj28e/riU+QDr2C4A+MqU/zlfFgDy4aMA6ffo/0erE/9n9DH/VGdd/0R59AFS4A0AKU8r//nOp//XNBX+wCAW//dvPABlSib/FltU/h0cDf/G59f+9JrIAN+J7QDThA4AX0DO/xE+9//pg3kBXRdNAM3MNP5RvYgAtNuKAY8SXgDMK4z+vK/bAG9ij/+XP6L/0zJH/hOSNQCSLVP+slLu/xCFVP/ixl3/yWEU/3h2I/9yMuf/ouWc/9MaDAByJ3P/ztSGAMXZoP90gV7+x9fb/0vf+QH9dLX/6Ndo/+SC9v+5dVYADgUIAO8dPQHtV4X/fZKJ/syo3wAuqPUAmmkWANzUof9rRRj/idq1//FUxv+CetP/jQiZ/76xdgBgWbIA/xAw/npgaf91Nuj/In5p/8xDpgDoNIr/05MMABk2BwAsD9f+M+wtAL5EgQFqk+EAHF0t/uyND/8RPaEA3HPAAOyRGP5vqKkA4Do//3+kvABS6ksB4J6GANFEbgHZptkARuGmAbvBj/8QB1j/Cs2MAHXAnAEROCYAG3xsAavXN/9f/dQAm4eo//aymf6aREoA6D1g/mmEOwAhTMcBvbCC/wloGf5Lxmb/6QFwAGzcFP9y5kYAjMKF/zmepP6SBlD/qcRhAVW3ggBGnt4BO+3q/2AZGv/or2H/C3n4/lgjwgDbtPz+SgjjAMPjSQG4bqH/MemkAYA1LwBSDnn/wb46ADCudf+EFyAAKAqGARYzGf/wC7D/bjmSAHWP7wGdZXb/NlRMAM24Ev8vBEj/TnBV/8EyQgFdEDT/CGmGAAxtSP86nPsAkCPMACygdf4ya8IAAUSl/29uogCeUyj+TNbqADrYzf+rYJP/KONyAbDj8QBG+bcBiFSL/zx69/6PCXX/sa6J/kn3jwDsuX7/Phn3/y1AOP+h9AYAIjk4AWnKUwCAk9AABmcK/0qKQf9hUGT/1q4h/zKGSv9ul4L+b1SsAFTHS/74O3D/CNiyAQm3XwDuGwj+qs3cAMPlhwBiTO3/4lsaAVLbJ//hvscB2ch5/1GzCP+MQc4Ass9X/vr8Lv9oWW4B/b2e/5DWnv+g9Tb/NbdcARXIwv+SIXEB0QH/AOtqK/+nNOgAneXdADMeGQD63RsBQZNX/097xABBxN//TCwRAVXxRADKt/n/QdTU/wkhmgFHO1AAr8I7/41ICQBkoPQA5tA4ADsZS/5QwsIAEgPI/qCfcwCEj/cBb105/zrtCwGG3of/eqNsAXsrvv/7vc7+ULZI/9D24AERPAkAoc8mAI1tWwDYD9P/iE5uAGKjaP8VUHn/rbK3AX+PBABoPFL+1hAN/2DuIQGelOb/f4E+/zP/0v8+jez+nTfg/3In9ADAvPr/5Ew1AGJUUf+tyz3+kzI3/8zrvwA0xfQAWCvT/hu/dwC855oAQlGhAFzBoAH643gAezfiALgRSACFqAr+Foec/ykZZ/8wyjoAupVR/7yG7wDrtb3+2Yu8/0owUgAu2uUAvf37ADLlDP/Tjb8BgPQZ/6nnev5WL73/hLcX/yWylv8zif0AyE4fABZpMgCCPAAAhKNb/hfnuwDAT+8AnWak/8BSFAEYtWf/8AnqAAF7pP+F6QD/yvLyADy69QDxEMf/4HSe/r99W//gVs8AeSXn/+MJxv8Pme//eejZ/ktwUgBfDDn+M9Zp/5TcYQHHYiQAnNEM/grUNADZtDf+1Kro/9gUVP+d+ocAnWN//gHOKQCVJEYBNsTJ/1d0AP7rq5YAG6PqAMqHtADQXwD+e5xdALc+SwCJ67YAzOH//9aL0v8Ccwj/HQxvADScAQD9Ffv/JaUf/gyC0wBqEjX+KmOaAA7ZPf7YC1z/yMVw/pMmxwAk/Hj+a6lNAAF7n//PS2YAo6/EACwB8AB4urD+DWJM/+188f/okrz/yGDgAMwfKQDQyA0AFeFg/6+cxAD30H4APrj0/gKrUQBVc54ANkAt/xOKcgCHR80A4y+TAdrnQgD90RwA9A+t/wYPdv4QltD/uRYy/1Zwz/9LcdcBP5Ir/wThE/7jFz7/Dv/W/i0Izf9XxZf+0lLX//X49/+A+EYA4fdXAFp4RgDV9VwADYXiAC+1BQFco2n/Bh6F/uiyPf/mlRj/EjGeAORkPf508/v/TUtcAVHbk/9Mo/7+jdX2AOglmP5hLGQAySUyAdT0OQCuq7f/+UpwAKacHgDe3WH/811J/vtlZP/Y2V3//oq7/46+NP87y7H/yF40AHNynv+lmGgBfmPi/3ad9AFryBAAwVrlAHkGWACcIF3+ffHT/w7tnf+lmhX/uOAW//oYmP9xTR8A96sX/+2xzP80iZH/wrZyAODqlQAKb2cByYEEAO6OTgA0Bij/btWl/jzP/QA+10UAYGEA/zEtygB4eRb/64swAcYtIv+2MhsBg9Jb/y42gACve2n/xo1O/kP07//1Nmf+Tiby/wJc+f77rlf/iz+QABhsG/8iZhIBIhaYAELldv4yj2MAkKmVAXYemACyCHkBCJ8SAFpl5v+BHXcARCQLAei3NwAX/2D/oSnB/z+L3gAPs/MA/2QP/1I1hwCJOZUBY/Cq/xbm5P4xtFL/PVIrAG712QDHfT0ALv00AI3F2wDTn8EAN3lp/rcUgQCpd6r/y7KL/4cotv+sDcr/QbKUAAjPKwB6NX8BSqEwAOPWgP5WC/P/ZFYHAfVEhv89KxUBmFRe/748+v7vduj/1oglAXFMa/9daGQBkM4X/26WmgHkZ7kA2jEy/odNi/+5AU4AAKGU/2Ed6f/PlJX/oKgAAFuAq/8GHBP+C2/3ACe7lv+K6JUAdT5E/z/YvP/r6iD+HTmg/xkM8QGpPL8AIION/+2fe/9exV7+dP4D/1yzYf55YVz/qnAOABWV+AD44wMAUGBtAEvASgEMWuL/oWpEAdByf/9yKv/+ShpK//ezlv55jDwAk0bI/9Yoof+hvMn/jUGH//Jz/AA+L8oAtJX//oI37QClEbr/CqnCAJxt2v9wjHv/aIDf/rGObP95Jdv/gE0S/29sFwFbwEsArvUW/wTsPv8rQJkB463+AO16hAF/Wbr/jlKA/vxUrgBas7EB89ZX/2c8ov/Qgg7/C4KLAM6B2/9e2Z3/7+bm/3Rzn/6ka18AM9oCAdh9xv+MyoD+C19E/zcJXf6umQb/zKxgAEWgbgDVJjH+G1DVAHZ9cgBGRkP/D45J/4N6uf/zFDL+gu0oANKfjAHFl0H/VJlCAMN+WgAQ7uwBdrtm/wMYhf+7ReYAOMVcAdVFXv9QiuUBzgfmAN5v5gFb6Xf/CVkHAQJiAQCUSoX/M/a0/+SxcAE6vWz/wsvt/hXRwwCTCiMBVp3iAB+ji/44B0v/Plp0ALU8qQCKotT+UacfAM1acP8hcOMAU5d1AbHgSf+ukNn/5sxP/xZN6P9yTuoA4Dl+/gkxjQDyk6UBaLaM/6eEDAF7RH8A4VcnAftsCADGwY8BeYfP/6wWRgAyRHT/Za8o//hp6QCmywcAbsXaANf+Gv6o4v0AH49gAAtnKQC3gcv+ZPdK/9V+hADSkywAx+obAZQvtQCbW54BNmmv/wJOkf5mml8AgM9//jR87P+CVEcA3fPTAJiqzwDeascAt1Re/lzIOP+KtnMBjmCSAIWI5ABhEpYAN/tCAIxmBADKZ5cAHhP4/zO4zwDKxlkAN8Xh/qlf+f9CQUT/vOp+AKbfZAFw7/QAkBfCADontgD0LBj+r0Sz/5h2mgGwooIA2XLM/q1+Tv8h3h7/JAJb/wKP8wAJ69cAA6uXARjX9f+oL6T+8ZLPAEWBtABE83EAkDVI/vstDgAXbqgARERP/25GX/6uW5D/Ic5f/4kpB/8Tu5n+I/9w/wmRuf4ynSUAC3AxAWYIvv/q86kBPFUXAEonvQB0Me8ArdXSAC6hbP+fliUAxHi5/yJiBv+Zwz7/YeZH/2Y9TAAa1Oz/pGEQAMY7kgCjF8QAOBg9ALViwQD7k+X/Yr0Y/y42zv/qUvYAt2cmAW0+zAAK8OAAkhZ1/46aeABF1CMA0GN2AXn/A/9IBsIAdRHF/30PFwCaT5kA1l7F/7k3k/8+/k7+f1KZAG5mP/9sUqH/abvUAVCKJwA8/13/SAy6ANL7HwG+p5D/5CwT/oBD6ADW+Wv+iJFW/4QusAC9u+P/0BaMANnTdAAyUbr+i/ofAB5AxgGHm2QAoM4X/rui0/8QvD8A/tAxAFVUvwDxwPL/mX6RAeqiov/mYdgBQId+AL6U3wE0ACv/HCe9AUCI7gCvxLkAYuLV/3+f9AHirzwAoOmOAbTzz/9FmFkBH2UVAJAZpP6Lv9EAWxl5ACCTBQAnunv/P3Pm/12nxv+P1dz/s5wT/xlCegDWoNn/Ai0+/2pPkv4ziWP/V2Tn/6+R6P9luAH/rgl9AFIloQEkco3/MN6O//W6mgAFrt3+P3Kb/4c3oAFQH4cAfvqzAezaLQAUHJEBEJNJAPm9hAERvcD/347G/0gUD//6Ne3+DwsSABvTcf7Vazj/rpOS/2B+MAAXwW0BJaJeAMed+f4YgLv/zTGy/l2kKv8rd+sBWLft/9rSAf9r/ioA5gpj/6IA4gDb7VsAgbLLANAyX/7O0F//979Z/m7qT/+lPfMAFHpw//b2uf5nBHsA6WPmAdtb/P/H3hb/s/Xp/9Px6gBv+sD/VVSIAGU6Mv+DrZz+dy0z/3bpEP7yWtYAXp/bAQMD6v9iTFz+UDbmAAXk5/41GN//cTh2ARSEAf+r0uwAOPGe/7pzE/8I5a4AMCwAAXJypv8GSeL/zVn0AInjSwH4rTgASnj2/ncDC/9ReMb/iHpi/5Lx3QFtwk7/3/FGAdbIqf9hvi//L2eu/2NcSP526bT/wSPp/hrlIP/e/MYAzCtH/8dUrACGZr4Ab+5h/uYo5gDjzUD+yAzhAKYZ3gBxRTP/j58YAKe4SgAd4HT+ntDpAMF0fv/UC4X/FjqMAcwkM//oHisA60a1/0A4kv6pElT/4gEN/8gysP801fX+qNFhAL9HNwAiTpwA6JA6AblKvQC6jpX+QEV//6HLk/+wl78AiOfL/qO2iQChfvv+6SBCAETPQgAeHCUAXXJgAf5c9/8sq0UAyncL/7x2MgH/U4j/R1IaAEbjAgAg63kBtSmaAEeG5f7K/yQAKZgFAJo/Sf8itnwAed2W/xrM1QEprFcAWp2S/22CFABHa8j/82a9AAHDkf4uWHUACM7jAL9u/f9tgBT+hlUz/4mxcAHYIhb/gxDQ/3mVqgByExcBplAf/3HwegDos/oARG60/tKqdwDfbKT/z0/p/xvl4v7RYlH/T0QHAIO5ZACqHaL/EaJr/zkVCwFkyLX/f0GmAaWGzABop6gAAaRPAJKHOwFGMoD/ZncN/uMGhwCijrP/oGTeABvg2wGeXcP/6o2JABAYff/uzi//YRFi/3RuDP9gc00AW+Po//j+T/9c5Qb+WMaLAM5LgQD6Tc7/jfR7AYpF3AAglwYBg6cW/+1Ep/7HvZYAo6uK/zO8Bv9fHYn+lOKzALVr0P+GH1L/l2Ut/4HK4QDgSJMAMIqX/8NAzv7t2p4Aah2J/v296f9nDxH/wmH/ALItqf7G4ZsAJzB1/4dqcwBhJrUAli9B/1OC5f72JoEAXO+a/ltjfwChbyH/7tny/4O5w//Vv57/KZbaAISpgwBZVPwBq0aA/6P4y/4BMrT/fExVAftvUABjQu//mu22/91+hf5KzGP/QZN3/2M4p/9P+JX/dJvk/+0rDv5FiQv/FvrxAVt6j//N+fMA1Bo8/zC2sAEwF7//y3mY/i1K1f8+WhL+9aPm/7lqdP9TI58ADCEC/1AiPgAQV67/rWVVAMokUf6gRcz/QOG7ADrOXgBWkC8A5Vb1AD+RvgElBScAbfsaAImT6gCieZH/kHTO/8Xouf+3voz/SQz+/4sU8v+qWu//YUK7//W1h/7eiDQA9QUz/ssvTgCYZdgASRd9AP5gIQHr0kn/K9FYAQeBbQB6aOT+qvLLAPLMh//KHOn/QQZ/AJ+QRwBkjF8ATpYNAPtrdgG2On3/ASZs/4290f8Im30BcaNb/3lPvv+G72z/TC/4AKPk7wARbwoAWJVL/9fr7wCnnxj/L5ds/2vRvADp52P+HMqU/64jiv9uGET/AkW1AGtmUgBm7QcAXCTt/92iUwE3ygb/h+qH/xj63gBBXqj+9fjS/6dsyf7/oW8AzQj+AIgNdABksIT/K9d+/7GFgv+eT5QAQ+AlAQzOFf8+Im4B7Wiv/1CEb/+OrkgAVOW0/mmzjABA+A//6YoQAPVDe/7aedT/P1/aAdWFif+PtlL/MBwLAPRyjQHRr0z/nbWW/7rlA/+knW8B572LAHfKvv/aakD/ROs//mAarP+7LwsB1xL7/1FUWQBEOoAAXnEFAVyB0P9hD1P+CRy8AO8JpAA8zZgAwKNi/7gSPADZtosAbTt4/wTA+wCp0vD/Jaxc/pTT9f+zQTQA/Q1zALmuzgFyvJX/7VqtACvHwP9YbHEANCNMAEIZlP/dBAf/l/Fy/77R6ABiMscAl5bV/xJKJAE1KAcAE4dB/xqsRQCu7VUAY18pAAM4EAAnoLH/yGra/rlEVP9buj3+Q4+N/w30pv9jcsYAx26j/8ESugB87/YBbkQWAALrLgHUPGsAaSppAQ7mmAAHBYMAjWia/9UDBgCD5KL/s2QcAed7Vf/ODt8B/WDmACaYlQFiiXoA1s0D/+KYs/8GhYkAnkWM/3Gimv+086z/G71z/48u3P/VhuH/fh1FALwriQHyRgkAWsz//+eqkwAXOBP+OH2d/zCz2v9Ptv3/JtS/ASnrfABglxwAh5S+AM35J/40YIj/1CyI/0PRg//8ghf/24AU/8aBdgBsZQsAsgWSAT4HZP+17F7+HBqkAEwWcP94Zk8AysDlAciw1wApQPT/zrhOAKctPwGgIwD/OwyO/8wJkP/bXuUBehtwAL1pbf9A0Er/+383AQLixgAsTNEAl5hN/9IXLgHJq0X/LNPnAL4l4P/1xD7/qbXe/yLTEQB38cX/5SOYARVFKP+y4qEAlLPBANvC/gEozjP/51z6AUOZqgAVlPEAqkVS/3kS5/9ccgMAuD7mAOHJV/+SYKL/tfLcAK273QHiPqr/OH7ZAXUN4/+zLO8AnY2b/5DdUwDr0dAAKhGlAftRhQB89cn+YdMY/1PWpgCaJAn/+C9/AFrbjP+h2Sb+1JM//0JUlAHPAwEA5oZZAX9Oev/gmwH/UohKALKc0P+6GTH/3gPSAeWWvv9VojT/KVSN/0l7VP5dEZYAdxMcASAW1/8cF8z/jvE0/+Q0fQAdTM8A16f6/q+k5gA3z2kBbbv1/6Es3AEpZYD/pxBeAF3Wa/92SAD+UD3q/3mvfQCLqfsAYSeT/vrEMf+ls27+30a7/xaOfQGas4r/drAqAQqumQCcXGYAqA2h/48QIAD6xbT/y6MsAVcgJAChmRT/e/wPABnjUAA8WI4AERbJAZrNTf8nPy8ACHqNAIAXtv7MJxP/BHAd/xckjP/S6nT+NTI//3mraP+g214AV1IO/ucqBQCli3/+Vk4mAII8Qv7LHi3/LsR6Afk1ov+Ij2f+19JyAOcHoP6pmCr/by32AI6Dh/+DR8z/JOILAAAc8v/hitX/9y7Y/vUDtwBs/EoBzhow/8029v/TxiT/eSMyADTYyv8mi4H+8kmUAEPnjf8qL8wATnQZAQThv/8Gk+QAOlixAHql5f/8U8n/4KdgAbG4nv/yabMB+MbwAIVCywH+JC8ALRhz/3c+/gDE4br+e42sABpVKf/ib7cA1eeXAAQ7B//uipQAQpMh/x/2jf/RjXT/aHAfAFihrABT1+b+L2+XAC0mNAGELcwAioBt/ul1hv/zvq3+8ezwAFJ/7P4o36H/brbh/3uu7wCH8pEBM9GaAJYDc/7ZpPz/N5xFAVRe///oSS0BFBPU/2DFO/5g+yEAJsdJAUCs9/91dDj/5BESAD6KZwH25aT/9HbJ/lYgn/9tIokBVdO6AArBwf56wrEAeu5m/6LaqwBs2aEBnqoiALAvmwG15Av/CJwAABBLXQDOYv8BOpojAAzzuP5DdUL/5uV7AMkqbgCG5LL+umx2/zoTmv9SqT7/co9zAe/EMv+tMMH/kwJU/5aGk/5f6EkAbeM0/r+JCgAozB7+TDRh/6TrfgD+fLwASrYVAXkdI//xHgf+VdrW/wdUlv5RG3X/oJ+Y/kIY3f/jCjwBjYdmANC9lgF1s1wAhBaI/3jHHAAVgU/+tglBANqjqQD2k8b/ayaQAU6vzf/WBfr+L1gd/6QvzP8rNwb/g4bP/nRk1gBgjEsBatyQAMMgHAGsUQX/x7M0/yVUywCqcK4ACwRbAEX0GwF1g1wAIZiv/4yZa//7hyv+V4oE/8bqk/55mFT/zWWbAZ0JGQBIahH+bJkA/73lugDBCLD/rpXRAO6CHQDp1n4BPeJmADmjBAHGbzP/LU9OAXPSCv/aCRn/novG/9NSu/5QhVMAnYHmAfOFhv8oiBAATWtP/7dVXAGxzMoAo0eT/5hFvgCsM7wB+tKs/9PycQFZWRr/QEJv/nSYKgChJxv/NlD+AGrRcwFnfGEA3eZi/x/nBgCywHj+D9nL/3yeTwBwkfcAXPowAaO1wf8lL47+kL2l/y6S8AAGS4AAKZ3I/ld51QABcewABS36AJAMUgAfbOcA4e93/6cHvf+75IT/br0iAF4szAGiNMUATrzx/jkUjQD0ki8BzmQzAH1rlP4bw00AmP1aAQePkP8zJR8AIncm/wfFdgCZvNMAlxR0/vVBNP+0/W4BL7HRAKFjEf923soAfbP8AXs2fv+ROb8AN7p5AArzigDN0+X/fZzx/pScuf/jE7z/fCkg/x8izv4ROVMAzBYl/ypgYgB3ZrgBA74cAG5S2v/IzMD/yZF2AHXMkgCEIGIBwMJ5AGqh+AHtWHwAF9QaAM2rWv/4MNgBjSXm/3zLAP6eqB7/1vgVAHC7B/9Lhe//SuPz//qTRgDWeKIApwmz/xaeEgDaTdEBYW1R//Qhs/85NDn/QazS//lH0f+Oqe4Anr2Z/67+Z/5iIQ4AjUzm/3GLNP8POtQAqNfJ//jM1wHfRKD/OZq3/i/neQBqpokAUYiKAKUrMwDniz0AOV87/nZiGf+XP+wBXr76/6m5cgEF+jr/S2lhAdffhgBxY6MBgD5wAGNqkwCjwwoAIc22ANYOrv+BJuf/NbbfAGIqn//3DSgAvNKxAQYVAP//PZT+iS2B/1kadP5+JnIA+zLy/nmGgP/M+af+pevXAMqx8wCFjT4A8IK+AW6v/wAAFJIBJdJ5/wcnggCO+lT/jcjPAAlfaP8L9K4Ahuh+AKcBe/4QwZX/6OnvAdVGcP/8dKD+8t7c/81V4wAHuToAdvc/AXRNsf8+9cj+PxIl/2s16P4y3dMAotsH/gJeKwC2Prb+oE7I/4eMqgDruOQArzWK/lA6Tf+YyQIBP8QiAAUeuACrsJoAeTvOACZjJwCsUE3+AIaXALoh8f5e/d//LHL8AGx+Of/JKA3/J+Ub/yfvFwGXeTP/mZb4AArqrv929gT+yPUmAEWh8gEQspYAcTiCAKsfaQAaWGz/MSpqAPupQgBFXZUAFDn+AKQZbwBavFr/zATFACjVMgHUYIT/WIq0/uSSfP+49vcAQXVW//1m0v7+eSQAiXMD/zwY2ACGEh0AO+JhALCORwAH0aEAvVQz/pv6SADVVOv/Ld7gAO6Uj/+qKjX/Tqd1ALoAKP99sWf/ReFCAOMHWAFLrAYAqS3jARAkRv8yAgn/i8EWAI+35/7aRTIA7DihAdWDKgCKkSz+iOUo/zE/I/89kfX/ZcAC/uincQCYaCYBebnaAHmL0/538CMAQb3Z/ruzov+gu+YAPvgO/zxOYQD/96P/4Ttb/2tHOv/xLyEBMnXsANuxP/70WrMAI8LX/71DMv8Xh4EAaL0l/7k5wgAjPuf/3PhsAAznsgCPUFsBg11l/5AnAgH/+rIABRHs/osgLgDMvCb+9XM0/79xSf6/bEX/FkX1ARfLsgCqY6oAQfhvACVsmf9AJUUAAFg+/lmUkP+/ROAB8Sc1ACnL7f+RfsL/3Sr9/xljlwBh/d8BSnMx/wavSP87sMsAfLf5AeTkYwCBDM/+qMDD/8ywEP6Y6qsATSVV/yF4h/+OwuMBH9Y6ANW7ff/oLjz/vnQq/peyE/8zPu3+zOzBAMLoPACsIp3/vRC4/mcDX/+N6ST+KRkL/xXDpgB29S0AQ9WV/58MEv+7pOMBoBkFAAxOwwErxeEAMI4p/sSbPP/fxxIBkYicAPx1qf6R4u4A7xdrAG21vP/mcDH+Sart/+e34/9Q3BQAwmt/AX/NZQAuNMUB0qsk/1gDWv84l40AYLv//ypOyAD+RkYB9H2oAMxEigF810YAZkLI/hE05AB13I/+y/h7ADgSrv+6l6T/M+jQAaDkK//5HRkBRL4/AA0AAAAA/wAAAAD1AAAAAAAA+wAAAAAAAP0AAAAA8wAAAAAHAAAAAAADAAAAAPMAAAAABQAAAAAAAAAACwAAAAAACwAAAADzAAAAAAAA/QAAAAAA/wAAAAADAAAAAPUAAAAAAAAADwAAAAAA/wAAAAD/AAAAAAcAAAAABQBBjIcCCwEBAEGwhwILAQEAQdCHAgugAeDrenw7QbiuFlbj+vGfxGraCY3rnDKx/YZiBRZfSbgAX5yVvKNQjCSx0LFVnIPvWwREXMRYHI6G2CJO3dCfEVfs////////////////////////////////////////f+3///////////////////////////////////////9/7v///////////////////////////////////////38AQZCJAgvBBQjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4FsirijXmC+KQs1l7yORRDdxLztN7M/7wLW824mBpdu16Ti1SPNbwlY5GdAFtvER8VmbTxmvpII/khiBbdrVXhyrQgIDo5iqB9i+b3BFAVuDEoyy5E6+hTEk4rT/1cN9DFVviXvydF2+crGWFjv+sd6ANRLHJacG3JuUJmnPdPGbwdJK8Z7BaZvk4yVPOIZHvu+11YyLxp3BD2WcrHfMoQwkdQIrWW8s6S2D5KZuqoR0StT7Qb3cqbBctVMRg9qI+Xar32buUlE+mBAytC1txjGoPyH7mMgnA7DkDu++x39Zv8KPqD3zC+DGJacKk0eRp9VvggPgUWPKBnBuDgpnKSkU/C/SRoUKtycmySZcOCEbLu0qxFr8bSxN37OVnRMNOFPeY6+LVHMKZaiydzy7Cmp25q7tRy7JwoE7NYIUhSxykmQD8Uyh6L+iATBCvEtmGqiRl/jQcItLwjC+VAajUWzHGFLv1hnoktEQqWVVJAaZ1iogcVeFNQ70uNG7MnCgahDI0NK4FsGkGVOrQVEIbDcemeuO30x3SCeoSJvhtbywNGNaycWzDBw5y4pB40qq2E5z42N3T8qcW6O4stbzby5o/LLvXe6Cj3RgLxdDb2OleHKr8KEUeMiE7DlkGggCx4woHmMj+v++kOm9gt7rbFCkFXnGsvej+b4rU3Lj8nhxxpxhJurOPifKB8LAIce4htEe6+DN1n3a6njRbu5/T331um8Xcqpn8AammMiixX1jCq4N+b4EmD8RG0ccEzULcRuEfQQj9XfbKJMkx0B7q8oyvL7JFQq+njxMDRCcxGcdQ7ZCPsu+1MVMKn5l/Jwpf1ns+tY6q2/LXxdYR0qMGURsgABB0I8CCyFTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucwEAQaCQAgs1cI0BAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0=") || (K = _, _ = i.locateFile ? i.locateFile(K, r) : r + K);
          var x = { 34904: () => i.getRandomValue(), 34940: () => {
            if (void 0 === i.getRandomValue)
              try {
                var A4 = "object" == typeof window ? window : self, I4 = void 0 !== A4.crypto ? A4.crypto : A4.msCrypto, g3 = function() {
                  var A5 = new Uint32Array(1);
                  return I4.getRandomValues(A5), A5[0] >>> 0;
                };
                g3(), i.getRandomValue = g3;
              } catch (A5) {
                try {
                  var C2 = require("crypto"), B2 = function() {
                    var A6 = C2.randomBytes(4);
                    return (A6[0] << 24 | A6[1] << 16 | A6[2] << 8 | A6[3]) >>> 0;
                  };
                  B2(), i.getRandomValue = B2;
                } catch (A6) {
                  throw "No secure random number generator found";
                }
              }
          } };
          function j(A4) {
            for (; A4.length > 0; )
              A4.shift()(i);
          }
          var X = [];
          function q(A4) {
            var I4 = c.buffer;
            try {
              return c.grow(A4 - I4.byteLength + 65535 >>> 16), H(), 1;
            } catch (A5) {
            }
          }
          var z = "function" == typeof atob ? atob : function(A4) {
            var I4, g3, C2, B2, Q2, i2, E2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o2 = "", a2 = 0;
            A4 = A4.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
              I4 = E2.indexOf(A4.charAt(a2++)) << 2 | (B2 = E2.indexOf(A4.charAt(a2++))) >> 4, g3 = (15 & B2) << 4 | (Q2 = E2.indexOf(A4.charAt(a2++))) >> 2, C2 = (3 & Q2) << 6 | (i2 = E2.indexOf(A4.charAt(a2++))), o2 += String.fromCharCode(I4), 64 !== Q2 && (o2 += String.fromCharCode(g3)), 64 !== i2 && (o2 += String.fromCharCode(C2));
            } while (a2 < A4.length);
            return o2;
          };
          function V(A4) {
            if (d(A4))
              return function(A5) {
                if ("boolean" == typeof n && n) {
                  var I4 = Buffer.from(A5, "base64");
                  return new Uint8Array(I4.buffer, I4.byteOffset, I4.byteLength);
                }
                try {
                  for (var g3 = z(A5), C2 = new Uint8Array(g3.length), B2 = 0; B2 < g3.length; ++B2)
                    C2[B2] = g3.charCodeAt(B2);
                  return C2;
                } catch (A6) {
                  throw new Error("Converting base64 string to bytes failed.");
                }
              }(A4.slice(m.length));
          }
          var O, T = { b: function(A4, I4, g3, C2) {
            b("Assertion failed: " + S(A4) + ", at: " + [I4 ? S(I4) : "unknown filename", g3, C2 ? S(C2) : "unknown function"]);
          }, c: function() {
            b("");
          }, a: function(A4, I4, g3) {
            return function(A5, I5, g4) {
              var C2 = function(A6, I6) {
                var g5;
                for (X.length = 0, I6 >>= 2; g5 = w[A6++]; )
                  I6 += 105 != g5 & I6, X.push(105 == g5 ? s[I6] : k[I6++ >> 1]), ++I6;
                return X;
              }(I5, g4);
              return x[A5].apply(null, C2);
            }(A4, I4, g3);
          }, d: function(A4, I4, g3) {
            w.copyWithin(A4, I4, I4 + g3);
          }, e: function(A4) {
            var I4, g3 = w.length, C2 = 2147483648;
            if ((A4 >>>= 0) > C2)
              return false;
            for (var B2 = 1; B2 <= 4; B2 *= 2) {
              var Q2 = g3 * (1 + 0.2 / B2);
              if (Q2 = Math.min(Q2, A4 + 100663296), q(Math.min(C2, (I4 = Math.max(A4, Q2)) + (65536 - I4 % 65536) % 65536)))
                return true;
            }
            return false;
          } };
          function W() {
            function A4() {
              O || (O = true, i.calledRun = true, F || (j(G), i.onRuntimeInitialized && i.onRuntimeInitialized(), function() {
                if (i.postRun)
                  for ("function" == typeof i.postRun && (i.postRun = [i.postRun]); i.postRun.length; )
                    A5 = i.postRun.shift(), U.unshift(A5);
                var A5;
                j(U);
              }()));
            }
            J > 0 || (function() {
              if (i.preRun)
                for ("function" == typeof i.preRun && (i.preRun = [i.preRun]); i.preRun.length; )
                  A5 = i.preRun.shift(), M.unshift(A5);
              var A5;
              j(M);
            }(), J > 0 || (i.setStatus ? (i.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                i.setStatus("");
              }, 1), A4();
            }, 1)) : A4()));
          }
          if (function() {
            var A4 = { a: T };
            function I4(A5, I5) {
              var g4 = A5.exports;
              i.asm = g4, c = i.asm.f, H(), i.asm.ac, function(A6) {
                if (J--, i.monitorRunDependencies && i.monitorRunDependencies(J), 0 == J && (null !== N && (clearInterval(N), N = null), Y)) {
                  var I6 = Y;
                  Y = null, I6();
                }
              }();
            }
            function g3(A5) {
              I4(A5.instance);
            }
            function C2(I5) {
              return function() {
                if (!e && (o || a)) {
                  if ("function" == typeof fetch && !L(_))
                    return fetch(_, { credentials: "same-origin" }).then(function(A5) {
                      if (!A5.ok)
                        throw "failed to load wasm binary file at '" + _ + "'";
                      return A5.arrayBuffer();
                    }).catch(function() {
                      return R(_);
                    });
                  if (B)
                    return new Promise(function(A5, I6) {
                      B(_, function(I7) {
                        A5(new Uint8Array(I7));
                      }, I6);
                    });
                }
                return Promise.resolve().then(function() {
                  return R(_);
                });
              }().then(function(I6) {
                return WebAssembly.instantiate(I6, A4);
              }).then(function(A5) {
                return A5;
              }).then(I5, function(A5) {
                y("failed to asynchronously prepare wasm: " + A5), b(A5);
              });
            }
            if (J++, i.monitorRunDependencies && i.monitorRunDependencies(J), i.instantiateWasm)
              try {
                return i.instantiateWasm(A4, I4);
              } catch (A5) {
                return y("Module.instantiateWasm callback failed with error: " + A5), false;
              }
            e || "function" != typeof WebAssembly.instantiateStreaming || d(_) || L(_) || n || "function" != typeof fetch ? C2(g3) : fetch(_, { credentials: "same-origin" }).then(function(I5) {
              return WebAssembly.instantiateStreaming(I5, A4).then(g3, function(A5) {
                return y("wasm streaming compile failed: " + A5), y("falling back to ArrayBuffer instantiation"), C2(g3);
              });
            });
          }(), i._crypto_aead_chacha20poly1305_encrypt_detached = function() {
            return (i._crypto_aead_chacha20poly1305_encrypt_detached = i.asm.g).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_encrypt = function() {
            return (i._crypto_aead_chacha20poly1305_encrypt = i.asm.h).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_encrypt_detached = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_encrypt_detached = i.asm.i).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_encrypt = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_encrypt = i.asm.j).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_decrypt_detached = function() {
            return (i._crypto_aead_chacha20poly1305_decrypt_detached = i.asm.k).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_decrypt = function() {
            return (i._crypto_aead_chacha20poly1305_decrypt = i.asm.l).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_decrypt_detached = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_decrypt_detached = i.asm.m).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_decrypt = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_decrypt = i.asm.n).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_keybytes = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_keybytes = i.asm.o).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_npubbytes = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_npubbytes = i.asm.p).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_nsecbytes = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_nsecbytes = i.asm.q).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_abytes = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_abytes = i.asm.r).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_messagebytes_max = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_messagebytes_max = i.asm.s).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_ietf_keygen = function() {
            return (i._crypto_aead_chacha20poly1305_ietf_keygen = i.asm.t).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_keybytes = function() {
            return (i._crypto_aead_chacha20poly1305_keybytes = i.asm.u).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_npubbytes = function() {
            return (i._crypto_aead_chacha20poly1305_npubbytes = i.asm.v).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_nsecbytes = function() {
            return (i._crypto_aead_chacha20poly1305_nsecbytes = i.asm.w).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_abytes = function() {
            return (i._crypto_aead_chacha20poly1305_abytes = i.asm.x).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_messagebytes_max = function() {
            return (i._crypto_aead_chacha20poly1305_messagebytes_max = i.asm.y).apply(null, arguments);
          }, i._crypto_aead_chacha20poly1305_keygen = function() {
            return (i._crypto_aead_chacha20poly1305_keygen = i.asm.z).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_encrypt_detached = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_encrypt_detached = i.asm.A).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_encrypt = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_encrypt = i.asm.B).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_decrypt_detached = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_decrypt_detached = i.asm.C).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_decrypt = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_decrypt = i.asm.D).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_keybytes = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_keybytes = i.asm.E).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_npubbytes = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_npubbytes = i.asm.F).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_nsecbytes = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_nsecbytes = i.asm.G).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_abytes = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_abytes = i.asm.H).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_messagebytes_max = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_messagebytes_max = i.asm.I).apply(null, arguments);
          }, i._crypto_aead_xchacha20poly1305_ietf_keygen = function() {
            return (i._crypto_aead_xchacha20poly1305_ietf_keygen = i.asm.J).apply(null, arguments);
          }, i._crypto_auth_bytes = function() {
            return (i._crypto_auth_bytes = i.asm.K).apply(null, arguments);
          }, i._crypto_auth_keybytes = function() {
            return (i._crypto_auth_keybytes = i.asm.L).apply(null, arguments);
          }, i._crypto_auth = function() {
            return (i._crypto_auth = i.asm.M).apply(null, arguments);
          }, i._crypto_auth_verify = function() {
            return (i._crypto_auth_verify = i.asm.N).apply(null, arguments);
          }, i._crypto_auth_keygen = function() {
            return (i._crypto_auth_keygen = i.asm.O).apply(null, arguments);
          }, i._crypto_box_seedbytes = function() {
            return (i._crypto_box_seedbytes = i.asm.P).apply(null, arguments);
          }, i._crypto_box_publickeybytes = function() {
            return (i._crypto_box_publickeybytes = i.asm.Q).apply(null, arguments);
          }, i._crypto_box_secretkeybytes = function() {
            return (i._crypto_box_secretkeybytes = i.asm.R).apply(null, arguments);
          }, i._crypto_box_beforenmbytes = function() {
            return (i._crypto_box_beforenmbytes = i.asm.S).apply(null, arguments);
          }, i._crypto_box_noncebytes = function() {
            return (i._crypto_box_noncebytes = i.asm.T).apply(null, arguments);
          }, i._crypto_box_macbytes = function() {
            return (i._crypto_box_macbytes = i.asm.U).apply(null, arguments);
          }, i._crypto_box_messagebytes_max = function() {
            return (i._crypto_box_messagebytes_max = i.asm.V).apply(null, arguments);
          }, i._crypto_box_seed_keypair = function() {
            return (i._crypto_box_seed_keypair = i.asm.W).apply(null, arguments);
          }, i._crypto_box_keypair = function() {
            return (i._crypto_box_keypair = i.asm.X).apply(null, arguments);
          }, i._crypto_box_beforenm = function() {
            return (i._crypto_box_beforenm = i.asm.Y).apply(null, arguments);
          }, i._crypto_box_detached_afternm = function() {
            return (i._crypto_box_detached_afternm = i.asm.Z).apply(null, arguments);
          }, i._crypto_box_detached = function() {
            return (i._crypto_box_detached = i.asm._).apply(null, arguments);
          }, i._crypto_box_easy_afternm = function() {
            return (i._crypto_box_easy_afternm = i.asm.$).apply(null, arguments);
          }, i._crypto_box_easy = function() {
            return (i._crypto_box_easy = i.asm.aa).apply(null, arguments);
          }, i._crypto_box_open_detached_afternm = function() {
            return (i._crypto_box_open_detached_afternm = i.asm.ba).apply(null, arguments);
          }, i._crypto_box_open_detached = function() {
            return (i._crypto_box_open_detached = i.asm.ca).apply(null, arguments);
          }, i._crypto_box_open_easy_afternm = function() {
            return (i._crypto_box_open_easy_afternm = i.asm.da).apply(null, arguments);
          }, i._crypto_box_open_easy = function() {
            return (i._crypto_box_open_easy = i.asm.ea).apply(null, arguments);
          }, i._crypto_box_seal = function() {
            return (i._crypto_box_seal = i.asm.fa).apply(null, arguments);
          }, i._crypto_box_seal_open = function() {
            return (i._crypto_box_seal_open = i.asm.ga).apply(null, arguments);
          }, i._crypto_box_sealbytes = function() {
            return (i._crypto_box_sealbytes = i.asm.ha).apply(null, arguments);
          }, i._crypto_generichash_bytes_min = function() {
            return (i._crypto_generichash_bytes_min = i.asm.ia).apply(null, arguments);
          }, i._crypto_generichash_bytes_max = function() {
            return (i._crypto_generichash_bytes_max = i.asm.ja).apply(null, arguments);
          }, i._crypto_generichash_bytes = function() {
            return (i._crypto_generichash_bytes = i.asm.ka).apply(null, arguments);
          }, i._crypto_generichash_keybytes_min = function() {
            return (i._crypto_generichash_keybytes_min = i.asm.la).apply(null, arguments);
          }, i._crypto_generichash_keybytes_max = function() {
            return (i._crypto_generichash_keybytes_max = i.asm.ma).apply(null, arguments);
          }, i._crypto_generichash_keybytes = function() {
            return (i._crypto_generichash_keybytes = i.asm.na).apply(null, arguments);
          }, i._crypto_generichash_statebytes = function() {
            return (i._crypto_generichash_statebytes = i.asm.oa).apply(null, arguments);
          }, i._crypto_generichash = function() {
            return (i._crypto_generichash = i.asm.pa).apply(null, arguments);
          }, i._crypto_generichash_init = function() {
            return (i._crypto_generichash_init = i.asm.qa).apply(null, arguments);
          }, i._crypto_generichash_update = function() {
            return (i._crypto_generichash_update = i.asm.ra).apply(null, arguments);
          }, i._crypto_generichash_final = function() {
            return (i._crypto_generichash_final = i.asm.sa).apply(null, arguments);
          }, i._crypto_generichash_keygen = function() {
            return (i._crypto_generichash_keygen = i.asm.ta).apply(null, arguments);
          }, i._crypto_hash_bytes = function() {
            return (i._crypto_hash_bytes = i.asm.ua).apply(null, arguments);
          }, i._crypto_hash = function() {
            return (i._crypto_hash = i.asm.va).apply(null, arguments);
          }, i._crypto_kdf_bytes_min = function() {
            return (i._crypto_kdf_bytes_min = i.asm.wa).apply(null, arguments);
          }, i._crypto_kdf_bytes_max = function() {
            return (i._crypto_kdf_bytes_max = i.asm.xa).apply(null, arguments);
          }, i._crypto_kdf_contextbytes = function() {
            return (i._crypto_kdf_contextbytes = i.asm.ya).apply(null, arguments);
          }, i._crypto_kdf_keybytes = function() {
            return (i._crypto_kdf_keybytes = i.asm.za).apply(null, arguments);
          }, i._crypto_kdf_derive_from_key = function() {
            return (i._crypto_kdf_derive_from_key = i.asm.Aa).apply(null, arguments);
          }, i._crypto_kdf_keygen = function() {
            return (i._crypto_kdf_keygen = i.asm.Ba).apply(null, arguments);
          }, i._crypto_kx_seed_keypair = function() {
            return (i._crypto_kx_seed_keypair = i.asm.Ca).apply(null, arguments);
          }, i._crypto_kx_keypair = function() {
            return (i._crypto_kx_keypair = i.asm.Da).apply(null, arguments);
          }, i._crypto_kx_client_session_keys = function() {
            return (i._crypto_kx_client_session_keys = i.asm.Ea).apply(null, arguments);
          }, i._crypto_kx_server_session_keys = function() {
            return (i._crypto_kx_server_session_keys = i.asm.Fa).apply(null, arguments);
          }, i._crypto_kx_publickeybytes = function() {
            return (i._crypto_kx_publickeybytes = i.asm.Ga).apply(null, arguments);
          }, i._crypto_kx_secretkeybytes = function() {
            return (i._crypto_kx_secretkeybytes = i.asm.Ha).apply(null, arguments);
          }, i._crypto_kx_seedbytes = function() {
            return (i._crypto_kx_seedbytes = i.asm.Ia).apply(null, arguments);
          }, i._crypto_kx_sessionkeybytes = function() {
            return (i._crypto_kx_sessionkeybytes = i.asm.Ja).apply(null, arguments);
          }, i._crypto_scalarmult_base = function() {
            return (i._crypto_scalarmult_base = i.asm.Ka).apply(null, arguments);
          }, i._crypto_scalarmult = function() {
            return (i._crypto_scalarmult = i.asm.La).apply(null, arguments);
          }, i._crypto_scalarmult_bytes = function() {
            return (i._crypto_scalarmult_bytes = i.asm.Ma).apply(null, arguments);
          }, i._crypto_scalarmult_scalarbytes = function() {
            return (i._crypto_scalarmult_scalarbytes = i.asm.Na).apply(null, arguments);
          }, i._crypto_secretbox_keybytes = function() {
            return (i._crypto_secretbox_keybytes = i.asm.Oa).apply(null, arguments);
          }, i._crypto_secretbox_noncebytes = function() {
            return (i._crypto_secretbox_noncebytes = i.asm.Pa).apply(null, arguments);
          }, i._crypto_secretbox_macbytes = function() {
            return (i._crypto_secretbox_macbytes = i.asm.Qa).apply(null, arguments);
          }, i._crypto_secretbox_messagebytes_max = function() {
            return (i._crypto_secretbox_messagebytes_max = i.asm.Ra).apply(null, arguments);
          }, i._crypto_secretbox_keygen = function() {
            return (i._crypto_secretbox_keygen = i.asm.Sa).apply(null, arguments);
          }, i._crypto_secretbox_detached = function() {
            return (i._crypto_secretbox_detached = i.asm.Ta).apply(null, arguments);
          }, i._crypto_secretbox_easy = function() {
            return (i._crypto_secretbox_easy = i.asm.Ua).apply(null, arguments);
          }, i._crypto_secretbox_open_detached = function() {
            return (i._crypto_secretbox_open_detached = i.asm.Va).apply(null, arguments);
          }, i._crypto_secretbox_open_easy = function() {
            return (i._crypto_secretbox_open_easy = i.asm.Wa).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_keygen = function() {
            return (i._crypto_secretstream_xchacha20poly1305_keygen = i.asm.Xa).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_init_push = function() {
            return (i._crypto_secretstream_xchacha20poly1305_init_push = i.asm.Ya).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_init_pull = function() {
            return (i._crypto_secretstream_xchacha20poly1305_init_pull = i.asm.Za).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_rekey = function() {
            return (i._crypto_secretstream_xchacha20poly1305_rekey = i.asm._a).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_push = function() {
            return (i._crypto_secretstream_xchacha20poly1305_push = i.asm.$a).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_pull = function() {
            return (i._crypto_secretstream_xchacha20poly1305_pull = i.asm.ab).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_statebytes = function() {
            return (i._crypto_secretstream_xchacha20poly1305_statebytes = i.asm.bb).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_abytes = function() {
            return (i._crypto_secretstream_xchacha20poly1305_abytes = i.asm.cb).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_headerbytes = function() {
            return (i._crypto_secretstream_xchacha20poly1305_headerbytes = i.asm.db).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_keybytes = function() {
            return (i._crypto_secretstream_xchacha20poly1305_keybytes = i.asm.eb).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_messagebytes_max = function() {
            return (i._crypto_secretstream_xchacha20poly1305_messagebytes_max = i.asm.fb).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_tag_message = function() {
            return (i._crypto_secretstream_xchacha20poly1305_tag_message = i.asm.gb).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_tag_push = function() {
            return (i._crypto_secretstream_xchacha20poly1305_tag_push = i.asm.hb).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_tag_rekey = function() {
            return (i._crypto_secretstream_xchacha20poly1305_tag_rekey = i.asm.ib).apply(null, arguments);
          }, i._crypto_secretstream_xchacha20poly1305_tag_final = function() {
            return (i._crypto_secretstream_xchacha20poly1305_tag_final = i.asm.jb).apply(null, arguments);
          }, i._crypto_shorthash_bytes = function() {
            return (i._crypto_shorthash_bytes = i.asm.kb).apply(null, arguments);
          }, i._crypto_shorthash_keybytes = function() {
            return (i._crypto_shorthash_keybytes = i.asm.lb).apply(null, arguments);
          }, i._crypto_shorthash = function() {
            return (i._crypto_shorthash = i.asm.mb).apply(null, arguments);
          }, i._crypto_shorthash_keygen = function() {
            return (i._crypto_shorthash_keygen = i.asm.nb).apply(null, arguments);
          }, i._crypto_sign_statebytes = function() {
            return (i._crypto_sign_statebytes = i.asm.ob).apply(null, arguments);
          }, i._crypto_sign_bytes = function() {
            return (i._crypto_sign_bytes = i.asm.pb).apply(null, arguments);
          }, i._crypto_sign_seedbytes = function() {
            return (i._crypto_sign_seedbytes = i.asm.qb).apply(null, arguments);
          }, i._crypto_sign_publickeybytes = function() {
            return (i._crypto_sign_publickeybytes = i.asm.rb).apply(null, arguments);
          }, i._crypto_sign_secretkeybytes = function() {
            return (i._crypto_sign_secretkeybytes = i.asm.sb).apply(null, arguments);
          }, i._crypto_sign_messagebytes_max = function() {
            return (i._crypto_sign_messagebytes_max = i.asm.tb).apply(null, arguments);
          }, i._crypto_sign_seed_keypair = function() {
            return (i._crypto_sign_seed_keypair = i.asm.ub).apply(null, arguments);
          }, i._crypto_sign_keypair = function() {
            return (i._crypto_sign_keypair = i.asm.vb).apply(null, arguments);
          }, i._crypto_sign = function() {
            return (i._crypto_sign = i.asm.wb).apply(null, arguments);
          }, i._crypto_sign_open = function() {
            return (i._crypto_sign_open = i.asm.xb).apply(null, arguments);
          }, i._crypto_sign_detached = function() {
            return (i._crypto_sign_detached = i.asm.yb).apply(null, arguments);
          }, i._crypto_sign_verify_detached = function() {
            return (i._crypto_sign_verify_detached = i.asm.zb).apply(null, arguments);
          }, i._crypto_sign_init = function() {
            return (i._crypto_sign_init = i.asm.Ab).apply(null, arguments);
          }, i._crypto_sign_update = function() {
            return (i._crypto_sign_update = i.asm.Bb).apply(null, arguments);
          }, i._crypto_sign_final_create = function() {
            return (i._crypto_sign_final_create = i.asm.Cb).apply(null, arguments);
          }, i._crypto_sign_final_verify = function() {
            return (i._crypto_sign_final_verify = i.asm.Db).apply(null, arguments);
          }, i._crypto_sign_ed25519_pk_to_curve25519 = function() {
            return (i._crypto_sign_ed25519_pk_to_curve25519 = i.asm.Eb).apply(null, arguments);
          }, i._crypto_sign_ed25519_sk_to_curve25519 = function() {
            return (i._crypto_sign_ed25519_sk_to_curve25519 = i.asm.Fb).apply(null, arguments);
          }, i._randombytes_random = function() {
            return (i._randombytes_random = i.asm.Gb).apply(null, arguments);
          }, i._randombytes_stir = function() {
            return (i._randombytes_stir = i.asm.Hb).apply(null, arguments);
          }, i._randombytes_uniform = function() {
            return (i._randombytes_uniform = i.asm.Ib).apply(null, arguments);
          }, i._randombytes_buf = function() {
            return (i._randombytes_buf = i.asm.Jb).apply(null, arguments);
          }, i._randombytes_buf_deterministic = function() {
            return (i._randombytes_buf_deterministic = i.asm.Kb).apply(null, arguments);
          }, i._randombytes_seedbytes = function() {
            return (i._randombytes_seedbytes = i.asm.Lb).apply(null, arguments);
          }, i._randombytes_close = function() {
            return (i._randombytes_close = i.asm.Mb).apply(null, arguments);
          }, i._randombytes = function() {
            return (i._randombytes = i.asm.Nb).apply(null, arguments);
          }, i._sodium_bin2hex = function() {
            return (i._sodium_bin2hex = i.asm.Ob).apply(null, arguments);
          }, i._sodium_hex2bin = function() {
            return (i._sodium_hex2bin = i.asm.Pb).apply(null, arguments);
          }, i._sodium_base64_encoded_len = function() {
            return (i._sodium_base64_encoded_len = i.asm.Qb).apply(null, arguments);
          }, i._sodium_bin2base64 = function() {
            return (i._sodium_bin2base64 = i.asm.Rb).apply(null, arguments);
          }, i._sodium_base642bin = function() {
            return (i._sodium_base642bin = i.asm.Sb).apply(null, arguments);
          }, i._sodium_init = function() {
            return (i._sodium_init = i.asm.Tb).apply(null, arguments);
          }, i._sodium_pad = function() {
            return (i._sodium_pad = i.asm.Ub).apply(null, arguments);
          }, i._sodium_unpad = function() {
            return (i._sodium_unpad = i.asm.Vb).apply(null, arguments);
          }, i._sodium_version_string = function() {
            return (i._sodium_version_string = i.asm.Wb).apply(null, arguments);
          }, i._sodium_library_version_major = function() {
            return (i._sodium_library_version_major = i.asm.Xb).apply(null, arguments);
          }, i._sodium_library_version_minor = function() {
            return (i._sodium_library_version_minor = i.asm.Yb).apply(null, arguments);
          }, i._sodium_library_minimal = function() {
            return (i._sodium_library_minimal = i.asm.Zb).apply(null, arguments);
          }, i._malloc = function() {
            return (i._malloc = i.asm._b).apply(null, arguments);
          }, i._free = function() {
            return (i._free = i.asm.$b).apply(null, arguments);
          }, i.UTF8ToString = S, i.setValue = function(A4, I4, g3 = "i8") {
            switch (g3.endsWith("*") && (g3 = "*"), g3) {
              case "i1":
              case "i8":
                D[A4 >> 0] = I4;
                break;
              case "i16":
                h[A4 >> 1] = I4;
                break;
              case "i32":
                s[A4 >> 2] = I4;
                break;
              case "i64":
                v = [I4 >>> 0, (P = I4, +Math.abs(P) >= 1 ? P > 0 ? (0 | Math.min(+Math.floor(P / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((P - +(~~P >>> 0)) / 4294967296) >>> 0 : 0)], s[A4 >> 2] = v[0], s[A4 + 4 >> 2] = v[1];
                break;
              case "float":
                u[A4 >> 2] = I4;
                break;
              case "double":
                k[A4 >> 3] = I4;
                break;
              case "*":
                p[A4 >> 2] = I4;
                break;
              default:
                b("invalid type for setValue: " + g3);
            }
          }, i.getValue = function(A4, I4 = "i8") {
            switch (I4.endsWith("*") && (I4 = "*"), I4) {
              case "i1":
              case "i8":
                return D[A4 >> 0];
              case "i16":
                return h[A4 >> 1];
              case "i32":
              case "i64":
                return s[A4 >> 2];
              case "float":
                return u[A4 >> 2];
              case "double":
                return k[A4 >> 3];
              case "*":
                return p[A4 >> 2];
              default:
                b("invalid type for getValue: " + I4);
            }
            return null;
          }, Y = function A4() {
            O || W(), O || (Y = A4);
          }, i.preInit)
            for ("function" == typeof i.preInit && (i.preInit = [i.preInit]); i.preInit.length > 0; )
              i.preInit.pop()();
          W();
        }).catch(function() {
          return C.useBackupModule();
        }), I2;
      }
      "function" == typeof define && define.amd ? define(["exports"], I) : "object" == typeof exports2 && "string" != typeof exports2.nodeName ? I(exports2) : A.libsodium = I(A.libsodium_mod || (A.commonJsStrict = {}));
    }(exports2);
  }
});

// ../../node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js
var require_libsodium_wrappers = __commonJS({
  "../../node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js"(exports2) {
    !function(e) {
      function r(e2, r2) {
        "use strict";
        var t2, a = "uint8array", _ = r2.ready.then(function() {
          function a2() {
            if (0 !== t2._sodium_init())
              throw new Error("libsodium was not correctly initialized.");
            for (var r3 = ["crypto_aead_chacha20poly1305_decrypt", "crypto_aead_chacha20poly1305_decrypt_detached", "crypto_aead_chacha20poly1305_encrypt", "crypto_aead_chacha20poly1305_encrypt_detached", "crypto_aead_chacha20poly1305_ietf_decrypt", "crypto_aead_chacha20poly1305_ietf_decrypt_detached", "crypto_aead_chacha20poly1305_ietf_encrypt", "crypto_aead_chacha20poly1305_ietf_encrypt_detached", "crypto_aead_chacha20poly1305_ietf_keygen", "crypto_aead_chacha20poly1305_keygen", "crypto_aead_xchacha20poly1305_ietf_decrypt", "crypto_aead_xchacha20poly1305_ietf_decrypt_detached", "crypto_aead_xchacha20poly1305_ietf_encrypt", "crypto_aead_xchacha20poly1305_ietf_encrypt_detached", "crypto_aead_xchacha20poly1305_ietf_keygen", "crypto_auth", "crypto_auth_hmacsha256", "crypto_auth_hmacsha256_final", "crypto_auth_hmacsha256_init", "crypto_auth_hmacsha256_keygen", "crypto_auth_hmacsha256_update", "crypto_auth_hmacsha256_verify", "crypto_auth_hmacsha512", "crypto_auth_hmacsha512_final", "crypto_auth_hmacsha512_init", "crypto_auth_hmacsha512_keygen", "crypto_auth_hmacsha512_update", "crypto_auth_hmacsha512_verify", "crypto_auth_keygen", "crypto_auth_verify", "crypto_box_beforenm", "crypto_box_curve25519xchacha20poly1305_keypair", "crypto_box_curve25519xchacha20poly1305_seal", "crypto_box_curve25519xchacha20poly1305_seal_open", "crypto_box_detached", "crypto_box_easy", "crypto_box_easy_afternm", "crypto_box_keypair", "crypto_box_open_detached", "crypto_box_open_easy", "crypto_box_open_easy_afternm", "crypto_box_seal", "crypto_box_seal_open", "crypto_box_seed_keypair", "crypto_core_ed25519_add", "crypto_core_ed25519_from_hash", "crypto_core_ed25519_from_uniform", "crypto_core_ed25519_is_valid_point", "crypto_core_ed25519_random", "crypto_core_ed25519_scalar_add", "crypto_core_ed25519_scalar_complement", "crypto_core_ed25519_scalar_invert", "crypto_core_ed25519_scalar_mul", "crypto_core_ed25519_scalar_negate", "crypto_core_ed25519_scalar_random", "crypto_core_ed25519_scalar_reduce", "crypto_core_ed25519_scalar_sub", "crypto_core_ed25519_sub", "crypto_core_hchacha20", "crypto_core_hsalsa20", "crypto_core_ristretto255_add", "crypto_core_ristretto255_from_hash", "crypto_core_ristretto255_is_valid_point", "crypto_core_ristretto255_random", "crypto_core_ristretto255_scalar_add", "crypto_core_ristretto255_scalar_complement", "crypto_core_ristretto255_scalar_invert", "crypto_core_ristretto255_scalar_mul", "crypto_core_ristretto255_scalar_negate", "crypto_core_ristretto255_scalar_random", "crypto_core_ristretto255_scalar_reduce", "crypto_core_ristretto255_scalar_sub", "crypto_core_ristretto255_sub", "crypto_generichash", "crypto_generichash_blake2b_salt_personal", "crypto_generichash_final", "crypto_generichash_init", "crypto_generichash_keygen", "crypto_generichash_update", "crypto_hash", "crypto_hash_sha256", "crypto_hash_sha256_final", "crypto_hash_sha256_init", "crypto_hash_sha256_update", "crypto_hash_sha512", "crypto_hash_sha512_final", "crypto_hash_sha512_init", "crypto_hash_sha512_update", "crypto_kdf_derive_from_key", "crypto_kdf_keygen", "crypto_kx_client_session_keys", "crypto_kx_keypair", "crypto_kx_seed_keypair", "crypto_kx_server_session_keys", "crypto_onetimeauth", "crypto_onetimeauth_final", "crypto_onetimeauth_init", "crypto_onetimeauth_keygen", "crypto_onetimeauth_update", "crypto_onetimeauth_verify", "crypto_pwhash", "crypto_pwhash_scryptsalsa208sha256", "crypto_pwhash_scryptsalsa208sha256_ll", "crypto_pwhash_scryptsalsa208sha256_str", "crypto_pwhash_scryptsalsa208sha256_str_verify", "crypto_pwhash_str", "crypto_pwhash_str_needs_rehash", "crypto_pwhash_str_verify", "crypto_scalarmult", "crypto_scalarmult_base", "crypto_scalarmult_ed25519", "crypto_scalarmult_ed25519_base", "crypto_scalarmult_ed25519_base_noclamp", "crypto_scalarmult_ed25519_noclamp", "crypto_scalarmult_ristretto255", "crypto_scalarmult_ristretto255_base", "crypto_secretbox_detached", "crypto_secretbox_easy", "crypto_secretbox_keygen", "crypto_secretbox_open_detached", "crypto_secretbox_open_easy", "crypto_secretstream_xchacha20poly1305_init_pull", "crypto_secretstream_xchacha20poly1305_init_push", "crypto_secretstream_xchacha20poly1305_keygen", "crypto_secretstream_xchacha20poly1305_pull", "crypto_secretstream_xchacha20poly1305_push", "crypto_secretstream_xchacha20poly1305_rekey", "crypto_shorthash", "crypto_shorthash_keygen", "crypto_shorthash_siphashx24", "crypto_sign", "crypto_sign_detached", "crypto_sign_ed25519_pk_to_curve25519", "crypto_sign_ed25519_sk_to_curve25519", "crypto_sign_ed25519_sk_to_pk", "crypto_sign_ed25519_sk_to_seed", "crypto_sign_final_create", "crypto_sign_final_verify", "crypto_sign_init", "crypto_sign_keypair", "crypto_sign_open", "crypto_sign_seed_keypair", "crypto_sign_update", "crypto_sign_verify_detached", "crypto_stream_chacha20", "crypto_stream_chacha20_ietf_xor", "crypto_stream_chacha20_ietf_xor_ic", "crypto_stream_chacha20_keygen", "crypto_stream_chacha20_xor", "crypto_stream_chacha20_xor_ic", "crypto_stream_keygen", "crypto_stream_xchacha20_keygen", "crypto_stream_xchacha20_xor", "crypto_stream_xchacha20_xor_ic", "randombytes_buf", "randombytes_buf_deterministic", "randombytes_close", "randombytes_random", "randombytes_set_implementation", "randombytes_stir", "randombytes_uniform", "sodium_version_string"], a3 = [x, k, S, T, w, Y, B, A, K, M, I, N, L, U, O, C, R, P, G, X, D, F, V, H, q, j, z, W, J, Q, Z, $, ee, re, te, ae, _e, se, ne, ce, oe, he, pe, ye, ie, le, ue, de, ve, ge, be, fe, me, Ee, xe, ke, Se, Te, we, Ye, Be, Ae, Ke, Me, Ie, Ne, Le, Ue, Oe, Ce, Re, Pe, Ge, Xe, De, Fe, Ve, He, qe, je, ze, We, Je, Qe, Ze, $e, er, rr, tr, ar, _r, sr, nr, cr, or, hr, pr, yr, ir, lr, ur, dr, vr, gr, br, fr, mr, Er, xr, kr, Sr, Tr, wr, Yr, Br, Ar, Kr, Mr, Ir, Nr, Lr, Ur, Or, Cr, Rr, Pr, Gr, Xr, Dr, Fr, Vr, Hr, qr, jr, zr, Wr, Jr, Qr, Zr, $r, et, rt, tt, at, _t, st, nt, ct, ot, ht, pt, yt, it, lt, ut, dt, vt, gt, bt, ft, mt, Et], _3 = 0; _3 < a3.length; _3++)
              "function" == typeof t2["_" + r3[_3]] && (e2[r3[_3]] = a3[_3]);
            var s3 = ["SODIUM_LIBRARY_VERSION_MAJOR", "SODIUM_LIBRARY_VERSION_MINOR", "crypto_aead_chacha20poly1305_ABYTES", "crypto_aead_chacha20poly1305_IETF_ABYTES", "crypto_aead_chacha20poly1305_IETF_KEYBYTES", "crypto_aead_chacha20poly1305_IETF_MESSAGEBYTES_MAX", "crypto_aead_chacha20poly1305_IETF_NPUBBYTES", "crypto_aead_chacha20poly1305_IETF_NSECBYTES", "crypto_aead_chacha20poly1305_KEYBYTES", "crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX", "crypto_aead_chacha20poly1305_NPUBBYTES", "crypto_aead_chacha20poly1305_NSECBYTES", "crypto_aead_chacha20poly1305_ietf_ABYTES", "crypto_aead_chacha20poly1305_ietf_KEYBYTES", "crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX", "crypto_aead_chacha20poly1305_ietf_NPUBBYTES", "crypto_aead_chacha20poly1305_ietf_NSECBYTES", "crypto_aead_xchacha20poly1305_IETF_ABYTES", "crypto_aead_xchacha20poly1305_IETF_KEYBYTES", "crypto_aead_xchacha20poly1305_IETF_MESSAGEBYTES_MAX", "crypto_aead_xchacha20poly1305_IETF_NPUBBYTES", "crypto_aead_xchacha20poly1305_IETF_NSECBYTES", "crypto_aead_xchacha20poly1305_ietf_ABYTES", "crypto_aead_xchacha20poly1305_ietf_KEYBYTES", "crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX", "crypto_aead_xchacha20poly1305_ietf_NPUBBYTES", "crypto_aead_xchacha20poly1305_ietf_NSECBYTES", "crypto_auth_BYTES", "crypto_auth_KEYBYTES", "crypto_auth_hmacsha256_BYTES", "crypto_auth_hmacsha256_KEYBYTES", "crypto_auth_hmacsha512256_BYTES", "crypto_auth_hmacsha512256_KEYBYTES", "crypto_auth_hmacsha512_BYTES", "crypto_auth_hmacsha512_KEYBYTES", "crypto_box_BEFORENMBYTES", "crypto_box_MACBYTES", "crypto_box_MESSAGEBYTES_MAX", "crypto_box_NONCEBYTES", "crypto_box_PUBLICKEYBYTES", "crypto_box_SEALBYTES", "crypto_box_SECRETKEYBYTES", "crypto_box_SEEDBYTES", "crypto_box_curve25519xchacha20poly1305_BEFORENMBYTES", "crypto_box_curve25519xchacha20poly1305_MACBYTES", "crypto_box_curve25519xchacha20poly1305_MESSAGEBYTES_MAX", "crypto_box_curve25519xchacha20poly1305_NONCEBYTES", "crypto_box_curve25519xchacha20poly1305_PUBLICKEYBYTES", "crypto_box_curve25519xchacha20poly1305_SEALBYTES", "crypto_box_curve25519xchacha20poly1305_SECRETKEYBYTES", "crypto_box_curve25519xchacha20poly1305_SEEDBYTES", "crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES", "crypto_box_curve25519xsalsa20poly1305_MACBYTES", "crypto_box_curve25519xsalsa20poly1305_MESSAGEBYTES_MAX", "crypto_box_curve25519xsalsa20poly1305_NONCEBYTES", "crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES", "crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES", "crypto_box_curve25519xsalsa20poly1305_SEEDBYTES", "crypto_core_ed25519_BYTES", "crypto_core_ed25519_HASHBYTES", "crypto_core_ed25519_NONREDUCEDSCALARBYTES", "crypto_core_ed25519_SCALARBYTES", "crypto_core_ed25519_UNIFORMBYTES", "crypto_core_hchacha20_CONSTBYTES", "crypto_core_hchacha20_INPUTBYTES", "crypto_core_hchacha20_KEYBYTES", "crypto_core_hchacha20_OUTPUTBYTES", "crypto_core_hsalsa20_CONSTBYTES", "crypto_core_hsalsa20_INPUTBYTES", "crypto_core_hsalsa20_KEYBYTES", "crypto_core_hsalsa20_OUTPUTBYTES", "crypto_core_ristretto255_BYTES", "crypto_core_ristretto255_HASHBYTES", "crypto_core_ristretto255_NONREDUCEDSCALARBYTES", "crypto_core_ristretto255_SCALARBYTES", "crypto_core_salsa2012_CONSTBYTES", "crypto_core_salsa2012_INPUTBYTES", "crypto_core_salsa2012_KEYBYTES", "crypto_core_salsa2012_OUTPUTBYTES", "crypto_core_salsa20_CONSTBYTES", "crypto_core_salsa20_INPUTBYTES", "crypto_core_salsa20_KEYBYTES", "crypto_core_salsa20_OUTPUTBYTES", "crypto_generichash_BYTES", "crypto_generichash_BYTES_MAX", "crypto_generichash_BYTES_MIN", "crypto_generichash_KEYBYTES", "crypto_generichash_KEYBYTES_MAX", "crypto_generichash_KEYBYTES_MIN", "crypto_generichash_blake2b_BYTES", "crypto_generichash_blake2b_BYTES_MAX", "crypto_generichash_blake2b_BYTES_MIN", "crypto_generichash_blake2b_KEYBYTES", "crypto_generichash_blake2b_KEYBYTES_MAX", "crypto_generichash_blake2b_KEYBYTES_MIN", "crypto_generichash_blake2b_PERSONALBYTES", "crypto_generichash_blake2b_SALTBYTES", "crypto_hash_BYTES", "crypto_hash_sha256_BYTES", "crypto_hash_sha512_BYTES", "crypto_kdf_BYTES_MAX", "crypto_kdf_BYTES_MIN", "crypto_kdf_CONTEXTBYTES", "crypto_kdf_KEYBYTES", "crypto_kdf_blake2b_BYTES_MAX", "crypto_kdf_blake2b_BYTES_MIN", "crypto_kdf_blake2b_CONTEXTBYTES", "crypto_kdf_blake2b_KEYBYTES", "crypto_kx_PUBLICKEYBYTES", "crypto_kx_SECRETKEYBYTES", "crypto_kx_SEEDBYTES", "crypto_kx_SESSIONKEYBYTES", "crypto_onetimeauth_BYTES", "crypto_onetimeauth_KEYBYTES", "crypto_onetimeauth_poly1305_BYTES", "crypto_onetimeauth_poly1305_KEYBYTES", "crypto_pwhash_ALG_ARGON2I13", "crypto_pwhash_ALG_ARGON2ID13", "crypto_pwhash_ALG_DEFAULT", "crypto_pwhash_BYTES_MAX", "crypto_pwhash_BYTES_MIN", "crypto_pwhash_MEMLIMIT_INTERACTIVE", "crypto_pwhash_MEMLIMIT_MAX", "crypto_pwhash_MEMLIMIT_MIN", "crypto_pwhash_MEMLIMIT_MODERATE", "crypto_pwhash_MEMLIMIT_SENSITIVE", "crypto_pwhash_OPSLIMIT_INTERACTIVE", "crypto_pwhash_OPSLIMIT_MAX", "crypto_pwhash_OPSLIMIT_MIN", "crypto_pwhash_OPSLIMIT_MODERATE", "crypto_pwhash_OPSLIMIT_SENSITIVE", "crypto_pwhash_PASSWD_MAX", "crypto_pwhash_PASSWD_MIN", "crypto_pwhash_SALTBYTES", "crypto_pwhash_STRBYTES", "crypto_pwhash_argon2i_BYTES_MAX", "crypto_pwhash_argon2i_BYTES_MIN", "crypto_pwhash_argon2i_SALTBYTES", "crypto_pwhash_argon2i_STRBYTES", "crypto_pwhash_argon2id_BYTES_MAX", "crypto_pwhash_argon2id_BYTES_MIN", "crypto_pwhash_argon2id_SALTBYTES", "crypto_pwhash_argon2id_STRBYTES", "crypto_pwhash_scryptsalsa208sha256_BYTES_MAX", "crypto_pwhash_scryptsalsa208sha256_BYTES_MIN", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE", "crypto_pwhash_scryptsalsa208sha256_SALTBYTES", "crypto_pwhash_scryptsalsa208sha256_STRBYTES", "crypto_scalarmult_BYTES", "crypto_scalarmult_SCALARBYTES", "crypto_scalarmult_curve25519_BYTES", "crypto_scalarmult_curve25519_SCALARBYTES", "crypto_scalarmult_ed25519_BYTES", "crypto_scalarmult_ed25519_SCALARBYTES", "crypto_scalarmult_ristretto255_BYTES", "crypto_scalarmult_ristretto255_SCALARBYTES", "crypto_secretbox_KEYBYTES", "crypto_secretbox_MACBYTES", "crypto_secretbox_MESSAGEBYTES_MAX", "crypto_secretbox_NONCEBYTES", "crypto_secretbox_xchacha20poly1305_KEYBYTES", "crypto_secretbox_xchacha20poly1305_MACBYTES", "crypto_secretbox_xchacha20poly1305_MESSAGEBYTES_MAX", "crypto_secretbox_xchacha20poly1305_NONCEBYTES", "crypto_secretbox_xsalsa20poly1305_KEYBYTES", "crypto_secretbox_xsalsa20poly1305_MACBYTES", "crypto_secretbox_xsalsa20poly1305_MESSAGEBYTES_MAX", "crypto_secretbox_xsalsa20poly1305_NONCEBYTES", "crypto_secretstream_xchacha20poly1305_ABYTES", "crypto_secretstream_xchacha20poly1305_HEADERBYTES", "crypto_secretstream_xchacha20poly1305_KEYBYTES", "crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX", "crypto_secretstream_xchacha20poly1305_TAG_FINAL", "crypto_secretstream_xchacha20poly1305_TAG_MESSAGE", "crypto_secretstream_xchacha20poly1305_TAG_PUSH", "crypto_secretstream_xchacha20poly1305_TAG_REKEY", "crypto_shorthash_BYTES", "crypto_shorthash_KEYBYTES", "crypto_shorthash_siphash24_BYTES", "crypto_shorthash_siphash24_KEYBYTES", "crypto_shorthash_siphashx24_BYTES", "crypto_shorthash_siphashx24_KEYBYTES", "crypto_sign_BYTES", "crypto_sign_MESSAGEBYTES_MAX", "crypto_sign_PUBLICKEYBYTES", "crypto_sign_SECRETKEYBYTES", "crypto_sign_SEEDBYTES", "crypto_sign_ed25519_BYTES", "crypto_sign_ed25519_MESSAGEBYTES_MAX", "crypto_sign_ed25519_PUBLICKEYBYTES", "crypto_sign_ed25519_SECRETKEYBYTES", "crypto_sign_ed25519_SEEDBYTES", "crypto_stream_KEYBYTES", "crypto_stream_MESSAGEBYTES_MAX", "crypto_stream_NONCEBYTES", "crypto_stream_chacha20_IETF_KEYBYTES", "crypto_stream_chacha20_IETF_MESSAGEBYTES_MAX", "crypto_stream_chacha20_IETF_NONCEBYTES", "crypto_stream_chacha20_KEYBYTES", "crypto_stream_chacha20_MESSAGEBYTES_MAX", "crypto_stream_chacha20_NONCEBYTES", "crypto_stream_chacha20_ietf_KEYBYTES", "crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX", "crypto_stream_chacha20_ietf_NONCEBYTES", "crypto_stream_salsa2012_KEYBYTES", "crypto_stream_salsa2012_MESSAGEBYTES_MAX", "crypto_stream_salsa2012_NONCEBYTES", "crypto_stream_salsa208_KEYBYTES", "crypto_stream_salsa208_MESSAGEBYTES_MAX", "crypto_stream_salsa208_NONCEBYTES", "crypto_stream_salsa20_KEYBYTES", "crypto_stream_salsa20_MESSAGEBYTES_MAX", "crypto_stream_salsa20_NONCEBYTES", "crypto_stream_xchacha20_KEYBYTES", "crypto_stream_xchacha20_MESSAGEBYTES_MAX", "crypto_stream_xchacha20_NONCEBYTES", "crypto_stream_xsalsa20_KEYBYTES", "crypto_stream_xsalsa20_MESSAGEBYTES_MAX", "crypto_stream_xsalsa20_NONCEBYTES", "crypto_verify_16_BYTES", "crypto_verify_32_BYTES", "crypto_verify_64_BYTES"];
            for (_3 = 0; _3 < s3.length; _3++)
              "function" == typeof (c3 = t2["_" + s3[_3].toLowerCase()]) && (e2[s3[_3]] = c3());
            var n3 = ["SODIUM_VERSION_STRING", "crypto_pwhash_STRPREFIX", "crypto_pwhash_scryptsalsa208sha256_STRPREFIX"];
            for (_3 = 0; _3 < n3.length; _3++) {
              var c3;
              "function" == typeof (c3 = t2["_" + n3[_3].toLowerCase()]) && (e2[n3[_3]] = t2.UTF8ToString(c3()));
            }
          }
          t2 = r2;
          try {
            a2();
            var _2 = new Uint8Array([98, 97, 108, 108, 115]), s2 = e2.randombytes_buf(e2.crypto_secretbox_NONCEBYTES), n2 = e2.randombytes_buf(e2.crypto_secretbox_KEYBYTES), c2 = e2.crypto_secretbox_easy(_2, s2, n2), o2 = e2.crypto_secretbox_open_easy(c2, s2, n2);
            if (e2.memcmp(_2, o2))
              return;
          } catch (e3) {
            if (null == t2.useBackupModule)
              throw new Error("Both wasm and asm failed to load" + e3);
          }
          t2.useBackupModule(), a2();
        });
        function s(e3) {
          if ("function" == typeof TextEncoder)
            return new TextEncoder().encode(e3);
          e3 = unescape(encodeURIComponent(e3));
          for (var r3 = new Uint8Array(e3.length), t3 = 0, a2 = e3.length; t3 < a2; t3++)
            r3[t3] = e3.charCodeAt(t3);
          return r3;
        }
        function n(e3) {
          if ("function" == typeof TextDecoder)
            return new TextDecoder("utf-8", { fatal: true }).decode(e3);
          var r3 = 8192, t3 = Math.ceil(e3.length / r3);
          if (t3 <= 1)
            try {
              return decodeURIComponent(escape(String.fromCharCode.apply(null, e3)));
            } catch (e4) {
              throw new TypeError("The encoded data was not valid.");
            }
          for (var a2 = "", _2 = 0, s2 = 0; s2 < t3; s2++) {
            var c2 = Array.prototype.slice.call(e3, s2 * r3 + _2, (s2 + 1) * r3 + _2);
            if (0 != c2.length) {
              var o2, h2 = c2.length, p2 = 0;
              do {
                var y2 = c2[--h2];
                y2 >= 240 ? (p2 = 4, o2 = true) : y2 >= 224 ? (p2 = 3, o2 = true) : y2 >= 192 ? (p2 = 2, o2 = true) : y2 < 128 && (p2 = 1, o2 = true);
              } while (!o2);
              for (var i2 = p2 - (c2.length - h2), l2 = 0; l2 < i2; l2++)
                _2--, c2.pop();
              a2 += n(c2);
            }
          }
          return a2;
        }
        function c(e3) {
          e3 = E(null, e3, "input");
          for (var r3, t3, a2, _2 = "", s2 = 0; s2 < e3.length; s2++)
            a2 = 87 + (t3 = 15 & e3[s2]) + (t3 - 10 >> 8 & -39) << 8 | 87 + (r3 = e3[s2] >>> 4) + (r3 - 10 >> 8 & -39), _2 += String.fromCharCode(255 & a2) + String.fromCharCode(a2 >>> 8);
          return _2;
        }
        var o = { ORIGINAL: 1, ORIGINAL_NO_PADDING: 3, URLSAFE: 5, URLSAFE_NO_PADDING: 7 };
        function h(e3) {
          if (null == e3)
            return o.URLSAFE_NO_PADDING;
          if (e3 !== o.ORIGINAL && e3 !== o.ORIGINAL_NO_PADDING && e3 !== o.URLSAFE && e3 != o.URLSAFE_NO_PADDING)
            throw new Error("unsupported base64 variant");
          return e3;
        }
        function p(e3, r3) {
          r3 = h(r3), e3 = E(_2, e3, "input");
          var a2, _2 = [], s2 = 0 | Math.floor(e3.length / 3), c2 = e3.length - 3 * s2, o2 = 4 * s2 + (0 !== c2 ? 0 == (2 & r3) ? 4 : 2 + (c2 >>> 1) : 0), p2 = new u(o2 + 1), y2 = d(e3);
          return _2.push(y2), _2.push(p2.address), 0 === t2._sodium_bin2base64(p2.address, p2.length, y2, e3.length, r3) && b(_2, "conversion failed"), p2.length = o2, a2 = n(p2.to_Uint8Array()), g(_2), a2;
        }
        function y(e3, r3) {
          var t3 = r3 || a;
          if (!i(t3))
            throw new Error(t3 + " output format is not available");
          if (e3 instanceof u) {
            if ("uint8array" === t3)
              return e3.to_Uint8Array();
            if ("text" === t3)
              return n(e3.to_Uint8Array());
            if ("hex" === t3)
              return c(e3.to_Uint8Array());
            if ("base64" === t3)
              return p(e3.to_Uint8Array(), o.URLSAFE_NO_PADDING);
            throw new Error('What is output format "' + t3 + '"?');
          }
          if ("object" == typeof e3) {
            for (var _2 = Object.keys(e3), s2 = {}, h2 = 0; h2 < _2.length; h2++)
              s2[_2[h2]] = y(e3[_2[h2]], t3);
            return s2;
          }
          if ("string" == typeof e3)
            return e3;
          throw new TypeError("Cannot format output");
        }
        function i(e3) {
          for (var r3 = ["uint8array", "text", "hex", "base64"], t3 = 0; t3 < r3.length; t3++)
            if (r3[t3] === e3)
              return true;
          return false;
        }
        function l(e3) {
          if (e3) {
            if ("string" != typeof e3)
              throw new TypeError("When defined, the output format must be a string");
            if (!i(e3))
              throw new Error(e3 + " is not a supported output format");
          }
        }
        function u(e3) {
          this.length = e3, this.address = v(e3);
        }
        function d(e3) {
          var r3 = v(e3.length);
          return t2.HEAPU8.set(e3, r3), r3;
        }
        function v(e3) {
          var r3 = t2._malloc(e3);
          if (0 === r3)
            throw { message: "_malloc() failed", length: e3 };
          return r3;
        }
        function g(e3) {
          if (e3)
            for (var r3 = 0; r3 < e3.length; r3++)
              a2 = e3[r3], t2._free(a2);
          var a2;
        }
        function b(e3, r3) {
          throw g(e3), new Error(r3);
        }
        function f(e3, r3) {
          throw g(e3), new TypeError(r3);
        }
        function m(e3, r3, t3) {
          null == r3 && f(e3, t3 + " cannot be null or undefined");
        }
        function E(e3, r3, t3) {
          return m(e3, r3, t3), r3 instanceof Uint8Array ? r3 : "string" == typeof r3 ? s(r3) : void f(e3, "unsupported input type for " + t3);
        }
        function x(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = null;
          null != e3 && (o2 = d(e3 = E(c2, e3, "secret_nonce")), e3.length, c2.push(o2)), r3 = E(c2, r3, "ciphertext");
          var h2, p2 = t2._crypto_aead_chacha20poly1305_abytes(), i2 = r3.length;
          i2 < p2 && f(c2, "ciphertext is too short"), h2 = d(r3), c2.push(h2);
          var v2 = null, m2 = 0;
          null != a2 && (v2 = d(a2 = E(c2, a2, "additional_data")), m2 = a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var x2, k2 = 0 | t2._crypto_aead_chacha20poly1305_npubbytes();
          _2.length !== k2 && f(c2, "invalid public_nonce length"), x2 = d(_2), c2.push(x2), s2 = E(c2, s2, "key");
          var S2, T2 = 0 | t2._crypto_aead_chacha20poly1305_keybytes();
          s2.length !== T2 && f(c2, "invalid key length"), S2 = d(s2), c2.push(S2);
          var w2 = new u(i2 - t2._crypto_aead_chacha20poly1305_abytes() | 0), Y2 = w2.address;
          if (c2.push(Y2), 0 === t2._crypto_aead_chacha20poly1305_decrypt(Y2, null, o2, h2, i2, 0, v2, m2, 0, x2, S2)) {
            var B2 = y(w2, n2);
            return g(c2), B2;
          }
          b(c2, "ciphertext cannot be decrypted using that key");
        }
        function k(e3, r3, a2, _2, s2, n2, c2) {
          var o2 = [];
          l(c2);
          var h2 = null;
          null != e3 && (h2 = d(e3 = E(o2, e3, "secret_nonce")), e3.length, o2.push(h2));
          var p2 = d(r3 = E(o2, r3, "ciphertext")), i2 = r3.length;
          o2.push(p2), a2 = E(o2, a2, "mac");
          var v2, m2 = 0 | t2._crypto_box_macbytes();
          a2.length !== m2 && f(o2, "invalid mac length"), v2 = d(a2), o2.push(v2);
          var x2 = null, k2 = 0;
          null != _2 && (x2 = d(_2 = E(o2, _2, "additional_data")), k2 = _2.length, o2.push(x2)), s2 = E(o2, s2, "public_nonce");
          var S2, T2 = 0 | t2._crypto_aead_chacha20poly1305_npubbytes();
          s2.length !== T2 && f(o2, "invalid public_nonce length"), S2 = d(s2), o2.push(S2), n2 = E(o2, n2, "key");
          var w2, Y2 = 0 | t2._crypto_aead_chacha20poly1305_keybytes();
          n2.length !== Y2 && f(o2, "invalid key length"), w2 = d(n2), o2.push(w2);
          var B2 = new u(0 | i2), A2 = B2.address;
          if (o2.push(A2), 0 === t2._crypto_aead_chacha20poly1305_decrypt_detached(A2, h2, p2, i2, 0, v2, x2, k2, 0, S2, w2)) {
            var K2 = y(B2, c2);
            return g(o2), K2;
          }
          b(o2, "ciphertext cannot be decrypted using that key");
        }
        function S(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "message")), h2 = e3.length;
          c2.push(o2);
          var p2 = null, i2 = 0;
          null != r3 && (p2 = d(r3 = E(c2, r3, "additional_data")), i2 = r3.length, c2.push(p2));
          var v2 = null;
          null != a2 && (v2 = d(a2 = E(c2, a2, "secret_nonce")), a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var m2, x2 = 0 | t2._crypto_aead_chacha20poly1305_npubbytes();
          _2.length !== x2 && f(c2, "invalid public_nonce length"), m2 = d(_2), c2.push(m2), s2 = E(c2, s2, "key");
          var k2, S2 = 0 | t2._crypto_aead_chacha20poly1305_keybytes();
          s2.length !== S2 && f(c2, "invalid key length"), k2 = d(s2), c2.push(k2);
          var T2 = new u(h2 + t2._crypto_aead_chacha20poly1305_abytes() | 0), w2 = T2.address;
          if (c2.push(w2), 0 === t2._crypto_aead_chacha20poly1305_encrypt(w2, null, o2, h2, 0, p2, i2, 0, v2, m2, k2)) {
            var Y2 = y(T2, n2);
            return g(c2), Y2;
          }
          b(c2, "invalid usage");
        }
        function T(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "message")), h2 = e3.length;
          c2.push(o2);
          var p2 = null, i2 = 0;
          null != r3 && (p2 = d(r3 = E(c2, r3, "additional_data")), i2 = r3.length, c2.push(p2));
          var v2 = null;
          null != a2 && (v2 = d(a2 = E(c2, a2, "secret_nonce")), a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var m2, x2 = 0 | t2._crypto_aead_chacha20poly1305_npubbytes();
          _2.length !== x2 && f(c2, "invalid public_nonce length"), m2 = d(_2), c2.push(m2), s2 = E(c2, s2, "key");
          var k2, S2 = 0 | t2._crypto_aead_chacha20poly1305_keybytes();
          s2.length !== S2 && f(c2, "invalid key length"), k2 = d(s2), c2.push(k2);
          var T2 = new u(0 | h2), w2 = T2.address;
          c2.push(w2);
          var Y2 = new u(0 | t2._crypto_aead_chacha20poly1305_abytes()), B2 = Y2.address;
          if (c2.push(B2), 0 === t2._crypto_aead_chacha20poly1305_encrypt_detached(w2, B2, null, o2, h2, 0, p2, i2, 0, v2, m2, k2)) {
            var A2 = y({ ciphertext: T2, mac: Y2 }, n2);
            return g(c2), A2;
          }
          b(c2, "invalid usage");
        }
        function w(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = null;
          null != e3 && (o2 = d(e3 = E(c2, e3, "secret_nonce")), e3.length, c2.push(o2)), r3 = E(c2, r3, "ciphertext");
          var h2, p2 = t2._crypto_aead_chacha20poly1305_ietf_abytes(), i2 = r3.length;
          i2 < p2 && f(c2, "ciphertext is too short"), h2 = d(r3), c2.push(h2);
          var v2 = null, m2 = 0;
          null != a2 && (v2 = d(a2 = E(c2, a2, "additional_data")), m2 = a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var x2, k2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_npubbytes();
          _2.length !== k2 && f(c2, "invalid public_nonce length"), x2 = d(_2), c2.push(x2), s2 = E(c2, s2, "key");
          var S2, T2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_keybytes();
          s2.length !== T2 && f(c2, "invalid key length"), S2 = d(s2), c2.push(S2);
          var w2 = new u(i2 - t2._crypto_aead_chacha20poly1305_ietf_abytes() | 0), Y2 = w2.address;
          if (c2.push(Y2), 0 === t2._crypto_aead_chacha20poly1305_ietf_decrypt(Y2, null, o2, h2, i2, 0, v2, m2, 0, x2, S2)) {
            var B2 = y(w2, n2);
            return g(c2), B2;
          }
          b(c2, "ciphertext cannot be decrypted using that key");
        }
        function Y(e3, r3, a2, _2, s2, n2, c2) {
          var o2 = [];
          l(c2);
          var h2 = null;
          null != e3 && (h2 = d(e3 = E(o2, e3, "secret_nonce")), e3.length, o2.push(h2));
          var p2 = d(r3 = E(o2, r3, "ciphertext")), i2 = r3.length;
          o2.push(p2), a2 = E(o2, a2, "mac");
          var v2, m2 = 0 | t2._crypto_box_macbytes();
          a2.length !== m2 && f(o2, "invalid mac length"), v2 = d(a2), o2.push(v2);
          var x2 = null, k2 = 0;
          null != _2 && (x2 = d(_2 = E(o2, _2, "additional_data")), k2 = _2.length, o2.push(x2)), s2 = E(o2, s2, "public_nonce");
          var S2, T2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_npubbytes();
          s2.length !== T2 && f(o2, "invalid public_nonce length"), S2 = d(s2), o2.push(S2), n2 = E(o2, n2, "key");
          var w2, Y2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_keybytes();
          n2.length !== Y2 && f(o2, "invalid key length"), w2 = d(n2), o2.push(w2);
          var B2 = new u(0 | i2), A2 = B2.address;
          if (o2.push(A2), 0 === t2._crypto_aead_chacha20poly1305_ietf_decrypt_detached(A2, h2, p2, i2, 0, v2, x2, k2, 0, S2, w2)) {
            var K2 = y(B2, c2);
            return g(o2), K2;
          }
          b(o2, "ciphertext cannot be decrypted using that key");
        }
        function B(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "message")), h2 = e3.length;
          c2.push(o2);
          var p2 = null, i2 = 0;
          null != r3 && (p2 = d(r3 = E(c2, r3, "additional_data")), i2 = r3.length, c2.push(p2));
          var v2 = null;
          null != a2 && (v2 = d(a2 = E(c2, a2, "secret_nonce")), a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var m2, x2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_npubbytes();
          _2.length !== x2 && f(c2, "invalid public_nonce length"), m2 = d(_2), c2.push(m2), s2 = E(c2, s2, "key");
          var k2, S2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_keybytes();
          s2.length !== S2 && f(c2, "invalid key length"), k2 = d(s2), c2.push(k2);
          var T2 = new u(h2 + t2._crypto_aead_chacha20poly1305_ietf_abytes() | 0), w2 = T2.address;
          if (c2.push(w2), 0 === t2._crypto_aead_chacha20poly1305_ietf_encrypt(w2, null, o2, h2, 0, p2, i2, 0, v2, m2, k2)) {
            var Y2 = y(T2, n2);
            return g(c2), Y2;
          }
          b(c2, "invalid usage");
        }
        function A(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "message")), h2 = e3.length;
          c2.push(o2);
          var p2 = null, i2 = 0;
          null != r3 && (p2 = d(r3 = E(c2, r3, "additional_data")), i2 = r3.length, c2.push(p2));
          var v2 = null;
          null != a2 && (v2 = d(a2 = E(c2, a2, "secret_nonce")), a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var m2, x2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_npubbytes();
          _2.length !== x2 && f(c2, "invalid public_nonce length"), m2 = d(_2), c2.push(m2), s2 = E(c2, s2, "key");
          var k2, S2 = 0 | t2._crypto_aead_chacha20poly1305_ietf_keybytes();
          s2.length !== S2 && f(c2, "invalid key length"), k2 = d(s2), c2.push(k2);
          var T2 = new u(0 | h2), w2 = T2.address;
          c2.push(w2);
          var Y2 = new u(0 | t2._crypto_aead_chacha20poly1305_ietf_abytes()), B2 = Y2.address;
          if (c2.push(B2), 0 === t2._crypto_aead_chacha20poly1305_ietf_encrypt_detached(w2, B2, null, o2, h2, 0, p2, i2, 0, v2, m2, k2)) {
            var A2 = y({ ciphertext: T2, mac: Y2 }, n2);
            return g(c2), A2;
          }
          b(c2, "invalid usage");
        }
        function K(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_aead_chacha20poly1305_ietf_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_aead_chacha20poly1305_ietf_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function M(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_aead_chacha20poly1305_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_aead_chacha20poly1305_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function I(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = null;
          null != e3 && (o2 = d(e3 = E(c2, e3, "secret_nonce")), e3.length, c2.push(o2)), r3 = E(c2, r3, "ciphertext");
          var h2, p2 = t2._crypto_aead_xchacha20poly1305_ietf_abytes(), i2 = r3.length;
          i2 < p2 && f(c2, "ciphertext is too short"), h2 = d(r3), c2.push(h2);
          var v2 = null, m2 = 0;
          null != a2 && (v2 = d(a2 = E(c2, a2, "additional_data")), m2 = a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var x2, k2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_npubbytes();
          _2.length !== k2 && f(c2, "invalid public_nonce length"), x2 = d(_2), c2.push(x2), s2 = E(c2, s2, "key");
          var S2, T2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_keybytes();
          s2.length !== T2 && f(c2, "invalid key length"), S2 = d(s2), c2.push(S2);
          var w2 = new u(i2 - t2._crypto_aead_xchacha20poly1305_ietf_abytes() | 0), Y2 = w2.address;
          if (c2.push(Y2), 0 === t2._crypto_aead_xchacha20poly1305_ietf_decrypt(Y2, null, o2, h2, i2, 0, v2, m2, 0, x2, S2)) {
            var B2 = y(w2, n2);
            return g(c2), B2;
          }
          b(c2, "ciphertext cannot be decrypted using that key");
        }
        function N(e3, r3, a2, _2, s2, n2, c2) {
          var o2 = [];
          l(c2);
          var h2 = null;
          null != e3 && (h2 = d(e3 = E(o2, e3, "secret_nonce")), e3.length, o2.push(h2));
          var p2 = d(r3 = E(o2, r3, "ciphertext")), i2 = r3.length;
          o2.push(p2), a2 = E(o2, a2, "mac");
          var v2, m2 = 0 | t2._crypto_box_macbytes();
          a2.length !== m2 && f(o2, "invalid mac length"), v2 = d(a2), o2.push(v2);
          var x2 = null, k2 = 0;
          null != _2 && (x2 = d(_2 = E(o2, _2, "additional_data")), k2 = _2.length, o2.push(x2)), s2 = E(o2, s2, "public_nonce");
          var S2, T2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_npubbytes();
          s2.length !== T2 && f(o2, "invalid public_nonce length"), S2 = d(s2), o2.push(S2), n2 = E(o2, n2, "key");
          var w2, Y2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_keybytes();
          n2.length !== Y2 && f(o2, "invalid key length"), w2 = d(n2), o2.push(w2);
          var B2 = new u(0 | i2), A2 = B2.address;
          if (o2.push(A2), 0 === t2._crypto_aead_xchacha20poly1305_ietf_decrypt_detached(A2, h2, p2, i2, 0, v2, x2, k2, 0, S2, w2)) {
            var K2 = y(B2, c2);
            return g(o2), K2;
          }
          b(o2, "ciphertext cannot be decrypted using that key");
        }
        function L(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "message")), h2 = e3.length;
          c2.push(o2);
          var p2 = null, i2 = 0;
          null != r3 && (p2 = d(r3 = E(c2, r3, "additional_data")), i2 = r3.length, c2.push(p2));
          var v2 = null;
          null != a2 && (v2 = d(a2 = E(c2, a2, "secret_nonce")), a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var m2, x2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_npubbytes();
          _2.length !== x2 && f(c2, "invalid public_nonce length"), m2 = d(_2), c2.push(m2), s2 = E(c2, s2, "key");
          var k2, S2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_keybytes();
          s2.length !== S2 && f(c2, "invalid key length"), k2 = d(s2), c2.push(k2);
          var T2 = new u(h2 + t2._crypto_aead_xchacha20poly1305_ietf_abytes() | 0), w2 = T2.address;
          if (c2.push(w2), 0 === t2._crypto_aead_xchacha20poly1305_ietf_encrypt(w2, null, o2, h2, 0, p2, i2, 0, v2, m2, k2)) {
            var Y2 = y(T2, n2);
            return g(c2), Y2;
          }
          b(c2, "invalid usage");
        }
        function U(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "message")), h2 = e3.length;
          c2.push(o2);
          var p2 = null, i2 = 0;
          null != r3 && (p2 = d(r3 = E(c2, r3, "additional_data")), i2 = r3.length, c2.push(p2));
          var v2 = null;
          null != a2 && (v2 = d(a2 = E(c2, a2, "secret_nonce")), a2.length, c2.push(v2)), _2 = E(c2, _2, "public_nonce");
          var m2, x2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_npubbytes();
          _2.length !== x2 && f(c2, "invalid public_nonce length"), m2 = d(_2), c2.push(m2), s2 = E(c2, s2, "key");
          var k2, S2 = 0 | t2._crypto_aead_xchacha20poly1305_ietf_keybytes();
          s2.length !== S2 && f(c2, "invalid key length"), k2 = d(s2), c2.push(k2);
          var T2 = new u(0 | h2), w2 = T2.address;
          c2.push(w2);
          var Y2 = new u(0 | t2._crypto_aead_xchacha20poly1305_ietf_abytes()), B2 = Y2.address;
          if (c2.push(B2), 0 === t2._crypto_aead_xchacha20poly1305_ietf_encrypt_detached(w2, B2, null, o2, h2, 0, p2, i2, 0, v2, m2, k2)) {
            var A2 = y({ ciphertext: T2, mac: Y2 }, n2);
            return g(c2), A2;
          }
          b(c2, "invalid usage");
        }
        function O(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_aead_xchacha20poly1305_ietf_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_aead_xchacha20poly1305_ietf_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function C(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_auth_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_auth_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_auth(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function R(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_auth_hmacsha256_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_auth_hmacsha256_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_auth_hmacsha256(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function P(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "state_address");
          var _2 = new u(0 | t2._crypto_auth_hmacsha256_bytes()), s2 = _2.address;
          if (a2.push(s2), 0 == (0 | t2._crypto_auth_hmacsha256_final(e3, s2))) {
            var n2 = (t2._free(e3), y(_2, r3));
            return g(a2), n2;
          }
          b(a2, "invalid usage");
        }
        function G(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = null, s2 = 0;
          null != e3 && (_2 = d(e3 = E(a2, e3, "key")), s2 = e3.length, a2.push(_2));
          var n2 = new u(208).address;
          if (0 == (0 | t2._crypto_auth_hmacsha256_init(n2, _2, s2))) {
            var c2 = n2;
            return g(a2), c2;
          }
          b(a2, "invalid usage");
        }
        function X(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_auth_hmacsha256_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_auth_hmacsha256_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function D(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_auth_hmacsha256_update(e3, s2, n2)) && b(_2, "invalid usage"), g(_2);
        }
        function F(e3, r3, a2) {
          var _2 = [];
          e3 = E(_2, e3, "tag");
          var s2, n2 = 0 | t2._crypto_auth_hmacsha256_bytes();
          e3.length !== n2 && f(_2, "invalid tag length"), s2 = d(e3), _2.push(s2);
          var c2 = d(r3 = E(_2, r3, "message")), o2 = r3.length;
          _2.push(c2), a2 = E(_2, a2, "key");
          var h2, p2 = 0 | t2._crypto_auth_hmacsha256_keybytes();
          a2.length !== p2 && f(_2, "invalid key length"), h2 = d(a2), _2.push(h2);
          var y2 = 0 == (0 | t2._crypto_auth_hmacsha256_verify(s2, c2, o2, 0, h2));
          return g(_2), y2;
        }
        function V(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_auth_hmacsha512_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_auth_hmacsha512_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_auth_hmacsha512(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function H(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "state_address");
          var _2 = new u(0 | t2._crypto_auth_hmacsha512_bytes()), s2 = _2.address;
          if (a2.push(s2), 0 == (0 | t2._crypto_auth_hmacsha512_final(e3, s2))) {
            var n2 = (t2._free(e3), y(_2, r3));
            return g(a2), n2;
          }
          b(a2, "invalid usage");
        }
        function q(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = null, s2 = 0;
          null != e3 && (_2 = d(e3 = E(a2, e3, "key")), s2 = e3.length, a2.push(_2));
          var n2 = new u(416).address;
          if (0 == (0 | t2._crypto_auth_hmacsha512_init(n2, _2, s2))) {
            var c2 = n2;
            return g(a2), c2;
          }
          b(a2, "invalid usage");
        }
        function j(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_auth_hmacsha512_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_auth_hmacsha512_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function z(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_auth_hmacsha512_update(e3, s2, n2)) && b(_2, "invalid usage"), g(_2);
        }
        function W(e3, r3, a2) {
          var _2 = [];
          e3 = E(_2, e3, "tag");
          var s2, n2 = 0 | t2._crypto_auth_hmacsha512_bytes();
          e3.length !== n2 && f(_2, "invalid tag length"), s2 = d(e3), _2.push(s2);
          var c2 = d(r3 = E(_2, r3, "message")), o2 = r3.length;
          _2.push(c2), a2 = E(_2, a2, "key");
          var h2, p2 = 0 | t2._crypto_auth_hmacsha512_keybytes();
          a2.length !== p2 && f(_2, "invalid key length"), h2 = d(a2), _2.push(h2);
          var y2 = 0 == (0 | t2._crypto_auth_hmacsha512_verify(s2, c2, o2, 0, h2));
          return g(_2), y2;
        }
        function J(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_auth_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_auth_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function Q(e3, r3, a2) {
          var _2 = [];
          e3 = E(_2, e3, "tag");
          var s2, n2 = 0 | t2._crypto_auth_bytes();
          e3.length !== n2 && f(_2, "invalid tag length"), s2 = d(e3), _2.push(s2);
          var c2 = d(r3 = E(_2, r3, "message")), o2 = r3.length;
          _2.push(c2), a2 = E(_2, a2, "key");
          var h2, p2 = 0 | t2._crypto_auth_keybytes();
          a2.length !== p2 && f(_2, "invalid key length"), h2 = d(a2), _2.push(h2);
          var y2 = 0 == (0 | t2._crypto_auth_verify(s2, c2, o2, 0, h2));
          return g(_2), y2;
        }
        function Z(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "publicKey");
          var s2, n2 = 0 | t2._crypto_box_publickeybytes();
          e3.length !== n2 && f(_2, "invalid publicKey length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "privateKey");
          var c2, o2 = 0 | t2._crypto_box_secretkeybytes();
          r3.length !== o2 && f(_2, "invalid privateKey length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_box_beforenmbytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_box_beforenm(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function $(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_box_curve25519xchacha20poly1305_publickeybytes()), _2 = a2.address;
          r3.push(_2);
          var s2 = new u(0 | t2._crypto_box_curve25519xchacha20poly1305_secretkeybytes()), n2 = s2.address;
          r3.push(n2), t2._crypto_box_curve25519xchacha20poly1305_keypair(_2, n2);
          var c2 = y({ publicKey: a2, privateKey: s2, keyType: "curve25519" }, e3);
          return g(r3), c2;
        }
        function ee(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "publicKey");
          var c2, o2 = 0 | t2._crypto_box_curve25519xchacha20poly1305_publickeybytes();
          r3.length !== o2 && f(_2, "invalid publicKey length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(n2 + t2._crypto_box_curve25519xchacha20poly1305_sealbytes() | 0), p2 = h2.address;
          _2.push(p2), t2._crypto_box_curve25519xchacha20poly1305_seal(p2, s2, n2, 0, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function re(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "ciphertext");
          var n2, c2 = t2._crypto_box_curve25519xchacha20poly1305_sealbytes(), o2 = e3.length;
          o2 < c2 && f(s2, "ciphertext is too short"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "publicKey");
          var h2, p2 = 0 | t2._crypto_box_curve25519xchacha20poly1305_publickeybytes();
          r3.length !== p2 && f(s2, "invalid publicKey length"), h2 = d(r3), s2.push(h2), a2 = E(s2, a2, "secretKey");
          var i2, v2 = 0 | t2._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
          a2.length !== v2 && f(s2, "invalid secretKey length"), i2 = d(a2), s2.push(i2);
          var b2 = new u(o2 - t2._crypto_box_curve25519xchacha20poly1305_sealbytes() | 0), m2 = b2.address;
          s2.push(m2), t2._crypto_box_curve25519xchacha20poly1305_seal_open(m2, n2, o2, 0, h2, i2);
          var x2 = y(b2, _2);
          return g(s2), x2;
        }
        function te(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2);
          var c2 = d(e3 = E(n2, e3, "message")), o2 = e3.length;
          n2.push(c2), r3 = E(n2, r3, "nonce");
          var h2, p2 = 0 | t2._crypto_box_noncebytes();
          r3.length !== p2 && f(n2, "invalid nonce length"), h2 = d(r3), n2.push(h2), a2 = E(n2, a2, "publicKey");
          var i2, v2 = 0 | t2._crypto_box_publickeybytes();
          a2.length !== v2 && f(n2, "invalid publicKey length"), i2 = d(a2), n2.push(i2), _2 = E(n2, _2, "privateKey");
          var m2, x2 = 0 | t2._crypto_box_secretkeybytes();
          _2.length !== x2 && f(n2, "invalid privateKey length"), m2 = d(_2), n2.push(m2);
          var k2 = new u(0 | o2), S2 = k2.address;
          n2.push(S2);
          var T2 = new u(0 | t2._crypto_box_macbytes()), w2 = T2.address;
          if (n2.push(w2), 0 == (0 | t2._crypto_box_detached(S2, w2, c2, o2, 0, h2, i2, m2))) {
            var Y2 = y({ ciphertext: k2, mac: T2 }, s2);
            return g(n2), Y2;
          }
          b(n2, "invalid usage");
        }
        function ae(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2);
          var c2 = d(e3 = E(n2, e3, "message")), o2 = e3.length;
          n2.push(c2), r3 = E(n2, r3, "nonce");
          var h2, p2 = 0 | t2._crypto_box_noncebytes();
          r3.length !== p2 && f(n2, "invalid nonce length"), h2 = d(r3), n2.push(h2), a2 = E(n2, a2, "publicKey");
          var i2, v2 = 0 | t2._crypto_box_publickeybytes();
          a2.length !== v2 && f(n2, "invalid publicKey length"), i2 = d(a2), n2.push(i2), _2 = E(n2, _2, "privateKey");
          var m2, x2 = 0 | t2._crypto_box_secretkeybytes();
          _2.length !== x2 && f(n2, "invalid privateKey length"), m2 = d(_2), n2.push(m2);
          var k2 = new u(o2 + t2._crypto_box_macbytes() | 0), S2 = k2.address;
          if (n2.push(S2), 0 == (0 | t2._crypto_box_easy(S2, c2, o2, 0, h2, i2, m2))) {
            var T2 = y(k2, s2);
            return g(n2), T2;
          }
          b(n2, "invalid usage");
        }
        function _e(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "message")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_box_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "sharedKey");
          var p2, i2 = 0 | t2._crypto_box_beforenmbytes();
          a2.length !== i2 && f(s2, "invalid sharedKey length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(c2 + t2._crypto_box_macbytes() | 0), m2 = v2.address;
          if (s2.push(m2), 0 == (0 | t2._crypto_box_easy_afternm(m2, n2, c2, 0, o2, p2))) {
            var x2 = y(v2, _2);
            return g(s2), x2;
          }
          b(s2, "invalid usage");
        }
        function se(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_box_publickeybytes()), _2 = a2.address;
          r3.push(_2);
          var s2 = new u(0 | t2._crypto_box_secretkeybytes()), n2 = s2.address;
          if (r3.push(n2), 0 == (0 | t2._crypto_box_keypair(_2, n2))) {
            var c2 = { publicKey: y(a2, e3), privateKey: y(s2, e3), keyType: "x25519" };
            return g(r3), c2;
          }
          b(r3, "internal error");
        }
        function ne(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2);
          var o2 = d(e3 = E(c2, e3, "ciphertext")), h2 = e3.length;
          c2.push(o2), r3 = E(c2, r3, "mac");
          var p2, i2 = 0 | t2._crypto_box_macbytes();
          r3.length !== i2 && f(c2, "invalid mac length"), p2 = d(r3), c2.push(p2), a2 = E(c2, a2, "nonce");
          var v2, m2 = 0 | t2._crypto_box_noncebytes();
          a2.length !== m2 && f(c2, "invalid nonce length"), v2 = d(a2), c2.push(v2), _2 = E(c2, _2, "publicKey");
          var x2, k2 = 0 | t2._crypto_box_publickeybytes();
          _2.length !== k2 && f(c2, "invalid publicKey length"), x2 = d(_2), c2.push(x2), s2 = E(c2, s2, "privateKey");
          var S2, T2 = 0 | t2._crypto_box_secretkeybytes();
          s2.length !== T2 && f(c2, "invalid privateKey length"), S2 = d(s2), c2.push(S2);
          var w2 = new u(0 | h2), Y2 = w2.address;
          if (c2.push(Y2), 0 == (0 | t2._crypto_box_open_detached(Y2, o2, p2, h2, 0, v2, x2, S2))) {
            var B2 = y(w2, n2);
            return g(c2), B2;
          }
          b(c2, "incorrect key pair for the given ciphertext");
        }
        function ce(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2), e3 = E(n2, e3, "ciphertext");
          var c2, o2 = t2._crypto_box_macbytes(), h2 = e3.length;
          h2 < o2 && f(n2, "ciphertext is too short"), c2 = d(e3), n2.push(c2), r3 = E(n2, r3, "nonce");
          var p2, i2 = 0 | t2._crypto_box_noncebytes();
          r3.length !== i2 && f(n2, "invalid nonce length"), p2 = d(r3), n2.push(p2), a2 = E(n2, a2, "publicKey");
          var v2, m2 = 0 | t2._crypto_box_publickeybytes();
          a2.length !== m2 && f(n2, "invalid publicKey length"), v2 = d(a2), n2.push(v2), _2 = E(n2, _2, "privateKey");
          var x2, k2 = 0 | t2._crypto_box_secretkeybytes();
          _2.length !== k2 && f(n2, "invalid privateKey length"), x2 = d(_2), n2.push(x2);
          var S2 = new u(h2 - t2._crypto_box_macbytes() | 0), T2 = S2.address;
          if (n2.push(T2), 0 == (0 | t2._crypto_box_open_easy(T2, c2, h2, 0, p2, v2, x2))) {
            var w2 = y(S2, s2);
            return g(n2), w2;
          }
          b(n2, "incorrect key pair for the given ciphertext");
        }
        function oe(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "ciphertext")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_box_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "sharedKey");
          var p2, i2 = 0 | t2._crypto_box_beforenmbytes();
          a2.length !== i2 && f(s2, "invalid sharedKey length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(c2 - t2._crypto_box_macbytes() | 0), m2 = v2.address;
          if (s2.push(m2), 0 == (0 | t2._crypto_box_open_easy_afternm(m2, n2, c2, 0, o2, p2))) {
            var x2 = y(v2, _2);
            return g(s2), x2;
          }
          b(s2, "incorrect secret key for the given ciphertext");
        }
        function he(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "publicKey");
          var c2, o2 = 0 | t2._crypto_box_publickeybytes();
          r3.length !== o2 && f(_2, "invalid publicKey length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(n2 + t2._crypto_box_sealbytes() | 0), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_box_seal(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function pe(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "ciphertext");
          var n2, c2 = t2._crypto_box_sealbytes(), o2 = e3.length;
          o2 < c2 && f(s2, "ciphertext is too short"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "publicKey");
          var h2, p2 = 0 | t2._crypto_box_publickeybytes();
          r3.length !== p2 && f(s2, "invalid publicKey length"), h2 = d(r3), s2.push(h2), a2 = E(s2, a2, "privateKey");
          var i2, v2 = 0 | t2._crypto_box_secretkeybytes();
          a2.length !== v2 && f(s2, "invalid privateKey length"), i2 = d(a2), s2.push(i2);
          var m2 = new u(o2 - t2._crypto_box_sealbytes() | 0), x2 = m2.address;
          if (s2.push(x2), 0 == (0 | t2._crypto_box_seal_open(x2, n2, o2, 0, h2, i2))) {
            var k2 = y(m2, _2);
            return g(s2), k2;
          }
          b(s2, "incorrect key pair for the given ciphertext");
        }
        function ye(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "seed");
          var _2, s2 = 0 | t2._crypto_box_seedbytes();
          e3.length !== s2 && f(a2, "invalid seed length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_box_publickeybytes()), c2 = n2.address;
          a2.push(c2);
          var o2 = new u(0 | t2._crypto_box_secretkeybytes()), h2 = o2.address;
          if (a2.push(h2), 0 == (0 | t2._crypto_box_seed_keypair(c2, h2, _2))) {
            var p2 = { publicKey: y(n2, r3), privateKey: y(o2, r3), keyType: "x25519" };
            return g(a2), p2;
          }
          b(a2, "invalid usage");
        }
        function ie(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "p");
          var s2, n2 = 0 | t2._crypto_core_ed25519_bytes();
          e3.length !== n2 && f(_2, "invalid p length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "q");
          var c2, o2 = 0 | t2._crypto_core_ed25519_bytes();
          r3.length !== o2 && f(_2, "invalid q length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ed25519_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_core_ed25519_add(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "input is an invalid element");
        }
        function le(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = d(e3 = E(a2, e3, "r"));
          e3.length, a2.push(_2);
          var s2 = new u(0 | t2._crypto_core_ed25519_bytes()), n2 = s2.address;
          if (a2.push(n2), 0 == (0 | t2._crypto_core_ed25519_from_hash(n2, _2))) {
            var c2 = y(s2, r3);
            return g(a2), c2;
          }
          b(a2, "invalid usage");
        }
        function ue(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = d(e3 = E(a2, e3, "r"));
          e3.length, a2.push(_2);
          var s2 = new u(0 | t2._crypto_core_ed25519_bytes()), n2 = s2.address;
          if (a2.push(n2), 0 == (0 | t2._crypto_core_ed25519_from_uniform(n2, _2))) {
            var c2 = y(s2, r3);
            return g(a2), c2;
          }
          b(a2, "invalid usage");
        }
        function de(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "repr");
          var _2, s2 = 0 | t2._crypto_core_ed25519_bytes();
          e3.length !== s2 && f(a2, "invalid repr length"), _2 = d(e3), a2.push(_2);
          var n2 = 1 == (0 | t2._crypto_core_ed25519_is_valid_point(_2));
          return g(a2), n2;
        }
        function ve(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_core_ed25519_bytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_core_ed25519_random(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function ge(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "x");
          var s2, n2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          e3.length !== n2 && f(_2, "invalid x length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "y");
          var c2, o2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          r3.length !== o2 && f(_2, "invalid y length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), p2 = h2.address;
          _2.push(p2), t2._crypto_core_ed25519_scalar_add(p2, s2, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function be(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "s");
          var _2, s2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          e3.length !== s2 && f(a2, "invalid s length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), c2 = n2.address;
          a2.push(c2), t2._crypto_core_ed25519_scalar_complement(c2, _2);
          var o2 = y(n2, r3);
          return g(a2), o2;
        }
        function fe(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "s");
          var _2, s2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          e3.length !== s2 && f(a2, "invalid s length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_core_ed25519_scalar_invert(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid reciprocate");
        }
        function me(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "x");
          var s2, n2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          e3.length !== n2 && f(_2, "invalid x length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "y");
          var c2, o2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          r3.length !== o2 && f(_2, "invalid y length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), p2 = h2.address;
          _2.push(p2), t2._crypto_core_ed25519_scalar_mul(p2, s2, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function Ee(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "s");
          var _2, s2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          e3.length !== s2 && f(a2, "invalid s length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), c2 = n2.address;
          a2.push(c2), t2._crypto_core_ed25519_scalar_negate(c2, _2);
          var o2 = y(n2, r3);
          return g(a2), o2;
        }
        function xe(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_core_ed25519_scalar_random(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function ke(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "sample");
          var _2, s2 = 0 | t2._crypto_core_ed25519_nonreducedscalarbytes();
          e3.length !== s2 && f(a2, "invalid sample length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), c2 = n2.address;
          a2.push(c2), t2._crypto_core_ed25519_scalar_reduce(c2, _2);
          var o2 = y(n2, r3);
          return g(a2), o2;
        }
        function Se(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "x");
          var s2, n2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          e3.length !== n2 && f(_2, "invalid x length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "y");
          var c2, o2 = 0 | t2._crypto_core_ed25519_scalarbytes();
          r3.length !== o2 && f(_2, "invalid y length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ed25519_scalarbytes()), p2 = h2.address;
          _2.push(p2), t2._crypto_core_ed25519_scalar_sub(p2, s2, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function Te(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "p");
          var s2, n2 = 0 | t2._crypto_core_ed25519_bytes();
          e3.length !== n2 && f(_2, "invalid p length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "q");
          var c2, o2 = 0 | t2._crypto_core_ed25519_bytes();
          r3.length !== o2 && f(_2, "invalid q length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ed25519_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_core_ed25519_sub(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "input is an invalid element");
        }
        function we(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "input");
          var n2, c2 = 0 | t2._crypto_core_hchacha20_inputbytes();
          e3.length !== c2 && f(s2, "invalid input length"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "privateKey");
          var o2, h2 = 0 | t2._crypto_core_hchacha20_keybytes();
          r3.length !== h2 && f(s2, "invalid privateKey length"), o2 = d(r3), s2.push(o2);
          var p2 = null;
          null != a2 && (p2 = d(a2 = E(s2, a2, "constant")), a2.length, s2.push(p2));
          var i2 = new u(0 | t2._crypto_core_hchacha20_outputbytes()), v2 = i2.address;
          if (s2.push(v2), 0 == (0 | t2._crypto_core_hchacha20(v2, n2, o2, p2))) {
            var m2 = y(i2, _2);
            return g(s2), m2;
          }
          b(s2, "invalid usage");
        }
        function Ye(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "input");
          var n2, c2 = 0 | t2._crypto_core_hsalsa20_inputbytes();
          e3.length !== c2 && f(s2, "invalid input length"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "privateKey");
          var o2, h2 = 0 | t2._crypto_core_hsalsa20_keybytes();
          r3.length !== h2 && f(s2, "invalid privateKey length"), o2 = d(r3), s2.push(o2);
          var p2 = null;
          null != a2 && (p2 = d(a2 = E(s2, a2, "constant")), a2.length, s2.push(p2));
          var i2 = new u(0 | t2._crypto_core_hsalsa20_outputbytes()), v2 = i2.address;
          if (s2.push(v2), 0 == (0 | t2._crypto_core_hsalsa20(v2, n2, o2, p2))) {
            var m2 = y(i2, _2);
            return g(s2), m2;
          }
          b(s2, "invalid usage");
        }
        function Be(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "p");
          var s2, n2 = 0 | t2._crypto_core_ristretto255_bytes();
          e3.length !== n2 && f(_2, "invalid p length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "q");
          var c2, o2 = 0 | t2._crypto_core_ristretto255_bytes();
          r3.length !== o2 && f(_2, "invalid q length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ristretto255_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_core_ristretto255_add(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "input is an invalid element");
        }
        function Ae(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = d(e3 = E(a2, e3, "r"));
          e3.length, a2.push(_2);
          var s2 = new u(0 | t2._crypto_core_ristretto255_bytes()), n2 = s2.address;
          if (a2.push(n2), 0 == (0 | t2._crypto_core_ristretto255_from_hash(n2, _2))) {
            var c2 = y(s2, r3);
            return g(a2), c2;
          }
          b(a2, "invalid usage");
        }
        function Ke(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "repr");
          var _2, s2 = 0 | t2._crypto_core_ristretto255_bytes();
          e3.length !== s2 && f(a2, "invalid repr length"), _2 = d(e3), a2.push(_2);
          var n2 = 1 == (0 | t2._crypto_core_ristretto255_is_valid_point(_2));
          return g(a2), n2;
        }
        function Me(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_core_ristretto255_bytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_core_ristretto255_random(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function Ie(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "x");
          var s2, n2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== n2 && f(_2, "invalid x length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "y");
          var c2, o2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          r3.length !== o2 && f(_2, "invalid y length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), p2 = h2.address;
          _2.push(p2), t2._crypto_core_ristretto255_scalar_add(p2, s2, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function Ne(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "s");
          var _2, s2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== s2 && f(a2, "invalid s length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), c2 = n2.address;
          a2.push(c2), t2._crypto_core_ristretto255_scalar_complement(c2, _2);
          var o2 = y(n2, r3);
          return g(a2), o2;
        }
        function Le(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "s");
          var _2, s2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== s2 && f(a2, "invalid s length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_core_ristretto255_scalar_invert(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid reciprocate");
        }
        function Ue(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "x");
          var s2, n2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== n2 && f(_2, "invalid x length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "y");
          var c2, o2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          r3.length !== o2 && f(_2, "invalid y length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), p2 = h2.address;
          _2.push(p2), t2._crypto_core_ristretto255_scalar_mul(p2, s2, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function Oe(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "s");
          var _2, s2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== s2 && f(a2, "invalid s length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), c2 = n2.address;
          a2.push(c2), t2._crypto_core_ristretto255_scalar_negate(c2, _2);
          var o2 = y(n2, r3);
          return g(a2), o2;
        }
        function Ce(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_core_ristretto255_scalar_random(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function Re(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "sample");
          var _2, s2 = 0 | t2._crypto_core_ristretto255_nonreducedscalarbytes();
          e3.length !== s2 && f(a2, "invalid sample length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), c2 = n2.address;
          a2.push(c2), t2._crypto_core_ristretto255_scalar_reduce(c2, _2);
          var o2 = y(n2, r3);
          return g(a2), o2;
        }
        function Pe(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "x");
          var s2, n2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== n2 && f(_2, "invalid x length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "y");
          var c2, o2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          r3.length !== o2 && f(_2, "invalid y length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ristretto255_scalarbytes()), p2 = h2.address;
          _2.push(p2), t2._crypto_core_ristretto255_scalar_sub(p2, s2, c2);
          var i2 = y(h2, a2);
          return g(_2), i2;
        }
        function Ge(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "p");
          var s2, n2 = 0 | t2._crypto_core_ristretto255_bytes();
          e3.length !== n2 && f(_2, "invalid p length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "q");
          var c2, o2 = 0 | t2._crypto_core_ristretto255_bytes();
          r3.length !== o2 && f(_2, "invalid q length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_core_ristretto255_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_core_ristretto255_sub(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "input is an invalid element");
        }
        function Xe(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), m(s2, e3, "hash_length"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(s2, "hash_length must be an unsigned integer");
          var n2 = d(r3 = E(s2, r3, "message")), c2 = r3.length;
          s2.push(n2);
          var o2 = null, h2 = 0;
          null != a2 && (o2 = d(a2 = E(s2, a2, "key")), h2 = a2.length, s2.push(o2));
          var p2 = new u(e3 |= 0), i2 = p2.address;
          if (s2.push(i2), 0 == (0 | t2._crypto_generichash(i2, e3, n2, c2, 0, o2, h2))) {
            var v2 = y(p2, _2);
            return g(s2), v2;
          }
          b(s2, "invalid usage");
        }
        function De(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2), m(n2, e3, "subkey_len"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(n2, "subkey_len must be an unsigned integer");
          var c2 = null, o2 = 0;
          null != r3 && (c2 = d(r3 = E(n2, r3, "key")), o2 = r3.length, n2.push(c2));
          var h2 = null, p2 = 0;
          null != a2 && (a2 = E(n2, a2, "id"), p2 = 0 | t2._crypto_generichash_blake2b_saltbytes(), a2.length !== p2 && f(n2, "invalid id length"), h2 = d(a2), n2.push(h2));
          var i2 = null, v2 = 0;
          null != _2 && (_2 = E(n2, _2, "ctx"), v2 = 0 | t2._crypto_generichash_blake2b_personalbytes(), _2.length !== v2 && f(n2, "invalid ctx length"), i2 = d(_2), n2.push(i2));
          var x2 = new u(0 | e3), k2 = x2.address;
          if (n2.push(k2), 0 == (0 | t2._crypto_generichash_blake2b_salt_personal(k2, e3, null, 0, 0, c2, o2, h2, i2))) {
            var S2 = y(x2, s2);
            return g(n2), S2;
          }
          b(n2, "invalid usage");
        }
        function Fe(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address"), m(_2, r3, "hash_length"), ("number" != typeof r3 || (0 | r3) !== r3 || r3 < 0) && f(_2, "hash_length must be an unsigned integer");
          var s2 = new u(r3 |= 0), n2 = s2.address;
          if (_2.push(n2), 0 == (0 | t2._crypto_generichash_final(e3, n2, r3))) {
            var c2 = (t2._free(e3), y(s2, a2));
            return g(_2), c2;
          }
          b(_2, "invalid usage");
        }
        function Ve(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = null, n2 = 0;
          null != e3 && (s2 = d(e3 = E(_2, e3, "key")), n2 = e3.length, _2.push(s2)), m(_2, r3, "hash_length"), ("number" != typeof r3 || (0 | r3) !== r3 || r3 < 0) && f(_2, "hash_length must be an unsigned integer");
          var c2 = new u(357).address;
          if (0 == (0 | t2._crypto_generichash_init(c2, s2, n2, r3))) {
            var o2 = c2;
            return g(_2), o2;
          }
          b(_2, "invalid usage");
        }
        function He(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_generichash_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_generichash_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function qe(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_generichash_update(e3, s2, n2)) && b(_2, "invalid usage"), g(_2);
        }
        function je(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = d(e3 = E(a2, e3, "message")), s2 = e3.length;
          a2.push(_2);
          var n2 = new u(0 | t2._crypto_hash_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_hash(c2, _2, s2, 0))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid usage");
        }
        function ze(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = d(e3 = E(a2, e3, "message")), s2 = e3.length;
          a2.push(_2);
          var n2 = new u(0 | t2._crypto_hash_sha256_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_hash_sha256(c2, _2, s2, 0))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid usage");
        }
        function We(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "state_address");
          var _2 = new u(0 | t2._crypto_hash_sha256_bytes()), s2 = _2.address;
          if (a2.push(s2), 0 == (0 | t2._crypto_hash_sha256_final(e3, s2))) {
            var n2 = (t2._free(e3), y(_2, r3));
            return g(a2), n2;
          }
          b(a2, "invalid usage");
        }
        function Je(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(104).address;
          if (0 == (0 | t2._crypto_hash_sha256_init(a2))) {
            var _2 = a2;
            return g(r3), _2;
          }
          b(r3, "invalid usage");
        }
        function Qe(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_hash_sha256_update(e3, s2, n2)) && b(_2, "invalid usage"), g(_2);
        }
        function Ze(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = d(e3 = E(a2, e3, "message")), s2 = e3.length;
          a2.push(_2);
          var n2 = new u(0 | t2._crypto_hash_sha512_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_hash_sha512(c2, _2, s2, 0))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid usage");
        }
        function $e(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "state_address");
          var _2 = new u(0 | t2._crypto_hash_sha512_bytes()), s2 = _2.address;
          if (a2.push(s2), 0 == (0 | t2._crypto_hash_sha512_final(e3, s2))) {
            var n2 = (t2._free(e3), y(_2, r3));
            return g(a2), n2;
          }
          b(a2, "invalid usage");
        }
        function er(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(208).address;
          if (0 == (0 | t2._crypto_hash_sha512_init(a2))) {
            var _2 = a2;
            return g(r3), _2;
          }
          b(r3, "invalid usage");
        }
        function rr(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_hash_sha512_update(e3, s2, n2)) && b(_2, "invalid usage"), g(_2);
        }
        function tr(e3, r3, a2, _2, n2) {
          var c2 = [];
          l(n2), m(c2, e3, "subkey_len"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(c2, "subkey_len must be an unsigned integer"), m(c2, r3, "subkey_id"), ("number" != typeof r3 || (0 | r3) !== r3 || r3 < 0) && f(c2, "subkey_id must be an unsigned integer"), "string" != typeof a2 && f(c2, "ctx must be a string"), a2 = s(a2 + "\0"), null != h2 && a2.length - 1 !== h2 && f(c2, "invalid ctx length");
          var o2 = d(a2), h2 = a2.length - 1;
          c2.push(o2), _2 = E(c2, _2, "key");
          var p2, i2 = 0 | t2._crypto_kdf_keybytes();
          _2.length !== i2 && f(c2, "invalid key length"), p2 = d(_2), c2.push(p2);
          var v2 = new u(0 | e3), b2 = v2.address;
          c2.push(b2), t2._crypto_kdf_derive_from_key(b2, e3, r3, r3 >>> 24 >>> 8, o2, p2);
          var x2 = y(v2, n2);
          return g(c2), x2;
        }
        function ar(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_kdf_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_kdf_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function _r(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "clientPublicKey");
          var n2, c2 = 0 | t2._crypto_kx_publickeybytes();
          e3.length !== c2 && f(s2, "invalid clientPublicKey length"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "clientSecretKey");
          var o2, h2 = 0 | t2._crypto_kx_secretkeybytes();
          r3.length !== h2 && f(s2, "invalid clientSecretKey length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "serverPublicKey");
          var p2, i2 = 0 | t2._crypto_kx_publickeybytes();
          a2.length !== i2 && f(s2, "invalid serverPublicKey length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(0 | t2._crypto_kx_sessionkeybytes()), m2 = v2.address;
          s2.push(m2);
          var x2 = new u(0 | t2._crypto_kx_sessionkeybytes()), k2 = x2.address;
          if (s2.push(k2), 0 == (0 | t2._crypto_kx_client_session_keys(m2, k2, n2, o2, p2))) {
            var S2 = y({ sharedRx: v2, sharedTx: x2 }, _2);
            return g(s2), S2;
          }
          b(s2, "invalid usage");
        }
        function sr(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_kx_publickeybytes()), _2 = a2.address;
          r3.push(_2);
          var s2 = new u(0 | t2._crypto_kx_secretkeybytes()), n2 = s2.address;
          if (r3.push(n2), 0 == (0 | t2._crypto_kx_keypair(_2, n2))) {
            var c2 = { publicKey: y(a2, e3), privateKey: y(s2, e3), keyType: "x25519" };
            return g(r3), c2;
          }
          b(r3, "internal error");
        }
        function nr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "seed");
          var _2, s2 = 0 | t2._crypto_kx_seedbytes();
          e3.length !== s2 && f(a2, "invalid seed length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_kx_publickeybytes()), c2 = n2.address;
          a2.push(c2);
          var o2 = new u(0 | t2._crypto_kx_secretkeybytes()), h2 = o2.address;
          if (a2.push(h2), 0 == (0 | t2._crypto_kx_seed_keypair(c2, h2, _2))) {
            var p2 = { publicKey: y(n2, r3), privateKey: y(o2, r3), keyType: "x25519" };
            return g(a2), p2;
          }
          b(a2, "internal error");
        }
        function cr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "serverPublicKey");
          var n2, c2 = 0 | t2._crypto_kx_publickeybytes();
          e3.length !== c2 && f(s2, "invalid serverPublicKey length"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "serverSecretKey");
          var o2, h2 = 0 | t2._crypto_kx_secretkeybytes();
          r3.length !== h2 && f(s2, "invalid serverSecretKey length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "clientPublicKey");
          var p2, i2 = 0 | t2._crypto_kx_publickeybytes();
          a2.length !== i2 && f(s2, "invalid clientPublicKey length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(0 | t2._crypto_kx_sessionkeybytes()), m2 = v2.address;
          s2.push(m2);
          var x2 = new u(0 | t2._crypto_kx_sessionkeybytes()), k2 = x2.address;
          if (s2.push(k2), 0 == (0 | t2._crypto_kx_server_session_keys(m2, k2, n2, o2, p2))) {
            var S2 = y({ sharedRx: v2, sharedTx: x2 }, _2);
            return g(s2), S2;
          }
          b(s2, "invalid usage");
        }
        function or(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_onetimeauth_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_onetimeauth_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_onetimeauth(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function hr(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "state_address");
          var _2 = new u(0 | t2._crypto_onetimeauth_bytes()), s2 = _2.address;
          if (a2.push(s2), 0 == (0 | t2._crypto_onetimeauth_final(e3, s2))) {
            var n2 = (t2._free(e3), y(_2, r3));
            return g(a2), n2;
          }
          b(a2, "invalid usage");
        }
        function pr(e3, r3) {
          var a2 = [];
          l(r3);
          var _2 = null;
          null != e3 && (_2 = d(e3 = E(a2, e3, "key")), e3.length, a2.push(_2));
          var s2 = new u(144).address;
          if (0 == (0 | t2._crypto_onetimeauth_init(s2, _2))) {
            var n2 = s2;
            return g(a2), n2;
          }
          b(a2, "invalid usage");
        }
        function yr(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_onetimeauth_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_onetimeauth_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function ir(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_onetimeauth_update(e3, s2, n2)) && b(_2, "invalid usage"), g(_2);
        }
        function lr(e3, r3, a2) {
          var _2 = [];
          e3 = E(_2, e3, "hash");
          var s2, n2 = 0 | t2._crypto_onetimeauth_bytes();
          e3.length !== n2 && f(_2, "invalid hash length"), s2 = d(e3), _2.push(s2);
          var c2 = d(r3 = E(_2, r3, "message")), o2 = r3.length;
          _2.push(c2), a2 = E(_2, a2, "key");
          var h2, p2 = 0 | t2._crypto_onetimeauth_keybytes();
          a2.length !== p2 && f(_2, "invalid key length"), h2 = d(a2), _2.push(h2);
          var y2 = 0 == (0 | t2._crypto_onetimeauth_verify(s2, c2, o2, 0, h2));
          return g(_2), y2;
        }
        function ur(e3, r3, a2, _2, s2, n2, c2) {
          var o2 = [];
          l(c2), m(o2, e3, "keyLength"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(o2, "keyLength must be an unsigned integer");
          var h2 = d(r3 = E(o2, r3, "password")), p2 = r3.length;
          o2.push(h2), a2 = E(o2, a2, "salt");
          var i2, v2 = 0 | t2._crypto_pwhash_saltbytes();
          a2.length !== v2 && f(o2, "invalid salt length"), i2 = d(a2), o2.push(i2), m(o2, _2, "opsLimit"), ("number" != typeof _2 || (0 | _2) !== _2 || _2 < 0) && f(o2, "opsLimit must be an unsigned integer"), m(o2, s2, "memLimit"), ("number" != typeof s2 || (0 | s2) !== s2 || s2 < 0) && f(o2, "memLimit must be an unsigned integer"), m(o2, n2, "algorithm"), ("number" != typeof n2 || (0 | n2) !== n2 || n2 < 0) && f(o2, "algorithm must be an unsigned integer");
          var x2 = new u(0 | e3), k2 = x2.address;
          if (o2.push(k2), 0 == (0 | t2._crypto_pwhash(k2, e3, 0, h2, p2, 0, i2, _2, 0, s2, n2))) {
            var S2 = y(x2, c2);
            return g(o2), S2;
          }
          b(o2, "invalid usage");
        }
        function dr(e3, r3, a2, _2, s2, n2) {
          var c2 = [];
          l(n2), m(c2, e3, "keyLength"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(c2, "keyLength must be an unsigned integer");
          var o2 = d(r3 = E(c2, r3, "password")), h2 = r3.length;
          c2.push(o2), a2 = E(c2, a2, "salt");
          var p2, i2 = 0 | t2._crypto_pwhash_scryptsalsa208sha256_saltbytes();
          a2.length !== i2 && f(c2, "invalid salt length"), p2 = d(a2), c2.push(p2), m(c2, _2, "opsLimit"), ("number" != typeof _2 || (0 | _2) !== _2 || _2 < 0) && f(c2, "opsLimit must be an unsigned integer"), m(c2, s2, "memLimit"), ("number" != typeof s2 || (0 | s2) !== s2 || s2 < 0) && f(c2, "memLimit must be an unsigned integer");
          var v2 = new u(0 | e3), x2 = v2.address;
          if (c2.push(x2), 0 == (0 | t2._crypto_pwhash_scryptsalsa208sha256(x2, e3, 0, o2, h2, 0, p2, _2, 0, s2))) {
            var k2 = y(v2, n2);
            return g(c2), k2;
          }
          b(c2, "invalid usage");
        }
        function vr(e3, r3, a2, _2, s2, n2, c2) {
          var o2 = [];
          l(c2);
          var h2 = d(e3 = E(o2, e3, "password")), p2 = e3.length;
          o2.push(h2);
          var i2 = d(r3 = E(o2, r3, "salt")), v2 = r3.length;
          o2.push(i2), m(o2, a2, "opsLimit"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(o2, "opsLimit must be an unsigned integer"), m(o2, _2, "r"), ("number" != typeof _2 || (0 | _2) !== _2 || _2 < 0) && f(o2, "r must be an unsigned integer"), m(o2, s2, "p"), ("number" != typeof s2 || (0 | s2) !== s2 || s2 < 0) && f(o2, "p must be an unsigned integer"), m(o2, n2, "keyLength"), ("number" != typeof n2 || (0 | n2) !== n2 || n2 < 0) && f(o2, "keyLength must be an unsigned integer");
          var x2 = new u(0 | n2), k2 = x2.address;
          if (o2.push(k2), 0 == (0 | t2._crypto_pwhash_scryptsalsa208sha256_ll(h2, p2, i2, v2, a2, 0, _2, s2, k2, n2))) {
            var S2 = y(x2, c2);
            return g(o2), S2;
          }
          b(o2, "invalid usage");
        }
        function gr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "password")), c2 = e3.length;
          s2.push(n2), m(s2, r3, "opsLimit"), ("number" != typeof r3 || (0 | r3) !== r3 || r3 < 0) && f(s2, "opsLimit must be an unsigned integer"), m(s2, a2, "memLimit"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(s2, "memLimit must be an unsigned integer");
          var o2 = new u(0 | t2._crypto_pwhash_scryptsalsa208sha256_strbytes()).address;
          if (s2.push(o2), 0 == (0 | t2._crypto_pwhash_scryptsalsa208sha256_str(o2, n2, c2, 0, r3, 0, a2))) {
            var h2 = t2.UTF8ToString(o2);
            return g(s2), h2;
          }
          b(s2, "invalid usage");
        }
        function br(e3, r3, a2) {
          var _2 = [];
          l(a2), "string" != typeof e3 && f(_2, "hashed_password must be a string"), e3 = s(e3 + "\0"), null != c2 && e3.length - 1 !== c2 && f(_2, "invalid hashed_password length");
          var n2 = d(e3), c2 = e3.length - 1;
          _2.push(n2);
          var o2 = d(r3 = E(_2, r3, "password")), h2 = r3.length;
          _2.push(o2);
          var p2 = 0 == (0 | t2._crypto_pwhash_scryptsalsa208sha256_str_verify(n2, o2, h2, 0));
          return g(_2), p2;
        }
        function fr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "password")), c2 = e3.length;
          s2.push(n2), m(s2, r3, "opsLimit"), ("number" != typeof r3 || (0 | r3) !== r3 || r3 < 0) && f(s2, "opsLimit must be an unsigned integer"), m(s2, a2, "memLimit"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(s2, "memLimit must be an unsigned integer");
          var o2 = new u(0 | t2._crypto_pwhash_strbytes()).address;
          if (s2.push(o2), 0 == (0 | t2._crypto_pwhash_str(o2, n2, c2, 0, r3, 0, a2))) {
            var h2 = t2.UTF8ToString(o2);
            return g(s2), h2;
          }
          b(s2, "invalid usage");
        }
        function mr(e3, r3, a2, _2) {
          var n2 = [];
          l(_2), "string" != typeof e3 && f(n2, "hashed_password must be a string"), e3 = s(e3 + "\0"), null != o2 && e3.length - 1 !== o2 && f(n2, "invalid hashed_password length");
          var c2 = d(e3), o2 = e3.length - 1;
          n2.push(c2), m(n2, r3, "opsLimit"), ("number" != typeof r3 || (0 | r3) !== r3 || r3 < 0) && f(n2, "opsLimit must be an unsigned integer"), m(n2, a2, "memLimit"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(n2, "memLimit must be an unsigned integer");
          var h2 = 0 != (0 | t2._crypto_pwhash_str_needs_rehash(c2, r3, 0, a2));
          return g(n2), h2;
        }
        function Er(e3, r3, a2) {
          var _2 = [];
          l(a2), "string" != typeof e3 && f(_2, "hashed_password must be a string"), e3 = s(e3 + "\0"), null != c2 && e3.length - 1 !== c2 && f(_2, "invalid hashed_password length");
          var n2 = d(e3), c2 = e3.length - 1;
          _2.push(n2);
          var o2 = d(r3 = E(_2, r3, "password")), h2 = r3.length;
          _2.push(o2);
          var p2 = 0 == (0 | t2._crypto_pwhash_str_verify(n2, o2, h2, 0));
          return g(_2), p2;
        }
        function xr(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "privateKey");
          var s2, n2 = 0 | t2._crypto_scalarmult_scalarbytes();
          e3.length !== n2 && f(_2, "invalid privateKey length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "publicKey");
          var c2, o2 = 0 | t2._crypto_scalarmult_bytes();
          r3.length !== o2 && f(_2, "invalid publicKey length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_scalarmult_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_scalarmult(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "weak public key");
        }
        function kr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "privateKey");
          var _2, s2 = 0 | t2._crypto_scalarmult_scalarbytes();
          e3.length !== s2 && f(a2, "invalid privateKey length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_scalarmult_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_scalarmult_base(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "unknown error");
        }
        function Sr(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "n");
          var s2, n2 = 0 | t2._crypto_scalarmult_ed25519_scalarbytes();
          e3.length !== n2 && f(_2, "invalid n length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "p");
          var c2, o2 = 0 | t2._crypto_scalarmult_ed25519_bytes();
          r3.length !== o2 && f(_2, "invalid p length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_scalarmult_ed25519_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_scalarmult_ed25519(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid point or scalar is 0");
        }
        function Tr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "scalar");
          var _2, s2 = 0 | t2._crypto_scalarmult_ed25519_scalarbytes();
          e3.length !== s2 && f(a2, "invalid scalar length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_scalarmult_ed25519_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_scalarmult_ed25519_base(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "scalar is 0");
        }
        function wr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "scalar");
          var _2, s2 = 0 | t2._crypto_scalarmult_ed25519_scalarbytes();
          e3.length !== s2 && f(a2, "invalid scalar length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_scalarmult_ed25519_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_scalarmult_ed25519_base_noclamp(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "scalar is 0");
        }
        function Yr(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "n");
          var s2, n2 = 0 | t2._crypto_scalarmult_ed25519_scalarbytes();
          e3.length !== n2 && f(_2, "invalid n length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "p");
          var c2, o2 = 0 | t2._crypto_scalarmult_ed25519_bytes();
          r3.length !== o2 && f(_2, "invalid p length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_scalarmult_ed25519_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_scalarmult_ed25519_noclamp(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid point or scalar is 0");
        }
        function Br(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "scalar");
          var s2, n2 = 0 | t2._crypto_scalarmult_ristretto255_scalarbytes();
          e3.length !== n2 && f(_2, "invalid scalar length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "element");
          var c2, o2 = 0 | t2._crypto_scalarmult_ristretto255_bytes();
          r3.length !== o2 && f(_2, "invalid element length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_scalarmult_ristretto255_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_scalarmult_ristretto255(p2, s2, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "result is identity element");
        }
        function Ar(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "scalar");
          var _2, s2 = 0 | t2._crypto_core_ristretto255_scalarbytes();
          e3.length !== s2 && f(a2, "invalid scalar length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_core_ristretto255_bytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_scalarmult_ristretto255_base(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "scalar is 0");
        }
        function Kr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "message")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_secretbox_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "key");
          var p2, i2 = 0 | t2._crypto_secretbox_keybytes();
          a2.length !== i2 && f(s2, "invalid key length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(0 | c2), m2 = v2.address;
          s2.push(m2);
          var x2 = new u(0 | t2._crypto_secretbox_macbytes()), k2 = x2.address;
          if (s2.push(k2), 0 == (0 | t2._crypto_secretbox_detached(m2, k2, n2, c2, 0, o2, p2))) {
            var S2 = y({ mac: x2, cipher: v2 }, _2);
            return g(s2), S2;
          }
          b(s2, "invalid usage");
        }
        function Mr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "message")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_secretbox_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "key");
          var p2, i2 = 0 | t2._crypto_secretbox_keybytes();
          a2.length !== i2 && f(s2, "invalid key length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(c2 + t2._crypto_secretbox_macbytes() | 0), m2 = v2.address;
          if (s2.push(m2), 0 == (0 | t2._crypto_secretbox_easy(m2, n2, c2, 0, o2, p2))) {
            var x2 = y(v2, _2);
            return g(s2), x2;
          }
          b(s2, "invalid usage");
        }
        function Ir(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_secretbox_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_secretbox_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function Nr(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2);
          var c2 = d(e3 = E(n2, e3, "ciphertext")), o2 = e3.length;
          n2.push(c2), r3 = E(n2, r3, "mac");
          var h2, p2 = 0 | t2._crypto_secretbox_macbytes();
          r3.length !== p2 && f(n2, "invalid mac length"), h2 = d(r3), n2.push(h2), a2 = E(n2, a2, "nonce");
          var i2, v2 = 0 | t2._crypto_secretbox_noncebytes();
          a2.length !== v2 && f(n2, "invalid nonce length"), i2 = d(a2), n2.push(i2), _2 = E(n2, _2, "key");
          var m2, x2 = 0 | t2._crypto_secretbox_keybytes();
          _2.length !== x2 && f(n2, "invalid key length"), m2 = d(_2), n2.push(m2);
          var k2 = new u(0 | o2), S2 = k2.address;
          if (n2.push(S2), 0 == (0 | t2._crypto_secretbox_open_detached(S2, c2, h2, o2, 0, i2, m2))) {
            var T2 = y(k2, s2);
            return g(n2), T2;
          }
          b(n2, "wrong secret key for the given ciphertext");
        }
        function Lr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), e3 = E(s2, e3, "ciphertext");
          var n2, c2 = t2._crypto_secretbox_macbytes(), o2 = e3.length;
          o2 < c2 && f(s2, "ciphertext is too short"), n2 = d(e3), s2.push(n2), r3 = E(s2, r3, "nonce");
          var h2, p2 = 0 | t2._crypto_secretbox_noncebytes();
          r3.length !== p2 && f(s2, "invalid nonce length"), h2 = d(r3), s2.push(h2), a2 = E(s2, a2, "key");
          var i2, v2 = 0 | t2._crypto_secretbox_keybytes();
          a2.length !== v2 && f(s2, "invalid key length"), i2 = d(a2), s2.push(i2);
          var m2 = new u(o2 - t2._crypto_secretbox_macbytes() | 0), x2 = m2.address;
          if (s2.push(x2), 0 == (0 | t2._crypto_secretbox_open_easy(x2, n2, o2, 0, h2, i2))) {
            var k2 = y(m2, _2);
            return g(s2), k2;
          }
          b(s2, "wrong secret key for the given ciphertext");
        }
        function Ur(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "header");
          var s2, n2 = 0 | t2._crypto_secretstream_xchacha20poly1305_headerbytes();
          e3.length !== n2 && f(_2, "invalid header length"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_secretstream_xchacha20poly1305_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(52).address;
          if (0 == (0 | t2._crypto_secretstream_xchacha20poly1305_init_pull(h2, s2, c2))) {
            var p2 = h2;
            return g(_2), p2;
          }
          b(_2, "invalid usage");
        }
        function Or(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "key");
          var _2, s2 = 0 | t2._crypto_secretstream_xchacha20poly1305_keybytes();
          e3.length !== s2 && f(a2, "invalid key length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(52).address, c2 = new u(0 | t2._crypto_secretstream_xchacha20poly1305_headerbytes()), o2 = c2.address;
          if (a2.push(o2), 0 == (0 | t2._crypto_secretstream_xchacha20poly1305_init_push(n2, o2, _2))) {
            var h2 = { state: n2, header: y(c2, r3) };
            return g(a2), h2;
          }
          b(a2, "invalid usage");
        }
        function Cr(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_secretstream_xchacha20poly1305_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_secretstream_xchacha20poly1305_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function Rr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), m(s2, e3, "state_address"), r3 = E(s2, r3, "cipher");
          var n2, c2 = t2._crypto_secretstream_xchacha20poly1305_abytes(), o2 = r3.length;
          o2 < c2 && f(s2, "cipher is too short"), n2 = d(r3), s2.push(n2);
          var h2 = null, p2 = 0;
          null != a2 && (h2 = d(a2 = E(s2, a2, "ad")), p2 = a2.length, s2.push(h2));
          var i2 = new u(o2 - t2._crypto_secretstream_xchacha20poly1305_abytes() | 0), b2 = i2.address;
          s2.push(b2);
          var x2, k2 = (x2 = v(1), s2.push(x2), (k2 = 0 === t2._crypto_secretstream_xchacha20poly1305_pull(e3, b2, 0, x2, n2, o2, 0, h2, p2) && { tag: t2.HEAPU8[x2], message: i2 }) && { message: y(k2.message, _2), tag: k2.tag });
          return g(s2), k2;
        }
        function Pr(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2), m(n2, e3, "state_address");
          var c2 = d(r3 = E(n2, r3, "message_chunk")), o2 = r3.length;
          n2.push(c2);
          var h2 = null, p2 = 0;
          null != a2 && (h2 = d(a2 = E(n2, a2, "ad")), p2 = a2.length, n2.push(h2)), m(n2, _2, "tag"), ("number" != typeof _2 || (0 | _2) !== _2 || _2 < 0) && f(n2, "tag must be an unsigned integer");
          var i2 = new u(o2 + t2._crypto_secretstream_xchacha20poly1305_abytes() | 0), v2 = i2.address;
          if (n2.push(v2), 0 == (0 | t2._crypto_secretstream_xchacha20poly1305_push(e3, v2, 0, c2, o2, 0, h2, p2, 0, _2))) {
            var x2 = y(i2, s2);
            return g(n2), x2;
          }
          b(n2, "invalid usage");
        }
        function Gr(e3, r3) {
          var a2 = [];
          return l(r3), m(a2, e3, "state_address"), t2._crypto_secretstream_xchacha20poly1305_rekey(e3), g(a2), true;
        }
        function Xr(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_shorthash_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_shorthash_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_shorthash(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function Dr(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_shorthash_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_shorthash_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function Fr(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "key");
          var c2, o2 = 0 | t2._crypto_shorthash_siphashx24_keybytes();
          r3.length !== o2 && f(_2, "invalid key length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_shorthash_siphashx24_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_shorthash_siphashx24(p2, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function Vr(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "privateKey");
          var c2, o2 = 0 | t2._crypto_sign_secretkeybytes();
          r3.length !== o2 && f(_2, "invalid privateKey length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(e3.length + t2._crypto_sign_bytes() | 0), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_sign(p2, null, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function Hr(e3, r3, a2) {
          var _2 = [];
          l(a2);
          var s2 = d(e3 = E(_2, e3, "message")), n2 = e3.length;
          _2.push(s2), r3 = E(_2, r3, "privateKey");
          var c2, o2 = 0 | t2._crypto_sign_secretkeybytes();
          r3.length !== o2 && f(_2, "invalid privateKey length"), c2 = d(r3), _2.push(c2);
          var h2 = new u(0 | t2._crypto_sign_bytes()), p2 = h2.address;
          if (_2.push(p2), 0 == (0 | t2._crypto_sign_detached(p2, null, s2, n2, 0, c2))) {
            var i2 = y(h2, a2);
            return g(_2), i2;
          }
          b(_2, "invalid usage");
        }
        function qr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "edPk");
          var _2, s2 = 0 | t2._crypto_sign_publickeybytes();
          e3.length !== s2 && f(a2, "invalid edPk length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_scalarmult_scalarbytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_sign_ed25519_pk_to_curve25519(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid key");
        }
        function jr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "edSk");
          var _2, s2 = 0 | t2._crypto_sign_secretkeybytes();
          e3.length !== s2 && f(a2, "invalid edSk length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_scalarmult_scalarbytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_sign_ed25519_sk_to_curve25519(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid key");
        }
        function zr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "privateKey");
          var _2, s2 = 0 | t2._crypto_sign_secretkeybytes();
          e3.length !== s2 && f(a2, "invalid privateKey length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_sign_publickeybytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_sign_ed25519_sk_to_pk(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid key");
        }
        function Wr(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "privateKey");
          var _2, s2 = 0 | t2._crypto_sign_secretkeybytes();
          e3.length !== s2 && f(a2, "invalid privateKey length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_sign_seedbytes()), c2 = n2.address;
          if (a2.push(c2), 0 == (0 | t2._crypto_sign_ed25519_sk_to_seed(c2, _2))) {
            var o2 = y(n2, r3);
            return g(a2), o2;
          }
          b(a2, "invalid key");
        }
        function Jr(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address"), r3 = E(_2, r3, "privateKey");
          var s2, n2 = 0 | t2._crypto_sign_secretkeybytes();
          r3.length !== n2 && f(_2, "invalid privateKey length"), s2 = d(r3), _2.push(s2);
          var c2 = new u(0 | t2._crypto_sign_bytes()), o2 = c2.address;
          if (_2.push(o2), 0 == (0 | t2._crypto_sign_final_create(e3, o2, null, s2))) {
            var h2 = (t2._free(e3), y(c2, a2));
            return g(_2), h2;
          }
          b(_2, "invalid usage");
        }
        function Qr(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), m(s2, e3, "state_address"), r3 = E(s2, r3, "signature");
          var n2, c2 = 0 | t2._crypto_sign_bytes();
          r3.length !== c2 && f(s2, "invalid signature length"), n2 = d(r3), s2.push(n2), a2 = E(s2, a2, "publicKey");
          var o2, h2 = 0 | t2._crypto_sign_publickeybytes();
          a2.length !== h2 && f(s2, "invalid publicKey length"), o2 = d(a2), s2.push(o2);
          var p2 = 0 == (0 | t2._crypto_sign_final_verify(e3, n2, o2));
          return g(s2), p2;
        }
        function Zr(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(208).address;
          if (0 == (0 | t2._crypto_sign_init(a2))) {
            var _2 = a2;
            return g(r3), _2;
          }
          b(r3, "internal error");
        }
        function $r(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_sign_publickeybytes()), _2 = a2.address;
          r3.push(_2);
          var s2 = new u(0 | t2._crypto_sign_secretkeybytes()), n2 = s2.address;
          if (r3.push(n2), 0 == (0 | t2._crypto_sign_keypair(_2, n2))) {
            var c2 = { publicKey: y(a2, e3), privateKey: y(s2, e3), keyType: "ed25519" };
            return g(r3), c2;
          }
          b(r3, "internal error");
        }
        function et(e3, r3, a2) {
          var _2 = [];
          l(a2), e3 = E(_2, e3, "signedMessage");
          var s2, n2 = t2._crypto_sign_bytes(), c2 = e3.length;
          c2 < n2 && f(_2, "signedMessage is too short"), s2 = d(e3), _2.push(s2), r3 = E(_2, r3, "publicKey");
          var o2, h2 = 0 | t2._crypto_sign_publickeybytes();
          r3.length !== h2 && f(_2, "invalid publicKey length"), o2 = d(r3), _2.push(o2);
          var p2 = new u(c2 - t2._crypto_sign_bytes() | 0), i2 = p2.address;
          if (_2.push(i2), 0 == (0 | t2._crypto_sign_open(i2, null, s2, c2, 0, o2))) {
            var v2 = y(p2, a2);
            return g(_2), v2;
          }
          b(_2, "incorrect signature for the given public key");
        }
        function rt(e3, r3) {
          var a2 = [];
          l(r3), e3 = E(a2, e3, "seed");
          var _2, s2 = 0 | t2._crypto_sign_seedbytes();
          e3.length !== s2 && f(a2, "invalid seed length"), _2 = d(e3), a2.push(_2);
          var n2 = new u(0 | t2._crypto_sign_publickeybytes()), c2 = n2.address;
          a2.push(c2);
          var o2 = new u(0 | t2._crypto_sign_secretkeybytes()), h2 = o2.address;
          if (a2.push(h2), 0 == (0 | t2._crypto_sign_seed_keypair(c2, h2, _2))) {
            var p2 = { publicKey: y(n2, r3), privateKey: y(o2, r3), keyType: "ed25519" };
            return g(a2), p2;
          }
          b(a2, "invalid usage");
        }
        function tt(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "state_address");
          var s2 = d(r3 = E(_2, r3, "message_chunk")), n2 = r3.length;
          _2.push(s2), 0 != (0 | t2._crypto_sign_update(e3, s2, n2, 0)) && b(_2, "invalid usage"), g(_2);
        }
        function at(e3, r3, a2) {
          var _2 = [];
          e3 = E(_2, e3, "signature");
          var s2, n2 = 0 | t2._crypto_sign_bytes();
          e3.length !== n2 && f(_2, "invalid signature length"), s2 = d(e3), _2.push(s2);
          var c2 = d(r3 = E(_2, r3, "message")), o2 = r3.length;
          _2.push(c2), a2 = E(_2, a2, "publicKey");
          var h2, p2 = 0 | t2._crypto_sign_publickeybytes();
          a2.length !== p2 && f(_2, "invalid publicKey length"), h2 = d(a2), _2.push(h2);
          var y2 = 0 == (0 | t2._crypto_sign_verify_detached(s2, c2, o2, 0, h2));
          return g(_2), y2;
        }
        function _t(e3, r3, a2, _2) {
          var s2 = [];
          l(_2), m(s2, e3, "outLength"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(s2, "outLength must be an unsigned integer"), r3 = E(s2, r3, "key");
          var n2, c2 = 0 | t2._crypto_stream_chacha20_keybytes();
          r3.length !== c2 && f(s2, "invalid key length"), n2 = d(r3), s2.push(n2), a2 = E(s2, a2, "nonce");
          var o2, h2 = 0 | t2._crypto_stream_chacha20_noncebytes();
          a2.length !== h2 && f(s2, "invalid nonce length"), o2 = d(a2), s2.push(o2);
          var p2 = new u(0 | e3), i2 = p2.address;
          s2.push(i2), t2._crypto_stream_chacha20(i2, e3, 0, o2, n2);
          var v2 = y(p2, _2);
          return g(s2), v2;
        }
        function st(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "input_message")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_stream_chacha20_ietf_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "key");
          var p2, i2 = 0 | t2._crypto_stream_chacha20_ietf_keybytes();
          a2.length !== i2 && f(s2, "invalid key length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(0 | c2), m2 = v2.address;
          if (s2.push(m2), 0 === t2._crypto_stream_chacha20_ietf_xor(m2, n2, c2, 0, o2, p2)) {
            var x2 = y(v2, _2);
            return g(s2), x2;
          }
          b(s2, "invalid usage");
        }
        function nt(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2);
          var c2 = d(e3 = E(n2, e3, "input_message")), o2 = e3.length;
          n2.push(c2), r3 = E(n2, r3, "nonce");
          var h2, p2 = 0 | t2._crypto_stream_chacha20_ietf_noncebytes();
          r3.length !== p2 && f(n2, "invalid nonce length"), h2 = d(r3), n2.push(h2), m(n2, a2, "nonce_increment"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(n2, "nonce_increment must be an unsigned integer"), _2 = E(n2, _2, "key");
          var i2, v2 = 0 | t2._crypto_stream_chacha20_ietf_keybytes();
          _2.length !== v2 && f(n2, "invalid key length"), i2 = d(_2), n2.push(i2);
          var x2 = new u(0 | o2), k2 = x2.address;
          if (n2.push(k2), 0 === t2._crypto_stream_chacha20_ietf_xor_ic(k2, c2, o2, 0, h2, a2, i2)) {
            var S2 = y(x2, s2);
            return g(n2), S2;
          }
          b(n2, "invalid usage");
        }
        function ct(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_stream_chacha20_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_stream_chacha20_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function ot(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "input_message")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_stream_chacha20_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "key");
          var p2, i2 = 0 | t2._crypto_stream_chacha20_keybytes();
          a2.length !== i2 && f(s2, "invalid key length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(0 | c2), m2 = v2.address;
          if (s2.push(m2), 0 === t2._crypto_stream_chacha20_xor(m2, n2, c2, 0, o2, p2)) {
            var x2 = y(v2, _2);
            return g(s2), x2;
          }
          b(s2, "invalid usage");
        }
        function ht(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2);
          var c2 = d(e3 = E(n2, e3, "input_message")), o2 = e3.length;
          n2.push(c2), r3 = E(n2, r3, "nonce");
          var h2, p2 = 0 | t2._crypto_stream_chacha20_noncebytes();
          r3.length !== p2 && f(n2, "invalid nonce length"), h2 = d(r3), n2.push(h2), m(n2, a2, "nonce_increment"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(n2, "nonce_increment must be an unsigned integer"), _2 = E(n2, _2, "key");
          var i2, v2 = 0 | t2._crypto_stream_chacha20_keybytes();
          _2.length !== v2 && f(n2, "invalid key length"), i2 = d(_2), n2.push(i2);
          var x2 = new u(0 | o2), k2 = x2.address;
          if (n2.push(k2), 0 === t2._crypto_stream_chacha20_xor_ic(k2, c2, o2, 0, h2, a2, 0, i2)) {
            var S2 = y(x2, s2);
            return g(n2), S2;
          }
          b(n2, "invalid usage");
        }
        function pt(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_stream_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_stream_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function yt(e3) {
          var r3 = [];
          l(e3);
          var a2 = new u(0 | t2._crypto_stream_xchacha20_keybytes()), _2 = a2.address;
          r3.push(_2), t2._crypto_stream_xchacha20_keygen(_2);
          var s2 = y(a2, e3);
          return g(r3), s2;
        }
        function it(e3, r3, a2, _2) {
          var s2 = [];
          l(_2);
          var n2 = d(e3 = E(s2, e3, "input_message")), c2 = e3.length;
          s2.push(n2), r3 = E(s2, r3, "nonce");
          var o2, h2 = 0 | t2._crypto_stream_xchacha20_noncebytes();
          r3.length !== h2 && f(s2, "invalid nonce length"), o2 = d(r3), s2.push(o2), a2 = E(s2, a2, "key");
          var p2, i2 = 0 | t2._crypto_stream_xchacha20_keybytes();
          a2.length !== i2 && f(s2, "invalid key length"), p2 = d(a2), s2.push(p2);
          var v2 = new u(0 | c2), m2 = v2.address;
          if (s2.push(m2), 0 === t2._crypto_stream_xchacha20_xor(m2, n2, c2, 0, o2, p2)) {
            var x2 = y(v2, _2);
            return g(s2), x2;
          }
          b(s2, "invalid usage");
        }
        function lt(e3, r3, a2, _2, s2) {
          var n2 = [];
          l(s2);
          var c2 = d(e3 = E(n2, e3, "input_message")), o2 = e3.length;
          n2.push(c2), r3 = E(n2, r3, "nonce");
          var h2, p2 = 0 | t2._crypto_stream_xchacha20_noncebytes();
          r3.length !== p2 && f(n2, "invalid nonce length"), h2 = d(r3), n2.push(h2), m(n2, a2, "nonce_increment"), ("number" != typeof a2 || (0 | a2) !== a2 || a2 < 0) && f(n2, "nonce_increment must be an unsigned integer"), _2 = E(n2, _2, "key");
          var i2, v2 = 0 | t2._crypto_stream_xchacha20_keybytes();
          _2.length !== v2 && f(n2, "invalid key length"), i2 = d(_2), n2.push(i2);
          var x2 = new u(0 | o2), k2 = x2.address;
          if (n2.push(k2), 0 === t2._crypto_stream_xchacha20_xor_ic(k2, c2, o2, 0, h2, a2, 0, i2)) {
            var S2 = y(x2, s2);
            return g(n2), S2;
          }
          b(n2, "invalid usage");
        }
        function ut(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "length"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(a2, "length must be an unsigned integer");
          var _2 = new u(0 | e3), s2 = _2.address;
          a2.push(s2), t2._randombytes_buf(s2, e3);
          var n2 = y(_2, r3);
          return g(a2), n2;
        }
        function dt(e3, r3, a2) {
          var _2 = [];
          l(a2), m(_2, e3, "length"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(_2, "length must be an unsigned integer"), r3 = E(_2, r3, "seed");
          var s2, n2 = 0 | t2._randombytes_seedbytes();
          r3.length !== n2 && f(_2, "invalid seed length"), s2 = d(r3), _2.push(s2);
          var c2 = new u(0 | e3), o2 = c2.address;
          _2.push(o2), t2._randombytes_buf_deterministic(o2, e3, s2);
          var h2 = y(c2, a2);
          return g(_2), h2;
        }
        function vt(e3) {
          l(e3), t2._randombytes_close();
        }
        function gt(e3) {
          l(e3);
          var r3 = t2._randombytes_random() >>> 0;
          return g([]), r3;
        }
        function bt(e3, r3) {
          var a2 = [];
          l(r3);
          for (var _2 = t2._malloc(24), s2 = 0; s2 < 6; s2++)
            t2.setValue(_2 + 4 * s2, t2.Runtime.addFunction(e3[["implementation_name", "random", "stir", "uniform", "buf", "close"][s2]]), "i32");
          0 != (0 | t2._randombytes_set_implementation(_2)) && b(a2, "unsupported implementation"), g(a2);
        }
        function ft(e3) {
          l(e3), t2._randombytes_stir();
        }
        function mt(e3, r3) {
          var a2 = [];
          l(r3), m(a2, e3, "upper_bound"), ("number" != typeof e3 || (0 | e3) !== e3 || e3 < 0) && f(a2, "upper_bound must be an unsigned integer");
          var _2 = t2._randombytes_uniform(e3) >>> 0;
          return g(a2), _2;
        }
        function Et() {
          var e3 = t2._sodium_version_string(), r3 = t2.UTF8ToString(e3);
          return g([]), r3;
        }
        return u.prototype.to_Uint8Array = function() {
          var e3 = new Uint8Array(this.length);
          return e3.set(t2.HEAPU8.subarray(this.address, this.address + this.length)), e3;
        }, e2.add = function(e3, r3) {
          if (!(e3 instanceof Uint8Array && r3 instanceof Uint8Array))
            throw new TypeError("Only Uint8Array instances can added");
          var t3 = e3.length, a2 = 0, _2 = 0;
          if (r3.length != e3.length)
            throw new TypeError("Arguments must have the same length");
          for (_2 = 0; _2 < t3; _2++)
            a2 >>= 8, a2 += e3[_2] + r3[_2], e3[_2] = 255 & a2;
        }, e2.base64_variants = o, e2.compare = function(e3, r3) {
          if (!(e3 instanceof Uint8Array && r3 instanceof Uint8Array))
            throw new TypeError("Only Uint8Array instances can be compared");
          if (e3.length !== r3.length)
            throw new TypeError("Only instances of identical length can be compared");
          for (var t3 = 0, a2 = 1, _2 = e3.length; _2-- > 0; )
            t3 |= r3[_2] - e3[_2] >> 8 & a2, a2 &= (r3[_2] ^ e3[_2]) - 1 >> 8;
          return t3 + t3 + a2 - 1;
        }, e2.from_base64 = function(e3, r3) {
          r3 = h(r3);
          var a2, _2 = [], s2 = new u(3 * (e3 = E(_2, e3, "input")).length / 4), n2 = d(e3), c2 = v(4), o2 = v(4);
          return _2.push(n2), _2.push(s2.address), _2.push(s2.result_bin_len_p), _2.push(s2.b64_end_p), 0 !== t2._sodium_base642bin(s2.address, s2.length, n2, e3.length, 0, c2, o2, r3) && b(_2, "invalid input"), t2.getValue(o2, "i32") - n2 !== e3.length && b(_2, "incomplete input"), s2.length = t2.getValue(c2, "i32"), a2 = s2.to_Uint8Array(), g(_2), a2;
        }, e2.from_hex = function(e3) {
          var r3, a2 = [], _2 = new u((e3 = E(a2, e3, "input")).length / 2), s2 = d(e3), n2 = v(4);
          return a2.push(s2), a2.push(_2.address), a2.push(_2.hex_end_p), 0 !== t2._sodium_hex2bin(_2.address, _2.length, s2, e3.length, 0, 0, n2) && b(a2, "invalid input"), t2.getValue(n2, "i32") - s2 !== e3.length && b(a2, "incomplete input"), r3 = _2.to_Uint8Array(), g(a2), r3;
        }, e2.from_string = s, e2.increment = function(e3) {
          if (!(e3 instanceof Uint8Array))
            throw new TypeError("Only Uint8Array instances can be incremented");
          for (var r3 = 256, t3 = 0, a2 = e3.length; t3 < a2; t3++)
            r3 >>= 8, r3 += e3[t3], e3[t3] = 255 & r3;
        }, e2.is_zero = function(e3) {
          if (!(e3 instanceof Uint8Array))
            throw new TypeError("Only Uint8Array instances can be checked");
          for (var r3 = 0, t3 = 0, a2 = e3.length; t3 < a2; t3++)
            r3 |= e3[t3];
          return 0 === r3;
        }, e2.libsodium = r2, e2.memcmp = function(e3, r3) {
          if (!(e3 instanceof Uint8Array && r3 instanceof Uint8Array))
            throw new TypeError("Only Uint8Array instances can be compared");
          if (e3.length !== r3.length)
            throw new TypeError("Only instances of identical length can be compared");
          for (var t3 = 0, a2 = 0, _2 = e3.length; a2 < _2; a2++)
            t3 |= e3[a2] ^ r3[a2];
          return 0 === t3;
        }, e2.memzero = function(e3) {
          if (!(e3 instanceof Uint8Array))
            throw new TypeError("Only Uint8Array instances can be wiped");
          for (var r3 = 0, t3 = e3.length; r3 < t3; r3++)
            e3[r3] = 0;
        }, e2.output_formats = function() {
          return ["uint8array", "text", "hex", "base64"];
        }, e2.pad = function(e3, r3) {
          if (!(e3 instanceof Uint8Array))
            throw new TypeError("buffer must be a Uint8Array");
          if ((r3 |= 0) <= 0)
            throw new Error("block size must be > 0");
          var a2, _2 = [], s2 = v(4), n2 = 1, c2 = 0, o2 = 0 | e3.length, h2 = new u(o2 + r3);
          _2.push(s2), _2.push(h2.address);
          for (var p2 = h2.address, y2 = h2.address + o2 + r3; p2 < y2; p2++)
            t2.HEAPU8[p2] = e3[c2], c2 += n2 = 1 & ~((65535 & ((o2 -= n2) >>> 48 | o2 >>> 32 | o2 >>> 16 | o2)) - 1 >> 16);
          return 0 !== t2._sodium_pad(s2, h2.address, e3.length, r3, h2.length) && b(_2, "internal error"), h2.length = t2.getValue(s2, "i32"), a2 = h2.to_Uint8Array(), g(_2), a2;
        }, e2.unpad = function(e3, r3) {
          if (!(e3 instanceof Uint8Array))
            throw new TypeError("buffer must be a Uint8Array");
          if ((r3 |= 0) <= 0)
            throw new Error("block size must be > 0");
          var a2 = [], _2 = d(e3), s2 = v(4);
          return a2.push(_2), a2.push(s2), 0 !== t2._sodium_unpad(s2, _2, e3.length, r3) && b(a2, "unsupported/invalid padding"), e3 = (e3 = new Uint8Array(e3)).subarray(0, t2.getValue(s2, "i32")), g(a2), e3;
        }, e2.ready = _, e2.symbols = function() {
          return Object.keys(e2).sort();
        }, e2.to_base64 = p, e2.to_hex = c, e2.to_string = n, e2;
      }
      var t = "object" == typeof e.sodium && "function" == typeof e.sodium.onload ? e.sodium.onload : null;
      "function" == typeof define && define.amd ? define(["exports", "libsodium"], r) : "object" == typeof exports2 && "string" != typeof exports2.nodeName ? r(exports2, require_libsodium()) : e.sodium = r(e.commonJsStrict = {}, e.libsodium), t && e.sodium.ready.then(function() {
        t(e.sodium);
      });
    }(exports2);
  }
});

// ../../node_modules/@cosmjs/crypto/build/libsodium.js
var require_libsodium2 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/libsodium.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Xchacha20poly1305Ietf = exports2.xchacha20NonceLength = exports2.Ed25519 = exports2.Ed25519Keypair = exports2.Argon2id = exports2.isArgon2idOptions = void 0;
    var utils_1 = require_build3();
    var libsodium_wrappers_1 = __importDefault(require_libsodium_wrappers());
    function isArgon2idOptions(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.outputLength !== "number")
        return false;
      if (typeof thing.opsLimit !== "number")
        return false;
      if (typeof thing.memLimitKib !== "number")
        return false;
      return true;
    }
    exports2.isArgon2idOptions = isArgon2idOptions;
    var Argon2id = class {
      static async execute(password, salt, options) {
        await libsodium_wrappers_1.default.ready;
        return libsodium_wrappers_1.default.crypto_pwhash(
          options.outputLength,
          password,
          salt,
          // libsodium only supports 16 byte salts and will throw when you don't respect that
          options.opsLimit,
          options.memLimitKib * 1024,
          libsodium_wrappers_1.default.crypto_pwhash_ALG_ARGON2ID13
        );
      }
    };
    exports2.Argon2id = Argon2id;
    var Ed25519Keypair = class {
      constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
      }
      // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
      static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
          throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
      }
      toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
      }
    };
    exports2.Ed25519Keypair = Ed25519Keypair;
    var Ed25519 = class {
      /**
       * Generates a keypair deterministically from a given 32 bytes seed.
       *
       * This seed equals the Ed25519 private key.
       * For implementation details see crypto_sign_seed_keypair in
       * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
       * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      static async makeKeypair(seed) {
        await libsodium_wrappers_1.default.ready;
        const keypair = libsodium_wrappers_1.default.crypto_sign_seed_keypair(seed);
        return Ed25519Keypair.fromLibsodiumPrivkey(keypair.privateKey);
      }
      static async createSignature(message, keyPair) {
        await libsodium_wrappers_1.default.ready;
        return libsodium_wrappers_1.default.crypto_sign_detached(message, keyPair.toLibsodiumPrivkey());
      }
      static async verifySignature(signature, message, pubkey) {
        await libsodium_wrappers_1.default.ready;
        return libsodium_wrappers_1.default.crypto_sign_verify_detached(signature, message, pubkey);
      }
    };
    exports2.Ed25519 = Ed25519;
    exports2.xchacha20NonceLength = 24;
    var Xchacha20poly1305Ietf = class {
      static async encrypt(message, key, nonce) {
        await libsodium_wrappers_1.default.ready;
        const additionalData = null;
        return libsodium_wrappers_1.default.crypto_aead_xchacha20poly1305_ietf_encrypt(
          message,
          additionalData,
          null,
          // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
          nonce,
          key
        );
      }
      static async decrypt(ciphertext, key, nonce) {
        await libsodium_wrappers_1.default.ready;
        const additionalData = null;
        return libsodium_wrappers_1.default.crypto_aead_xchacha20poly1305_ietf_decrypt(
          null,
          // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
          ciphertext,
          additionalData,
          nonce,
          key
        );
      }
    };
    exports2.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
  }
});

// ../../node_modules/@cosmjs/crypto/build/random.js
var require_random = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Random = void 0;
    var Random = class {
      /**
       * Returns `count` cryptographically secure random bytes
       */
      static getBytes(count) {
        try {
          const globalObject = typeof window === "object" ? window : self;
          const cryptoApi = typeof globalObject.crypto !== "undefined" ? globalObject.crypto : globalObject.msCrypto;
          const out = new Uint8Array(count);
          cryptoApi.getRandomValues(out);
          return out;
        } catch (_a) {
          try {
            const crypto = require("crypto");
            return new Uint8Array([...crypto.randomBytes(count)]);
          } catch (_b) {
            throw new Error("No secure random number generator found");
          }
        }
      }
    };
    exports2.Random = Random;
  }
});

// ../../node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "../../node_modules/@noble/hashes/ripemd160.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.RIPEMD160 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
    var Pi = Id.map((i) => (9 * i + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    var shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
    var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
    var rotl = (word, shift) => word << shift | word >>> 32 - shift;
    function f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      else if (group === 1)
        return x & y | ~x & z;
      else if (group === 2)
        return (x | ~y) ^ z;
      else if (group === 3)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    var BUF = new Uint32Array(16);
    var RIPEMD160 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports2.RIPEMD160 = RIPEMD160;
    exports2.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// ../../node_modules/@cosmjs/crypto/build/ripemd.js
var require_ripemd = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/ripemd.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.Ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var utils_1 = require_utils2();
    var Ripemd160 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = ripemd160_1.ripemd160.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports2.Ripemd160 = Ripemd160;
    function ripemd160(data) {
      return new Ripemd160(data).digest();
    }
    exports2.ripemd160 = ripemd160;
  }
});

// ../../node_modules/elliptic/package.json
var require_package = __commonJS({
  "../../node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// ../../node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "../../node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// ../../node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "../../node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// ../../node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils3();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// ../../node_modules/brorand/index.js
var require_brorand = __commonJS({
  "../../node_modules/brorand/index.js"(exports2, module2) {
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto = require("crypto");
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits();
    var Base = require_base();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// ../../node_modules/hash.js/lib/hash/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// ../../node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "../../node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils5();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils5();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// ../../node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// ../../node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha.js
var require_sha4 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// ../../node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils5();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// ../../node_modules/hash.js/lib/hash/hmac.js
var require_hmac3 = __commonJS({
  "../../node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// ../../node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "../../node_modules/hash.js/lib/hash.js"(exports2) {
    var hash = exports2;
    hash.utils = require_utils5();
    hash.common = require_common();
    hash.sha = require_sha4();
    hash.ripemd = require_ripemd2();
    hash.hmac = require_hmac3();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// ../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils4();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// ../../node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "../../node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash = require_hash();
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "../../node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// ../../node_modules/@cosmjs/crypto/build/secp256k1signature.js
var require_secp256k1signature = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/secp256k1signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendedSecp256k1Signature = exports2.Secp256k1Signature = void 0;
    function trimLeadingNullBytes(inData) {
      let numberOfLeadingNullBytes = 0;
      for (const byte of inData) {
        if (byte === 0) {
          numberOfLeadingNullBytes++;
        } else {
          break;
        }
      }
      return inData.slice(numberOfLeadingNullBytes);
    }
    var derTagInteger = 2;
    var Secp256k1Signature = class {
      constructor(r, s) {
        if (r.length > 32 || r.length === 0 || r[0] === 0) {
          throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        }
        if (s.length > 32 || s.length === 0 || s[0] === 0) {
          throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        }
        this.data = {
          r,
          s
        };
      }
      /**
       * Takes the pair of integers (r, s) as 2x32 byte of binary data.
       *
       * Note: This is the format Cosmos SDK uses natively.
       *
       * @param data a 64 byte value containing integers r and s.
       */
      static fromFixedLength(data) {
        if (data.length !== 64) {
          throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);
        }
        return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));
      }
      static fromDer(data) {
        let pos = 0;
        if (data[pos++] !== 48) {
          throw new Error("Prefix 0x30 expected");
        }
        const bodyLength = data[pos++];
        if (data.length - pos !== bodyLength) {
          throw new Error("Data length mismatch detected");
        }
        const rTag = data[pos++];
        if (rTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const rLength = data[pos++];
        if (rLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const rData = data.slice(pos, pos + rLength);
        pos += rLength;
        const sTag = data[pos++];
        if (sTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const sLength = data[pos++];
        if (sLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const sData = data.slice(pos, pos + sLength);
        pos += sLength;
        return new Secp256k1Signature(
          // r/s data can contain leading 0 bytes to express integers being non-negative in DER
          trimLeadingNullBytes(rData),
          trimLeadingNullBytes(sData)
        );
      }
      r(length) {
        if (length === void 0) {
          return this.data.r;
        } else {
          const paddingLength = length - this.data.r.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter r");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.r]);
        }
      }
      s(length) {
        if (length === void 0) {
          return this.data.s;
        } else {
          const paddingLength = length - this.data.s.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter s");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.s]);
        }
      }
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32)]);
      }
      toDer() {
        const rEncoded = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r;
        const sEncoded = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);
        return new Uint8Array([48, data.length, ...data]);
      }
    };
    exports2.Secp256k1Signature = Secp256k1Signature;
    var ExtendedSecp256k1Signature = class extends Secp256k1Signature {
      constructor(r, s, recovery) {
        super(r, s);
        if (!Number.isInteger(recovery)) {
          throw new Error("The recovery parameter must be an integer.");
        }
        if (recovery < 0 || recovery > 4) {
          throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        }
        this.recovery = recovery;
      }
      /**
       * Decode extended signature from the simple fixed length encoding
       * described in toFixedLength().
       */
      static fromFixedLength(data) {
        if (data.length !== 65) {
          throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);
        }
        return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);
      }
      /**
       * A simple custom encoding that encodes the extended signature as
       * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
       * where | denotes concatenation of bonary data.
       */
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
      }
    };
    exports2.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;
  }
});

// ../../node_modules/@cosmjs/crypto/build/secp256k1.js
var require_secp256k12 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/secp256k1.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Secp256k1 = void 0;
    var encoding_1 = require_build();
    var bn_js_1 = __importDefault(require_bn());
    var elliptic_1 = __importDefault(require_elliptic());
    var secp256k1signature_1 = require_secp256k1signature();
    var secp256k1 = new elliptic_1.default.ec("secp256k1");
    var secp256k1N = new bn_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "hex");
    var Secp256k1 = class {
      /**
       * Takes a 32 byte private key and returns a privkey/pubkey pair.
       *
       * The resulting pubkey is uncompressed. For the use in Cosmos it should
       * be compressed first using `Secp256k1.compressPubkey`.
       */
      static async makeKeypair(privkey) {
        if (privkey.length !== 32) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const keypair = secp256k1.keyFromPrivate(privkey);
        if (keypair.validate().result !== true) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const privkeyAsBigInteger = new bn_js_1.default(privkey);
        if (privkeyAsBigInteger.gte(secp256k1N)) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const out = {
          privkey: (0, encoding_1.fromHex)(keypair.getPrivate("hex")),
          // encodes uncompressed as
          // - 1-byte prefix "04"
          // - 32-byte x coordinate
          // - 32-byte y coordinate
          pubkey: Uint8Array.from(keypair.getPublic("array"))
        };
        return out;
      }
      /**
       * Creates a signature that is
       * - deterministic (RFC 6979)
       * - lowS signature
       * - DER encoded
       */
      static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const keypair = secp256k1.keyFromPrivate(privkey);
        const { r, s, recoveryParam } = keypair.sign(messageHash, { canonical: true });
        if (typeof recoveryParam !== "number")
          throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(s.toArray()), recoveryParam);
      }
      static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const keypair = secp256k1.keyFromPublic(pubkey);
        try {
          return keypair.verify(messageHash, signature.toDer());
        } catch (error) {
          return false;
        }
      }
      static recoverPubkey(signature, messageHash) {
        const signatureForElliptic = { r: (0, encoding_1.toHex)(signature.r()), s: (0, encoding_1.toHex)(signature.s()) };
        const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);
        const keypair = secp256k1.keyFromPublic(point);
        return (0, encoding_1.fromHex)(keypair.getPublic(false, "hex"));
      }
      /**
       * Takes a compressed or uncompressed pubkey and return a compressed one.
       *
       * This function is idempotent.
       */
      static compressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return pubkey;
          case 65:
            return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, "array"));
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      /**
       * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
       *
       * This function is idempotent.
       */
      static uncompressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(false, "array"));
          case 65:
            return pubkey;
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      static trimRecoveryByte(signature) {
        switch (signature.length) {
          case 64:
            return signature;
          case 65:
            return signature.slice(0, 64);
          default:
            throw new Error("Invalid signature length");
        }
      }
    };
    exports2.Secp256k1 = Secp256k1;
  }
});

// ../../node_modules/@cosmjs/crypto/build/slip10.js
var require_slip10 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/slip10.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToPath = exports2.pathToString = exports2.Slip10 = exports2.Slip10RawIndex = exports2.slip10CurveFromString = exports2.Slip10Curve = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var bn_js_1 = __importDefault(require_bn());
    var elliptic_1 = __importDefault(require_elliptic());
    var hmac_1 = require_hmac2();
    var sha_1 = require_sha();
    var Slip10Curve;
    (function(Slip10Curve2) {
      Slip10Curve2["Secp256k1"] = "Bitcoin seed";
      Slip10Curve2["Ed25519"] = "ed25519 seed";
    })(Slip10Curve = exports2.Slip10Curve || (exports2.Slip10Curve = {}));
    function slip10CurveFromString(curveString) {
      switch (curveString) {
        case Slip10Curve.Ed25519:
          return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
          return Slip10Curve.Secp256k1;
        default:
          throw new Error(`Unknown curve string: '${curveString}'`);
      }
    }
    exports2.slip10CurveFromString = slip10CurveFromString;
    var Slip10RawIndex = class extends math_1.Uint32 {
      static hardened(hardenedIndex) {
        return new Slip10RawIndex(hardenedIndex + 2 ** 31);
      }
      static normal(normalIndex) {
        return new Slip10RawIndex(normalIndex);
      }
      isHardened() {
        return this.data >= 2 ** 31;
      }
    };
    exports2.Slip10RawIndex = Slip10RawIndex;
    var secp256k1 = new elliptic_1.default.ec("secp256k1");
    var Slip10 = class {
      static derivePath(curve, seed, path) {
        let result = this.master(curve, seed);
        for (const rawIndex of path) {
          result = this.child(curve, result.privkey, result.chainCode, rawIndex);
        }
        return result;
      }
      static master(curve, seed) {
        const i = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) {
          return this.master(curve, i);
        }
        return {
          chainCode: ir,
          privkey: il
        };
      }
      static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i;
        if (rawIndex.isHardened()) {
          const payload = new Uint8Array([0, ...parentPrivkey, ...rawIndex.toBytesBigEndian()]);
          i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
          if (curve === Slip10Curve.Ed25519) {
            throw new Error("Normal keys are not allowed with ed25519");
          } else {
            const data = new Uint8Array([
              ...Slip10.serializedPoint(curve, new bn_js_1.default(parentPrivkey)),
              ...rawIndex.toBytesBigEndian()
            ]);
            i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data).digest();
          }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i);
      }
      /**
       * Implementation of ser_P(point(k_par)) from BIP-0032
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
       */
      static serializedPoint(curve, p) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return (0, encoding_1.fromHex)(secp256k1.g.mul(p).encodeCompressed("hex"));
          default:
            throw new Error("curve not supported");
        }
      }
      static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i) {
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        const returnChainCode = ir;
        if (curve === Slip10Curve.Ed25519) {
          return {
            chainCode: returnChainCode,
            privkey: il
          };
        }
        const n = this.n(curve);
        const returnChildKeyAsNumber = new bn_js_1.default(il).add(new bn_js_1.default(parentPrivkey)).mod(n);
        const returnChildKey = Uint8Array.from(returnChildKeyAsNumber.toArray("be", 32));
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
          const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([1, ...ir, ...rawIndex.toBytesBigEndian()])).digest();
          return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        return {
          chainCode: returnChainCode,
          privkey: returnChildKey
        };
      }
      static isZero(privkey) {
        return privkey.every((byte) => byte === 0);
      }
      static isGteN(curve, privkey) {
        const keyAsNumber = new bn_js_1.default(privkey);
        return keyAsNumber.gte(this.n(curve));
      }
      static n(curve) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return new bn_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
          default:
            throw new Error("curve not supported");
        }
      }
    };
    exports2.Slip10 = Slip10;
    function pathToString(path) {
      return path.reduce((current, component) => {
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
      }, "m");
    }
    exports2.pathToString = pathToString;
    function stringToPath(input) {
      if (!input.startsWith("m"))
        throw new Error("Path string must start with 'm'");
      let rest = input.slice(1);
      const out = new Array();
      while (rest) {
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match)
          throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31)
          throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe)
          out.push(Slip10RawIndex.hardened(value));
        else
          out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
      }
      return out;
    }
    exports2.stringToPath = stringToPath;
  }
});

// ../../node_modules/@cosmjs/crypto/build/index.js
var require_build4 = __commonJS({
  "../../node_modules/@cosmjs/crypto/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToPath = exports2.Slip10RawIndex = exports2.slip10CurveFromString = exports2.Slip10Curve = exports2.Slip10 = exports2.pathToString = exports2.sha512 = exports2.Sha512 = exports2.sha256 = exports2.Sha256 = exports2.Secp256k1Signature = exports2.ExtendedSecp256k1Signature = exports2.Secp256k1 = exports2.ripemd160 = exports2.Ripemd160 = exports2.Random = exports2.Xchacha20poly1305Ietf = exports2.xchacha20NonceLength = exports2.isArgon2idOptions = exports2.Ed25519Keypair = exports2.Ed25519 = exports2.Argon2id = exports2.keccak256 = exports2.Keccak256 = exports2.Hmac = exports2.EnglishMnemonic = exports2.Bip39 = void 0;
    var bip39_1 = require_bip39();
    Object.defineProperty(exports2, "Bip39", { enumerable: true, get: function() {
      return bip39_1.Bip39;
    } });
    Object.defineProperty(exports2, "EnglishMnemonic", { enumerable: true, get: function() {
      return bip39_1.EnglishMnemonic;
    } });
    var hmac_1 = require_hmac2();
    Object.defineProperty(exports2, "Hmac", { enumerable: true, get: function() {
      return hmac_1.Hmac;
    } });
    var keccak_1 = require_keccak();
    Object.defineProperty(exports2, "Keccak256", { enumerable: true, get: function() {
      return keccak_1.Keccak256;
    } });
    Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
      return keccak_1.keccak256;
    } });
    var libsodium_1 = require_libsodium2();
    Object.defineProperty(exports2, "Argon2id", { enumerable: true, get: function() {
      return libsodium_1.Argon2id;
    } });
    Object.defineProperty(exports2, "Ed25519", { enumerable: true, get: function() {
      return libsodium_1.Ed25519;
    } });
    Object.defineProperty(exports2, "Ed25519Keypair", { enumerable: true, get: function() {
      return libsodium_1.Ed25519Keypair;
    } });
    Object.defineProperty(exports2, "isArgon2idOptions", { enumerable: true, get: function() {
      return libsodium_1.isArgon2idOptions;
    } });
    Object.defineProperty(exports2, "xchacha20NonceLength", { enumerable: true, get: function() {
      return libsodium_1.xchacha20NonceLength;
    } });
    Object.defineProperty(exports2, "Xchacha20poly1305Ietf", { enumerable: true, get: function() {
      return libsodium_1.Xchacha20poly1305Ietf;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports2, "Random", { enumerable: true, get: function() {
      return random_1.Random;
    } });
    var ripemd_1 = require_ripemd();
    Object.defineProperty(exports2, "Ripemd160", { enumerable: true, get: function() {
      return ripemd_1.Ripemd160;
    } });
    Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
      return ripemd_1.ripemd160;
    } });
    var secp256k1_1 = require_secp256k12();
    Object.defineProperty(exports2, "Secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.Secp256k1;
    } });
    var secp256k1signature_1 = require_secp256k1signature();
    Object.defineProperty(exports2, "ExtendedSecp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.ExtendedSecp256k1Signature;
    } });
    Object.defineProperty(exports2, "Secp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.Secp256k1Signature;
    } });
    var sha_1 = require_sha();
    Object.defineProperty(exports2, "Sha256", { enumerable: true, get: function() {
      return sha_1.Sha256;
    } });
    Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
      return sha_1.sha256;
    } });
    Object.defineProperty(exports2, "Sha512", { enumerable: true, get: function() {
      return sha_1.Sha512;
    } });
    Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
      return sha_1.sha512;
    } });
    var slip10_1 = require_slip10();
    Object.defineProperty(exports2, "pathToString", { enumerable: true, get: function() {
      return slip10_1.pathToString;
    } });
    Object.defineProperty(exports2, "Slip10", { enumerable: true, get: function() {
      return slip10_1.Slip10;
    } });
    Object.defineProperty(exports2, "Slip10Curve", { enumerable: true, get: function() {
      return slip10_1.Slip10Curve;
    } });
    Object.defineProperty(exports2, "slip10CurveFromString", { enumerable: true, get: function() {
      return slip10_1.slip10CurveFromString;
    } });
    Object.defineProperty(exports2, "Slip10RawIndex", { enumerable: true, get: function() {
      return slip10_1.Slip10RawIndex;
    } });
    Object.defineProperty(exports2, "stringToPath", { enumerable: true, get: function() {
      return slip10_1.stringToPath;
    } });
  }
});

// ../../node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "../../node_modules/@cosmjs/amino/build/pubkeys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMultisigThresholdPubkey = exports2.isSinglePubkey = exports2.pubkeyType = exports2.isSecp256k1Pubkey = exports2.isEd25519Pubkey = void 0;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    exports2.isEd25519Pubkey = isEd25519Pubkey;
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports2.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports2.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports2.pubkeyType.ed25519, exports2.pubkeyType.secp256k1, exports2.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    exports2.isSinglePubkey = isSinglePubkey;
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
    exports2.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
  }
});

// ../../node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/@cosmjs/amino/build/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBech32Pubkey = exports2.encodeAminoPubkey = exports2.decodeBech32Pubkey = exports2.decodeAminoPubkey = exports2.encodeEd25519Pubkey = exports2.encodeSecp256k1Pubkey = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var utils_1 = require_build3();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    exports2.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    exports2.encodeEd25519Pubkey = encodeEd25519Pubkey;
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data) {
      if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSecp256k1)) {
        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixEd25519)) {
        const rest = data.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSr25519)) {
        const rest = data.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data.slice(0, 5)));
      }
    }
    exports2.decodeAminoPubkey = decodeAminoPubkey;
    function decodeBech32Pubkey(bechEncoded) {
      const { data } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data);
    }
    exports2.decodeBech32Pubkey = decodeBech32Pubkey;
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data) {
      const reader = Array.from(data);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    exports2.encodeAminoPubkey = encodeAminoPubkey;
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
    exports2.encodeBech32Pubkey = encodeBech32Pubkey;
  }
});

// ../../node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "../../node_modules/@cosmjs/amino/build/addresses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pubkeyToAddress = exports2.pubkeyToRawAddress = exports2.rawSecp256k1PubkeyToRawAddress = exports2.rawEd25519PubkeyToRawAddress = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    exports2.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    exports2.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    exports2.pubkeyToRawAddress = pubkeyToRawAddress;
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
    exports2.pubkeyToAddress = pubkeyToAddress;
  }
});

// ../../node_modules/@cosmjs/amino/build/coins.js
var require_coins2 = __commonJS({
  "../../node_modules/@cosmjs/amino/build/coins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addCoins = exports2.parseCoins = exports2.coins = exports2.coin = void 0;
    var math_1 = require_build2();
    function coin(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    exports2.coin = coin;
    function coins(amount, denom) {
      return [coin(amount, denom)];
    }
    exports2.coins = coins;
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z]+)/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    exports2.parseCoins = parseCoins;
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
    exports2.addCoins = addCoins;
  }
});

// ../../node_modules/@cosmjs/amino/build/multisig.js
var require_multisig2 = __commonJS({
  "../../node_modules/@cosmjs/amino/build/multisig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMultisigThresholdPubkey = exports2.compareArrays = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var addresses_1 = require_addresses();
    function compareArrays(a, b) {
      const aHex = (0, encoding_1.toHex)(a);
      const bHex = (0, encoding_1.toHex)(b);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    exports2.compareArrays = compareArrays;
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
    exports2.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
  }
});

// ../../node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "../../node_modules/@cosmjs/amino/build/paths.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeCosmoshubPath = void 0;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
    exports2.makeCosmoshubPath = makeCosmoshubPath;
  }
});

// ../../node_modules/@cosmjs/amino/build/signature.js
var require_signature3 = __commonJS({
  "../../node_modules/@cosmjs/amino/build/signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSignature = exports2.encodeSecp256k1Signature = void 0;
    var encoding_1 = require_build();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    exports2.encodeSecp256k1Signature = encodeSecp256k1Signature;
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
    exports2.decodeSignature = decodeSignature;
  }
});

// ../../node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "../../node_modules/@cosmjs/amino/build/signdoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeSignDoc = exports2.makeSignDoc = exports2.sortedJsonStringify = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortedObject(obj[key]);
      });
      return result;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    exports2.sortedJsonStringify = sortedJsonStringify;
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || ""
      };
    }
    exports2.makeSignDoc = makeSignDoc;
    function serializeSignDoc(signDoc) {
      return (0, encoding_1.toUtf8)(sortedJsonStringify(signDoc));
    }
    exports2.serializeSignDoc = serializeSignDoc;
  }
});

// ../../node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "../../node_modules/@cosmjs/amino/build/wallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = exports2.supportedAlgorithms = exports2.executeKdf = exports2.cosmjsSalt = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    exports2.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports2.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports2.executeKdf = executeKdf;
    exports2.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.encrypt = encrypt;
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.decrypt = decrypt;
  }
});

// ../../node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "../../node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Secp256k1HdWallet = exports2.extractKdfConfiguration = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature3();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    exports2.extractKdfConfiguration = extractKdfConfiguration;
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet = class {
      constructor(mnemonic, options) {
        var _a, _b;
        const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;
        const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports2.Secp256k1HdWallet = Secp256k1HdWallet;
  }
});

// ../../node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "../../node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature3();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class {
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports2.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// ../../node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "../../node_modules/@cosmjs/amino/build/stdtx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeStdTx = exports2.isStdTx = void 0;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    exports2.isStdTx = isStdTx;
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
    exports2.makeStdTx = makeStdTx;
  }
});

// ../../node_modules/@cosmjs/amino/build/index.js
var require_build5 = __commonJS({
  "../../node_modules/@cosmjs/amino/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeKdf = exports2.makeStdTx = exports2.isStdTx = exports2.serializeSignDoc = exports2.makeSignDoc = exports2.encodeSecp256k1Signature = exports2.decodeSignature = exports2.Secp256k1Wallet = exports2.Secp256k1HdWallet = exports2.extractKdfConfiguration = exports2.pubkeyType = exports2.isSinglePubkey = exports2.isSecp256k1Pubkey = exports2.isMultisigThresholdPubkey = exports2.isEd25519Pubkey = exports2.makeCosmoshubPath = exports2.createMultisigThresholdPubkey = exports2.encodeSecp256k1Pubkey = exports2.encodeEd25519Pubkey = exports2.encodeBech32Pubkey = exports2.encodeAminoPubkey = exports2.decodeBech32Pubkey = exports2.decodeAminoPubkey = exports2.parseCoins = exports2.coins = exports2.coin = exports2.addCoins = exports2.rawSecp256k1PubkeyToRawAddress = exports2.rawEd25519PubkeyToRawAddress = exports2.pubkeyToRawAddress = exports2.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports2, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports2, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports2, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports2, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins2();
    Object.defineProperty(exports2, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports2, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports2, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports2, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports2, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports2, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports2, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports2, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports2, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports2, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig2();
    Object.defineProperty(exports2, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports2, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports2, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports2, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports2, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports2, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports2, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports2, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports2, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports2, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature3();
    Object.defineProperty(exports2, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports2, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports2, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports2, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports2, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports2, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports2, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/signing.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeSignBytes = exports2.makeSignDoc = exports2.makeAuthInfoBytes = void 0;
    var utils_1 = require_build3();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    var long_1 = __importDefault(require_long());
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: long_1.default.fromNumber(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: long_1.default.fromNumber(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    exports2.makeAuthInfoBytes = makeAuthInfoBytes;
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: long_1.default.fromNumber(accountNumber)
      };
    }
    exports2.makeSignDoc = makeSignDoc;
    function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
    exports2.makeSignBytes = makeSignBytes;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/wallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = exports2.supportedAlgorithms = exports2.executeKdf = exports2.cosmjsSalt = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    exports2.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports2.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports2.executeKdf = executeKdf;
    exports2.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.encrypt = encrypt;
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.decrypt = decrypt;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectSecp256k1HdWallet = exports2.extractKdfConfiguration = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    exports2.extractKdfConfiguration = extractKdfConfiguration;
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet = class {
      constructor(mnemonic, options) {
        var _a, _b;
        const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;
        const hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports2.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class {
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports2.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/paths.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeCosmoshubPath = void 0;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
    exports2.makeCosmoshubPath = makeCosmoshubPath;
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js
var require_keys = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivKey = exports2.PubKey = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "cosmos.crypto.ed25519";
    function createBasePubKey() {
      return { key: new Uint8Array() };
    }
    exports2.PubKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePubKey();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return { key: new Uint8Array() };
    }
    exports2.PrivKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePrivKey();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js
var require_keys2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LegacyAminoPubKey = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    exports2.protobufPackage = "cosmos.crypto.multisig";
    function createBaseLegacyAminoPubKey() {
      return { threshold: 0, publicKeys: [] };
    }
    exports2.LegacyAminoPubKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threshold !== 0) {
          writer.uint32(8).uint32(message.threshold);
        }
        for (const v of message.publicKeys) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLegacyAminoPubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.uint32();
              break;
            case 2:
              message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
          publicKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.publicKeys) ? object.publicKeys.map((e) => any_1.Any.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = Math.round(message.threshold));
        if (message.publicKeys) {
          obj.publicKeys = message.publicKeys.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.publicKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseLegacyAminoPubKey();
        message.threshold = (_a = object.threshold) !== null && _a !== void 0 ? _a : 0;
        message.publicKeys = ((_b = object.publicKeys) === null || _b === void 0 ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js
var require_keys3 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivKey = exports2.PubKey = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "cosmos.crypto.secp256k1";
    function createBasePubKey() {
      return { key: new Uint8Array() };
    }
    exports2.PubKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePubKey();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return { key: new Uint8Array() };
    }
    exports2.PrivKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePrivKey();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodePubkey = exports2.anyToSinglePubkey = exports2.encodePubkey = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    exports2.encodePubkey = encodePubkey;
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    exports2.anyToSinglePubkey = anyToSinglePubkey;
    function decodePubkey(pubkey) {
      if (!pubkey || !pubkey.value) {
        return null;
      }
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized`);
      }
    }
    exports2.decodePubkey = decodePubkey;
  }
});

// ../../node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js
var require_bank = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = exports2.DenomUnit = exports2.Supply = exports2.Output = exports2.Input = exports2.SendEnabled = exports2.Params = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseParams() {
      return { sendEnabled: [], defaultSendEnabled: false };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.sendEnabled) {
          exports2.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
          writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(exports2.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 2:
              message.defaultSendEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sendEnabled: Array.isArray(object === null || object === void 0 ? void 0 : object.sendEnabled) ? object.sendEnabled.map((e) => exports2.SendEnabled.fromJSON(e)) : [],
          defaultSendEnabled: isSet(object.defaultSendEnabled) ? Boolean(object.defaultSendEnabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? exports2.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseParams();
        message.sendEnabled = ((_a = object.sendEnabled) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.SendEnabled.fromPartial(e))) || [];
        message.defaultSendEnabled = (_b = object.defaultSendEnabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseSendEnabled() {
      return { denom: "", enabled: false };
    }
    exports2.SendEnabled = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
          writer.uint32(16).bool(message.enabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.enabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet(object.denom) ? String(object.denom) : "",
          enabled: isSet(object.enabled) ? Boolean(object.enabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseSendEnabled();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseInput() {
      return { address: "", coins: [] };
    }
    exports2.Input = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseInput();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseOutput() {
      return { address: "", coins: [] };
    }
    exports2.Output = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseOutput();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSupply() {
      return { total: [] };
    }
    exports2.Supply = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.total) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { total: Array.isArray(object === null || object === void 0 ? void 0 : object.total) ? object.total.map((e) => coin_1.Coin.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSupply();
        message.total = ((_a = object.total) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDenomUnit() {
      return { denom: "", exponent: 0, aliases: [] };
    }
    exports2.DenomUnit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
          writer.uint32(16).uint32(message.exponent);
        }
        for (const v of message.aliases) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.exponent = reader.uint32();
              break;
            case 3:
              message.aliases.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet(object.denom) ? String(object.denom) : "",
          exponent: isSet(object.exponent) ? Number(object.exponent) : 0,
          aliases: Array.isArray(object === null || object === void 0 ? void 0 : object.aliases) ? object.aliases.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) {
          obj.aliases = message.aliases.map((e) => e);
        } else {
          obj.aliases = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseDenomUnit();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.exponent = (_b = object.exponent) !== null && _b !== void 0 ? _b : 0;
        message.aliases = ((_c = object.aliases) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMetadata() {
      return { description: "", denomUnits: [], base: "", display: "", name: "", symbol: "" };
    }
    exports2.Metadata = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
          writer.uint32(10).string(message.description);
        }
        for (const v of message.denomUnits) {
          exports2.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
          writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
          writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
          writer.uint32(50).string(message.symbol);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = reader.string();
              break;
            case 2:
              message.denomUnits.push(exports2.DenomUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              message.base = reader.string();
              break;
            case 4:
              message.display = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          description: isSet(object.description) ? String(object.description) : "",
          denomUnits: Array.isArray(object === null || object === void 0 ? void 0 : object.denomUnits) ? object.denomUnits.map((e) => exports2.DenomUnit.fromJSON(e)) : [],
          base: isSet(object.base) ? String(object.base) : "",
          display: isSet(object.display) ? String(object.display) : "",
          name: isSet(object.name) ? String(object.name) : "",
          symbol: isSet(object.symbol) ? String(object.symbol) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description);
        if (message.denomUnits) {
          obj.denomUnits = message.denomUnits.map((e) => e ? exports2.DenomUnit.toJSON(e) : void 0);
        } else {
          obj.denomUnits = [];
        }
        message.base !== void 0 && (obj.base = message.base);
        message.display !== void 0 && (obj.display = message.display);
        message.name !== void 0 && (obj.name = message.name);
        message.symbol !== void 0 && (obj.symbol = message.symbol);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMetadata();
        message.description = (_a = object.description) !== null && _a !== void 0 ? _a : "";
        message.denomUnits = ((_b = object.denomUnits) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.DenomUnit.fromPartial(e))) || [];
        message.base = (_c = object.base) !== null && _c !== void 0 ? _c : "";
        message.display = (_d = object.display) !== null && _d !== void 0 ? _d : "";
        message.name = (_e = object.name) !== null && _e !== void 0 ? _e : "";
        message.symbol = (_f = object.symbol) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js
var require_tx2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgMultiSendResponse = exports2.MsgMultiSend = exports2.MsgSendResponse = exports2.MsgSend = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend() {
      return { fromAddress: "", toAddress: "", amount: [] };
    }
    exports2.MsgSend = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : "",
          toAddress: isSet(object.toAddress) ? String(object.toAddress) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgSend();
        message.fromAddress = (_a = object.fromAddress) !== null && _a !== void 0 ? _a : "";
        message.toAddress = (_b = object.toAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse() {
      return {};
    }
    exports2.MsgSendResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSendResponse();
        return message;
      }
    };
    function createBaseMsgMultiSend() {
      return { inputs: [], outputs: [] };
    }
    exports2.MsgMultiSend = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.inputs) {
          bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputs) {
          bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          inputs: Array.isArray(object === null || object === void 0 ? void 0 : object.inputs) ? object.inputs.map((e) => bank_1.Input.fromJSON(e)) : [],
          outputs: Array.isArray(object === null || object === void 0 ? void 0 : object.outputs) ? object.outputs.map((e) => bank_1.Output.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e) => e ? bank_1.Input.toJSON(e) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiSend();
        message.inputs = ((_a = object.inputs) === null || _a === void 0 ? void 0 : _a.map((e) => bank_1.Input.fromPartial(e))) || [];
        message.outputs = ((_b = object.outputs) === null || _b === void 0 ? void 0 : _b.map((e) => bank_1.Output.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse() {
      return {};
    }
    exports2.MsgMultiSendResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgMultiSendResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
      }
      Send(request) {
        const data = exports2.MsgSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data);
        return promise.then((data2) => exports2.MsgSendResponse.decode(new minimal_1.default.Reader(data2)));
      }
      MultiSend(request) {
        const data = exports2.MsgMultiSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data);
        return promise.then((data2) => exports2.MsgMultiSendResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Registry = exports2.isTxBodyEncodeObject = exports2.isPbjsGeneratedType = exports2.isTsProtoGeneratedType = void 0;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTsProtoGeneratedType(type) {
      return typeof type.fromPartial === "function";
    }
    exports2.isTsProtoGeneratedType = isTsProtoGeneratedType;
    function isPbjsGeneratedType(type) {
      return !isTsProtoGeneratedType(type);
    }
    exports2.isPbjsGeneratedType = isPbjsGeneratedType;
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
      googleAny: "/google.protobuf.Any"
    };
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    exports2.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var Registry = class {
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overriden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type) {
        this.types.set(typeUrl, type);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports2.Registry = Registry;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/signer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isOfflineDirectSigner = void 0;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
    exports2.isOfflineDirectSigner = isOfflineDirectSigner;
  }
});

// ../../node_modules/@cosmjs/proto-signing/build/index.js
var require_build6 = __commonJS({
  "../../node_modules/@cosmjs/proto-signing/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.coins = exports2.coin = exports2.executeKdf = exports2.makeSignDoc = exports2.makeSignBytes = exports2.makeAuthInfoBytes = exports2.isOfflineDirectSigner = exports2.Registry = exports2.isTxBodyEncodeObject = exports2.isTsProtoGeneratedType = exports2.isPbjsGeneratedType = exports2.encodePubkey = exports2.decodePubkey = exports2.anyToSinglePubkey = exports2.makeCosmoshubPath = exports2.DirectSecp256k1Wallet = exports2.extractKdfConfiguration = exports2.DirectSecp256k1HdWallet = exports2.decodeTxRaw = exports2.parseCoins = void 0;
    var coins_1 = require_coins();
    Object.defineProperty(exports2, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports2, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports2, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports2, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports2, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports2, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports2, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports2, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports2, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports2, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports2, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports2, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports2, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports2, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports2, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports2, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports2, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports2, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build5();
    Object.defineProperty(exports2, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports2, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
  }
});

// ../../node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js
var require_auth = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.ModuleAccount = exports2.BaseAccount = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    exports2.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseBaseAccount() {
      return { address: "", pubKey: void 0, accountNumber: long_1.default.UZERO, sequence: long_1.default.UZERO };
    }
    exports2.BaseAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pubKey !== void 0) {
          any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (!message.accountNumber.isZero()) {
          writer.uint32(24).uint64(message.accountNumber);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(32).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pubKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.accountNumber = reader.uint64();
              break;
            case 4:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          pubKey: isSet(object.pubKey) ? any_1.Any.fromJSON(object.pubKey) : void 0,
          accountNumber: isSet(object.accountNumber) ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO,
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : void 0);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || long_1.default.UZERO).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseBaseAccount();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? any_1.Any.fromPartial(object.pubKey) : void 0;
        message.accountNumber = object.accountNumber !== void 0 && object.accountNumber !== null ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO;
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseModuleAccount() {
      return { baseAccount: void 0, name: "", permissions: [] };
    }
    exports2.ModuleAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseAccount !== void 0) {
          exports2.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        for (const v of message.permissions) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = exports2.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.permissions.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          baseAccount: isSet(object.baseAccount) ? exports2.BaseAccount.fromJSON(object.baseAccount) : void 0,
          name: isSet(object.name) ? String(object.name) : "",
          permissions: Array.isArray(object === null || object === void 0 ? void 0 : object.permissions) ? object.permissions.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? exports2.BaseAccount.toJSON(message.baseAccount) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        if (message.permissions) {
          obj.permissions = message.permissions.map((e) => e);
        } else {
          obj.permissions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseModuleAccount();
        message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? exports2.BaseAccount.fromPartial(object.baseAccount) : void 0;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.permissions = ((_b = object.permissions) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxMemoCharacters: long_1.default.UZERO,
        txSigLimit: long_1.default.UZERO,
        txSizeCostPerByte: long_1.default.UZERO,
        sigVerifyCostEd25519: long_1.default.UZERO,
        sigVerifyCostSecp256k1: long_1.default.UZERO
      };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxMemoCharacters.isZero()) {
          writer.uint32(8).uint64(message.maxMemoCharacters);
        }
        if (!message.txSigLimit.isZero()) {
          writer.uint32(16).uint64(message.txSigLimit);
        }
        if (!message.txSizeCostPerByte.isZero()) {
          writer.uint32(24).uint64(message.txSizeCostPerByte);
        }
        if (!message.sigVerifyCostEd25519.isZero()) {
          writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        }
        if (!message.sigVerifyCostSecp256k1.isZero()) {
          writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxMemoCharacters = reader.uint64();
              break;
            case 2:
              message.txSigLimit = reader.uint64();
              break;
            case 3:
              message.txSizeCostPerByte = reader.uint64();
              break;
            case 4:
              message.sigVerifyCostEd25519 = reader.uint64();
              break;
            case 5:
              message.sigVerifyCostSecp256k1 = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          maxMemoCharacters: isSet(object.maxMemoCharacters) ? long_1.default.fromValue(object.maxMemoCharacters) : long_1.default.UZERO,
          txSigLimit: isSet(object.txSigLimit) ? long_1.default.fromValue(object.txSigLimit) : long_1.default.UZERO,
          txSizeCostPerByte: isSet(object.txSizeCostPerByte) ? long_1.default.fromValue(object.txSizeCostPerByte) : long_1.default.UZERO,
          sigVerifyCostEd25519: isSet(object.sigVerifyCostEd25519) ? long_1.default.fromValue(object.sigVerifyCostEd25519) : long_1.default.UZERO,
          sigVerifyCostSecp256k1: isSet(object.sigVerifyCostSecp256k1) ? long_1.default.fromValue(object.sigVerifyCostSecp256k1) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = (message.maxMemoCharacters || long_1.default.UZERO).toString());
        message.txSigLimit !== void 0 && (obj.txSigLimit = (message.txSigLimit || long_1.default.UZERO).toString());
        message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || long_1.default.UZERO).toString());
        message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || long_1.default.UZERO).toString());
        message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.maxMemoCharacters = object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null ? long_1.default.fromValue(object.maxMemoCharacters) : long_1.default.UZERO;
        message.txSigLimit = object.txSigLimit !== void 0 && object.txSigLimit !== null ? long_1.default.fromValue(object.txSigLimit) : long_1.default.UZERO;
        message.txSizeCostPerByte = object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null ? long_1.default.fromValue(object.txSizeCostPerByte) : long_1.default.UZERO;
        message.sigVerifyCostEd25519 = object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null ? long_1.default.fromValue(object.sigVerifyCostEd25519) : long_1.default.UZERO;
        message.sigVerifyCostSecp256k1 = object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null ? long_1.default.fromValue(object.sigVerifyCostSecp256k1) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js
var require_vesting = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermanentLockedAccount = exports2.PeriodicVestingAccount = exports2.Period = exports2.DelayedVestingAccount = exports2.ContinuousVestingAccount = exports2.BaseVestingAccount = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var auth_1 = require_auth();
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseBaseVestingAccount() {
      return {
        baseAccount: void 0,
        originalVesting: [],
        delegatedFree: [],
        delegatedVesting: [],
        endTime: long_1.default.ZERO
      };
    }
    exports2.BaseVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseAccount !== void 0) {
          auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.originalVesting) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.delegatedFree) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.delegatedVesting) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (!message.endTime.isZero()) {
          writer.uint32(40).int64(message.endTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.endTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          baseAccount: isSet(object.baseAccount) ? auth_1.BaseAccount.fromJSON(object.baseAccount) : void 0,
          originalVesting: Array.isArray(object === null || object === void 0 ? void 0 : object.originalVesting) ? object.originalVesting.map((e) => coin_1.Coin.fromJSON(e)) : [],
          delegatedFree: Array.isArray(object === null || object === void 0 ? void 0 : object.delegatedFree) ? object.delegatedFree.map((e) => coin_1.Coin.fromJSON(e)) : [],
          delegatedVesting: Array.isArray(object === null || object === void 0 ? void 0 : object.delegatedVesting) ? object.delegatedVesting.map((e) => coin_1.Coin.fromJSON(e)) : [],
          endTime: isSet(object.endTime) ? long_1.default.fromValue(object.endTime) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : void 0);
        if (message.originalVesting) {
          obj.originalVesting = message.originalVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.originalVesting = [];
        }
        if (message.delegatedFree) {
          obj.delegatedFree = message.delegatedFree.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedFree = [];
        }
        if (message.delegatedVesting) {
          obj.delegatedVesting = message.delegatedVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedVesting = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseBaseVestingAccount();
        message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? auth_1.BaseAccount.fromPartial(object.baseAccount) : void 0;
        message.originalVesting = ((_a = object.originalVesting) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedFree = ((_b = object.delegatedFree) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedVesting = ((_c = object.delegatedVesting) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.endTime = object.endTime !== void 0 && object.endTime !== null ? long_1.default.fromValue(object.endTime) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseContinuousVestingAccount() {
      return { baseVestingAccount: void 0, startTime: long_1.default.ZERO };
    }
    exports2.ContinuousVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (!message.startTime.isZero()) {
          writer.uint32(16).int64(message.startTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContinuousVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          baseVestingAccount: isSet(object.baseVestingAccount) ? exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0,
          startTime: isSet(object.startTime) ? long_1.default.fromValue(object.startTime) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContinuousVestingAccount();
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        message.startTime = object.startTime !== void 0 && object.startTime !== null ? long_1.default.fromValue(object.startTime) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseDelayedVestingAccount() {
      return { baseVestingAccount: void 0 };
    }
    exports2.DelayedVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelayedVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          baseVestingAccount: isSet(object.baseVestingAccount) ? exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelayedVestingAccount();
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        return message;
      }
    };
    function createBasePeriod() {
      return { length: long_1.default.ZERO, amount: [] };
    }
    exports2.Period = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.length.isZero()) {
          writer.uint32(8).int64(message.length);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.length = reader.int64();
              break;
            case 2:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          length: isSet(object.length) ? long_1.default.fromValue(object.length) : long_1.default.ZERO,
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.length !== void 0 && (obj.length = (message.length || long_1.default.ZERO).toString());
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePeriod();
        message.length = object.length !== void 0 && object.length !== null ? long_1.default.fromValue(object.length) : long_1.default.ZERO;
        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePeriodicVestingAccount() {
      return { baseVestingAccount: void 0, startTime: long_1.default.ZERO, vestingPeriods: [] };
    }
    exports2.PeriodicVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (!message.startTime.isZero()) {
          writer.uint32(16).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          exports2.Period.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            case 3:
              message.vestingPeriods.push(exports2.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          baseVestingAccount: isSet(object.baseVestingAccount) ? exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0,
          startTime: isSet(object.startTime) ? long_1.default.fromValue(object.startTime) : long_1.default.ZERO,
          vestingPeriods: Array.isArray(object === null || object === void 0 ? void 0 : object.vestingPeriods) ? object.vestingPeriods.map((e) => exports2.Period.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || long_1.default.ZERO).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? exports2.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePeriodicVestingAccount();
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        message.startTime = object.startTime !== void 0 && object.startTime !== null ? long_1.default.fromValue(object.startTime) : long_1.default.ZERO;
        message.vestingPeriods = ((_a = object.vestingPeriods) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Period.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePermanentLockedAccount() {
      return { baseVestingAccount: void 0 };
    }
    exports2.PermanentLockedAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          baseVestingAccount: isSet(object.baseVestingAccount) ? exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePermanentLockedAccount();
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/accounts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.accountFromAny = void 0;
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodePubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      var _a, _b, _c, _d, _e, _f, _g;
      const { typeUrl, value } = input;
      switch (typeUrl) {
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = (_a = vesting_1.BaseVestingAccount.decode(value)) === null || _a === void 0 ? void 0 : _a.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = (_c = (_b = vesting_1.ContinuousVestingAccount.decode(value)) === null || _b === void 0 ? void 0 : _b.baseVestingAccount) === null || _c === void 0 ? void 0 : _c.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = (_e = (_d = vesting_1.DelayedVestingAccount.decode(value)) === null || _d === void 0 ? void 0 : _d.baseVestingAccount) === null || _e === void 0 ? void 0 : _e.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = (_g = (_f = vesting_1.PeriodicVestingAccount.decode(value)) === null || _f === void 0 ? void 0 : _f.baseVestingAccount) === null || _g === void 0 ? void 0 : _g.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
    exports2.accountFromAny = accountFromAny;
  }
});

// ../../node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/aminotypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AminoTypes = void 0;
    function isAminoConverter(converter) {
      return typeof converter[1] !== "string";
    }
    var AminoTypes = class {
      constructor(types) {
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (converter === "not_supported_by_chain") {
          throw new Error(`The message type '${typeUrl}' cannot be signed using the Amino JSON sign mode because this is not supported by chain.`);
        }
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(isAminoConverter).filter(([_typeUrl, { aminoType }]) => aminoType === type);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports2.AminoTypes = AminoTypes;
  }
});

// ../../node_modules/@cosmjs/stargate/build/events.js
var require_events = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromTendermint34Event = void 0;
    var encoding_1 = require_build();
    function fromTendermint34Event(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: (0, encoding_1.fromUtf8)(attr.key, true),
          value: (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
    exports2.fromTendermint34Event = fromTendermint34Event;
  }
});

// ../../node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/fee.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateFee = exports2.GasPrice = void 0;
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class {
      constructor(amount, denom) {
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-z][a-z0-9]*)$/i);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports2.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
    exports2.calculateFee = calculateFee;
  }
});

// ../../node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/logs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findAttribute = exports2.parseRawLog = exports2.parseLogs = exports2.parseLog = exports2.parseEvent = exports2.parseAttribute = void 0;
    var utils_1 = require_build3();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    exports2.parseAttribute = parseAttribute;
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    exports2.parseEvent = parseEvent;
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    exports2.parseLog = parseLog;
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    exports2.parseLogs = parseLogs;
    function parseRawLog(input = "[]") {
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    exports2.parseRawLog = parseRawLog;
    function findAttribute(logs, eventType, attrKey) {
      var _a;
      const firstLogs = logs.find(() => true);
      const out = (_a = firstLogs === null || firstLogs === void 0 ? void 0 : firstLogs.events.find((event) => event.type === eventType)) === null || _a === void 0 ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
    exports2.findAttribute = findAttribute;
  }
});

// ../../node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js
var require_pagination = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageResponse = exports2.PageRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "cosmos.base.query.v1beta1";
    function createBasePageRequest() {
      return { key: new Uint8Array(), offset: long_1.default.UZERO, limit: long_1.default.UZERO, countTotal: false, reverse: false };
    }
    exports2.PageRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (!message.offset.isZero()) {
          writer.uint32(16).uint64(message.offset);
        }
        if (!message.limit.isZero()) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
          writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
          writer.uint32(40).bool(message.reverse);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.offset = reader.uint64();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.countTotal = reader.bool();
              break;
            case 5:
              message.reverse = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          offset: isSet(object.offset) ? long_1.default.fromValue(object.offset) : long_1.default.UZERO,
          limit: isSet(object.limit) ? long_1.default.fromValue(object.limit) : long_1.default.UZERO,
          countTotal: isSet(object.countTotal) ? Boolean(object.countTotal) : false,
          reverse: isSet(object.reverse) ? Boolean(object.reverse) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.offset !== void 0 && (obj.offset = (message.offset || long_1.default.UZERO).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || long_1.default.UZERO).toString());
        message.countTotal !== void 0 && (obj.countTotal = message.countTotal);
        message.reverse !== void 0 && (obj.reverse = message.reverse);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePageRequest();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.offset = object.offset !== void 0 && object.offset !== null ? long_1.default.fromValue(object.offset) : long_1.default.UZERO;
        message.limit = object.limit !== void 0 && object.limit !== null ? long_1.default.fromValue(object.limit) : long_1.default.UZERO;
        message.countTotal = (_b = object.countTotal) !== null && _b !== void 0 ? _b : false;
        message.reverse = (_c = object.reverse) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    function createBasePageResponse() {
      return { nextKey: new Uint8Array(), total: long_1.default.UZERO };
    }
    exports2.PageResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nextKey.length !== 0) {
          writer.uint32(10).bytes(message.nextKey);
        }
        if (!message.total.isZero()) {
          writer.uint32(16).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextKey = reader.bytes();
              break;
            case 2:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          nextKey: isSet(object.nextKey) ? bytesFromBase64(object.nextKey) : new Uint8Array(),
          total: isSet(object.total) ? long_1.default.fromValue(object.total) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.nextKey !== void 0 && (obj.nextKey = base64FromBytes(message.nextKey !== void 0 ? message.nextKey : new Uint8Array()));
        message.total !== void 0 && (obj.total = (message.total || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePageResponse();
        message.nextKey = (_a = object.nextKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.total = object.total !== void 0 && object.total !== null ? long_1.default.fromValue(object.total) : long_1.default.UZERO;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js
var require_query = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryAccountResponse = exports2.QueryAccountRequest = exports2.QueryAccountsResponse = exports2.QueryAccountsRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var pagination_1 = require_pagination();
    var auth_1 = require_auth();
    exports2.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseQueryAccountsRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryAccountsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAccountsResponse() {
      return { accounts: [], pagination: void 0 };
    }
    exports2.QueryAccountsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          accounts: Array.isArray(object === null || object === void 0 ? void 0 : object.accounts) ? object.accounts.map((e) => any_1.Any.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAccountsResponse();
        message.accounts = ((_a = object.accounts) === null || _a === void 0 ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAccountRequest() {
      return { address: "" };
    }
    exports2.QueryAccountRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { address: isSet(object.address) ? String(object.address) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAccountRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryAccountResponse() {
      return { account: void 0 };
    }
    exports2.QueryAccountResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { account: isSet(object.account) ? any_1.Any.fromJSON(object.account) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountResponse();
        message.account = object.account !== void 0 && object.account !== null ? any_1.Any.fromPartial(object.account) : void 0;
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = auth_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? auth_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? auth_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.Params = this.Params.bind(this);
      }
      Accounts(request) {
        const data = exports2.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
        return promise.then((data2) => exports2.QueryAccountsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Account(request) {
        const data = exports2.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data);
        return promise.then((data2) => exports2.QueryAccountResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@confio/ics23/build/generated/codecimpl.js
var require_codecimpl = __commonJS({
  "../../node_modules/@confio/ics23/build/generated/codecimpl.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.ics23 = function() {
      var ics23 = {};
      ics23.HashOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_HASH"] = 0;
        values[valuesById[1] = "SHA256"] = 1;
        values[valuesById[2] = "SHA512"] = 2;
        values[valuesById[3] = "KECCAK"] = 3;
        values[valuesById[4] = "RIPEMD160"] = 4;
        values[valuesById[5] = "BITCOIN"] = 5;
        values[valuesById[6] = "SHA512_256"] = 6;
        return values;
      }();
      ics23.LengthOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_PREFIX"] = 0;
        values[valuesById[1] = "VAR_PROTO"] = 1;
        values[valuesById[2] = "VAR_RLP"] = 2;
        values[valuesById[3] = "FIXED32_BIG"] = 3;
        values[valuesById[4] = "FIXED32_LITTLE"] = 4;
        values[valuesById[5] = "FIXED64_BIG"] = 5;
        values[valuesById[6] = "FIXED64_LITTLE"] = 6;
        values[valuesById[7] = "REQUIRE_32_BYTES"] = 7;
        values[valuesById[8] = "REQUIRE_64_BYTES"] = 8;
        return values;
      }();
      ics23.ExistenceProof = function() {
        function ExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ExistenceProof.prototype.key = $util.newBuffer([]);
        ExistenceProof.prototype.value = $util.newBuffer([]);
        ExistenceProof.prototype.leaf = null;
        ExistenceProof.prototype.path = $util.emptyArray;
        ExistenceProof.create = function create(properties) {
          return new ExistenceProof(properties);
        };
        ExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length)
            for (var i = 0; i < message.path.length; ++i)
              $root.ics23.InnerOp.encode(message.path[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
          return writer;
        };
        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.path[i]);
              if (error)
                return "path." + error;
            }
          }
          return null;
        };
        ExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ExistenceProof)
            return object;
          var message = new $root.ics23.ExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.ExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.ExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i) {
              if (typeof object.path[i] !== "object")
                throw TypeError(".ics23.ExistenceProof.path: object expected");
              message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);
            }
          }
          return message;
        };
        ExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);
          }
          return object;
        };
        ExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExistenceProof;
      }();
      ics23.NonExistenceProof = function() {
        function NonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NonExistenceProof.prototype.key = $util.newBuffer([]);
        NonExistenceProof.prototype.left = null;
        NonExistenceProof.prototype.right = null;
        NonExistenceProof.create = function create(properties) {
          return new NonExistenceProof(properties);
        };
        NonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.ExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.ExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.ExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.ExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        NonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.NonExistenceProof)
            return object;
          var message = new $root.ics23.NonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.NonExistenceProof.left: object expected");
            message.left = $root.ics23.ExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.NonExistenceProof.right: object expected");
            message.right = $root.ics23.ExistenceProof.fromObject(object.right);
          }
          return message;
        };
        NonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.ExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.ExistenceProof.toObject(message.right, options);
          return object;
        };
        NonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return NonExistenceProof;
      }();
      ics23.CommitmentProof = function() {
        function CommitmentProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CommitmentProof.prototype.exist = null;
        CommitmentProof.prototype.nonexist = null;
        CommitmentProof.prototype.batch = null;
        CommitmentProof.prototype.compressed = null;
        var $oneOfFields;
        Object.defineProperty(CommitmentProof.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist", "batch", "compressed"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CommitmentProof.create = function create(properties) {
          return new CommitmentProof(properties);
        };
        CommitmentProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.batch != null && message.hasOwnProperty("batch"))
            $root.ics23.BatchProof.encode(message.batch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.compressed != null && message.hasOwnProperty("compressed"))
            $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          return writer;
        };
        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CommitmentProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());
                break;
              case 4:
                message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CommitmentProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.BatchProof.verify(message.batch);
              if (error)
                return "batch." + error;
            }
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedBatchProof.verify(message.compressed);
              if (error)
                return "compressed." + error;
            }
          }
          return null;
        };
        CommitmentProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CommitmentProof)
            return object;
          var message = new $root.ics23.CommitmentProof();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CommitmentProof.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          if (object.batch != null) {
            if (typeof object.batch !== "object")
              throw TypeError(".ics23.CommitmentProof.batch: object expected");
            message.batch = $root.ics23.BatchProof.fromObject(object.batch);
          }
          if (object.compressed != null) {
            if (typeof object.compressed !== "object")
              throw TypeError(".ics23.CommitmentProof.compressed: object expected");
            message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);
          }
          return message;
        };
        CommitmentProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            object.batch = $root.ics23.BatchProof.toObject(message.batch, options);
            if (options.oneofs)
              object.proof = "batch";
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);
            if (options.oneofs)
              object.proof = "compressed";
          }
          return object;
        };
        CommitmentProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CommitmentProof;
      }();
      ics23.LeafOp = function() {
        function LeafOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        LeafOp.prototype.hash = 0;
        LeafOp.prototype.prehashKey = 0;
        LeafOp.prototype.prehashValue = 0;
        LeafOp.prototype.length = 0;
        LeafOp.prototype.prefix = $util.newBuffer([]);
        LeafOp.create = function create(properties) {
          return new LeafOp(properties);
        };
        LeafOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.prehashKey);
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.prehashValue);
          if (message.length != null && message.hasOwnProperty("length"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.length);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.prefix);
          return writer;
        };
        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        LeafOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prehashKey = reader.int32();
                break;
              case 3:
                message.prehashValue = reader.int32();
                break;
              case 4:
                message.length = reader.int32();
                break;
              case 5:
                message.prefix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        LeafOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        LeafOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            switch (message.prehashKey) {
              default:
                return "prehashKey: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            switch (message.prehashValue) {
              default:
                return "prehashValue: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.length != null && message.hasOwnProperty("length"))
            switch (message.length) {
              default:
                return "length: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          return null;
        };
        LeafOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.LeafOp)
            return object;
          var message = new $root.ics23.LeafOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          switch (object.prehashKey) {
            case "NO_HASH":
            case 0:
              message.prehashKey = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashKey = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashKey = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashKey = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashKey = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashKey = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashKey = 6;
              break;
          }
          switch (object.prehashValue) {
            case "NO_HASH":
            case 0:
              message.prehashValue = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashValue = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashValue = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashValue = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashValue = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashValue = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashValue = 6;
              break;
          }
          switch (object.length) {
            case "NO_PREFIX":
            case 0:
              message.length = 0;
              break;
            case "VAR_PROTO":
            case 1:
              message.length = 1;
              break;
            case "VAR_RLP":
            case 2:
              message.length = 2;
              break;
            case "FIXED32_BIG":
            case 3:
              message.length = 3;
              break;
            case "FIXED32_LITTLE":
            case 4:
              message.length = 4;
              break;
            case "FIXED64_BIG":
            case 5:
              message.length = 5;
              break;
            case "FIXED64_LITTLE":
            case 6:
              message.length = 6;
              break;
            case "REQUIRE_32_BYTES":
            case 7:
              message.length = 7;
              break;
            case "REQUIRE_64_BYTES":
            case 8:
              message.length = 8;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          return message;
        };
        LeafOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            object.prehashKey = options.enums === String ? "NO_HASH" : 0;
            object.prehashValue = options.enums === String ? "NO_HASH" : 0;
            object.length = options.enums === String ? "NO_PREFIX" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;
          if (message.length != null && message.hasOwnProperty("length"))
            object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          return object;
        };
        LeafOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LeafOp;
      }();
      ics23.InnerOp = function() {
        function InnerOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerOp.prototype.hash = 0;
        InnerOp.prototype.prefix = $util.newBuffer([]);
        InnerOp.prototype.suffix = $util.newBuffer([]);
        InnerOp.create = function create(properties) {
          return new InnerOp(properties);
        };
        InnerOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.prefix);
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.suffix);
          return writer;
        };
        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prefix = reader.bytes();
                break;
              case 3:
                message.suffix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          if (message.suffix != null && message.hasOwnProperty("suffix")) {
            if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
              return "suffix: buffer expected";
          }
          return null;
        };
        InnerOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerOp)
            return object;
          var message = new $root.ics23.InnerOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          if (object.suffix != null) {
            if (typeof object.suffix === "string")
              $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
            else if (object.suffix.length)
              message.suffix = object.suffix;
          }
          return message;
        };
        InnerOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
            if (options.bytes === String)
              object.suffix = "";
            else {
              object.suffix = [];
              if (options.bytes !== Array)
                object.suffix = $util.newBuffer(object.suffix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
          return object;
        };
        InnerOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerOp;
      }();
      ics23.ProofSpec = function() {
        function ProofSpec(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ProofSpec.prototype.leafSpec = null;
        ProofSpec.prototype.innerSpec = null;
        ProofSpec.prototype.maxDepth = 0;
        ProofSpec.prototype.minDepth = 0;
        ProofSpec.create = function create(properties) {
          return new ProofSpec(properties);
        };
        ProofSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.maxDepth);
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.minDepth);
          return writer;
        };
        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ProofSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 2:
                message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());
                break;
              case 3:
                message.maxDepth = reader.int32();
                break;
              case 4:
                message.minDepth = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ProofSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ProofSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec")) {
            var error = $root.ics23.LeafOp.verify(message.leafSpec);
            if (error)
              return "leafSpec." + error;
          }
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec")) {
            var error = $root.ics23.InnerSpec.verify(message.innerSpec);
            if (error)
              return "innerSpec." + error;
          }
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth")) {
            if (!$util.isInteger(message.maxDepth))
              return "maxDepth: integer expected";
          }
          if (message.minDepth != null && message.hasOwnProperty("minDepth")) {
            if (!$util.isInteger(message.minDepth))
              return "minDepth: integer expected";
          }
          return null;
        };
        ProofSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ProofSpec)
            return object;
          var message = new $root.ics23.ProofSpec();
          if (object.leafSpec != null) {
            if (typeof object.leafSpec !== "object")
              throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
            message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);
          }
          if (object.innerSpec != null) {
            if (typeof object.innerSpec !== "object")
              throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
            message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);
          }
          if (object.maxDepth != null)
            message.maxDepth = object.maxDepth | 0;
          if (object.minDepth != null)
            message.minDepth = object.minDepth | 0;
          return message;
        };
        ProofSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.leafSpec = null;
            object.innerSpec = null;
            object.maxDepth = 0;
            object.minDepth = 0;
          }
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            object.maxDepth = message.maxDepth;
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            object.minDepth = message.minDepth;
          return object;
        };
        ProofSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProofSpec;
      }();
      ics23.InnerSpec = function() {
        function InnerSpec(properties) {
          this.childOrder = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerSpec.prototype.childOrder = $util.emptyArray;
        InnerSpec.prototype.childSize = 0;
        InnerSpec.prototype.minPrefixLength = 0;
        InnerSpec.prototype.maxPrefixLength = 0;
        InnerSpec.prototype.emptyChild = $util.newBuffer([]);
        InnerSpec.prototype.hash = 0;
        InnerSpec.create = function create(properties) {
          return new InnerSpec(properties);
        };
        InnerSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.childOrder != null && message.childOrder.length) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork();
            for (var i = 0; i < message.childOrder.length; ++i)
              writer.int32(message.childOrder[i]);
            writer.ldelim();
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.childSize);
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.minPrefixLength);
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.maxPrefixLength);
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.emptyChild);
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).int32(message.hash);
          return writer;
        };
        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.childOrder && message.childOrder.length))
                  message.childOrder = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.childOrder.push(reader.int32());
                } else
                  message.childOrder.push(reader.int32());
                break;
              case 2:
                message.childSize = reader.int32();
                break;
              case 3:
                message.minPrefixLength = reader.int32();
                break;
              case 4:
                message.maxPrefixLength = reader.int32();
                break;
              case 5:
                message.emptyChild = reader.bytes();
                break;
              case 6:
                message.hash = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.childOrder != null && message.hasOwnProperty("childOrder")) {
            if (!Array.isArray(message.childOrder))
              return "childOrder: array expected";
            for (var i = 0; i < message.childOrder.length; ++i)
              if (!$util.isInteger(message.childOrder[i]))
                return "childOrder: integer[] expected";
          }
          if (message.childSize != null && message.hasOwnProperty("childSize")) {
            if (!$util.isInteger(message.childSize))
              return "childSize: integer expected";
          }
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength")) {
            if (!$util.isInteger(message.minPrefixLength))
              return "minPrefixLength: integer expected";
          }
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength")) {
            if (!$util.isInteger(message.maxPrefixLength))
              return "maxPrefixLength: integer expected";
          }
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild")) {
            if (!(message.emptyChild && typeof message.emptyChild.length === "number" || $util.isString(message.emptyChild)))
              return "emptyChild: buffer expected";
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          return null;
        };
        InnerSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerSpec)
            return object;
          var message = new $root.ics23.InnerSpec();
          if (object.childOrder) {
            if (!Array.isArray(object.childOrder))
              throw TypeError(".ics23.InnerSpec.childOrder: array expected");
            message.childOrder = [];
            for (var i = 0; i < object.childOrder.length; ++i)
              message.childOrder[i] = object.childOrder[i] | 0;
          }
          if (object.childSize != null)
            message.childSize = object.childSize | 0;
          if (object.minPrefixLength != null)
            message.minPrefixLength = object.minPrefixLength | 0;
          if (object.maxPrefixLength != null)
            message.maxPrefixLength = object.maxPrefixLength | 0;
          if (object.emptyChild != null) {
            if (typeof object.emptyChild === "string")
              $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);
            else if (object.emptyChild.length)
              message.emptyChild = object.emptyChild;
          }
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          return message;
        };
        InnerSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.childOrder = [];
          if (options.defaults) {
            object.childSize = 0;
            object.minPrefixLength = 0;
            object.maxPrefixLength = 0;
            if (options.bytes === String)
              object.emptyChild = "";
            else {
              object.emptyChild = [];
              if (options.bytes !== Array)
                object.emptyChild = $util.newBuffer(object.emptyChild);
            }
            object.hash = options.enums === String ? "NO_HASH" : 0;
          }
          if (message.childOrder && message.childOrder.length) {
            object.childOrder = [];
            for (var j = 0; j < message.childOrder.length; ++j)
              object.childOrder[j] = message.childOrder[j];
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            object.childSize = message.childSize;
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            object.minPrefixLength = message.minPrefixLength;
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            object.maxPrefixLength = message.maxPrefixLength;
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          return object;
        };
        InnerSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerSpec;
      }();
      ics23.BatchProof = function() {
        function BatchProof(properties) {
          this.entries = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchProof.prototype.entries = $util.emptyArray;
        BatchProof.create = function create(properties) {
          return new BatchProof(properties);
        };
        BatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.BatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          return null;
        };
        BatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchProof)
            return object;
          var message = new $root.ics23.BatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.BatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.BatchProof.entries: object expected");
              message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);
            }
          }
          return message;
        };
        BatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.entries = [];
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);
          }
          return object;
        };
        BatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchProof;
      }();
      ics23.BatchEntry = function() {
        function BatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchEntry.prototype.exist = null;
        BatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(BatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        BatchEntry.create = function create(properties) {
          return new BatchEntry(properties);
        };
        BatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        BatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchEntry)
            return object;
          var message = new $root.ics23.BatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.BatchEntry.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.BatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        BatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        BatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchEntry;
      }();
      ics23.CompressedBatchProof = function() {
        function CompressedBatchProof(properties) {
          this.entries = [];
          this.lookupInners = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchProof.prototype.entries = $util.emptyArray;
        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;
        CompressedBatchProof.create = function create(properties) {
          return new CompressedBatchProof(properties);
        };
        CompressedBatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.lookupInners != null && message.lookupInners.length)
            for (var i = 0; i < message.lookupInners.length; ++i)
              $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.lookupInners && message.lookupInners.length))
                  message.lookupInners = [];
                message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          if (message.lookupInners != null && message.hasOwnProperty("lookupInners")) {
            if (!Array.isArray(message.lookupInners))
              return "lookupInners: array expected";
            for (var i = 0; i < message.lookupInners.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);
              if (error)
                return "lookupInners." + error;
            }
          }
          return null;
        };
        CompressedBatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchProof)
            return object;
          var message = new $root.ics23.CompressedBatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
              message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);
            }
          }
          if (object.lookupInners) {
            if (!Array.isArray(object.lookupInners))
              throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
            message.lookupInners = [];
            for (var i = 0; i < object.lookupInners.length; ++i) {
              if (typeof object.lookupInners[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
              message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);
            }
          }
          return message;
        };
        CompressedBatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.entries = [];
            object.lookupInners = [];
          }
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);
          }
          if (message.lookupInners && message.lookupInners.length) {
            object.lookupInners = [];
            for (var j = 0; j < message.lookupInners.length; ++j)
              object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);
          }
          return object;
        };
        CompressedBatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchProof;
      }();
      ics23.CompressedBatchEntry = function() {
        function CompressedBatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchEntry.prototype.exist = null;
        CompressedBatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(CompressedBatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CompressedBatchEntry.create = function create(properties) {
          return new CompressedBatchEntry(properties);
        };
        CompressedBatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        CompressedBatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchEntry)
            return object;
          var message = new $root.ics23.CompressedBatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
            message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        CompressedBatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        CompressedBatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchEntry;
      }();
      ics23.CompressedExistenceProof = function() {
        function CompressedExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedExistenceProof.prototype.value = $util.newBuffer([]);
        CompressedExistenceProof.prototype.leaf = null;
        CompressedExistenceProof.prototype.path = $util.emptyArray;
        CompressedExistenceProof.create = function create(properties) {
          return new CompressedExistenceProof(properties);
        };
        CompressedExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork();
            for (var i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          return writer;
        };
        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          return null;
        };
        CompressedExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedExistenceProof)
            return object;
          var message = new $root.ics23.CompressedExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          return message;
        };
        CompressedExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          return object;
        };
        CompressedExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedExistenceProof;
      }();
      ics23.CompressedNonExistenceProof = function() {
        function CompressedNonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedNonExistenceProof.prototype.left = null;
        CompressedNonExistenceProof.prototype.right = null;
        CompressedNonExistenceProof.create = function create(properties) {
          return new CompressedNonExistenceProof(properties);
        };
        CompressedNonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedNonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedNonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        CompressedNonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedNonExistenceProof)
            return object;
          var message = new $root.ics23.CompressedNonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
            message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
            message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);
          }
          return message;
        };
        CompressedNonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);
          return object;
        };
        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedNonExistenceProof;
      }();
      return ics23;
    }();
    module2.exports = $root;
  }
});

// ../../node_modules/@confio/ics23/build/compress.js
var require_compress = __commonJS({
  "../../node_modules/@confio/ics23/build/compress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompress = exports2.compress = void 0;
    var codecimpl_1 = require_codecimpl();
    function compress(proof) {
      if (!proof.batch) {
        return proof;
      }
      return { compressed: compressBatch(proof.batch) };
    }
    exports2.compress = compress;
    function decompress(proof) {
      if (!proof.compressed) {
        return proof;
      }
      return { batch: decompressBatch(proof.compressed) };
    }
    exports2.decompress = decompress;
    function compressBatch(proof) {
      const centries = [];
      const lookup = [];
      const registry = /* @__PURE__ */ new Map();
      for (const entry of proof.entries) {
        if (entry.exist) {
          const centry = { exist: compressExist(entry.exist, lookup, registry) };
          centries.push(centry);
        } else if (entry.nonexist) {
          const non = entry.nonexist;
          const centry = {
            nonexist: {
              key: non.key,
              left: compressExist(non.left, lookup, registry),
              right: compressExist(non.right, lookup, registry)
            }
          };
          centries.push(centry);
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      }
      return {
        entries: centries,
        lookupInners: lookup
      };
    }
    function compressExist(exist, lookup, registry) {
      if (!exist) {
        return void 0;
      }
      const path = exist.path.map((inner) => {
        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();
        let idx = registry.get(sig);
        if (idx === void 0) {
          idx = lookup.length;
          lookup.push(inner);
          registry.set(sig, idx);
        }
        return idx;
      });
      return {
        key: exist.key,
        value: exist.value,
        leaf: exist.leaf,
        path
      };
    }
    function decompressBatch(proof) {
      const lookup = proof.lookupInners;
      const entries = proof.entries.map((comp) => {
        if (comp.exist) {
          return { exist: decompressExist(comp.exist, lookup) };
        } else if (comp.nonexist) {
          const non = comp.nonexist;
          return {
            nonexist: {
              key: non.key,
              left: decompressExist(non.left, lookup),
              right: decompressExist(non.right, lookup)
            }
          };
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      });
      return {
        entries
      };
    }
    function decompressExist(exist, lookup) {
      if (!exist) {
        return void 0;
      }
      const { key, value, leaf, path } = exist;
      const newPath = (path || []).map((idx) => lookup[idx]);
      return { key, value, leaf, path: newPath };
    }
  }
});

// ../../node_modules/@confio/ics23/build/ops.js
var require_ops = __commonJS({
  "../../node_modules/@confio/ics23/build/ops.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.doHash = exports2.applyInner = exports2.applyLeaf = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var codecimpl_1 = require_codecimpl();
    function applyLeaf(leaf, key, value) {
      if (key.length === 0) {
        throw new Error("Missing key");
      }
      if (value.length === 0) {
        throw new Error("Missing value");
      }
      const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);
      const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);
      const data = new Uint8Array([
        ...ensureBytes(leaf.prefix),
        ...pkey,
        ...pvalue
      ]);
      return doHash(ensureHash(leaf.hash), data);
    }
    exports2.applyLeaf = applyLeaf;
    function applyInner(inner, child) {
      if (child.length === 0) {
        throw new Error("Inner op needs child value");
      }
      const preimage = new Uint8Array([
        ...ensureBytes(inner.prefix),
        ...child,
        ...ensureBytes(inner.suffix)
      ]);
      return doHash(ensureHash(inner.hash), preimage);
    }
    exports2.applyInner = applyInner;
    function ensure(maybe, value) {
      return maybe === void 0 || maybe === null ? value : maybe;
    }
    var ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);
    var ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);
    var ensureBytes = (b) => ensure(b, new Uint8Array([]));
    function prepareLeafData(hashOp, lengthOp, data) {
      const h = doHashOrNoop(hashOp, data);
      return doLengthOp(lengthOp, h);
    }
    function doHashOrNoop(hashOp, preimage) {
      if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {
        return preimage;
      }
      return doHash(hashOp, preimage);
    }
    function doHash(hashOp, preimage) {
      switch (hashOp) {
        case codecimpl_1.ics23.HashOp.SHA256:
          return (0, sha256_1.sha256)(preimage);
        case codecimpl_1.ics23.HashOp.SHA512:
          return (0, sha512_1.sha512)(preimage);
        case codecimpl_1.ics23.HashOp.RIPEMD160:
          return (0, ripemd160_1.ripemd160)(preimage);
        case codecimpl_1.ics23.HashOp.BITCOIN:
          return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));
        case codecimpl_1.ics23.HashOp.SHA512_256:
          return (0, sha512_1.sha512_256)(preimage);
      }
      throw new Error(`Unsupported hashop: ${hashOp}`);
    }
    exports2.doHash = doHash;
    function doLengthOp(lengthOp, data) {
      switch (lengthOp) {
        case codecimpl_1.ics23.LengthOp.NO_PREFIX:
          return data;
        case codecimpl_1.ics23.LengthOp.VAR_PROTO:
          return new Uint8Array([...encodeVarintProto(data.length), ...data]);
        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:
          if (data.length !== 32) {
            throw new Error(`Length is ${data.length}, not 32 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:
          if (data.length !== 64) {
            throw new Error(`Length is ${data.length}, not 64 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:
          return new Uint8Array([...encodeFixed32Le(data.length), ...data]);
      }
      throw new Error(`Unsupported lengthop: ${lengthOp}`);
    }
    function encodeVarintProto(n) {
      let enc = [];
      let l = n;
      while (l >= 128) {
        const b = l % 128 + 128;
        enc = [...enc, b];
        l = l / 128;
      }
      enc = [...enc, l];
      return new Uint8Array(enc);
    }
    function encodeFixed32Le(n) {
      const enc = new Uint8Array(4);
      let l = n;
      for (let i = enc.length; i > 0; i--) {
        enc[Math.abs(i - enc.length)] = l % 256;
        l = Math.floor(l / 256);
      }
      return enc;
    }
  }
});

// ../../node_modules/@confio/ics23/build/specs.js
var require_specs = __commonJS({
  "../../node_modules/@confio/ics23/build/specs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytesBefore = exports2.ensureBytesBefore = exports2.bytesEqual = exports2.ensureBytesEqual = exports2.ensureInner = exports2.ensureLeaf = void 0;
    function ensureLeaf(leaf, spec) {
      if (leaf.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${leaf.hash}`);
      }
      if (leaf.prehashKey !== spec.prehashKey) {
        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);
      }
      if (leaf.prehashValue !== spec.prehashValue) {
        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);
      }
      if (leaf.length !== spec.length) {
        throw new Error(`Unexpected length op: ${leaf.length}`);
      }
      ensurePrefix(leaf.prefix, spec.prefix);
    }
    exports2.ensureLeaf = ensureLeaf;
    function ensureInner(inner, prefix, spec) {
      if (inner.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${inner.hash}`);
      }
      if (!inner.prefix) {
        throw new Error("No prefix set for inner node");
      }
      if (hasPrefix(inner.prefix, prefix)) {
        throw new Error(`Inner node has leaf prefix`);
      }
      if (inner.prefix.length < (spec.minPrefixLength || 0)) {
        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);
      }
      const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;
      if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {
        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);
      }
    }
    exports2.ensureInner = ensureInner;
    function ensurePrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return;
      }
      if (!check) {
        throw new Error(`Target bytes missing`);
      }
      ensureBytesEqual(prefix, check.slice(0, prefix.length));
    }
    function ensureBytesEqual(a, b) {
      if (a.length !== b.length) {
        throw new Error(`Different lengths ${a.length} vs ${b.length}`);
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);
        }
      }
    }
    exports2.ensureBytesEqual = ensureBytesEqual;
    function bytesEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.bytesEqual = bytesEqual;
    function hasPrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return false;
      }
      if (!check) {
        return false;
      }
      if (check.length <= prefix.length) {
        return false;
      }
      for (let i = 0; i < prefix.length; i++) {
        if (check[i] !== prefix[i]) {
          return false;
        }
      }
      throw true;
    }
    function ensureBytesBefore(first, last) {
      if (!bytesBefore(first, last)) {
        throw new Error("first is after last");
      }
    }
    exports2.ensureBytesBefore = ensureBytesBefore;
    function bytesBefore(first, last) {
      const min = first.length < last.length ? first.length : last.length;
      for (let i = 0; i < min; i++) {
        if (first[i] < last[i]) {
          return true;
        }
        if (first[i] > last[i]) {
          return false;
        }
      }
      return first.length < last.length;
    }
    exports2.bytesBefore = bytesBefore;
  }
});

// ../../node_modules/@confio/ics23/build/proofs.js
var require_proofs = __commonJS({
  "../../node_modules/@confio/ics23/build/proofs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureLeftNeighbor = exports2.ensureSpec = exports2.calculateExistenceRoot = exports2.verifyNonExistence = exports2.verifyExistence = exports2.smtSpec = exports2.tendermintSpec = exports2.iavlSpec = void 0;
    var codecimpl_1 = require_codecimpl();
    var ops_1 = require_ops();
    var specs_1 = require_specs();
    exports2.iavlSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 4,
        maxPrefixLength: 12,
        childSize: 33,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports2.tendermintSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 1,
        maxPrefixLength: 1,
        childSize: 32,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports2.smtSpec = {
      leafSpec: {
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,
        prefix: Uint8Array.from([0])
      },
      innerSpec: {
        childOrder: [0, 1],
        childSize: 32,
        minPrefixLength: 1,
        maxPrefixLength: 1,
        emptyChild: new Uint8Array(32),
        hash: codecimpl_1.ics23.HashOp.SHA256
      },
      maxDepth: 256
    };
    function verifyExistence(proof, spec, root, key, value) {
      ensureSpec(proof, spec);
      const calc = calculateExistenceRoot(proof);
      (0, specs_1.ensureBytesEqual)(calc, root);
      (0, specs_1.ensureBytesEqual)(key, proof.key);
      (0, specs_1.ensureBytesEqual)(value, proof.value);
    }
    exports2.verifyExistence = verifyExistence;
    function verifyNonExistence(proof, spec, root, key) {
      let leftKey;
      let rightKey;
      if (proof.left) {
        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);
        leftKey = proof.left.key;
      }
      if (proof.right) {
        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);
        rightKey = proof.right.key;
      }
      if (!leftKey && !rightKey) {
        throw new Error("neither left nor right proof defined");
      }
      if (leftKey) {
        (0, specs_1.ensureBytesBefore)(leftKey, key);
      }
      if (rightKey) {
        (0, specs_1.ensureBytesBefore)(key, rightKey);
      }
      if (!spec.innerSpec) {
        throw new Error("no inner spec");
      }
      if (!leftKey) {
        ensureLeftMost(spec.innerSpec, proof.right.path);
      } else if (!rightKey) {
        ensureRightMost(spec.innerSpec, proof.left.path);
      } else {
        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);
      }
      return;
    }
    exports2.verifyNonExistence = verifyNonExistence;
    function calculateExistenceRoot(proof) {
      if (!proof.key || !proof.value) {
        throw new Error("Existence proof needs key and value set");
      }
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      const path = proof.path || [];
      let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);
      for (const inner of path) {
        res = (0, ops_1.applyInner)(inner, res);
      }
      return res;
    }
    exports2.calculateExistenceRoot = calculateExistenceRoot;
    function ensureSpec(proof, spec) {
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      if (!spec.leafSpec) {
        throw new Error("Spec must include leafSpec");
      }
      if (!spec.innerSpec) {
        throw new Error("Spec must include innerSpec");
      }
      (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);
      const path = proof.path || [];
      if (spec.minDepth && path.length < spec.minDepth) {
        throw new Error(`Too few inner nodes ${path.length}`);
      }
      if (spec.maxDepth && path.length > spec.maxDepth) {
        throw new Error(`Too many inner nodes ${path.length}`);
      }
      for (const inner of path) {
        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);
      }
    }
    exports2.ensureSpec = ensureSpec;
    function ensureLeftMost(spec, path) {
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureRightMost(spec, path) {
      const len = spec.childOrder.length - 1;
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureLeftNeighbor(spec, left, right) {
      const mutleft = [...left];
      const mutright = [...right];
      let topleft = mutleft.pop();
      let topright = mutright.pop();
      while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {
        topleft = mutleft.pop();
        topright = mutright.pop();
      }
      if (!isLeftStep(spec, topleft, topright)) {
        throw new Error(`Not left neightbor at first divergent step`);
      }
      ensureRightMost(spec, mutleft);
      ensureLeftMost(spec, mutright);
    }
    exports2.ensureLeftNeighbor = ensureLeftNeighbor;
    function isLeftStep(spec, left, right) {
      const leftidx = orderFromPadding(spec, left);
      const rightidx = orderFromPadding(spec, right);
      return rightidx === leftidx + 1;
    }
    function orderFromPadding(spec, inner) {
      for (let branch = 0; branch < spec.childOrder.length; branch++) {
        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);
        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {
          return branch;
        }
      }
      throw new Error(`Cannot find any valid spacing for this node`);
    }
    function hasPadding(op, minPrefix, maxPrefix, suffix) {
      if ((op.prefix || []).length < minPrefix) {
        return false;
      }
      if ((op.prefix || []).length > maxPrefix) {
        return false;
      }
      return (op.suffix || []).length === suffix;
    }
    function getPadding(spec, branch) {
      const idx = getPosition(spec.childOrder, branch);
      const prefix = idx * spec.childSize;
      const minPrefix = prefix + spec.minPrefixLength;
      const maxPrefix = prefix + spec.maxPrefixLength;
      const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;
      return { minPrefix, maxPrefix, suffix };
    }
    function getPosition(order, branch) {
      if (branch < 0 || branch >= order.length) {
        throw new Error(`Invalid branch: ${branch}`);
      }
      return order.findIndex((val) => val === branch);
    }
  }
});

// ../../node_modules/@confio/ics23/build/ics23.js
var require_ics23 = __commonJS({
  "../../node_modules/@confio/ics23/build/ics23.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.batchVerifyNonMembership = exports2.batchVerifyMembership = exports2.verifyNonMembership = exports2.verifyMembership = void 0;
    var compress_1 = require_compress();
    var proofs_1 = require_proofs();
    var specs_1 = require_specs();
    function verifyMembership(proof, spec, root, key, value) {
      const norm = (0, compress_1.decompress)(proof);
      const exist = getExistForKey(norm, key);
      if (!exist) {
        return false;
      }
      try {
        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports2.verifyMembership = verifyMembership;
    function verifyNonMembership(proof, spec, root, key) {
      const norm = (0, compress_1.decompress)(proof);
      const nonexist = getNonExistForKey(norm, key);
      if (!nonexist) {
        return false;
      }
      try {
        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports2.verifyNonMembership = verifyNonMembership;
    function batchVerifyMembership(proof, spec, root, items) {
      const norm = (0, compress_1.decompress)(proof);
      for (const [key, value] of items.entries()) {
        if (!verifyMembership(norm, spec, root, key, value)) {
          return false;
        }
      }
      return true;
    }
    exports2.batchVerifyMembership = batchVerifyMembership;
    function batchVerifyNonMembership(proof, spec, root, keys) {
      const norm = (0, compress_1.decompress)(proof);
      for (const key of keys) {
        if (!verifyNonMembership(norm, spec, root, key)) {
          return false;
        }
      }
      return true;
    }
    exports2.batchVerifyNonMembership = batchVerifyNonMembership;
    function getExistForKey(proof, key) {
      const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);
      if (match(proof.exist)) {
        return proof.exist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.exist || null).find(match);
      }
      return void 0;
    }
    function getNonExistForKey(proof, key) {
      const match = (p) => {
        return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));
      };
      if (match(proof.nonexist)) {
        return proof.nonexist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.nonexist || null).find(match);
      }
      return void 0;
    }
  }
});

// ../../node_modules/@confio/ics23/build/index.js
var require_build7 = __commonJS({
  "../../node_modules/@confio/ics23/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyNonExistence = exports2.verifyExistence = exports2.tendermintSpec = exports2.iavlSpec = exports2.calculateExistenceRoot = exports2.verifyNonMembership = exports2.verifyMembership = exports2.ics23 = void 0;
    var codecimpl_1 = require_codecimpl();
    Object.defineProperty(exports2, "ics23", { enumerable: true, get: function() {
      return codecimpl_1.ics23;
    } });
    var ics23_1 = require_ics23();
    Object.defineProperty(exports2, "verifyMembership", { enumerable: true, get: function() {
      return ics23_1.verifyMembership;
    } });
    Object.defineProperty(exports2, "verifyNonMembership", { enumerable: true, get: function() {
      return ics23_1.verifyNonMembership;
    } });
    var proofs_1 = require_proofs();
    Object.defineProperty(exports2, "calculateExistenceRoot", { enumerable: true, get: function() {
      return proofs_1.calculateExistenceRoot;
    } });
    Object.defineProperty(exports2, "iavlSpec", { enumerable: true, get: function() {
      return proofs_1.iavlSpec;
    } });
    Object.defineProperty(exports2, "tendermintSpec", { enumerable: true, get: function() {
      return proofs_1.tendermintSpec;
    } });
    Object.defineProperty(exports2, "verifyExistence", { enumerable: true, get: function() {
      return proofs_1.verifyExistence;
    } });
    Object.defineProperty(exports2, "verifyNonExistence", { enumerable: true, get: function() {
      return proofs_1.verifyNonExistence;
    } });
  }
});

// ../../node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "../../node_modules/symbol-observable/lib/ponyfill.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// ../../node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "../../node_modules/symbol-observable/ponyfill.js"(exports2, module2) {
    module2.exports = require_ponyfill();
  }
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../../node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../../node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/has/src/index.js
var require_src = __commonJS({
  "../../node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../../node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// ../../node_modules/globalthis/implementation.js
var require_implementation3 = __commonJS({
  "../../node_modules/globalthis/implementation.js"(exports2, module2) {
    "use strict";
    module2.exports = global;
  }
});

// ../../node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/globalthis/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// ../../node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "../../node_modules/globalthis/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module2.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define2.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// ../../node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "../../node_modules/globalthis/index.js"(exports2, module2) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = getGlobal;
  }
});

// ../../node_modules/xstream/index.js
var require_xstream = __commonJS({
  "../../node_modules/xstream/index.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NO_IL = exports2.NO = exports2.MemoryStream = exports2.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports2.NO = NO;
    function noop() {
    }
    function cp(a) {
      var l = a.length;
      var b = Array(l);
      for (var i = 0; i < l; ++i)
        b[i] = a[i];
      return b;
    }
    function and(f1, f2) {
      return function andFn(t) {
        return f1(t) && f2(t);
      };
    }
    function _try(c, t, u) {
      try {
        return c.f(t);
      } catch (e) {
        u._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop,
      _e: noop,
      _c: noop
    };
    exports2.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = (
      /** @class */
      function() {
        function StreamSub2(_stream, _listener) {
          this._stream = _stream;
          this._listener = _listener;
        }
        StreamSub2.prototype.unsubscribe = function() {
          this._stream._remove(this._listener);
        };
        return StreamSub2;
      }()
    );
    var Observer = (
      /** @class */
      function() {
        function Observer2(_listener) {
          this._listener = _listener;
        }
        Observer2.prototype.next = function(value) {
          this._listener._n(value);
        };
        Observer2.prototype.error = function(err) {
          this._listener._e(err);
        };
        Observer2.prototype.complete = function() {
          this._listener._c();
        };
        return Observer2;
      }()
    );
    var FromObservable = (
      /** @class */
      function() {
        function FromObservable2(observable) {
          this.type = "fromObservable";
          this.ins = observable;
          this.active = false;
        }
        FromObservable2.prototype._start = function(out) {
          this.out = out;
          this.active = true;
          this._sub = this.ins.subscribe(new Observer(out));
          if (!this.active)
            this._sub.unsubscribe();
        };
        FromObservable2.prototype._stop = function() {
          if (this._sub)
            this._sub.unsubscribe();
          this.active = false;
        };
        return FromObservable2;
      }()
    );
    var Merge = (
      /** @class */
      function() {
        function Merge2(insArr) {
          this.type = "merge";
          this.insArr = insArr;
          this.out = NO;
          this.ac = 0;
        }
        Merge2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var L = s.length;
          this.ac = L;
          for (var i = 0; i < L; i++)
            s[i]._add(this);
        };
        Merge2.prototype._stop = function() {
          var s = this.insArr;
          var L = s.length;
          for (var i = 0; i < L; i++)
            s[i]._remove(this);
          this.out = NO;
        };
        Merge2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        Merge2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Merge2.prototype._c = function() {
          if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
              return;
            u._c();
          }
        };
        return Merge2;
      }()
    );
    var CombineListener = (
      /** @class */
      function() {
        function CombineListener2(i, out, p) {
          this.i = i;
          this.out = out;
          this.p = p;
          p.ils.push(this);
        }
        CombineListener2.prototype._n = function(t) {
          var p = this.p, out = this.out;
          if (out === NO)
            return;
          if (p.up(t, this.i)) {
            var b = cp(p.vals);
            out._n(b);
          }
        };
        CombineListener2.prototype._e = function(err) {
          var out = this.out;
          if (out === NO)
            return;
          out._e(err);
        };
        CombineListener2.prototype._c = function() {
          var p = this.p;
          if (p.out === NO)
            return;
          if (--p.Nc === 0)
            p.out._c();
        };
        return CombineListener2;
      }()
    );
    var Combine = (
      /** @class */
      function() {
        function Combine2(insArr) {
          this.type = "combine";
          this.insArr = insArr;
          this.out = NO;
          this.ils = [];
          this.Nc = this.Nn = 0;
          this.vals = [];
        }
        Combine2.prototype.up = function(t, i) {
          var v = this.vals[i];
          var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
          this.vals[i] = t;
          return Nn === 0;
        };
        Combine2.prototype._start = function(out) {
          this.out = out;
          var s = this.insArr;
          var n = this.Nc = this.Nn = s.length;
          var vals = this.vals = new Array(n);
          if (n === 0) {
            out._n([]);
            out._c();
          } else {
            for (var i = 0; i < n; i++) {
              vals[i] = NO;
              s[i]._add(new CombineListener(i, out, this));
            }
          }
        };
        Combine2.prototype._stop = function() {
          var s = this.insArr;
          var n = s.length;
          var ils = this.ils;
          for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
          this.out = NO;
          this.ils = [];
          this.vals = [];
        };
        return Combine2;
      }()
    );
    var FromArray = (
      /** @class */
      function() {
        function FromArray2(a) {
          this.type = "fromArray";
          this.a = a;
        }
        FromArray2.prototype._start = function(out) {
          var a = this.a;
          for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
          out._c();
        };
        FromArray2.prototype._stop = function() {
        };
        return FromArray2;
      }()
    );
    var FromPromise = (
      /** @class */
      function() {
        function FromPromise2(p) {
          this.type = "fromPromise";
          this.on = false;
          this.p = p;
        }
        FromPromise2.prototype._start = function(out) {
          var prod = this;
          this.on = true;
          this.p.then(function(v) {
            if (prod.on) {
              out._n(v);
              out._c();
            }
          }, function(e) {
            out._e(e);
          }).then(noop, function(err) {
            setTimeout(function() {
              throw err;
            });
          });
        };
        FromPromise2.prototype._stop = function() {
          this.on = false;
        };
        return FromPromise2;
      }()
    );
    var Periodic = (
      /** @class */
      function() {
        function Periodic2(period) {
          this.type = "periodic";
          this.period = period;
          this.intervalID = -1;
          this.i = 0;
        }
        Periodic2.prototype._start = function(out) {
          var self2 = this;
          function intervalHandler() {
            out._n(self2.i++);
          }
          this.intervalID = setInterval(intervalHandler, this.period);
        };
        Periodic2.prototype._stop = function() {
          if (this.intervalID !== -1)
            clearInterval(this.intervalID);
          this.intervalID = -1;
          this.i = 0;
        };
        return Periodic2;
      }()
    );
    var Debug = (
      /** @class */
      function() {
        function Debug2(ins, arg) {
          this.type = "debug";
          this.ins = ins;
          this.out = NO;
          this.s = noop;
          this.l = "";
          if (typeof arg === "string")
            this.l = arg;
          else if (typeof arg === "function")
            this.s = arg;
        }
        Debug2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Debug2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Debug2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var s = this.s, l = this.l;
          if (s !== noop) {
            try {
              s(t);
            } catch (e) {
              u._e(e);
            }
          } else if (l)
            console.log(l + ":", t);
          else
            console.log(t);
          u._n(t);
        };
        Debug2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Debug2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Debug2;
      }()
    );
    var Drop = (
      /** @class */
      function() {
        function Drop2(max, ins) {
          this.type = "drop";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.dropped = 0;
        }
        Drop2.prototype._start = function(out) {
          this.out = out;
          this.dropped = 0;
          this.ins._add(this);
        };
        Drop2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Drop2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          if (this.dropped++ >= this.max)
            u._n(t);
        };
        Drop2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Drop2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Drop2;
      }()
    );
    var EndWhenListener = (
      /** @class */
      function() {
        function EndWhenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        EndWhenListener2.prototype._n = function() {
          this.op.end();
        };
        EndWhenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        EndWhenListener2.prototype._c = function() {
          this.op.end();
        };
        return EndWhenListener2;
      }()
    );
    var EndWhen = (
      /** @class */
      function() {
        function EndWhen2(o, ins) {
          this.type = "endWhen";
          this.ins = ins;
          this.out = NO;
          this.o = o;
          this.oil = NO_IL;
        }
        EndWhen2.prototype._start = function(out) {
          this.out = out;
          this.o._add(this.oil = new EndWhenListener(out, this));
          this.ins._add(this);
        };
        EndWhen2.prototype._stop = function() {
          this.ins._remove(this);
          this.o._remove(this.oil);
          this.out = NO;
          this.oil = NO_IL;
        };
        EndWhen2.prototype.end = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        EndWhen2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        EndWhen2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        EndWhen2.prototype._c = function() {
          this.end();
        };
        return EndWhen2;
      }()
    );
    var Filter = (
      /** @class */
      function() {
        function Filter2(passes, ins) {
          this.type = "filter";
          this.ins = ins;
          this.out = NO;
          this.f = passes;
        }
        Filter2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Filter2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Filter2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO || !r)
            return;
          u._n(t);
        };
        Filter2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Filter2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Filter2;
      }()
    );
    var FlattenListener = (
      /** @class */
      function() {
        function FlattenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        FlattenListener2.prototype._n = function(t) {
          this.out._n(t);
        };
        FlattenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        FlattenListener2.prototype._c = function() {
          this.op.inner = NO;
          this.op.less();
        };
        return FlattenListener2;
      }()
    );
    var Flatten = (
      /** @class */
      function() {
        function Flatten2(ins) {
          this.type = "flatten";
          this.ins = ins;
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        }
        Flatten2.prototype._start = function(out) {
          this.out = out;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
          this.ins._add(this);
        };
        Flatten2.prototype._stop = function() {
          this.ins._remove(this);
          if (this.inner !== NO)
            this.inner._remove(this.il);
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        };
        Flatten2.prototype.less = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (!this.open && this.inner === NO)
            u._c();
        };
        Flatten2.prototype._n = function(s) {
          var u = this.out;
          if (u === NO)
            return;
          var _a = this, inner = _a.inner, il = _a.il;
          if (inner !== NO && il !== NO_IL)
            inner._remove(il);
          (this.inner = s)._add(this.il = new FlattenListener(u, this));
        };
        Flatten2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Flatten2.prototype._c = function() {
          this.open = false;
          this.less();
        };
        return Flatten2;
      }()
    );
    var Fold = (
      /** @class */
      function() {
        function Fold2(f, seed, ins) {
          var _this = this;
          this.type = "fold";
          this.ins = ins;
          this.out = NO;
          this.f = function(t) {
            return f(_this.acc, t);
          };
          this.acc = this.seed = seed;
        }
        Fold2.prototype._start = function(out) {
          this.out = out;
          this.acc = this.seed;
          out._n(this.acc);
          this.ins._add(this);
        };
        Fold2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.acc = this.seed;
        };
        Fold2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(this.acc = r);
        };
        Fold2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Fold2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Fold2;
      }()
    );
    var Last = (
      /** @class */
      function() {
        function Last2(ins) {
          this.type = "last";
          this.ins = ins;
          this.out = NO;
          this.has = false;
          this.val = NO;
        }
        Last2.prototype._start = function(out) {
          this.out = out;
          this.has = false;
          this.ins._add(this);
        };
        Last2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.val = NO;
        };
        Last2.prototype._n = function(t) {
          this.has = true;
          this.val = t;
        };
        Last2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Last2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          if (this.has) {
            u._n(this.val);
            u._c();
          } else
            u._e(new Error("last() failed because input stream completed"));
        };
        return Last2;
      }()
    );
    var MapOp = (
      /** @class */
      function() {
        function MapOp2(project, ins) {
          this.type = "map";
          this.ins = ins;
          this.out = NO;
          this.f = project;
        }
        MapOp2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        MapOp2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        MapOp2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var r = _try(this, t, u);
          if (r === NO)
            return;
          u._n(r);
        };
        MapOp2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        MapOp2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return MapOp2;
      }()
    );
    var Remember = (
      /** @class */
      function() {
        function Remember2(ins) {
          this.type = "remember";
          this.ins = ins;
          this.out = NO;
        }
        Remember2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(out);
        };
        Remember2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return Remember2;
      }()
    );
    var ReplaceError = (
      /** @class */
      function() {
        function ReplaceError2(replacer, ins) {
          this.type = "replaceError";
          this.ins = ins;
          this.out = NO;
          this.f = replacer;
        }
        ReplaceError2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        ReplaceError2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        ReplaceError2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          u._n(t);
        };
        ReplaceError2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
          } catch (e) {
            u._e(e);
          }
        };
        ReplaceError2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return ReplaceError2;
      }()
    );
    var StartWith = (
      /** @class */
      function() {
        function StartWith2(ins, val) {
          this.type = "startWith";
          this.ins = ins;
          this.out = NO;
          this.val = val;
        }
        StartWith2.prototype._start = function(out) {
          this.out = out;
          this.out._n(this.val);
          this.ins._add(out);
        };
        StartWith2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return StartWith2;
      }()
    );
    var Take = (
      /** @class */
      function() {
        function Take2(max, ins) {
          this.type = "take";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.taken = 0;
        }
        Take2.prototype._start = function(out) {
          this.out = out;
          this.taken = 0;
          if (this.max <= 0)
            out._c();
          else
            this.ins._add(this);
        };
        Take2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Take2.prototype._n = function(t) {
          var u = this.out;
          if (u === NO)
            return;
          var m = ++this.taken;
          if (m < this.max)
            u._n(t);
          else if (m === this.max) {
            u._n(t);
            u._c();
          }
        };
        Take2.prototype._e = function(err) {
          var u = this.out;
          if (u === NO)
            return;
          u._e(err);
        };
        Take2.prototype._c = function() {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        };
        return Take2;
      }()
    );
    var Stream = (
      /** @class */
      function() {
        function Stream2(producer) {
          this._prod = producer || NO;
          this._ils = [];
          this._stopID = NO;
          this._dl = NO;
          this._d = false;
          this._target = null;
          this._err = NO;
        }
        Stream2.prototype._n = function(t) {
          var a = this._ils;
          var L = a.length;
          if (this._d)
            this._dl._n(t);
          if (L == 1)
            a[0]._n(t);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._n(t);
          }
        };
        Stream2.prototype._e = function(err) {
          if (this._err !== NO)
            return;
          this._err = err;
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._e(err);
          if (L == 1)
            a[0]._e(err);
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._e(err);
          }
          if (!this._d && L == 0)
            throw this._err;
        };
        Stream2.prototype._c = function() {
          var a = this._ils;
          var L = a.length;
          this._x();
          if (this._d)
            this._dl._c();
          if (L == 1)
            a[0]._c();
          else if (L == 0)
            return;
          else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
              b[i]._c();
          }
        };
        Stream2.prototype._x = function() {
          if (this._ils.length === 0)
            return;
          if (this._prod !== NO)
            this._prod._stop();
          this._err = NO;
          this._ils = [];
        };
        Stream2.prototype._stopNow = function() {
          this._prod._stop();
          this._err = NO;
          this._stopID = NO;
        };
        Stream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1)
            return;
          if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        Stream2.prototype._remove = function(il) {
          var _this = this;
          var ta = this._target;
          if (ta)
            return ta._remove(il);
          var a = this._ils;
          var i = a.indexOf(il);
          if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
              this._err = NO;
              this._stopID = setTimeout(function() {
                return _this._stopNow();
              });
            } else if (a.length === 1) {
              this._pruneCycles();
            }
          }
        };
        Stream2.prototype._pruneCycles = function() {
          if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
        };
        Stream2.prototype._hasNoSinks = function(x, trace) {
          if (trace.indexOf(x) !== -1)
            return true;
          else if (x.out === this)
            return true;
          else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
          else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
              if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                return false;
            return true;
          } else
            return false;
        };
        Stream2.prototype.ctor = function() {
          return this instanceof MemoryStream ? MemoryStream : Stream2;
        };
        Stream2.prototype.addListener = function(listener) {
          listener._n = listener.next || noop;
          listener._e = listener.error || noop;
          listener._c = listener.complete || noop;
          this._add(listener);
        };
        Stream2.prototype.removeListener = function(listener) {
          this._remove(listener);
        };
        Stream2.prototype.subscribe = function(listener) {
          this.addListener(listener);
          return new StreamSub(this, listener);
        };
        Stream2.prototype[$$observable] = function() {
          return this;
        };
        Stream2.create = function(producer) {
          if (producer) {
            if (typeof producer.start !== "function" || typeof producer.stop !== "function")
              throw new Error("producer requires both start and stop functions");
            internalizeProducer(producer);
          }
          return new Stream2(producer);
        };
        Stream2.createWithMemory = function(producer) {
          if (producer)
            internalizeProducer(producer);
          return new MemoryStream(producer);
        };
        Stream2.never = function() {
          return new Stream2({ _start: noop, _stop: noop });
        };
        Stream2.empty = function() {
          return new Stream2({
            _start: function(il) {
              il._c();
            },
            _stop: noop
          });
        };
        Stream2.throw = function(error) {
          return new Stream2({
            _start: function(il) {
              il._e(error);
            },
            _stop: noop
          });
        };
        Stream2.from = function(input) {
          if (typeof input[$$observable] === "function")
            return Stream2.fromObservable(input);
          else if (typeof input.then === "function")
            return Stream2.fromPromise(input);
          else if (Array.isArray(input))
            return Stream2.fromArray(input);
          throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
        };
        Stream2.of = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          return Stream2.fromArray(items);
        };
        Stream2.fromArray = function(array) {
          return new Stream2(new FromArray(array));
        };
        Stream2.fromPromise = function(promise) {
          return new Stream2(new FromPromise(promise));
        };
        Stream2.fromObservable = function(obs) {
          if (obs.endWhen !== void 0)
            return obs;
          var o = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
          return new Stream2(new FromObservable(o));
        };
        Stream2.periodic = function(period) {
          return new Stream2(new Periodic(period));
        };
        Stream2.prototype._map = function(project) {
          return new (this.ctor())(new MapOp(project, this));
        };
        Stream2.prototype.map = function(project) {
          return this._map(project);
        };
        Stream2.prototype.mapTo = function(projectedValue) {
          var s = this.map(function() {
            return projectedValue;
          });
          var op = s._prod;
          op.type = "mapTo";
          return s;
        };
        Stream2.prototype.filter = function(passes) {
          var p = this._prod;
          if (p instanceof Filter)
            return new Stream2(new Filter(and(p.f, passes), p.ins));
          return new Stream2(new Filter(passes, this));
        };
        Stream2.prototype.take = function(amount) {
          return new (this.ctor())(new Take(amount, this));
        };
        Stream2.prototype.drop = function(amount) {
          return new Stream2(new Drop(amount, this));
        };
        Stream2.prototype.last = function() {
          return new Stream2(new Last(this));
        };
        Stream2.prototype.startWith = function(initial) {
          return new MemoryStream(new StartWith(this, initial));
        };
        Stream2.prototype.endWhen = function(other) {
          return new (this.ctor())(new EndWhen(other, this));
        };
        Stream2.prototype.fold = function(accumulate, seed) {
          return new MemoryStream(new Fold(accumulate, seed, this));
        };
        Stream2.prototype.replaceError = function(replace) {
          return new (this.ctor())(new ReplaceError(replace, this));
        };
        Stream2.prototype.flatten = function() {
          return new Stream2(new Flatten(this));
        };
        Stream2.prototype.compose = function(operator) {
          return operator(this);
        };
        Stream2.prototype.remember = function() {
          return new MemoryStream(new Remember(this));
        };
        Stream2.prototype.debug = function(labelOrSpy) {
          return new (this.ctor())(new Debug(this, labelOrSpy));
        };
        Stream2.prototype.imitate = function(target) {
          if (target instanceof MemoryStream)
            throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
          this._target = target;
          for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
          this._ils = [];
        };
        Stream2.prototype.shamefullySendNext = function(value) {
          this._n(value);
        };
        Stream2.prototype.shamefullySendError = function(error) {
          this._e(error);
        };
        Stream2.prototype.shamefullySendComplete = function() {
          this._c();
        };
        Stream2.prototype.setDebugListener = function(listener) {
          if (!listener) {
            this._d = false;
            this._dl = NO;
          } else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
          }
        };
        Stream2.merge = function merge() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Merge(streams));
        };
        Stream2.combine = function combine() {
          var streams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
          }
          return new Stream2(new Combine(streams));
        };
        return Stream2;
      }()
    );
    exports2.Stream = Stream;
    var MemoryStream = (
      /** @class */
      function(_super) {
        __extends(MemoryStream2, _super);
        function MemoryStream2(producer) {
          var _this = _super.call(this, producer) || this;
          _this._has = false;
          return _this;
        }
        MemoryStream2.prototype._n = function(x) {
          this._v = x;
          this._has = true;
          _super.prototype._n.call(this, x);
        };
        MemoryStream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a = this._ils;
          a.push(il);
          if (a.length > 1) {
            if (this._has)
              il._n(this._v);
            return;
          }
          if (this._stopID !== NO) {
            if (this._has)
              il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else if (this._has)
            il._n(this._v);
          else {
            var p = this._prod;
            if (p !== NO)
              p._start(this);
          }
        };
        MemoryStream2.prototype._stopNow = function() {
          this._has = false;
          _super.prototype._stopNow.call(this);
        };
        MemoryStream2.prototype._x = function() {
          this._has = false;
          _super.prototype._x.call(this);
        };
        MemoryStream2.prototype.map = function(project) {
          return this._map(project);
        };
        MemoryStream2.prototype.mapTo = function(projectedValue) {
          return _super.prototype.mapTo.call(this, projectedValue);
        };
        MemoryStream2.prototype.take = function(amount) {
          return _super.prototype.take.call(this, amount);
        };
        MemoryStream2.prototype.endWhen = function(other) {
          return _super.prototype.endWhen.call(this, other);
        };
        MemoryStream2.prototype.replaceError = function(replace) {
          return _super.prototype.replaceError.call(this, replace);
        };
        MemoryStream2.prototype.remember = function() {
          return this;
        };
        MemoryStream2.prototype.debug = function(labelOrSpy) {
          return _super.prototype.debug.call(this, labelOrSpy);
        };
        return MemoryStream2;
      }(Stream)
    );
    exports2.MemoryStream = MemoryStream;
    var xs = Stream;
    exports2.default = xs;
  }
});

// ../../node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "../../node_modules/@cosmjs/stream/build/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
    exports2.concat = concat;
  }
});

// ../../node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "../../node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      get value() {
        return this.internalValue;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports2.DefaultValueProducer = DefaultValueProducer;
  }
});

// ../../node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "../../node_modules/@cosmjs/stream/build/dropduplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dropDuplicates = void 0;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
    exports2.dropDuplicates = dropDuplicates;
  }
});

// ../../node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "../../node_modules/@cosmjs/stream/build/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstEvent = exports2.toListPromise = exports2.fromListPromise = void 0;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => listener.error(error));
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    exports2.fromListPromise = fromListPromise;
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`);
          },
          error: (error) => reject(error)
        });
      });
    }
    exports2.toListPromise = toListPromise;
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
    exports2.firstEvent = firstEvent;
  }
});

// ../../node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "../../node_modules/@cosmjs/stream/build/reducer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lastValue = exports2.asArray = exports2.countStream = exports2.Reducer = void 0;
    var Reducer = class {
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports2.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    exports2.countStream = countStream;
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    exports2.asArray = asArray;
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
    exports2.lastValue = lastValue;
  }
});

// ../../node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "../../node_modules/@cosmjs/stream/build/valueandupdates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      get value() {
        return this.producer.value;
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => subscription.unsubscribe(), 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject("Update stream completed without expected value");
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports2.ValueAndUpdates = ValueAndUpdates;
  }
});

// ../../node_modules/@cosmjs/stream/build/index.js
var require_build8 = __commonJS({
  "../../node_modules/@cosmjs/stream/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueAndUpdates = exports2.toListPromise = exports2.fromListPromise = exports2.firstEvent = exports2.dropDuplicates = exports2.DefaultValueProducer = exports2.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports2, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports2, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports2, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports2, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports2, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports2);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports2, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClient = void 0;
    var ics23_1 = require_build7();
    var encoding_1 = require_build();
    var stream_1 = require_build8();
    var utils_1 = require_build3();
    function checkAndParseOp(op, kind, key) {
      if (op.type !== kind) {
        throw new Error(`Op expected to be ${kind}, got "${op.type}`);
      }
      if (!(0, utils_1.arrayContentEquals)(key, op.key)) {
        throw new Error(`Proven key different than queried key.
Query: ${(0, encoding_1.toHex)(key)}
Proven: ${(0, encoding_1.toHex)(op.key)}`);
      }
      return ics23_1.ics23.CommitmentProof.decode(op.data);
    }
    var QueryClient = class {
      constructor(tmClient) {
        this.tmClient = tmClient;
      }
      static withExtensions(tmClient, ...extensionSetups) {
        const client = new QueryClient(tmClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      /**
       * @deprecated use queryStoreVerified instead
       */
      async queryVerified(store, queryKey, desiredHeight) {
        const { value } = await this.queryStoreVerified(store, queryKey, desiredHeight);
        return value;
      }
      /**
       * Queries the database store with a proof, which is then verified.
       *
       * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
       */
      async queryStoreVerified(store, queryKey, desiredHeight) {
        const { height, proof, key, value } = await this.queryRawProof(store, queryKey, desiredHeight);
        const subProof = checkAndParseOp(proof.ops[0], "ics23:iavl", queryKey);
        const storeProof = checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        (0, utils_1.assert)(storeProof.exist);
        (0, utils_1.assert)(storeProof.exist.value);
        if (!value || value.length === 0) {
          (0, utils_1.assert)(subProof.nonexist);
          (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, queryKey);
        } else {
          (0, utils_1.assert)(subProof.exist);
          (0, utils_1.assert)(subProof.exist.value);
          (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, queryKey, value);
        }
        const header = await this.getNextHeader(height);
        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);
        return { key, value, height };
      }
      async queryRawProof(store, queryKey, desiredHeight) {
        var _a;
        const { key, value, height, proof, code, log } = await this.tmClient.abciQuery({
          // we need the StoreKey for the module, not the module name
          // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
          path: `/store/${store}/key`,
          data: queryKey,
          prove: true,
          height: desiredHeight
        });
        if (code) {
          throw new Error(`Query failed with (${code}): ${log}`);
        }
        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {
          throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);
        }
        if (!height) {
          throw new Error("No query height returned");
        }
        if (!proof || proof.ops.length !== 2) {
          throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);
        }
        checkAndParseOp(proof.ops[0], "ics23:iavl", key);
        checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        return {
          key,
          value,
          height,
          // need to clone this: readonly input / writeable output
          proof: {
            ops: [...proof.ops]
          }
        };
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * @deprecated use queryAbci instead
       */
      async queryUnverified(path, request, desiredHeight) {
        const response = await this.queryAbci(path, request, desiredHeight);
        return response.value;
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.tmClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
      // this must return the header for height+1
      // throws an error if height is 0 or undefined
      async getNextHeader(height) {
        (0, utils_1.assertDefined)(height);
        if (height === 0) {
          throw new Error("Query returned height 0, cannot prove it");
        }
        const searchHeight = height + 1;
        let nextHeader;
        let headersSubscription;
        try {
          headersSubscription = this.tmClient.subscribeNewBlockHeader();
        } catch (_a) {
        }
        if (headersSubscription) {
          const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);
          if (firstHeader.height === searchHeight) {
            nextHeader = firstHeader;
          }
        }
        while (!nextHeader) {
          const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map((meta) => meta.header).find((h) => h.height === searchHeight);
          if (correctHeader) {
            nextHeader = correctHeader;
          } else {
            await (0, utils_1.sleep)(1e3);
          }
        }
        (0, utils_1.assert)(nextHeader.height === searchHeight, "Got wrong header. This is a bug in the logic above.");
        return nextHeader;
      }
    };
    exports2.QueryClient = QueryClient;
  }
});

// ../../node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeCosmosSdkDecFromProto = exports2.longify = exports2.createProtobufRpcClient = exports2.createPagination = exports2.toAccAddress = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var pagination_1 = require_pagination();
    var long_1 = __importDefault(require_long());
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    exports2.toAccAddress = toAccAddress;
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : void 0;
    }
    exports2.createPagination = createPagination;
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data, void 0);
          return response.value;
        }
      };
    }
    exports2.createProtobufRpcClient = createProtobufRpcClient;
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return long_1.default.fromBytesBE([...checkedValue.toBytesBigEndian()], true);
    }
    exports2.longify = longify;
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
    exports2.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
  }
});

// ../../node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.longify = exports2.decodeCosmosSdkDecFromProto = exports2.createProtobufRpcClient = exports2.createPagination = exports2.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports2, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils6();
    Object.defineProperty(exports2, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports2, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports2, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports2, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupAuthExtension = void 0;
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account !== null && account !== void 0 ? account : null;
          }
        }
      };
    }
    exports2.setupAuthExtension = setupAuthExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAuthzAminoConverters = void 0;
    function createAuthzAminoConverters() {
      return {
        "/cosmos.authz.v1beta1.MsgGrant": "not_supported_by_chain",
        "/cosmos.authz.v1beta1.MsgExec": "not_supported_by_chain",
        "/cosmos.authz.v1beta1.MsgRevoke": "not_supported_by_chain"
      };
    }
    exports2.createAuthzAminoConverters = createAuthzAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/cosmjs-types/google/protobuf/timestamp.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return { seconds: long_1.default.ZERO, nanos: 0 };
    }
    exports2.Timestamp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.seconds.isZero()) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          seconds: isSet(object.seconds) ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO,
          nanos: isSet(object.nanos) ? Number(object.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || long_1.default.ZERO).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseTimestamp();
        message.seconds = object.seconds !== void 0 && object.seconds !== null ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO;
        message.nanos = (_a = object.nanos) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GrantAuthorization = exports2.Grant = exports2.GenericAuthorization = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return { msg: "" };
    }
    exports2.GenericAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { msg: isSet(object.msg) ? String(object.msg) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseGenericAuthorization();
        message.msg = (_a = object.msg) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseGrant() {
      return { authorization: void 0, expiration: void 0 };
    }
    exports2.Grant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          authorization: isSet(object.authorization) ? any_1.Any.fromJSON(object.authorization) : void 0,
          expiration: isSet(object.expiration) ? fromJsonTimestamp(object.expiration) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = fromTimestamp(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        message.authorization = object.authorization !== void 0 && object.authorization !== null ? any_1.Any.fromPartial(object.authorization) : void 0;
        message.expiration = object.expiration !== void 0 && object.expiration !== null ? timestamp_1.Timestamp.fromPartial(object.expiration) : void 0;
        return message;
      }
    };
    function createBaseGrantAuthorization() {
      return { granter: "", grantee: "", authorization: void 0, expiration: void 0 };
    }
    exports2.GrantAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          authorization: isSet(object.authorization) ? any_1.Any.fromJSON(object.authorization) : void 0,
          expiration: isSet(object.expiration) ? fromJsonTimestamp(object.expiration) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = fromTimestamp(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseGrantAuthorization();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.authorization = object.authorization !== void 0 && object.authorization !== null ? any_1.Any.fromPartial(object.authorization) : void 0;
        message.expiration = object.expiration !== void 0 && object.expiration !== null ? timestamp_1.Timestamp.fromPartial(object.expiration) : void 0;
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js
var require_tx3 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgRevokeResponse = exports2.MsgRevoke = exports2.MsgGrantResponse = exports2.MsgExec = exports2.MsgExecResponse = exports2.MsgGrant = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var authz_1 = require_authz();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant() {
      return { granter: "", grantee: "", grant: void 0 };
    }
    exports2.MsgGrant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          grant: isSet(object.grant) ? authz_1.Grant.fromJSON(object.grant) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgGrant();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.grant = object.grant !== void 0 && object.grant !== null ? authz_1.Grant.fromPartial(object.grant) : void 0;
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return { results: [] };
    }
    exports2.MsgExecResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          results: Array.isArray(object === null || object === void 0 ? void 0 : object.results) ? object.results.map((e) => bytesFromBase64(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgExecResponse();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgExec() {
      return { grantee: "", msgs: [] };
    }
    exports2.MsgExec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v of message.msgs) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          msgs: Array.isArray(object === null || object === void 0 ? void 0 : object.msgs) ? object.msgs.map((e) => any_1.Any.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgExec();
        message.grantee = (_a = object.grantee) !== null && _a !== void 0 ? _a : "";
        message.msgs = ((_b = object.msgs) === null || _b === void 0 ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgGrantResponse() {
      return {};
    }
    exports2.MsgGrantResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantResponse();
        return message;
      }
    };
    function createBaseMsgRevoke() {
      return { granter: "", grantee: "", msgTypeUrl: "" };
    }
    exports2.MsgRevoke = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgRevoke();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.msgTypeUrl = (_c = object.msgTypeUrl) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse() {
      return {};
    }
    exports2.MsgRevokeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grant = this.Grant.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Revoke = this.Revoke.bind(this);
      }
      Grant(request) {
        const data = exports2.MsgGrant.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", data);
        return promise.then((data2) => exports2.MsgGrantResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Exec(request) {
        const data = exports2.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", data);
        return promise.then((data2) => exports2.MsgExecResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Revoke(request) {
        const data = exports2.MsgRevoke.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", data);
        return promise.then((data2) => exports2.MsgRevokeResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports2.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// ../../node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js
var require_query2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryGranteeGrantsResponse = exports2.QueryGranteeGrantsRequest = exports2.QueryGranterGrantsResponse = exports2.QueryGranterGrantsRequest = exports2.QueryGrantsResponse = exports2.QueryGrantsRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var authz_1 = require_authz();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseQueryGrantsRequest() {
      return { granter: "", grantee: "", msgTypeUrl: "", pagination: void 0 };
    }
    exports2.QueryGrantsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseQueryGrantsRequest();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.msgTypeUrl = (_c = object.msgTypeUrl) !== null && _c !== void 0 ? _c : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryGrantsResponse() {
      return { grants: [], pagination: void 0 };
    }
    exports2.QueryGrantsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.grants) {
          authz_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grants: Array.isArray(object === null || object === void 0 ? void 0 : object.grants) ? object.grants.map((e) => authz_1.Grant.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.Grant.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGrantsResponse();
        message.grants = ((_a = object.grants) === null || _a === void 0 ? void 0 : _a.map((e) => authz_1.Grant.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryGranterGrantsRequest() {
      return { granter: "", pagination: void 0 };
    }
    exports2.QueryGranterGrantsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGranterGrantsRequest();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryGranterGrantsResponse() {
      return { grants: [], pagination: void 0 };
    }
    exports2.QueryGranterGrantsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grants: Array.isArray(object === null || object === void 0 ? void 0 : object.grants) ? object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGranterGrantsResponse();
        message.grants = ((_a = object.grants) === null || _a === void 0 ? void 0 : _a.map((e) => authz_1.GrantAuthorization.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryGranteeGrantsRequest() {
      return { grantee: "", pagination: void 0 };
    }
    exports2.QueryGranteeGrantsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGranteeGrantsRequest();
        message.grantee = (_a = object.grantee) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryGranteeGrantsResponse() {
      return { grants: [], pagination: void 0 };
    }
    exports2.QueryGranteeGrantsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grants: Array.isArray(object === null || object === void 0 ? void 0 : object.grants) ? object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGranteeGrantsResponse();
        message.grants = ((_a = object.grants) === null || _a === void 0 ? void 0 : _a.map((e) => authz_1.GrantAuthorization.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grants = this.Grants.bind(this);
        this.GranterGrants = this.GranterGrants.bind(this);
        this.GranteeGrants = this.GranteeGrants.bind(this);
      }
      Grants(request) {
        const data = exports2.QueryGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", data);
        return promise.then((data2) => exports2.QueryGrantsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GranterGrants(request) {
        const data = exports2.QueryGranterGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", data);
        return promise.then((data2) => exports2.QueryGranterGrantsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GranteeGrants(request) {
        const data = exports2.QueryGranteeGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", data);
        return promise.then((data2) => exports2.QueryGranteeGrantsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupAuthzExtension = void 0;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            const response = await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupAuthzExtension = setupAuthzExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBankAminoConverters = exports2.isAminoMsgMultiSend = exports2.isAminoMsgSend = void 0;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    exports2.isAminoMsgSend = isAminoMsgSend;
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    exports2.isAminoMsgMultiSend = isAminoMsgMultiSend;
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
    exports2.createBankAminoConverters = createBankAminoConverters;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgSendEncodeObject = exports2.bankTypes = void 0;
    var tx_1 = require_tx2();
    exports2.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
    exports2.isMsgSendEncodeObject = isMsgSendEncodeObject;
  }
});

// ../../node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js
var require_query3 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryDenomMetadataResponse = exports2.QueryDenomMetadataRequest = exports2.QueryDenomsMetadataResponse = exports2.QueryDenomsMetadataRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QuerySupplyOfResponse = exports2.QuerySupplyOfRequest = exports2.QueryTotalSupplyResponse = exports2.QueryTotalSupplyRequest = exports2.QuerySpendableBalancesResponse = exports2.QuerySpendableBalancesRequest = exports2.QueryAllBalancesResponse = exports2.QueryAllBalancesRequest = exports2.QueryBalanceResponse = exports2.QueryBalanceRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseQueryBalanceRequest() {
      return { address: "", denom: "" };
    }
    exports2.QueryBalanceRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          denom: isSet(object.denom) ? String(object.denom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryBalanceRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.denom = (_b = object.denom) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryBalanceResponse() {
      return { balance: void 0 };
    }
    exports2.QueryBalanceResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { balance: isSet(object.balance) ? coin_1.Coin.fromJSON(object.balance) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceResponse();
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : void 0;
        return message;
      }
    };
    function createBaseQueryAllBalancesRequest() {
      return { address: "", pagination: void 0 };
    }
    exports2.QueryAllBalancesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllBalancesRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllBalancesResponse() {
      return { balances: [], pagination: void 0 };
    }
    exports2.QueryAllBalancesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          balances: Array.isArray(object === null || object === void 0 ? void 0 : object.balances) ? object.balances.map((e) => coin_1.Coin.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllBalancesResponse();
        message.balances = ((_a = object.balances) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQuerySpendableBalancesRequest() {
      return { address: "", pagination: void 0 };
    }
    exports2.QuerySpendableBalancesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySpendableBalancesRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQuerySpendableBalancesResponse() {
      return { balances: [], pagination: void 0 };
    }
    exports2.QuerySpendableBalancesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          balances: Array.isArray(object === null || object === void 0 ? void 0 : object.balances) ? object.balances.map((e) => coin_1.Coin.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySpendableBalancesResponse();
        message.balances = ((_a = object.balances) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryTotalSupplyRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryTotalSupplyRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalSupplyRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryTotalSupplyResponse() {
      return { supply: [], pagination: void 0 };
    }
    exports2.QueryTotalSupplyResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.supply) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          supply: Array.isArray(object === null || object === void 0 ? void 0 : object.supply) ? object.supply.map((e) => coin_1.Coin.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.supply) {
          obj.supply = message.supply.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.supply = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryTotalSupplyResponse();
        message.supply = ((_a = object.supply) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQuerySupplyOfRequest() {
      return { denom: "" };
    }
    exports2.QuerySupplyOfRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { denom: isSet(object.denom) ? String(object.denom) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySupplyOfRequest();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQuerySupplyOfResponse() {
      return { amount: void 0 };
    }
    exports2.QuerySupplyOfResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfResponse();
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? bank_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? bank_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQueryDenomsMetadataRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryDenomsMetadataRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomsMetadataRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDenomsMetadataResponse() {
      return { metadatas: [], pagination: void 0 };
    }
    exports2.QueryDenomsMetadataResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.metadatas) {
          bank_1.Metadata.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          metadatas: Array.isArray(object === null || object === void 0 ? void 0 : object.metadatas) ? object.metadatas.map((e) => bank_1.Metadata.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.metadatas) {
          obj.metadatas = message.metadatas.map((e) => e ? bank_1.Metadata.toJSON(e) : void 0);
        } else {
          obj.metadatas = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomsMetadataResponse();
        message.metadatas = ((_a = object.metadatas) === null || _a === void 0 ? void 0 : _a.map((e) => bank_1.Metadata.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDenomMetadataRequest() {
      return { denom: "" };
    }
    exports2.QueryDenomMetadataRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { denom: isSet(object.denom) ? String(object.denom) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomMetadataRequest();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataResponse() {
      return { metadata: void 0 };
    }
    exports2.QueryDenomMetadataResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { metadata: isSet(object.metadata) ? bank_1.Metadata.fromJSON(object.metadata) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataResponse();
        message.metadata = object.metadata !== void 0 && object.metadata !== null ? bank_1.Metadata.fromPartial(object.metadata) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.SpendableBalances = this.SpendableBalances.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
      }
      Balance(request) {
        const data = exports2.QueryBalanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data);
        return promise.then((data2) => exports2.QueryBalanceResponse.decode(new minimal_1.default.Reader(data2)));
      }
      AllBalances(request) {
        const data = exports2.QueryAllBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data);
        return promise.then((data2) => exports2.QueryAllBalancesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SpendableBalances(request) {
        const data = exports2.QuerySpendableBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", data);
        return promise.then((data2) => exports2.QuerySpendableBalancesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      TotalSupply(request) {
        const data = exports2.QueryTotalSupplyRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data);
        return promise.then((data2) => exports2.QueryTotalSupplyResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SupplyOf(request) {
        const data = exports2.QuerySupplyOfRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data);
        return promise.then((data2) => exports2.QuerySupplyOfResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomMetadata(request) {
        const data = exports2.QueryDenomMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data);
        return promise.then((data2) => exports2.QueryDenomMetadataResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomsMetadata(request) {
        const data = exports2.QueryDenomsMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data);
        return promise.then((data2) => exports2.QueryDenomsMetadataResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupBankExtension = void 0;
    var utils_1 = require_build3();
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances({ address });
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata({
              pagination: void 0
              // Not implemented
            });
            return metadatas;
          }
        }
      };
    }
    exports2.setupBankExtension = setupBankExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCrysisAminoConverters = exports2.isAminoMsgVerifyInvariant = void 0;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    exports2.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
    exports2.createCrysisAminoConverters = createCrysisAminoConverters;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDistributionAminoConverters = exports2.isAminoMsgFundCommunityPool = exports2.isAminoMsgWithdrawValidatorCommission = exports2.isAminoMsgWithdrawDelegatorReward = exports2.isAminoMsgSetWithdrawAddress = void 0;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    exports2.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    exports2.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    exports2.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    exports2.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
    exports2.createDistributionAminoConverters = createDistributionAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js
var require_tx4 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgFundCommunityPoolResponse = exports2.MsgFundCommunityPool = exports2.MsgWithdrawValidatorCommissionResponse = exports2.MsgWithdrawValidatorCommission = exports2.MsgWithdrawDelegatorRewardResponse = exports2.MsgWithdrawDelegatorReward = exports2.MsgSetWithdrawAddressResponse = exports2.MsgSetWithdrawAddress = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress() {
      return { delegatorAddress: "", withdrawAddress: "" };
    }
    exports2.MsgSetWithdrawAddress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          withdrawAddress: isSet(object.withdrawAddress) ? String(object.withdrawAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.withdrawAddress = (_b = object.withdrawAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse() {
      return {};
    }
    exports2.MsgSetWithdrawAddressResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports2.MsgWithdrawDelegatorReward = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse() {
      return {};
    }
    exports2.MsgWithdrawDelegatorRewardResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission() {
      return { validatorAddress: "" };
    }
    exports2.MsgWithdrawValidatorCommission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse() {
      return {};
    }
    exports2.MsgWithdrawValidatorCommissionResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        return message;
      }
    };
    function createBaseMsgFundCommunityPool() {
      return { amount: [], depositor: "" };
    }
    exports2.MsgFundCommunityPool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
          depositor: isSet(object.depositor) ? String(object.depositor) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgFundCommunityPool();
        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse() {
      return {};
    }
    exports2.MsgFundCommunityPoolResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
      }
      SetWithdrawAddress(request) {
        const data = exports2.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data);
        return promise.then((data2) => exports2.MsgSetWithdrawAddressResponse.decode(new minimal_1.default.Reader(data2)));
      }
      WithdrawDelegatorReward(request) {
        const data = exports2.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data);
        return promise.then((data2) => exports2.MsgWithdrawDelegatorRewardResponse.decode(new minimal_1.default.Reader(data2)));
      }
      WithdrawValidatorCommission(request) {
        const data = exports2.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data);
        return promise.then((data2) => exports2.MsgWithdrawValidatorCommissionResponse.decode(new minimal_1.default.Reader(data2)));
      }
      FundCommunityPool(request) {
        const data = exports2.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data);
        return promise.then((data2) => exports2.MsgFundCommunityPoolResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgWithdrawDelegatorRewardEncodeObject = exports2.distributionTypes = void 0;
    var tx_1 = require_tx4();
    exports2.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
    exports2.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
  }
});

// ../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js
var require_distribution = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommunityPoolSpendProposalWithDeposit = exports2.DelegationDelegatorReward = exports2.DelegatorStartingInfo = exports2.CommunityPoolSpendProposal = exports2.FeePool = exports2.ValidatorSlashEvents = exports2.ValidatorSlashEvent = exports2.ValidatorOutstandingRewards = exports2.ValidatorAccumulatedCommission = exports2.ValidatorCurrentRewards = exports2.ValidatorHistoricalRewards = exports2.Params = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseParams() {
      return { communityTax: "", baseProposerReward: "", bonusProposerReward: "", withdrawAddrEnabled: false };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.communityTax !== "") {
          writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
          writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
          writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
          writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityTax = reader.string();
              break;
            case 2:
              message.baseProposerReward = reader.string();
              break;
            case 3:
              message.bonusProposerReward = reader.string();
              break;
            case 4:
              message.withdrawAddrEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          communityTax: isSet(object.communityTax) ? String(object.communityTax) : "",
          baseProposerReward: isSet(object.baseProposerReward) ? String(object.baseProposerReward) : "",
          bonusProposerReward: isSet(object.bonusProposerReward) ? String(object.bonusProposerReward) : "",
          withdrawAddrEnabled: isSet(object.withdrawAddrEnabled) ? Boolean(object.withdrawAddrEnabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.communityTax !== void 0 && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== void 0 && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== void 0 && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== void 0 && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseParams();
        message.communityTax = (_a = object.communityTax) !== null && _a !== void 0 ? _a : "";
        message.baseProposerReward = (_b = object.baseProposerReward) !== null && _b !== void 0 ? _b : "";
        message.bonusProposerReward = (_c = object.bonusProposerReward) !== null && _c !== void 0 ? _c : "";
        message.withdrawAddrEnabled = (_d = object.withdrawAddrEnabled) !== null && _d !== void 0 ? _d : false;
        return message;
      }
    };
    function createBaseValidatorHistoricalRewards() {
      return { cumulativeRewardRatio: [], referenceCount: 0 };
    }
    exports2.ValidatorHistoricalRewards = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.cumulativeRewardRatio) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
          writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.referenceCount = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          cumulativeRewardRatio: Array.isArray(object === null || object === void 0 ? void 0 : object.cumulativeRewardRatio) ? object.cumulativeRewardRatio.map((e) => coin_1.DecCoin.fromJSON(e)) : [],
          referenceCount: isSet(object.referenceCount) ? Number(object.referenceCount) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio) {
          obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.cumulativeRewardRatio = [];
        }
        message.referenceCount !== void 0 && (obj.referenceCount = Math.round(message.referenceCount));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = ((_a = object.cumulativeRewardRatio) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.referenceCount = (_b = object.referenceCount) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseValidatorCurrentRewards() {
      return { rewards: [], period: long_1.default.UZERO };
    }
    exports2.ValidatorCurrentRewards = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (!message.period.isZero()) {
          writer.uint32(16).uint64(message.period);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.period = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rewards: Array.isArray(object === null || object === void 0 ? void 0 : object.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromJSON(e)) : [],
          period: isSet(object.period) ? long_1.default.fromValue(object.period) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        message.period !== void 0 && (obj.period = (message.period || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorCurrentRewards();
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.period = object.period !== void 0 && object.period !== null ? long_1.default.fromValue(object.period) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseValidatorAccumulatedCommission() {
      return { commission: [] };
    }
    exports2.ValidatorAccumulatedCommission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          commission: Array.isArray(object === null || object === void 0 ? void 0 : object.commission) ? object.commission.map((e) => coin_1.DecCoin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorAccumulatedCommission();
        message.commission = ((_a = object.commission) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseValidatorOutstandingRewards() {
      return { rewards: [] };
    }
    exports2.ValidatorOutstandingRewards = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rewards: Array.isArray(object === null || object === void 0 ? void 0 : object.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseValidatorSlashEvent() {
      return { validatorPeriod: long_1.default.UZERO, fraction: "" };
    }
    exports2.ValidatorSlashEvent = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.validatorPeriod.isZero()) {
          writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
          writer.uint32(18).string(message.fraction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorPeriod = reader.uint64();
              break;
            case 2:
              message.fraction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorPeriod: isSet(object.validatorPeriod) ? long_1.default.fromValue(object.validatorPeriod) : long_1.default.UZERO,
          fraction: isSet(object.fraction) ? String(object.fraction) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorPeriod !== void 0 && (obj.validatorPeriod = (message.validatorPeriod || long_1.default.UZERO).toString());
        message.fraction !== void 0 && (obj.fraction = message.fraction);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorSlashEvent();
        message.validatorPeriod = object.validatorPeriod !== void 0 && object.validatorPeriod !== null ? long_1.default.fromValue(object.validatorPeriod) : long_1.default.UZERO;
        message.fraction = (_a = object.fraction) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseValidatorSlashEvents() {
      return { validatorSlashEvents: [] };
    }
    exports2.ValidatorSlashEvents = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validatorSlashEvents) {
          exports2.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorSlashEvents.push(exports2.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorSlashEvents: Array.isArray(object === null || object === void 0 ? void 0 : object.validatorSlashEvents) ? object.validatorSlashEvents.map((e) => exports2.ValidatorSlashEvent.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents) {
          obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? exports2.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.validatorSlashEvents = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = ((_a = object.validatorSlashEvents) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.ValidatorSlashEvent.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFeePool() {
      return { communityPool: [] };
    }
    exports2.FeePool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.communityPool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          communityPool: Array.isArray(object === null || object === void 0 ? void 0 : object.communityPool) ? object.communityPool.map((e) => coin_1.DecCoin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.communityPool) {
          obj.communityPool = message.communityPool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.communityPool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseFeePool();
        message.communityPool = ((_a = object.communityPool) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposal() {
      return { title: "", description: "", recipient: "", amount: [] };
    }
    exports2.CommunityPoolSpendProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : "",
          recipient: isSet(object.recipient) ? String(object.recipient) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseCommunityPoolSpendProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.recipient = (_c = object.recipient) !== null && _c !== void 0 ? _c : "";
        message.amount = ((_d = object.amount) === null || _d === void 0 ? void 0 : _d.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegatorStartingInfo() {
      return { previousPeriod: long_1.default.UZERO, stake: "", height: long_1.default.UZERO };
    }
    exports2.DelegatorStartingInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.previousPeriod.isZero()) {
          writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
          writer.uint32(18).string(message.stake);
        }
        if (!message.height.isZero()) {
          writer.uint32(24).uint64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.previousPeriod = reader.uint64();
              break;
            case 2:
              message.stake = reader.string();
              break;
            case 3:
              message.height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          previousPeriod: isSet(object.previousPeriod) ? long_1.default.fromValue(object.previousPeriod) : long_1.default.UZERO,
          stake: isSet(object.stake) ? String(object.stake) : "",
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.previousPeriod !== void 0 && (obj.previousPeriod = (message.previousPeriod || long_1.default.UZERO).toString());
        message.stake !== void 0 && (obj.stake = message.stake);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDelegatorStartingInfo();
        message.previousPeriod = object.previousPeriod !== void 0 && object.previousPeriod !== null ? long_1.default.fromValue(object.previousPeriod) : long_1.default.UZERO;
        message.stake = (_a = object.stake) !== null && _a !== void 0 ? _a : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseDelegationDelegatorReward() {
      return { validatorAddress: "", reward: [] };
    }
    exports2.DelegationDelegatorReward = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          reward: Array.isArray(object === null || object === void 0 ? void 0 : object.reward) ? object.reward.map((e) => coin_1.DecCoin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) {
          obj.reward = message.reward.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.reward = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        message.reward = ((_b = object.reward) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposalWithDeposit() {
      return { title: "", description: "", recipient: "", amount: "", deposit: "" };
    }
    exports2.CommunityPoolSpendProposalWithDeposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
          writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
          writer.uint32(42).string(message.deposit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : "",
          recipient: isSet(object.recipient) ? String(object.recipient) : "",
          amount: isSet(object.amount) ? String(object.amount) : "",
          deposit: isSet(object.deposit) ? String(object.deposit) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.deposit !== void 0 && (obj.deposit = message.deposit);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.recipient = (_c = object.recipient) !== null && _c !== void 0 ? _c : "";
        message.amount = (_d = object.amount) !== null && _d !== void 0 ? _d : "";
        message.deposit = (_e = object.deposit) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js
var require_query4 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryCommunityPoolResponse = exports2.QueryCommunityPoolRequest = exports2.QueryDelegatorWithdrawAddressResponse = exports2.QueryDelegatorWithdrawAddressRequest = exports2.QueryDelegatorValidatorsResponse = exports2.QueryDelegatorValidatorsRequest = exports2.QueryDelegationTotalRewardsResponse = exports2.QueryDelegationTotalRewardsRequest = exports2.QueryDelegationRewardsResponse = exports2.QueryDelegationRewardsRequest = exports2.QueryValidatorSlashesResponse = exports2.QueryValidatorSlashesRequest = exports2.QueryValidatorCommissionResponse = exports2.QueryValidatorCommissionRequest = exports2.QueryValidatorOutstandingRewardsResponse = exports2.QueryValidatorOutstandingRewardsRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var coin_1 = require_coin();
    var distribution_1 = require_distribution();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? distribution_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? distribution_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsRequest() {
      return { validatorAddress: "" };
    }
    exports2.QueryValidatorOutstandingRewardsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsResponse() {
      return { rewards: void 0 };
    }
    exports2.QueryValidatorOutstandingRewardsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rewards !== void 0) {
          distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rewards: isSet(object.rewards) ? distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.rewards !== void 0 && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        message.rewards = object.rewards !== void 0 && object.rewards !== null ? distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorCommissionRequest() {
      return { validatorAddress: "" };
    }
    exports2.QueryValidatorCommissionRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorCommissionRequest();
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryValidatorCommissionResponse() {
      return { commission: void 0 };
    }
    exports2.QueryValidatorCommissionResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commission !== void 0) {
          distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          commission: isSet(object.commission) ? distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.commission !== void 0 && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionResponse();
        message.commission = object.commission !== void 0 && object.commission !== null ? distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorSlashesRequest() {
      return {
        validatorAddress: "",
        startingHeight: long_1.default.UZERO,
        endingHeight: long_1.default.UZERO,
        pagination: void 0
      };
    }
    exports2.QueryValidatorSlashesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        if (!message.startingHeight.isZero()) {
          writer.uint32(16).uint64(message.startingHeight);
        }
        if (!message.endingHeight.isZero()) {
          writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.startingHeight = reader.uint64();
              break;
            case 3:
              message.endingHeight = reader.uint64();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          startingHeight: isSet(object.startingHeight) ? long_1.default.fromValue(object.startingHeight) : long_1.default.UZERO,
          endingHeight: isSet(object.endingHeight) ? long_1.default.fromValue(object.endingHeight) : long_1.default.UZERO,
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== void 0 && (obj.startingHeight = (message.startingHeight || long_1.default.UZERO).toString());
        message.endingHeight !== void 0 && (obj.endingHeight = (message.endingHeight || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorSlashesRequest();
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        message.startingHeight = object.startingHeight !== void 0 && object.startingHeight !== null ? long_1.default.fromValue(object.startingHeight) : long_1.default.UZERO;
        message.endingHeight = object.endingHeight !== void 0 && object.endingHeight !== null ? long_1.default.fromValue(object.endingHeight) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorSlashesResponse() {
      return { slashes: [], pagination: void 0 };
    }
    exports2.QueryValidatorSlashesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.slashes) {
          distribution_1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          slashes: Array.isArray(object === null || object === void 0 ? void 0 : object.slashes) ? object.slashes.map((e) => distribution_1.ValidatorSlashEvent.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.slashes) {
          obj.slashes = message.slashes.map((e) => e ? distribution_1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.slashes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorSlashesResponse();
        message.slashes = ((_a = object.slashes) === null || _a === void 0 ? void 0 : _a.map((e) => distribution_1.ValidatorSlashEvent.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegationRewardsRequest() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports2.QueryDelegationRewardsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryDelegationRewardsRequest();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryDelegationRewardsResponse() {
      return { rewards: [] };
    }
    exports2.QueryDelegationRewardsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rewards: Array.isArray(object === null || object === void 0 ? void 0 : object.rewards) ? object.rewards.map((e) => coin_1.DecCoin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegationRewardsResponse();
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsRequest() {
      return { delegatorAddress: "" };
    }
    exports2.QueryDelegationTotalRewardsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsResponse() {
      return { rewards: [], total: [] };
    }
    exports2.QueryDelegationTotalRewardsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          distribution_1.DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.total) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
              break;
            case 2:
              message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rewards: Array.isArray(object === null || object === void 0 ? void 0 : object.rewards) ? object.rewards.map((e) => distribution_1.DelegationDelegatorReward.fromJSON(e)) : [],
          total: Array.isArray(object === null || object === void 0 ? void 0 : object.total) ? object.total.map((e) => coin_1.DecCoin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? distribution_1.DelegationDelegatorReward.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => distribution_1.DelegationDelegatorReward.fromPartial(e))) || [];
        message.total = ((_b = object.total) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return { delegatorAddress: "" };
    }
    exports2.QueryDelegatorValidatorsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return { validators: [] };
    }
    exports2.QueryDelegatorValidatorsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressRequest() {
      return { delegatorAddress: "" };
    }
    exports2.QueryDelegatorWithdrawAddressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressResponse() {
      return { withdrawAddress: "" };
    }
    exports2.QueryDelegatorWithdrawAddressResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.withdrawAddress !== "") {
          writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { withdrawAddress: isSet(object.withdrawAddress) ? String(object.withdrawAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        message.withdrawAddress = (_a = object.withdrawAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryCommunityPoolRequest() {
      return {};
    }
    exports2.QueryCommunityPoolRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryCommunityPoolRequest();
        return message;
      }
    };
    function createBaseQueryCommunityPoolResponse() {
      return { pool: [] };
    }
    exports2.QueryCommunityPoolResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pool: Array.isArray(object === null || object === void 0 ? void 0 : object.pool) ? object.pool.map((e) => coin_1.DecCoin.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.pool) {
          obj.pool = message.pool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.pool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryCommunityPoolResponse();
        message.pool = ((_a = object.pool) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorOutstandingRewards(request) {
        const data = exports2.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data);
        return promise.then((data2) => exports2.QueryValidatorOutstandingRewardsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorCommission(request) {
        const data = exports2.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data);
        return promise.then((data2) => exports2.QueryValidatorCommissionResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorSlashes(request) {
        const data = exports2.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data);
        return promise.then((data2) => exports2.QueryValidatorSlashesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegationRewards(request) {
        const data = exports2.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data);
        return promise.then((data2) => exports2.QueryDelegationRewardsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegationTotalRewards(request) {
        const data = exports2.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data);
        return promise.then((data2) => exports2.QueryDelegationTotalRewardsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorValidators(request) {
        const data = exports2.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data2) => exports2.QueryDelegatorValidatorsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorWithdrawAddress(request) {
        const data = exports2.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data);
        return promise.then((data2) => exports2.QueryDelegatorWithdrawAddressResponse.decode(new minimal_1.default.Reader(data2)));
      }
      CommunityPool(request) {
        const data = exports2.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data);
        return promise.then((data2) => exports2.QueryCommunityPoolResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupDistributionExtension = void 0;
    var query_1 = require_query4();
    var long_1 = __importDefault(require_long());
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: long_1.default.fromNumber(startingHeight, true),
              endingHeight: long_1.default.fromNumber(endingHeight, true),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupDistributionExtension = setupDistributionExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEvidenceAminoConverters = exports2.isAminoMsgSubmitEvidence = void 0;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    exports2.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
    exports2.createEvidenceAminoConverters = createEvidenceAminoConverters;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFeegrantAminoConverters = void 0;
    function createFeegrantAminoConverters() {
      return {
        "/cosmos.feegrant.v1beta1.MsgGrantAllowance": "not_supported_by_chain",
        "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": "not_supported_by_chain"
      };
    }
    exports2.createFeegrantAminoConverters = createFeegrantAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js
var require_tx5 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgRevokeAllowanceResponse = exports2.MsgRevokeAllowance = exports2.MsgGrantAllowanceResponse = exports2.MsgGrantAllowance = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    exports2.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseMsgGrantAllowance() {
      return { granter: "", grantee: "", allowance: void 0 };
    }
    exports2.MsgGrantAllowance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          allowance: isSet(object.allowance) ? any_1.Any.fromJSON(object.allowance) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgGrantAllowance();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.allowance = object.allowance !== void 0 && object.allowance !== null ? any_1.Any.fromPartial(object.allowance) : void 0;
        return message;
      }
    };
    function createBaseMsgGrantAllowanceResponse() {
      return {};
    }
    exports2.MsgGrantAllowanceResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantAllowanceResponse();
        return message;
      }
    };
    function createBaseMsgRevokeAllowance() {
      return { granter: "", grantee: "" };
    }
    exports2.MsgRevokeAllowance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRevokeAllowance();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgRevokeAllowanceResponse() {
      return {};
    }
    exports2.MsgRevokeAllowanceResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeAllowanceResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.GrantAllowance = this.GrantAllowance.bind(this);
        this.RevokeAllowance = this.RevokeAllowance.bind(this);
      }
      GrantAllowance(request) {
        const data = exports2.MsgGrantAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", data);
        return promise.then((data2) => exports2.MsgGrantAllowanceResponse.decode(new minimal_1.default.Reader(data2)));
      }
      RevokeAllowance(request) {
        const data = exports2.MsgRevokeAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", data);
        return promise.then((data2) => exports2.MsgRevokeAllowanceResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports2.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// ../../node_modules/cosmjs-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "../../node_modules/cosmjs-types/google/protobuf/duration.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Duration = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "google.protobuf";
    function createBaseDuration() {
      return { seconds: long_1.default.ZERO, nanos: 0 };
    }
    exports2.Duration = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.seconds.isZero()) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          seconds: isSet(object.seconds) ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO,
          nanos: isSet(object.nanos) ? Number(object.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || long_1.default.ZERO).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDuration();
        message.seconds = object.seconds !== void 0 && object.seconds !== null ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO;
        message.nanos = (_a = object.nanos) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js
var require_feegrant = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Grant = exports2.AllowedMsgAllowance = exports2.PeriodicAllowance = exports2.BasicAllowance = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var duration_1 = require_duration();
    var timestamp_1 = require_timestamp();
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseBasicAllowance() {
      return { spendLimit: [], expiration: void 0 };
    }
    exports2.BasicAllowance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.spendLimit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBasicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          spendLimit: Array.isArray(object === null || object === void 0 ? void 0 : object.spendLimit) ? object.spendLimit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          expiration: isSet(object.expiration) ? fromJsonTimestamp(object.expiration) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.spendLimit = [];
        }
        message.expiration !== void 0 && (obj.expiration = fromTimestamp(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseBasicAllowance();
        message.spendLimit = ((_a = object.spendLimit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.expiration = object.expiration !== void 0 && object.expiration !== null ? timestamp_1.Timestamp.fromPartial(object.expiration) : void 0;
        return message;
      }
    };
    function createBasePeriodicAllowance() {
      return {
        basic: void 0,
        period: void 0,
        periodSpendLimit: [],
        periodCanSpend: [],
        periodReset: void 0
      };
    }
    exports2.PeriodicAllowance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.basic !== void 0) {
          exports2.BasicAllowance.encode(message.basic, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== void 0) {
          duration_1.Duration.encode(message.period, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.periodSpendLimit) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.periodCanSpend) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.periodReset !== void 0) {
          timestamp_1.Timestamp.encode(message.periodReset, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.basic = exports2.BasicAllowance.decode(reader, reader.uint32());
              break;
            case 2:
              message.period = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.periodSpendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.periodCanSpend.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.periodReset = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          basic: isSet(object.basic) ? exports2.BasicAllowance.fromJSON(object.basic) : void 0,
          period: isSet(object.period) ? duration_1.Duration.fromJSON(object.period) : void 0,
          periodSpendLimit: Array.isArray(object === null || object === void 0 ? void 0 : object.periodSpendLimit) ? object.periodSpendLimit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          periodCanSpend: Array.isArray(object === null || object === void 0 ? void 0 : object.periodCanSpend) ? object.periodCanSpend.map((e) => coin_1.Coin.fromJSON(e)) : [],
          periodReset: isSet(object.periodReset) ? fromJsonTimestamp(object.periodReset) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.basic !== void 0 && (obj.basic = message.basic ? exports2.BasicAllowance.toJSON(message.basic) : void 0);
        message.period !== void 0 && (obj.period = message.period ? duration_1.Duration.toJSON(message.period) : void 0);
        if (message.periodSpendLimit) {
          obj.periodSpendLimit = message.periodSpendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodSpendLimit = [];
        }
        if (message.periodCanSpend) {
          obj.periodCanSpend = message.periodCanSpend.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodCanSpend = [];
        }
        message.periodReset !== void 0 && (obj.periodReset = fromTimestamp(message.periodReset).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePeriodicAllowance();
        message.basic = object.basic !== void 0 && object.basic !== null ? exports2.BasicAllowance.fromPartial(object.basic) : void 0;
        message.period = object.period !== void 0 && object.period !== null ? duration_1.Duration.fromPartial(object.period) : void 0;
        message.periodSpendLimit = ((_a = object.periodSpendLimit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.periodCanSpend = ((_b = object.periodCanSpend) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.periodReset = object.periodReset !== void 0 && object.periodReset !== null ? timestamp_1.Timestamp.fromPartial(object.periodReset) : void 0;
        return message;
      }
    };
    function createBaseAllowedMsgAllowance() {
      return { allowance: void 0, allowedMessages: [] };
    }
    exports2.AllowedMsgAllowance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.allowedMessages) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAllowedMsgAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowedMessages.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          allowance: isSet(object.allowance) ? any_1.Any.fromJSON(object.allowance) : void 0,
          allowedMessages: Array.isArray(object === null || object === void 0 ? void 0 : object.allowedMessages) ? object.allowedMessages.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        if (message.allowedMessages) {
          obj.allowedMessages = message.allowedMessages.map((e) => e);
        } else {
          obj.allowedMessages = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseAllowedMsgAllowance();
        message.allowance = object.allowance !== void 0 && object.allowance !== null ? any_1.Any.fromPartial(object.allowance) : void 0;
        message.allowedMessages = ((_a = object.allowedMessages) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseGrant() {
      return { granter: "", grantee: "", allowance: void 0 };
    }
    exports2.Grant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          allowance: isSet(object.allowance) ? any_1.Any.fromJSON(object.allowance) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseGrant();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.allowance = object.allowance !== void 0 && object.allowance !== null ? any_1.Any.fromPartial(object.allowance) : void 0;
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js
var require_query5 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryAllowancesByGranterResponse = exports2.QueryAllowancesByGranterRequest = exports2.QueryAllowancesResponse = exports2.QueryAllowancesRequest = exports2.QueryAllowanceResponse = exports2.QueryAllowanceRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var feegrant_1 = require_feegrant();
    exports2.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseQueryAllowanceRequest() {
      return { granter: "", grantee: "" };
    }
    exports2.QueryAllowanceRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          grantee: isSet(object.grantee) ? String(object.grantee) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryAllowanceRequest();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryAllowanceResponse() {
      return { allowance: void 0 };
    }
    exports2.QueryAllowanceResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.allowance !== void 0) {
          feegrant_1.Grant.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = feegrant_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { allowance: isSet(object.allowance) ? feegrant_1.Grant.fromJSON(object.allowance) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? feegrant_1.Grant.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceResponse();
        message.allowance = object.allowance !== void 0 && object.allowance !== null ? feegrant_1.Grant.fromPartial(object.allowance) : void 0;
        return message;
      }
    };
    function createBaseQueryAllowancesRequest() {
      return { grantee: "", pagination: void 0 };
    }
    exports2.QueryAllowancesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grantee: isSet(object.grantee) ? String(object.grantee) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllowancesRequest();
        message.grantee = (_a = object.grantee) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllowancesResponse() {
      return { allowances: [], pagination: void 0 };
    }
    exports2.QueryAllowancesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          allowances: Array.isArray(object === null || object === void 0 ? void 0 : object.allowances) ? object.allowances.map((e) => feegrant_1.Grant.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllowancesResponse();
        message.allowances = ((_a = object.allowances) === null || _a === void 0 ? void 0 : _a.map((e) => feegrant_1.Grant.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterRequest() {
      return { granter: "", pagination: void 0 };
    }
    exports2.QueryAllowancesByGranterRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet(object.granter) ? String(object.granter) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllowancesByGranterRequest();
        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterResponse() {
      return { allowances: [], pagination: void 0 };
    }
    exports2.QueryAllowancesByGranterResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          allowances: Array.isArray(object === null || object === void 0 ? void 0 : object.allowances) ? object.allowances.map((e) => feegrant_1.Grant.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllowancesByGranterResponse();
        message.allowances = ((_a = object.allowances) === null || _a === void 0 ? void 0 : _a.map((e) => feegrant_1.Grant.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Allowance = this.Allowance.bind(this);
        this.Allowances = this.Allowances.bind(this);
        this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
      }
      Allowance(request) {
        const data = exports2.QueryAllowanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", data);
        return promise.then((data2) => exports2.QueryAllowanceResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Allowances(request) {
        const data = exports2.QueryAllowancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", data);
        return promise.then((data2) => exports2.QueryAllowancesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      AllowancesByGranter(request) {
        const data = exports2.QueryAllowancesByGranterRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", data);
        return promise.then((data2) => exports2.QueryAllowancesByGranterResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupFeegrantExtension = void 0;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupFeegrantExtension = setupFeegrantExtension;
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TallyParams = exports2.VotingParams = exports2.DepositParams = exports2.Vote = exports2.TallyResult = exports2.Proposal = exports2.Deposit = exports2.TextProposal = exports2.WeightedVoteOption = exports2.proposalStatusToJSON = exports2.proposalStatusFromJSON = exports2.ProposalStatus = exports2.voteOptionToJSON = exports2.voteOptionFromJSON = exports2.VoteOption = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var duration_1 = require_duration();
    var timestamp_1 = require_timestamp();
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption = exports2.VoteOption || (exports2.VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports2.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus = exports2.ProposalStatus || (exports2.ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports2.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return { option: 0, weight: "" };
    }
    exports2.WeightedVoteOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,
          weight: isSet(object.weight) ? String(object.weight) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseWeightedVoteOption();
        message.option = (_a = object.option) !== null && _a !== void 0 ? _a : 0;
        message.weight = (_b = object.weight) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return { title: "", description: "" };
    }
    exports2.TextProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTextProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDeposit() {
      return { proposalId: long_1.default.UZERO, depositor: "", amount: [] };
    }
    exports2.Deposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          depositor: isSet(object.depositor) ? String(object.depositor) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDeposit();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.depositor = (_a = object.depositor) !== null && _a !== void 0 ? _a : "";
        message.amount = ((_b = object.amount) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        proposalId: long_1.default.UZERO,
        content: void 0,
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0
      };
    }
    exports2.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports2.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports2.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          content: isSet(object.content) ? any_1.Any.fromJSON(object.content) : void 0,
          status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,
          finalTallyResult: isSet(object.finalTallyResult) ? exports2.TallyResult.fromJSON(object.finalTallyResult) : void 0,
          submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : void 0,
          depositEndTime: isSet(object.depositEndTime) ? fromJsonTimestamp(object.depositEndTime) : void 0,
          totalDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.totalDeposit) ? object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          votingStartTime: isSet(object.votingStartTime) ? fromJsonTimestamp(object.votingStartTime) : void 0,
          votingEndTime: isSet(object.votingEndTime) ? fromJsonTimestamp(object.votingEndTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports2.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = fromTimestamp(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = fromTimestamp(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = fromTimestamp(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = fromTimestamp(message.votingEndTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseProposal();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromPartial(object.content) : void 0;
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;
        message.finalTallyResult = object.finalTallyResult !== void 0 && object.finalTallyResult !== null ? exports2.TallyResult.fromPartial(object.finalTallyResult) : void 0;
        message.submitTime = object.submitTime !== void 0 && object.submitTime !== null ? timestamp_1.Timestamp.fromPartial(object.submitTime) : void 0;
        message.depositEndTime = object.depositEndTime !== void 0 && object.depositEndTime !== null ? timestamp_1.Timestamp.fromPartial(object.depositEndTime) : void 0;
        message.totalDeposit = ((_b = object.totalDeposit) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.votingStartTime = object.votingStartTime !== void 0 && object.votingStartTime !== null ? timestamp_1.Timestamp.fromPartial(object.votingStartTime) : void 0;
        message.votingEndTime = object.votingEndTime !== void 0 && object.votingEndTime !== null ? timestamp_1.Timestamp.fromPartial(object.votingEndTime) : void 0;
        return message;
      }
    };
    function createBaseTallyResult() {
      return { yes: "", abstain: "", no: "", noWithVeto: "" };
    }
    exports2.TallyResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          yes: isSet(object.yes) ? String(object.yes) : "",
          abstain: isSet(object.abstain) ? String(object.abstain) : "",
          no: isSet(object.no) ? String(object.no) : "",
          noWithVeto: isSet(object.noWithVeto) ? String(object.noWithVeto) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTallyResult();
        message.yes = (_a = object.yes) !== null && _a !== void 0 ? _a : "";
        message.abstain = (_b = object.abstain) !== null && _b !== void 0 ? _b : "";
        message.no = (_c = object.no) !== null && _c !== void 0 ? _c : "";
        message.noWithVeto = (_d = object.noWithVeto) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseVote() {
      return { proposalId: long_1.default.UZERO, voter: "", option: 0, options: [] };
    }
    exports2.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
          exports2.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports2.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          voter: isSet(object.voter) ? String(object.voter) : "",
          option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,
          options: Array.isArray(object === null || object === void 0 ? void 0 : object.options) ? object.options.map((e) => exports2.WeightedVoteOption.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports2.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseVote();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        message.option = (_b = object.option) !== null && _b !== void 0 ? _b : 0;
        message.options = ((_c = object.options) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDepositParams() {
      return { minDeposit: [], maxDepositPeriod: void 0 };
    }
    exports2.DepositParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          minDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.minDeposit) ? object.minDeposit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          maxDepositPeriod: isSet(object.maxDepositPeriod) ? duration_1.Duration.fromJSON(object.maxDepositPeriod) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a = object.minDeposit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.maxDepositPeriod = object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null ? duration_1.Duration.fromPartial(object.maxDepositPeriod) : void 0;
        return message;
      }
    };
    function createBaseVotingParams() {
      return { votingPeriod: void 0 };
    }
    exports2.VotingParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { votingPeriod: isSet(object.votingPeriod) ? duration_1.Duration.fromJSON(object.votingPeriod) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        message.votingPeriod = object.votingPeriod !== void 0 && object.votingPeriod !== null ? duration_1.Duration.fromPartial(object.votingPeriod) : void 0;
        return message;
      }
    };
    function createBaseTallyParams() {
      return { quorum: new Uint8Array(), threshold: new Uint8Array(), vetoThreshold: new Uint8Array() };
    }
    exports2.TallyParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          quorum: isSet(object.quorum) ? bytesFromBase64(object.quorum) : new Uint8Array(),
          threshold: isSet(object.threshold) ? bytesFromBase64(object.threshold) : new Uint8Array(),
          vetoThreshold: isSet(object.vetoThreshold) ? bytesFromBase64(object.vetoThreshold) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = base64FromBytes(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = base64FromBytes(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = base64FromBytes(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTallyParams();
        message.quorum = (_a = object.quorum) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.threshold = (_b = object.threshold) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.vetoThreshold = (_c = object.vetoThreshold) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGovAminoConverters = exports2.isAminoMsgDeposit = exports2.isAminoMsgVoteWeighted = exports2.isAminoMsgVote = exports2.isAminoMsgSubmitProposal = void 0;
    var math_1 = require_build2();
    var utils_1 = require_build3();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var long_1 = __importDefault(require_long());
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    exports2.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    exports2.isAminoMsgVote = isAminoMsgVote;
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    exports2.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    exports2.isAminoMsgDeposit = isAminoMsgDeposit;
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: long_1.default.fromString(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: long_1.default.fromString(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o) => ({
                option: o.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: long_1.default.fromString(proposal_id),
              voter,
              options: options.map((o) => ({
                option: (0, gov_1.voteOptionFromJSON)(o.option),
                weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
    exports2.createGovAminoConverters = createGovAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js
var require_tx6 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgDepositResponse = exports2.MsgDeposit = exports2.MsgVoteWeightedResponse = exports2.MsgVoteWeighted = exports2.MsgVoteResponse = exports2.MsgVote = exports2.MsgSubmitProposalResponse = exports2.MsgSubmitProposal = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal() {
      return { content: void 0, initialDeposit: [], proposer: "" };
    }
    exports2.MsgSubmitProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          content: isSet(object.content) ? any_1.Any.fromJSON(object.content) : void 0,
          initialDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.initialDeposit) ? object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          proposer: isSet(object.proposer) ? String(object.proposer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSubmitProposal();
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromPartial(object.content) : void 0;
        message.initialDeposit = ((_a = object.initialDeposit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = (_b = object.proposer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return { proposalId: long_1.default.UZERO };
    }
    exports2.MsgSubmitProposalResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseMsgVote() {
      return { proposalId: long_1.default.UZERO, voter: "", option: 0 };
    }
    exports2.MsgVote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          voter: isSet(object.voter) ? String(object.voter) : "",
          option: isSet(object.option) ? (0, gov_1.voteOptionFromJSON)(object.option) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgVote();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        message.option = (_b = object.option) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports2.MsgVoteResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return { proposalId: long_1.default.UZERO, voter: "", options: [] };
    }
    exports2.MsgVoteWeighted = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          voter: isSet(object.voter) ? String(object.voter) : "",
          options: Array.isArray(object === null || object === void 0 ? void 0 : object.options) ? object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgVoteWeighted();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        message.options = ((_b = object.options) === null || _b === void 0 ? void 0 : _b.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports2.MsgVoteWeightedResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return { proposalId: long_1.default.UZERO, depositor: "", amount: [] };
    }
    exports2.MsgDeposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          depositor: isSet(object.depositor) ? String(object.depositor) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgDeposit();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.depositor = (_a = object.depositor) !== null && _a !== void 0 ? _a : "";
        message.amount = ((_b = object.amount) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports2.MsgDepositResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
      }
      SubmitProposal(request) {
        const data = exports2.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data);
        return promise.then((data2) => exports2.MsgSubmitProposalResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Vote(request) {
        const data = exports2.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data);
        return promise.then((data2) => exports2.MsgVoteResponse.decode(new minimal_1.default.Reader(data2)));
      }
      VoteWeighted(request) {
        const data = exports2.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data);
        return promise.then((data2) => exports2.MsgVoteWeightedResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Deposit(request) {
        const data = exports2.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data);
        return promise.then((data2) => exports2.MsgDepositResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgVoteWeightedEncodeObject = exports2.isMsgVoteEncodeObject = exports2.isMsgSubmitProposalEncodeObject = exports2.isMsgDepositEncodeObject = exports2.govTypes = void 0;
    var tx_1 = require_tx6();
    exports2.govTypes = [
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_1.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    exports2.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    exports2.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    exports2.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
    exports2.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
  }
});

// ../../node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js
var require_query6 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryTallyResultResponse = exports2.QueryTallyResultRequest = exports2.QueryDepositsResponse = exports2.QueryDepositsRequest = exports2.QueryDepositResponse = exports2.QueryDepositRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryVotesResponse = exports2.QueryVotesRequest = exports2.QueryVoteResponse = exports2.QueryVoteRequest = exports2.QueryProposalsResponse = exports2.QueryProposalsRequest = exports2.QueryProposalResponse = exports2.QueryProposalRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var gov_1 = require_gov();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseQueryProposalRequest() {
      return { proposalId: long_1.default.UZERO };
    }
    exports2.QueryProposalRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalRequest();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryProposalResponse() {
      return { proposal: void 0 };
    }
    exports2.QueryProposalResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposal !== void 0) {
          gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { proposal: isSet(object.proposal) ? gov_1.Proposal.fromJSON(object.proposal) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.proposal !== void 0 && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalResponse();
        message.proposal = object.proposal !== void 0 && object.proposal !== null ? gov_1.Proposal.fromPartial(object.proposal) : void 0;
        return message;
      }
    };
    function createBaseQueryProposalsRequest() {
      return { proposalStatus: 0, voter: "", depositor: "", pagination: void 0 };
    }
    exports2.QueryProposalsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalStatus !== 0) {
          writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
          writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalStatus = reader.int32();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.depositor = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalStatus: isSet(object.proposalStatus) ? (0, gov_1.proposalStatusFromJSON)(object.proposalStatus) : 0,
          voter: isSet(object.voter) ? String(object.voter) : "",
          depositor: isSet(object.depositor) ? String(object.depositor) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalStatus !== void 0 && (obj.proposalStatus = (0, gov_1.proposalStatusToJSON)(message.proposalStatus));
        message.voter !== void 0 && (obj.voter = message.voter);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseQueryProposalsRequest();
        message.proposalStatus = (_a = object.proposalStatus) !== null && _a !== void 0 ? _a : 0;
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        message.depositor = (_c = object.depositor) !== null && _c !== void 0 ? _c : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryProposalsResponse() {
      return { proposals: [], pagination: void 0 };
    }
    exports2.QueryProposalsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.proposals) {
          gov_1.Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposals: Array.isArray(object === null || object === void 0 ? void 0 : object.proposals) ? object.proposals.map((e) => gov_1.Proposal.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.proposals) {
          obj.proposals = message.proposals.map((e) => e ? gov_1.Proposal.toJSON(e) : void 0);
        } else {
          obj.proposals = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryProposalsResponse();
        message.proposals = ((_a = object.proposals) === null || _a === void 0 ? void 0 : _a.map((e) => gov_1.Proposal.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryVoteRequest() {
      return { proposalId: long_1.default.UZERO, voter: "" };
    }
    exports2.QueryVoteRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          voter: isSet(object.voter) ? String(object.voter) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryVoteRequest();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryVoteResponse() {
      return { vote: void 0 };
    }
    exports2.QueryVoteResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.vote !== void 0) {
          gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vote = gov_1.Vote.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { vote: isSet(object.vote) ? gov_1.Vote.fromJSON(object.vote) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.vote !== void 0 && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteResponse();
        message.vote = object.vote !== void 0 && object.vote !== null ? gov_1.Vote.fromPartial(object.vote) : void 0;
        return message;
      }
    };
    function createBaseQueryVotesRequest() {
      return { proposalId: long_1.default.UZERO, pagination: void 0 };
    }
    exports2.QueryVotesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesRequest();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryVotesResponse() {
      return { votes: [], pagination: void 0 };
    }
    exports2.QueryVotesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.votes) {
          gov_1.Vote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          votes: Array.isArray(object === null || object === void 0 ? void 0 : object.votes) ? object.votes.map((e) => gov_1.Vote.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? gov_1.Vote.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryVotesResponse();
        message.votes = ((_a = object.votes) === null || _a === void 0 ? void 0 : _a.map((e) => gov_1.Vote.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return { paramsType: "" };
    }
    exports2.QueryParamsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.paramsType !== "") {
          writer.uint32(10).string(message.paramsType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paramsType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { paramsType: isSet(object.paramsType) ? String(object.paramsType) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.paramsType !== void 0 && (obj.paramsType = message.paramsType);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryParamsRequest();
        message.paramsType = (_a = object.paramsType) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { votingParams: void 0, depositParams: void 0, tallyParams: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.votingParams !== void 0) {
          gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== void 0) {
          gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== void 0) {
          gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          votingParams: isSet(object.votingParams) ? gov_1.VotingParams.fromJSON(object.votingParams) : void 0,
          depositParams: isSet(object.depositParams) ? gov_1.DepositParams.fromJSON(object.depositParams) : void 0,
          tallyParams: isSet(object.tallyParams) ? gov_1.TallyParams.fromJSON(object.tallyParams) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : void 0);
        message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : void 0);
        message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.votingParams = object.votingParams !== void 0 && object.votingParams !== null ? gov_1.VotingParams.fromPartial(object.votingParams) : void 0;
        message.depositParams = object.depositParams !== void 0 && object.depositParams !== null ? gov_1.DepositParams.fromPartial(object.depositParams) : void 0;
        message.tallyParams = object.tallyParams !== void 0 && object.tallyParams !== null ? gov_1.TallyParams.fromPartial(object.tallyParams) : void 0;
        return message;
      }
    };
    function createBaseQueryDepositRequest() {
      return { proposalId: long_1.default.UZERO, depositor: "" };
    }
    exports2.QueryDepositRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          depositor: isSet(object.depositor) ? String(object.depositor) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDepositRequest();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.depositor = (_a = object.depositor) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDepositResponse() {
      return { deposit: void 0 };
    }
    exports2.QueryDepositResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deposit !== void 0) {
          gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { deposit: isSet(object.deposit) ? gov_1.Deposit.fromJSON(object.deposit) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.deposit !== void 0 && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositResponse();
        message.deposit = object.deposit !== void 0 && object.deposit !== null ? gov_1.Deposit.fromPartial(object.deposit) : void 0;
        return message;
      }
    };
    function createBaseQueryDepositsRequest() {
      return { proposalId: long_1.default.UZERO, pagination: void 0 };
    }
    exports2.QueryDepositsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO,
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsRequest();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDepositsResponse() {
      return { deposits: [], pagination: void 0 };
    }
    exports2.QueryDepositsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.deposits) {
          gov_1.Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          deposits: Array.isArray(object === null || object === void 0 ? void 0 : object.deposits) ? object.deposits.map((e) => gov_1.Deposit.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.deposits) {
          obj.deposits = message.deposits.map((e) => e ? gov_1.Deposit.toJSON(e) : void 0);
        } else {
          obj.deposits = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDepositsResponse();
        message.deposits = ((_a = object.deposits) === null || _a === void 0 ? void 0 : _a.map((e) => gov_1.Deposit.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryTallyResultRequest() {
      return { proposalId: long_1.default.UZERO };
    }
    exports2.QueryTallyResultRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { proposalId: isSet(object.proposalId) ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultRequest();
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryTallyResultResponse() {
      return { tally: void 0 };
    }
    exports2.QueryTallyResultResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tally !== void 0) {
          gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { tally: isSet(object.tally) ? gov_1.TallyResult.fromJSON(object.tally) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.tally !== void 0 && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultResponse();
        message.tally = object.tally !== void 0 && object.tally !== null ? gov_1.TallyResult.fromPartial(object.tally) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
      }
      Proposal(request) {
        const data = exports2.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data);
        return promise.then((data2) => exports2.QueryProposalResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Proposals(request) {
        const data = exports2.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data);
        return promise.then((data2) => exports2.QueryProposalsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Vote(request) {
        const data = exports2.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data);
        return promise.then((data2) => exports2.QueryVoteResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Votes(request) {
        const data = exports2.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data);
        return promise.then((data2) => exports2.QueryVotesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Deposit(request) {
        const data = exports2.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data);
        return promise.then((data2) => exports2.QueryDepositResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Deposits(request) {
        const data = exports2.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data);
        return promise.then((data2) => exports2.QueryDepositsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      TallyResult(request) {
        const data = exports2.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data);
        return promise.then((data2) => exports2.QueryTallyResultResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupGovExtension = void 0;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
    exports2.setupGovExtension = setupGovExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages8 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createIbcAminoConverters = exports2.isAminoMsgTransfer = void 0;
    var long_1 = __importDefault(require_long());
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    exports2.isAminoMsgTransfer = isAminoMsgTransfer;
    function omitDefault(input) {
      if (typeof input === "string") {
        return input === "" ? void 0 : input;
      }
      if (typeof input === "number") {
        return input === 0 ? void 0 : input;
      }
      if (long_1.default.isLong(input)) {
        return input.isZero() ? void 0 : input;
      }
      throw new Error(`Got unsupported type '${typeof input}'`);
    }
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp }) => {
            var _a, _b, _c;
            return {
              source_port: sourcePort,
              source_channel: sourceChannel,
              token,
              sender,
              receiver,
              timeout_height: timeoutHeight ? {
                revision_height: (_a = omitDefault(timeoutHeight.revisionHeight)) === null || _a === void 0 ? void 0 : _a.toString(),
                revision_number: (_b = omitDefault(timeoutHeight.revisionNumber)) === null || _b === void 0 ? void 0 : _b.toString()
              } : {},
              timeout_timestamp: (_c = omitDefault(timeoutTimestamp)) === null || _c === void 0 ? void 0 : _c.toString()
            };
          },
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp }) => ({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: long_1.default.fromString(timeout_height.revision_height || "0", true),
              revisionNumber: long_1.default.fromString(timeout_height.revision_number || "0", true)
            } : void 0,
            timeoutTimestamp: long_1.default.fromString(timeout_timestamp || "0", true)
          })
        }
      };
    }
    exports2.createIbcAminoConverters = createIbcAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModuleVersion = exports2.CancelSoftwareUpgradeProposal = exports2.SoftwareUpgradeProposal = exports2.Plan = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    exports2.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan() {
      return { name: "", time: void 0, height: long_1.default.ZERO, info: "", upgradedClientState: void 0 };
    }
    exports2.Plan = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(18).fork()).ldelim();
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet(object.name) ? String(object.name) : "",
          time: isSet(object.time) ? fromJsonTimestamp(object.time) : void 0,
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          info: isSet(object.info) ? String(object.info) : "",
          upgradedClientState: isSet(object.upgradedClientState) ? any_1.Any.fromJSON(object.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePlan();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
        message.upgradedClientState = object.upgradedClientState !== void 0 && object.upgradedClientState !== null ? any_1.Any.fromPartial(object.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return { title: "", description: "", plan: void 0 };
    }
    exports2.SoftwareUpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports2.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports2.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : "",
          plan: isSet(object.plan) ? exports2.Plan.fromJSON(object.plan) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports2.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseSoftwareUpgradeProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object.plan !== void 0 && object.plan !== null ? exports2.Plan.fromPartial(object.plan) : void 0;
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return { title: "", description: "" };
    }
    exports2.CancelSoftwareUpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseModuleVersion() {
      return { name: "", version: long_1.default.UZERO };
    }
    exports2.ModuleVersion = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (!message.version.isZero()) {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet(object.name) ? String(object.name) : "",
          version: isSet(object.version) ? long_1.default.fromValue(object.version) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = (message.version || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseModuleVersion();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.version = object.version !== void 0 && object.version !== null ? long_1.default.fromValue(object.version) : long_1.default.UZERO;
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/client/v1/client.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Height = exports2.UpgradeProposal = exports2.ClientUpdateProposal = exports2.ClientConsensusStates = exports2.ConsensusStateWithHeight = exports2.IdentifiedClientState = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var upgrade_1 = require_upgrade();
    var any_1 = require_any();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return { clientId: "", clientState: void 0 };
    }
    exports2.IdentifiedClientState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          clientState: isSet(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseIdentifiedClientState();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return { height: void 0, consensusState: void 0 };
    }
    exports2.ConsensusStateWithHeight = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== void 0) {
          exports2.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports2.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? exports2.Height.fromJSON(object.height) : void 0,
          consensusState: isSet(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports2.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusStateWithHeight();
        message.height = object.height !== void 0 && object.height !== null ? exports2.Height.fromPartial(object.height) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return { clientId: "", consensusStates: [] };
    }
    exports2.ClientConsensusStates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.consensusStates) {
          exports2.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports2.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          consensusStates: Array.isArray(object === null || object === void 0 ? void 0 : object.consensusStates) ? object.consensusStates.map((e) => exports2.ConsensusStateWithHeight.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports2.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseClientConsensusStates();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.consensusStates = ((_b = object.consensusStates) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.ConsensusStateWithHeight.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return { title: "", description: "", subjectClientId: "", substituteClientId: "" };
    }
    exports2.ClientUpdateProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : "",
          subjectClientId: isSet(object.subjectClientId) ? String(object.subjectClientId) : "",
          substituteClientId: isSet(object.substituteClientId) ? String(object.substituteClientId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseClientUpdateProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.subjectClientId = (_c = object.subjectClientId) !== null && _c !== void 0 ? _c : "";
        message.substituteClientId = (_d = object.substituteClientId) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return { title: "", description: "", plan: void 0, upgradedClientState: void 0 };
    }
    exports2.UpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet(object.title) ? String(object.title) : "",
          description: isSet(object.description) ? String(object.description) : "",
          plan: isSet(object.plan) ? upgrade_1.Plan.fromJSON(object.plan) : void 0,
          upgradedClientState: isSet(object.upgradedClientState) ? any_1.Any.fromJSON(object.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseUpgradeProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object.plan !== void 0 && object.plan !== null ? upgrade_1.Plan.fromPartial(object.plan) : void 0;
        message.upgradedClientState = object.upgradedClientState !== void 0 && object.upgradedClientState !== null ? any_1.Any.fromPartial(object.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseHeight() {
      return { revisionNumber: long_1.default.UZERO, revisionHeight: long_1.default.UZERO };
    }
    exports2.Height = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.revisionNumber.isZero()) {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = reader.uint64();
              break;
            case 2:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          revisionNumber: isSet(object.revisionNumber) ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO,
          revisionHeight: isSet(object.revisionHeight) ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeight();
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseParams() {
      return { allowedClients: [] };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.allowedClients) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          allowedClients: Array.isArray(object === null || object === void 0 ? void 0 : object.allowedClients) ? object.allowedClients.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseParams();
        message.allowedClients = ((_a = object.allowedClients) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js
var require_tx7 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgTransferResponse = exports2.MsgTransfer = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    var client_1 = require_client();
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: void 0,
        sender: "",
        receiver: "",
        timeoutHeight: void 0,
        timeoutTimestamp: long_1.default.UZERO
      };
    }
    exports2.MsgTransfer = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (!message.timeoutTimestamp.isZero()) {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sourcePort: isSet(object.sourcePort) ? String(object.sourcePort) : "",
          sourceChannel: isSet(object.sourceChannel) ? String(object.sourceChannel) : "",
          token: isSet(object.token) ? coin_1.Coin.fromJSON(object.token) : void 0,
          sender: isSet(object.sender) ? String(object.sender) : "",
          receiver: isSet(object.receiver) ? String(object.receiver) : "",
          timeoutHeight: isSet(object.timeoutHeight) ? client_1.Height.fromJSON(object.timeoutHeight) : void 0,
          timeoutTimestamp: isSet(object.timeoutTimestamp) ? long_1.default.fromValue(object.timeoutTimestamp) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgTransfer();
        message.sourcePort = (_a = object.sourcePort) !== null && _a !== void 0 ? _a : "";
        message.sourceChannel = (_b = object.sourceChannel) !== null && _b !== void 0 ? _b : "";
        message.token = object.token !== void 0 && object.token !== null ? coin_1.Coin.fromPartial(object.token) : void 0;
        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : "";
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromPartial(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? long_1.default.fromValue(object.timeoutTimestamp) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {};
    }
    exports2.MsgTransferResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgTransferResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
      }
      Transfer(request) {
        const data = exports2.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data);
        return promise.then((data2) => exports2.MsgTransferResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/channel.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Acknowledgement = exports2.PacketState = exports2.Packet = exports2.Counterparty = exports2.IdentifiedChannel = exports2.Channel = exports2.orderToJSON = exports2.orderFromJSON = exports2.Order = exports2.stateToJSON = exports2.stateFromJSON = exports2.State = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var client_1 = require_client();
    exports2.protobufPackage = "ibc.core.channel.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State = exports2.State || (exports2.State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State.STATE_CLOSED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports2.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.STATE_CLOSED:
          return "STATE_CLOSED";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.stateToJSON = stateToJSON;
    var Order;
    (function(Order2) {
      Order2[Order2["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order2[Order2["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order2[Order2["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order2[Order2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order = exports2.Order || (exports2.Order = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order.UNRECOGNIZED;
      }
    }
    exports2.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
          return "ORDER_ORDERED";
        case Order.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.orderToJSON = orderToJSON;
    function createBaseChannel() {
      return { state: 0, ordering: 0, counterparty: void 0, connectionHops: [], version: "" };
    }
    exports2.Channel = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          state: isSet(object.state) ? stateFromJSON(object.state) : 0,
          ordering: isSet(object.ordering) ? orderFromJSON(object.ordering) : 0,
          counterparty: isSet(object.counterparty) ? exports2.Counterparty.fromJSON(object.counterparty) : void 0,
          connectionHops: Array.isArray(object === null || object === void 0 ? void 0 : object.connectionHops) ? object.connectionHops.map((e) => String(e)) : [],
          version: isSet(object.version) ? String(object.version) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseChannel();
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports2.Counterparty.fromPartial(object.counterparty) : void 0;
        message.connectionHops = ((_c = object.connectionHops) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseIdentifiedChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: void 0,
        connectionHops: [],
        version: "",
        portId: "",
        channelId: ""
      };
    }
    exports2.IdentifiedChannel = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          state: isSet(object.state) ? stateFromJSON(object.state) : 0,
          ordering: isSet(object.ordering) ? orderFromJSON(object.ordering) : 0,
          counterparty: isSet(object.counterparty) ? exports2.Counterparty.fromJSON(object.counterparty) : void 0,
          connectionHops: Array.isArray(object === null || object === void 0 ? void 0 : object.connectionHops) ? object.connectionHops.map((e) => String(e)) : [],
          version: isSet(object.version) ? String(object.version) : "",
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseIdentifiedChannel();
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports2.Counterparty.fromPartial(object.counterparty) : void 0;
        message.connectionHops = ((_c = object.connectionHops) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        message.portId = (_e = object.portId) !== null && _e !== void 0 ? _e : "";
        message.channelId = (_f = object.channelId) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseCounterparty() {
      return { portId: "", channelId: "" };
    }
    exports2.Counterparty = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCounterparty();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBasePacket() {
      return {
        sequence: long_1.default.UZERO,
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: void 0,
        timeoutTimestamp: long_1.default.UZERO
      };
    }
    exports2.Packet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.sequence.isZero()) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (!message.timeoutTimestamp.isZero()) {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO,
          sourcePort: isSet(object.sourcePort) ? String(object.sourcePort) : "",
          sourceChannel: isSet(object.sourceChannel) ? String(object.sourceChannel) : "",
          destinationPort: isSet(object.destinationPort) ? String(object.destinationPort) : "",
          destinationChannel: isSet(object.destinationChannel) ? String(object.destinationChannel) : "",
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          timeoutHeight: isSet(object.timeoutHeight) ? client_1.Height.fromJSON(object.timeoutHeight) : void 0,
          timeoutTimestamp: isSet(object.timeoutTimestamp) ? long_1.default.fromValue(object.timeoutTimestamp) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBasePacket();
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        message.sourcePort = (_a = object.sourcePort) !== null && _a !== void 0 ? _a : "";
        message.sourceChannel = (_b = object.sourceChannel) !== null && _b !== void 0 ? _b : "";
        message.destinationPort = (_c = object.destinationPort) !== null && _c !== void 0 ? _c : "";
        message.destinationChannel = (_d = object.destinationChannel) !== null && _d !== void 0 ? _d : "";
        message.data = (_e = object.data) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromPartial(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? long_1.default.fromValue(object.timeoutTimestamp) : long_1.default.UZERO;
        return message;
      }
    };
    function createBasePacketState() {
      return { portId: "", channelId: "", sequence: long_1.default.UZERO, data: new Uint8Array() };
    }
    exports2.PacketState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO,
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePacketState();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseAcknowledgement() {
      return { result: void 0, error: void 0 };
    }
    exports2.Acknowledgement = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          result: isSet(object.result) ? bytesFromBase64(object.result) : void 0,
          error: isSet(object.error) ? String(object.error) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? base64FromBytes(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseAcknowledgement();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : void 0;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/tx.js
var require_tx8 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgAcknowledgementResponse = exports2.MsgAcknowledgement = exports2.MsgTimeoutOnCloseResponse = exports2.MsgTimeoutOnClose = exports2.MsgTimeoutResponse = exports2.MsgTimeout = exports2.MsgRecvPacketResponse = exports2.MsgRecvPacket = exports2.MsgChannelCloseConfirmResponse = exports2.MsgChannelCloseConfirm = exports2.MsgChannelCloseInitResponse = exports2.MsgChannelCloseInit = exports2.MsgChannelOpenConfirmResponse = exports2.MsgChannelOpenConfirm = exports2.MsgChannelOpenAckResponse = exports2.MsgChannelOpenAck = exports2.MsgChannelOpenTryResponse = exports2.MsgChannelOpenTry = exports2.MsgChannelOpenInitResponse = exports2.MsgChannelOpenInit = exports2.responseResultTypeToJSON = exports2.responseResultTypeFromJSON = exports2.ResponseResultType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var client_1 = require_client();
    var channel_1 = require_channel();
    exports2.protobufPackage = "ibc.core.channel.v1";
    var ResponseResultType;
    (function(ResponseResultType2) {
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_UNSPECIFIED";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_NOOP"] = 1] = "RESPONSE_RESULT_NOOP";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_SUCCESS"] = 2] = "RESPONSE_RESULT_SUCCESS";
      ResponseResultType2[ResponseResultType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseResultType = exports2.ResponseResultType || (exports2.ResponseResultType = {}));
    function responseResultTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RESPONSE_RESULT_UNSPECIFIED":
          return ResponseResultType.RESPONSE_RESULT_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_NOOP":
          return ResponseResultType.RESPONSE_RESULT_NOOP;
        case 2:
        case "RESPONSE_RESULT_SUCCESS":
          return ResponseResultType.RESPONSE_RESULT_SUCCESS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseResultType.UNRECOGNIZED;
      }
    }
    exports2.responseResultTypeFromJSON = responseResultTypeFromJSON;
    function responseResultTypeToJSON(object) {
      switch (object) {
        case ResponseResultType.RESPONSE_RESULT_UNSPECIFIED:
          return "RESPONSE_RESULT_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_NOOP:
          return "RESPONSE_RESULT_NOOP";
        case ResponseResultType.RESPONSE_RESULT_SUCCESS:
          return "RESPONSE_RESULT_SUCCESS";
        case ResponseResultType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseResultTypeToJSON = responseResultTypeToJSON;
    function createBaseMsgChannelOpenInit() {
      return { portId: "", channel: void 0, signer: "" };
    }
    exports2.MsgChannelOpenInit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgChannelOpenInit();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgChannelOpenInitResponse() {
      return { channelId: "" };
    }
    exports2.MsgChannelOpenInitResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.channelId !== "") {
          writer.uint32(10).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { channelId: isSet(object.channelId) ? String(object.channelId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgChannelOpenInitResponse();
        message.channelId = (_a = object.channelId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTry() {
      return {
        portId: "",
        previousChannelId: "",
        channel: void 0,
        counterpartyVersion: "",
        proofInit: new Uint8Array(),
        proofHeight: void 0,
        signer: ""
      };
    }
    exports2.MsgChannelOpenTry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.previousChannelId !== "") {
          writer.uint32(18).string(message.previousChannelId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(42).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.previousChannelId = reader.string();
              break;
            case 3:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofInit = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          previousChannelId: isSet(object.previousChannelId) ? String(object.previousChannelId) : "",
          channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : void 0,
          counterpartyVersion: isSet(object.counterpartyVersion) ? String(object.counterpartyVersion) : "",
          proofInit: isSet(object.proofInit) ? bytesFromBase64(object.proofInit) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.previousChannelId !== void 0 && (obj.previousChannelId = message.previousChannelId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== void 0 && (obj.proofInit = base64FromBytes(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgChannelOpenTry();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.previousChannelId = (_b = object.previousChannelId) !== null && _b !== void 0 ? _b : "";
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : void 0;
        message.counterpartyVersion = (_c = object.counterpartyVersion) !== null && _c !== void 0 ? _c : "";
        message.proofInit = (_d = object.proofInit) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_e = object.signer) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTryResponse() {
      return {};
    }
    exports2.MsgChannelOpenTryResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenTryResponse();
        return message;
      }
    };
    function createBaseMsgChannelOpenAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelId: "",
        counterpartyVersion: "",
        proofTry: new Uint8Array(),
        proofHeight: void 0,
        signer: ""
      };
    }
    exports2.MsgChannelOpenAck = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelId !== "") {
          writer.uint32(26).string(message.counterpartyChannelId);
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(42).bytes(message.proofTry);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelId = reader.string();
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofTry = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          counterpartyChannelId: isSet(object.counterpartyChannelId) ? String(object.counterpartyChannelId) : "",
          counterpartyVersion: isSet(object.counterpartyVersion) ? String(object.counterpartyVersion) : "",
          proofTry: isSet(object.proofTry) ? bytesFromBase64(object.proofTry) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== void 0 && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== void 0 && (obj.proofTry = base64FromBytes(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgChannelOpenAck();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.counterpartyChannelId = (_c = object.counterpartyChannelId) !== null && _c !== void 0 ? _c : "";
        message.counterpartyVersion = (_d = object.counterpartyVersion) !== null && _d !== void 0 ? _d : "";
        message.proofTry = (_e = object.proofTry) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAckResponse() {
      return {};
    }
    exports2.MsgChannelOpenAckResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirm() {
      return { portId: "", channelId: "", proofAck: new Uint8Array(), proofHeight: void 0, signer: "" };
    }
    exports2.MsgChannelOpenConfirm = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(26).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofAck = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          proofAck: isSet(object.proofAck) ? bytesFromBase64(object.proofAck) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofAck !== void 0 && (obj.proofAck = base64FromBytes(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgChannelOpenConfirm();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.proofAck = (_c = object.proofAck) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirmResponse() {
      return {};
    }
    exports2.MsgChannelOpenConfirmResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseInit() {
      return { portId: "", channelId: "", signer: "" };
    }
    exports2.MsgChannelCloseInit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgChannelCloseInit();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgChannelCloseInitResponse() {
      return {};
    }
    exports2.MsgChannelCloseInitResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirm() {
      return { portId: "", channelId: "", proofInit: new Uint8Array(), proofHeight: void 0, signer: "" };
    }
    exports2.MsgChannelCloseConfirm = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(26).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofInit = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          proofInit: isSet(object.proofInit) ? bytesFromBase64(object.proofInit) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofInit !== void 0 && (obj.proofInit = base64FromBytes(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgChannelCloseConfirm();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.proofInit = (_c = object.proofInit) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirmResponse() {
      return {};
    }
    exports2.MsgChannelCloseConfirmResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
      }
    };
    function createBaseMsgRecvPacket() {
      return { packet: void 0, proofCommitment: new Uint8Array(), proofHeight: void 0, signer: "" };
    }
    exports2.MsgRecvPacket = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofCommitment.length !== 0) {
          writer.uint32(18).bytes(message.proofCommitment);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofCommitment = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : void 0,
          proofCommitment: isSet(object.proofCommitment) ? bytesFromBase64(object.proofCommitment) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofCommitment !== void 0 && (obj.proofCommitment = base64FromBytes(message.proofCommitment !== void 0 ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRecvPacket();
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.proofCommitment = (_a = object.proofCommitment) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgRecvPacketResponse() {
      return { result: 0 };
    }
    exports2.MsgRecvPacketResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgRecvPacketResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseMsgTimeout() {
      return {
        packet: void 0,
        proofUnreceived: new Uint8Array(),
        proofHeight: void 0,
        nextSequenceRecv: long_1.default.UZERO,
        signer: ""
      };
    }
    exports2.MsgTimeout = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (!message.nextSequenceRecv.isZero()) {
          writer.uint32(32).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : void 0,
          proofUnreceived: isSet(object.proofUnreceived) ? bytesFromBase64(object.proofUnreceived) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          nextSequenceRecv: isSet(object.nextSequenceRecv) ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgTimeout();
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.proofUnreceived = (_a = object.proofUnreceived) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.nextSequenceRecv = object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgTimeoutResponse() {
      return { result: 0 };
    }
    exports2.MsgTimeoutResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgTimeoutResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseMsgTimeoutOnClose() {
      return {
        packet: void 0,
        proofUnreceived: new Uint8Array(),
        proofClose: new Uint8Array(),
        proofHeight: void 0,
        nextSequenceRecv: long_1.default.UZERO,
        signer: ""
      };
    }
    exports2.MsgTimeoutOnClose = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofClose.length !== 0) {
          writer.uint32(26).bytes(message.proofClose);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (!message.nextSequenceRecv.isZero()) {
          writer.uint32(40).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofClose = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : void 0,
          proofUnreceived: isSet(object.proofUnreceived) ? bytesFromBase64(object.proofUnreceived) : new Uint8Array(),
          proofClose: isSet(object.proofClose) ? bytesFromBase64(object.proofClose) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          nextSequenceRecv: isSet(object.nextSequenceRecv) ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== void 0 && (obj.proofClose = base64FromBytes(message.proofClose !== void 0 ? message.proofClose : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgTimeoutOnClose();
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.proofUnreceived = (_a = object.proofUnreceived) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofClose = (_b = object.proofClose) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.nextSequenceRecv = object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgTimeoutOnCloseResponse() {
      return { result: 0 };
    }
    exports2.MsgTimeoutOnCloseResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseMsgAcknowledgement() {
      return {
        packet: void 0,
        acknowledgement: new Uint8Array(),
        proofAcked: new Uint8Array(),
        proofHeight: void 0,
        signer: ""
      };
    }
    exports2.MsgAcknowledgement = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
          writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proofAcked.length !== 0) {
          writer.uint32(26).bytes(message.proofAcked);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.acknowledgement = reader.bytes();
              break;
            case 3:
              message.proofAcked = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : void 0,
          acknowledgement: isSet(object.acknowledgement) ? bytesFromBase64(object.acknowledgement) : new Uint8Array(),
          proofAcked: isSet(object.proofAcked) ? bytesFromBase64(object.proofAcked) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.acknowledgement !== void 0 && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== void 0 && (obj.proofAcked = base64FromBytes(message.proofAcked !== void 0 ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgAcknowledgement();
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.acknowledgement = (_a = object.acknowledgement) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofAcked = (_b = object.proofAcked) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgAcknowledgementResponse() {
      return { result: 0 };
    }
    exports2.MsgAcknowledgementResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgAcknowledgementResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
      }
      ChannelOpenInit(request) {
        const data = exports2.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data);
        return promise.then((data2) => exports2.MsgChannelOpenInitResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelOpenTry(request) {
        const data = exports2.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data);
        return promise.then((data2) => exports2.MsgChannelOpenTryResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelOpenAck(request) {
        const data = exports2.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data);
        return promise.then((data2) => exports2.MsgChannelOpenAckResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelOpenConfirm(request) {
        const data = exports2.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data);
        return promise.then((data2) => exports2.MsgChannelOpenConfirmResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelCloseInit(request) {
        const data = exports2.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data);
        return promise.then((data2) => exports2.MsgChannelCloseInitResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelCloseConfirm(request) {
        const data = exports2.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data);
        return promise.then((data2) => exports2.MsgChannelCloseConfirmResponse.decode(new minimal_1.default.Reader(data2)));
      }
      RecvPacket(request) {
        const data = exports2.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data);
        return promise.then((data2) => exports2.MsgRecvPacketResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Timeout(request) {
        const data = exports2.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data);
        return promise.then((data2) => exports2.MsgTimeoutResponse.decode(new minimal_1.default.Reader(data2)));
      }
      TimeoutOnClose(request) {
        const data = exports2.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data);
        return promise.then((data2) => exports2.MsgTimeoutOnCloseResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Acknowledgement(request) {
        const data = exports2.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data);
        return promise.then((data2) => exports2.MsgAcknowledgementResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/client/v1/tx.js
var require_tx9 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/client/v1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgSubmitMisbehaviourResponse = exports2.MsgSubmitMisbehaviour = exports2.MsgUpgradeClientResponse = exports2.MsgUpgradeClient = exports2.MsgUpdateClientResponse = exports2.MsgUpdateClient = exports2.MsgCreateClientResponse = exports2.MsgCreateClient = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseMsgCreateClient() {
      return { clientState: void 0, consensusState: void 0, signer: "" };
    }
    exports2.MsgCreateClient = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientState: isSet(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0,
          consensusState: isSet(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCreateClient();
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseMsgCreateClientResponse() {
      return {};
    }
    exports2.MsgCreateClientResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpdateClient() {
      return { clientId: "", header: void 0, signer: "" };
    }
    exports2.MsgUpdateClient = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header !== void 0) {
          any_1.Any.encode(message.header, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          header: isSet(object.header) ? any_1.Any.fromJSON(object.header) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header !== void 0 && (obj.header = message.header ? any_1.Any.toJSON(message.header) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgUpdateClient();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.header = object.header !== void 0 && object.header !== null ? any_1.Any.fromPartial(object.header) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgUpdateClientResponse() {
      return {};
    }
    exports2.MsgUpdateClientResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpgradeClient() {
      return {
        clientId: "",
        clientState: void 0,
        consensusState: void 0,
        proofUpgradeClient: new Uint8Array(),
        proofUpgradeConsensusState: new Uint8Array(),
        signer: ""
      };
    }
    exports2.MsgUpgradeClient = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofUpgradeClient.length !== 0) {
          writer.uint32(34).bytes(message.proofUpgradeClient);
        }
        if (message.proofUpgradeConsensusState.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofUpgradeClient = reader.bytes();
              break;
            case 5:
              message.proofUpgradeConsensusState = reader.bytes();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          clientState: isSet(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0,
          consensusState: isSet(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0,
          proofUpgradeClient: isSet(object.proofUpgradeClient) ? bytesFromBase64(object.proofUpgradeClient) : new Uint8Array(),
          proofUpgradeConsensusState: isSet(object.proofUpgradeConsensusState) ? bytesFromBase64(object.proofUpgradeConsensusState) : new Uint8Array(),
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proofUpgradeClient !== void 0 && (obj.proofUpgradeClient = base64FromBytes(message.proofUpgradeClient !== void 0 ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== void 0 && (obj.proofUpgradeConsensusState = base64FromBytes(message.proofUpgradeConsensusState !== void 0 ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgUpgradeClient();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.proofUpgradeClient = (_b = object.proofUpgradeClient) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofUpgradeConsensusState = (_c = object.proofUpgradeConsensusState) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgUpgradeClientResponse() {
      return {};
    }
    exports2.MsgUpgradeClientResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviour() {
      return { clientId: "", misbehaviour: void 0, signer: "" };
    }
    exports2.MsgSubmitMisbehaviour = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.misbehaviour !== void 0) {
          any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          misbehaviour: isSet(object.misbehaviour) ? any_1.Any.fromJSON(object.misbehaviour) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.misbehaviour !== void 0 && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSubmitMisbehaviour();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.misbehaviour = object.misbehaviour !== void 0 && object.misbehaviour !== null ? any_1.Any.fromPartial(object.misbehaviour) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviourResponse() {
      return {};
    }
    exports2.MsgSubmitMisbehaviourResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
      }
      CreateClient(request) {
        const data = exports2.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data);
        return promise.then((data2) => exports2.MsgCreateClientResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpdateClient(request) {
        const data = exports2.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data);
        return promise.then((data2) => exports2.MsgUpdateClientResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpgradeClient(request) {
        const data = exports2.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data);
        return promise.then((data2) => exports2.MsgUpgradeClientResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SubmitMisbehaviour(request) {
        const data = exports2.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data);
        return promise.then((data2) => exports2.MsgSubmitMisbehaviourResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/confio/proofs.js
var require_proofs2 = __commonJS({
  "../../node_modules/cosmjs-types/confio/proofs.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressedNonExistenceProof = exports2.CompressedExistenceProof = exports2.CompressedBatchEntry = exports2.CompressedBatchProof = exports2.BatchEntry = exports2.BatchProof = exports2.InnerSpec = exports2.ProofSpec = exports2.InnerOp = exports2.LeafOp = exports2.CommitmentProof = exports2.NonExistenceProof = exports2.ExistenceProof = exports2.lengthOpToJSON = exports2.lengthOpFromJSON = exports2.LengthOp = exports2.hashOpToJSON = exports2.hashOpFromJSON = exports2.HashOp = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "ics23";
    var HashOp;
    (function(HashOp2) {
      HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
      HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
      HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
      HashOp2[HashOp2["KECCAK"] = 3] = "KECCAK";
      HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
      HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
      HashOp2[HashOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashOp = exports2.HashOp || (exports2.HashOp = {}));
    function hashOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_HASH":
          return HashOp.NO_HASH;
        case 1:
        case "SHA256":
          return HashOp.SHA256;
        case 2:
        case "SHA512":
          return HashOp.SHA512;
        case 3:
        case "KECCAK":
          return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
          return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
          return HashOp.BITCOIN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return HashOp.UNRECOGNIZED;
      }
    }
    exports2.hashOpFromJSON = hashOpFromJSON;
    function hashOpToJSON(object) {
      switch (object) {
        case HashOp.NO_HASH:
          return "NO_HASH";
        case HashOp.SHA256:
          return "SHA256";
        case HashOp.SHA512:
          return "SHA512";
        case HashOp.KECCAK:
          return "KECCAK";
        case HashOp.RIPEMD160:
          return "RIPEMD160";
        case HashOp.BITCOIN:
          return "BITCOIN";
        case HashOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.hashOpToJSON = hashOpToJSON;
    var LengthOp;
    (function(LengthOp2) {
      LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
      LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
      LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
      LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
      LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
      LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
      LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
      LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
      LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
      LengthOp2[LengthOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LengthOp = exports2.LengthOp || (exports2.LengthOp = {}));
    function lengthOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_PREFIX":
          return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
          return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
          return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
          return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
          return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
          return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
          return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
          return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
          return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return LengthOp.UNRECOGNIZED;
      }
    }
    exports2.lengthOpFromJSON = lengthOpFromJSON;
    function lengthOpToJSON(object) {
      switch (object) {
        case LengthOp.NO_PREFIX:
          return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
          return "VAR_PROTO";
        case LengthOp.VAR_RLP:
          return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
          return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
          return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
          return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
          return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
          return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
          return "REQUIRE_64_BYTES";
        case LengthOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.lengthOpToJSON = lengthOpToJSON;
    function createBaseExistenceProof() {
      return { key: new Uint8Array(), value: new Uint8Array(), leaf: void 0, path: [] };
    }
    exports2.ExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports2.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.path) {
          exports2.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports2.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              message.path.push(exports2.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),
          leaf: isSet(object.leaf) ? exports2.LeafOp.fromJSON(object.leaf) : void 0,
          path: Array.isArray(object === null || object === void 0 ? void 0 : object.path) ? object.path.map((e) => exports2.InnerOp.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports2.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e ? exports2.InnerOp.toJSON(e) : void 0);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseExistenceProof();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.leaf = object.leaf !== void 0 && object.leaf !== null ? exports2.LeafOp.fromPartial(object.leaf) : void 0;
        message.path = ((_c = object.path) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseNonExistenceProof() {
      return { key: new Uint8Array(), left: void 0, right: void 0 };
    }
    exports2.NonExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports2.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports2.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          left: isSet(object.left) ? exports2.ExistenceProof.fromJSON(object.left) : void 0,
          right: isSet(object.right) ? exports2.ExistenceProof.fromJSON(object.right) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports2.ExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports2.ExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseNonExistenceProof();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.left = object.left !== void 0 && object.left !== null ? exports2.ExistenceProof.fromPartial(object.left) : void 0;
        message.right = object.right !== void 0 && object.right !== null ? exports2.ExistenceProof.fromPartial(object.right) : void 0;
        return message;
      }
    };
    function createBaseCommitmentProof() {
      return { exist: void 0, nonexist: void 0, batch: void 0, compressed: void 0 };
    }
    exports2.CommitmentProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exist !== void 0) {
          exports2.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports2.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        if (message.batch !== void 0) {
          exports2.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        }
        if (message.compressed !== void 0) {
          exports2.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitmentProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports2.NonExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.batch = exports2.BatchProof.decode(reader, reader.uint32());
              break;
            case 4:
              message.compressed = exports2.CompressedBatchProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          exist: isSet(object.exist) ? exports2.ExistenceProof.fromJSON(object.exist) : void 0,
          nonexist: isSet(object.nonexist) ? exports2.NonExistenceProof.fromJSON(object.nonexist) : void 0,
          batch: isSet(object.batch) ? exports2.BatchProof.fromJSON(object.batch) : void 0,
          compressed: isSet(object.compressed) ? exports2.CompressedBatchProof.fromJSON(object.compressed) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports2.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports2.NonExistenceProof.toJSON(message.nonexist) : void 0);
        message.batch !== void 0 && (obj.batch = message.batch ? exports2.BatchProof.toJSON(message.batch) : void 0);
        message.compressed !== void 0 && (obj.compressed = message.compressed ? exports2.CompressedBatchProof.toJSON(message.compressed) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitmentProof();
        message.exist = object.exist !== void 0 && object.exist !== null ? exports2.ExistenceProof.fromPartial(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports2.NonExistenceProof.fromPartial(object.nonexist) : void 0;
        message.batch = object.batch !== void 0 && object.batch !== null ? exports2.BatchProof.fromPartial(object.batch) : void 0;
        message.compressed = object.compressed !== void 0 && object.compressed !== null ? exports2.CompressedBatchProof.fromPartial(object.compressed) : void 0;
        return message;
      }
    };
    function createBaseLeafOp() {
      return { hash: 0, prehashKey: 0, prehashValue: 0, length: 0, prefix: new Uint8Array() };
    }
    exports2.LeafOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prehashKey !== 0) {
          writer.uint32(16).int32(message.prehashKey);
        }
        if (message.prehashValue !== 0) {
          writer.uint32(24).int32(message.prehashValue);
        }
        if (message.length !== 0) {
          writer.uint32(32).int32(message.length);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(42).bytes(message.prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeafOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prehashKey = reader.int32();
              break;
            case 3:
              message.prehashValue = reader.int32();
              break;
            case 4:
              message.length = reader.int32();
              break;
            case 5:
              message.prefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          hash: isSet(object.hash) ? hashOpFromJSON(object.hash) : 0,
          prehashKey: isSet(object.prehashKey) ? hashOpFromJSON(object.prehashKey) : 0,
          prehashValue: isSet(object.prehashValue) ? hashOpFromJSON(object.prehashValue) : 0,
          length: isSet(object.length) ? lengthOpFromJSON(object.length) : 0,
          prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== void 0 && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== void 0 && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== void 0 && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== void 0 && (obj.prefix = base64FromBytes(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseLeafOp();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : 0;
        message.prehashKey = (_b = object.prehashKey) !== null && _b !== void 0 ? _b : 0;
        message.prehashValue = (_c = object.prehashValue) !== null && _c !== void 0 ? _c : 0;
        message.length = (_d = object.length) !== null && _d !== void 0 ? _d : 0;
        message.prefix = (_e = object.prefix) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
      }
    };
    function createBaseInnerOp() {
      return { hash: 0, prefix: new Uint8Array(), suffix: new Uint8Array() };
    }
    exports2.InnerOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(18).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
          writer.uint32(26).bytes(message.suffix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prefix = reader.bytes();
              break;
            case 3:
              message.suffix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          hash: isSet(object.hash) ? hashOpFromJSON(object.hash) : 0,
          prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : new Uint8Array(),
          suffix: isSet(object.suffix) ? bytesFromBase64(object.suffix) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== void 0 && (obj.prefix = base64FromBytes(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        message.suffix !== void 0 && (obj.suffix = base64FromBytes(message.suffix !== void 0 ? message.suffix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseInnerOp();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : 0;
        message.prefix = (_b = object.prefix) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.suffix = (_c = object.suffix) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseProofSpec() {
      return { leafSpec: void 0, innerSpec: void 0, maxDepth: 0, minDepth: 0 };
    }
    exports2.ProofSpec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.leafSpec !== void 0) {
          exports2.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.innerSpec !== void 0) {
          exports2.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxDepth !== 0) {
          writer.uint32(24).int32(message.maxDepth);
        }
        if (message.minDepth !== 0) {
          writer.uint32(32).int32(message.minDepth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.leafSpec = exports2.LeafOp.decode(reader, reader.uint32());
              break;
            case 2:
              message.innerSpec = exports2.InnerSpec.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxDepth = reader.int32();
              break;
            case 4:
              message.minDepth = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          leafSpec: isSet(object.leafSpec) ? exports2.LeafOp.fromJSON(object.leafSpec) : void 0,
          innerSpec: isSet(object.innerSpec) ? exports2.InnerSpec.fromJSON(object.innerSpec) : void 0,
          maxDepth: isSet(object.maxDepth) ? Number(object.maxDepth) : 0,
          minDepth: isSet(object.minDepth) ? Number(object.minDepth) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.leafSpec !== void 0 && (obj.leafSpec = message.leafSpec ? exports2.LeafOp.toJSON(message.leafSpec) : void 0);
        message.innerSpec !== void 0 && (obj.innerSpec = message.innerSpec ? exports2.InnerSpec.toJSON(message.innerSpec) : void 0);
        message.maxDepth !== void 0 && (obj.maxDepth = Math.round(message.maxDepth));
        message.minDepth !== void 0 && (obj.minDepth = Math.round(message.minDepth));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseProofSpec();
        message.leafSpec = object.leafSpec !== void 0 && object.leafSpec !== null ? exports2.LeafOp.fromPartial(object.leafSpec) : void 0;
        message.innerSpec = object.innerSpec !== void 0 && object.innerSpec !== null ? exports2.InnerSpec.fromPartial(object.innerSpec) : void 0;
        message.maxDepth = (_a = object.maxDepth) !== null && _a !== void 0 ? _a : 0;
        message.minDepth = (_b = object.minDepth) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseInnerSpec() {
      return {
        childOrder: [],
        childSize: 0,
        minPrefixLength: 0,
        maxPrefixLength: 0,
        emptyChild: new Uint8Array(),
        hash: 0
      };
    }
    exports2.InnerSpec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.childOrder) {
          writer.int32(v);
        }
        writer.ldelim();
        if (message.childSize !== 0) {
          writer.uint32(16).int32(message.childSize);
        }
        if (message.minPrefixLength !== 0) {
          writer.uint32(24).int32(message.minPrefixLength);
        }
        if (message.maxPrefixLength !== 0) {
          writer.uint32(32).int32(message.maxPrefixLength);
        }
        if (message.emptyChild.length !== 0) {
          writer.uint32(42).bytes(message.emptyChild);
        }
        if (message.hash !== 0) {
          writer.uint32(48).int32(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.childOrder.push(reader.int32());
                }
              } else {
                message.childOrder.push(reader.int32());
              }
              break;
            case 2:
              message.childSize = reader.int32();
              break;
            case 3:
              message.minPrefixLength = reader.int32();
              break;
            case 4:
              message.maxPrefixLength = reader.int32();
              break;
            case 5:
              message.emptyChild = reader.bytes();
              break;
            case 6:
              message.hash = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          childOrder: Array.isArray(object === null || object === void 0 ? void 0 : object.childOrder) ? object.childOrder.map((e) => Number(e)) : [],
          childSize: isSet(object.childSize) ? Number(object.childSize) : 0,
          minPrefixLength: isSet(object.minPrefixLength) ? Number(object.minPrefixLength) : 0,
          maxPrefixLength: isSet(object.maxPrefixLength) ? Number(object.maxPrefixLength) : 0,
          emptyChild: isSet(object.emptyChild) ? bytesFromBase64(object.emptyChild) : new Uint8Array(),
          hash: isSet(object.hash) ? hashOpFromJSON(object.hash) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.childOrder) {
          obj.childOrder = message.childOrder.map((e) => Math.round(e));
        } else {
          obj.childOrder = [];
        }
        message.childSize !== void 0 && (obj.childSize = Math.round(message.childSize));
        message.minPrefixLength !== void 0 && (obj.minPrefixLength = Math.round(message.minPrefixLength));
        message.maxPrefixLength !== void 0 && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));
        message.emptyChild !== void 0 && (obj.emptyChild = base64FromBytes(message.emptyChild !== void 0 ? message.emptyChild : new Uint8Array()));
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseInnerSpec();
        message.childOrder = ((_a = object.childOrder) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.childSize = (_b = object.childSize) !== null && _b !== void 0 ? _b : 0;
        message.minPrefixLength = (_c = object.minPrefixLength) !== null && _c !== void 0 ? _c : 0;
        message.maxPrefixLength = (_d = object.maxPrefixLength) !== null && _d !== void 0 ? _d : 0;
        message.emptyChild = (_e = object.emptyChild) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.hash = (_f = object.hash) !== null && _f !== void 0 ? _f : 0;
        return message;
      }
    };
    function createBaseBatchProof() {
      return { entries: [] };
    }
    exports2.BatchProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
          exports2.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports2.BatchEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.BatchEntry.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.BatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseBatchProof();
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.BatchEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseBatchEntry() {
      return { exist: void 0, nonexist: void 0 };
    }
    exports2.BatchEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exist !== void 0) {
          exports2.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports2.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports2.NonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          exist: isSet(object.exist) ? exports2.ExistenceProof.fromJSON(object.exist) : void 0,
          nonexist: isSet(object.nonexist) ? exports2.NonExistenceProof.fromJSON(object.nonexist) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports2.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports2.NonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchEntry();
        message.exist = object.exist !== void 0 && object.exist !== null ? exports2.ExistenceProof.fromPartial(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports2.NonExistenceProof.fromPartial(object.nonexist) : void 0;
        return message;
      }
    };
    function createBaseCompressedBatchProof() {
      return { entries: [], lookupInners: [] };
    }
    exports2.CompressedBatchProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
          exports2.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.lookupInners) {
          exports2.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports2.CompressedBatchEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.lookupInners.push(exports2.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.CompressedBatchEntry.fromJSON(e)) : [],
          lookupInners: Array.isArray(object === null || object === void 0 ? void 0 : object.lookupInners) ? object.lookupInners.map((e) => exports2.InnerOp.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.CompressedBatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        if (message.lookupInners) {
          obj.lookupInners = message.lookupInners.map((e) => e ? exports2.InnerOp.toJSON(e) : void 0);
        } else {
          obj.lookupInners = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCompressedBatchProof();
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.CompressedBatchEntry.fromPartial(e))) || [];
        message.lookupInners = ((_b = object.lookupInners) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCompressedBatchEntry() {
      return { exist: void 0, nonexist: void 0 };
    }
    exports2.CompressedBatchEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exist !== void 0) {
          exports2.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports2.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports2.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports2.CompressedNonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          exist: isSet(object.exist) ? exports2.CompressedExistenceProof.fromJSON(object.exist) : void 0,
          nonexist: isSet(object.nonexist) ? exports2.CompressedNonExistenceProof.fromJSON(object.nonexist) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports2.CompressedExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports2.CompressedNonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchEntry();
        message.exist = object.exist !== void 0 && object.exist !== null ? exports2.CompressedExistenceProof.fromPartial(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports2.CompressedNonExistenceProof.fromPartial(object.nonexist) : void 0;
        return message;
      }
    };
    function createBaseCompressedExistenceProof() {
      return { key: new Uint8Array(), value: new Uint8Array(), leaf: void 0, path: [] };
    }
    exports2.CompressedExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports2.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.path) {
          writer.int32(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports2.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.path.push(reader.int32());
                }
              } else {
                message.path.push(reader.int32());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),
          leaf: isSet(object.leaf) ? exports2.LeafOp.fromJSON(object.leaf) : void 0,
          path: Array.isArray(object === null || object === void 0 ? void 0 : object.path) ? object.path.map((e) => Number(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports2.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => Math.round(e));
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCompressedExistenceProof();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.leaf = object.leaf !== void 0 && object.leaf !== null ? exports2.LeafOp.fromPartial(object.leaf) : void 0;
        message.path = ((_c = object.path) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompressedNonExistenceProof() {
      return { key: new Uint8Array(), left: void 0, right: void 0 };
    }
    exports2.CompressedNonExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports2.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports2.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports2.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports2.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          left: isSet(object.left) ? exports2.CompressedExistenceProof.fromJSON(object.left) : void 0,
          right: isSet(object.right) ? exports2.CompressedExistenceProof.fromJSON(object.right) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports2.CompressedExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports2.CompressedExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseCompressedNonExistenceProof();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.left = object.left !== void 0 && object.left !== null ? exports2.CompressedExistenceProof.fromPartial(object.left) : void 0;
        message.right = object.right !== void 0 && object.right !== null ? exports2.CompressedExistenceProof.fromPartial(object.right) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js
var require_commitment = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MerkleProof = exports2.MerklePath = exports2.MerklePrefix = exports2.MerkleRoot = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var proofs_1 = require_proofs2();
    exports2.protobufPackage = "ibc.core.commitment.v1";
    function createBaseMerkleRoot() {
      return { hash: new Uint8Array() };
    }
    exports2.MerkleRoot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMerkleRoot();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePrefix() {
      return { keyPrefix: new Uint8Array() };
    }
    exports2.MerklePrefix = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.keyPrefix.length !== 0) {
          writer.uint32(10).bytes(message.keyPrefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPrefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { keyPrefix: isSet(object.keyPrefix) ? bytesFromBase64(object.keyPrefix) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.keyPrefix !== void 0 && (obj.keyPrefix = base64FromBytes(message.keyPrefix !== void 0 ? message.keyPrefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMerklePrefix();
        message.keyPrefix = (_a = object.keyPrefix) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePath() {
      return { keyPath: [] };
    }
    exports2.MerklePath = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.keyPath) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPath.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { keyPath: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPath) ? object.keyPath.map((e) => String(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.keyPath) {
          obj.keyPath = message.keyPath.map((e) => e);
        } else {
          obj.keyPath = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMerklePath();
        message.keyPath = ((_a = object.keyPath) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMerkleProof() {
      return { proofs: [] };
    }
    exports2.MerkleProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.proofs) {
          proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proofs: Array.isArray(object === null || object === void 0 ? void 0 : object.proofs) ? object.proofs.map((e) => proofs_1.CommitmentProof.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.proofs) {
          obj.proofs = message.proofs.map((e) => e ? proofs_1.CommitmentProof.toJSON(e) : void 0);
        } else {
          obj.proofs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMerkleProof();
        message.proofs = ((_a = object.proofs) === null || _a === void 0 ? void 0 : _a.map((e) => proofs_1.CommitmentProof.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/connection/v1/connection.js
var require_connection = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/connection/v1/connection.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Version = exports2.ConnectionPaths = exports2.ClientPaths = exports2.Counterparty = exports2.IdentifiedConnection = exports2.ConnectionEnd = exports2.stateToJSON = exports2.stateFromJSON = exports2.State = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var commitment_1 = require_commitment();
    exports2.protobufPackage = "ibc.core.connection.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State = exports2.State || (exports2.State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports2.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.stateToJSON = stateToJSON;
    function createBaseConnectionEnd() {
      return { clientId: "", versions: [], state: 0, counterparty: void 0, delayPeriod: long_1.default.UZERO };
    }
    exports2.ConnectionEnd = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.versions) {
          exports2.Version.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.versions.push(exports2.Version.decode(reader, reader.uint32()));
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          versions: Array.isArray(object === null || object === void 0 ? void 0 : object.versions) ? object.versions.map((e) => exports2.Version.fromJSON(e)) : [],
          state: isSet(object.state) ? stateFromJSON(object.state) : 0,
          counterparty: isSet(object.counterparty) ? exports2.Counterparty.fromJSON(object.counterparty) : void 0,
          delayPeriod: isSet(object.delayPeriod) ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports2.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseConnectionEnd();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.versions = ((_b = object.versions) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.Version.fromPartial(e))) || [];
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports2.Counterparty.fromPartial(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseIdentifiedConnection() {
      return { id: "", clientId: "", versions: [], state: 0, counterparty: void 0, delayPeriod: long_1.default.UZERO };
    }
    exports2.IdentifiedConnection = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        for (const v of message.versions) {
          exports2.Version.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(48).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.versions.push(exports2.Version.decode(reader, reader.uint32()));
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 6:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet(object.id) ? String(object.id) : "",
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          versions: Array.isArray(object === null || object === void 0 ? void 0 : object.versions) ? object.versions.map((e) => exports2.Version.fromJSON(e)) : [],
          state: isSet(object.state) ? stateFromJSON(object.state) : 0,
          counterparty: isSet(object.counterparty) ? exports2.Counterparty.fromJSON(object.counterparty) : void 0,
          delayPeriod: isSet(object.delayPeriod) ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports2.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseIdentifiedConnection();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.clientId = (_b = object.clientId) !== null && _b !== void 0 ? _b : "";
        message.versions = ((_c = object.versions) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.Version.fromPartial(e))) || [];
        message.state = (_d = object.state) !== null && _d !== void 0 ? _d : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports2.Counterparty.fromPartial(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseCounterparty() {
      return { clientId: "", connectionId: "", prefix: void 0 };
    }
    exports2.Counterparty = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.prefix !== void 0) {
          commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.connectionId = reader.string();
              break;
            case 3:
              message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          connectionId: isSet(object.connectionId) ? String(object.connectionId) : "",
          prefix: isSet(object.prefix) ? commitment_1.MerklePrefix.fromJSON(object.prefix) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.prefix !== void 0 && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCounterparty();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.connectionId = (_b = object.connectionId) !== null && _b !== void 0 ? _b : "";
        message.prefix = object.prefix !== void 0 && object.prefix !== null ? commitment_1.MerklePrefix.fromPartial(object.prefix) : void 0;
        return message;
      }
    };
    function createBaseClientPaths() {
      return { paths: [] };
    }
    exports2.ClientPaths = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.paths) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { paths: Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map((e) => String(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseClientPaths();
        message.paths = ((_a = object.paths) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseConnectionPaths() {
      return { clientId: "", paths: [] };
    }
    exports2.ConnectionPaths = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.paths) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          paths: Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseConnectionPaths();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.paths = ((_b = object.paths) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVersion() {
      return { identifier: "", features: [] };
    }
    exports2.Version = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identifier !== "") {
          writer.uint32(10).string(message.identifier);
        }
        for (const v of message.features) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.features.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          identifier: isSet(object.identifier) ? String(object.identifier) : "",
          features: Array.isArray(object === null || object === void 0 ? void 0 : object.features) ? object.features.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.identifier !== void 0 && (obj.identifier = message.identifier);
        if (message.features) {
          obj.features = message.features.map((e) => e);
        } else {
          obj.features = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseVersion();
        message.identifier = (_a = object.identifier) !== null && _a !== void 0 ? _a : "";
        message.features = ((_b = object.features) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return { maxExpectedTimePerBlock: long_1.default.UZERO };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxExpectedTimePerBlock.isZero()) {
          writer.uint32(8).uint64(message.maxExpectedTimePerBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxExpectedTimePerBlock = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          maxExpectedTimePerBlock: isSet(object.maxExpectedTimePerBlock) ? long_1.default.fromValue(object.maxExpectedTimePerBlock) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxExpectedTimePerBlock !== void 0 && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.maxExpectedTimePerBlock = object.maxExpectedTimePerBlock !== void 0 && object.maxExpectedTimePerBlock !== null ? long_1.default.fromValue(object.maxExpectedTimePerBlock) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/connection/v1/tx.js
var require_tx10 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/connection/v1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgConnectionOpenConfirmResponse = exports2.MsgConnectionOpenConfirm = exports2.MsgConnectionOpenAckResponse = exports2.MsgConnectionOpenAck = exports2.MsgConnectionOpenTryResponse = exports2.MsgConnectionOpenTry = exports2.MsgConnectionOpenInitResponse = exports2.MsgConnectionOpenInit = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var client_1 = require_client();
    var connection_1 = require_connection();
    exports2.protobufPackage = "ibc.core.connection.v1";
    function createBaseMsgConnectionOpenInit() {
      return { clientId: "", counterparty: void 0, version: void 0, delayPeriod: long_1.default.UZERO, signer: "" };
    }
    exports2.MsgConnectionOpenInit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(32).uint64(message.delayPeriod);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.delayPeriod = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          counterparty: isSet(object.counterparty) ? connection_1.Counterparty.fromJSON(object.counterparty) : void 0,
          version: isSet(object.version) ? connection_1.Version.fromJSON(object.version) : void 0,
          delayPeriod: isSet(object.delayPeriod) ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgConnectionOpenInit();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? connection_1.Counterparty.fromPartial(object.counterparty) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? connection_1.Version.fromPartial(object.version) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenInitResponse() {
      return {};
    }
    exports2.MsgConnectionOpenInitResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTry() {
      return {
        clientId: "",
        previousConnectionId: "",
        clientState: void 0,
        counterparty: void 0,
        delayPeriod: long_1.default.UZERO,
        counterpartyVersions: [],
        proofHeight: void 0,
        proofInit: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: void 0,
        signer: ""
      };
    }
    exports2.MsgConnectionOpenTry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.previousConnectionId !== "") {
          writer.uint32(18).string(message.previousConnectionId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        for (const v of message.counterpartyVersions) {
          connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(66).bytes(message.proofInit);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(74).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(82).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(98).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.previousConnectionId = reader.string();
              break;
            case 3:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            case 6:
              message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofInit = reader.bytes();
              break;
            case 9:
              message.proofClient = reader.bytes();
              break;
            case 10:
              message.proofConsensus = reader.bytes();
              break;
            case 11:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 12:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          previousConnectionId: isSet(object.previousConnectionId) ? String(object.previousConnectionId) : "",
          clientState: isSet(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0,
          counterparty: isSet(object.counterparty) ? connection_1.Counterparty.fromJSON(object.counterparty) : void 0,
          delayPeriod: isSet(object.delayPeriod) ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO,
          counterpartyVersions: Array.isArray(object === null || object === void 0 ? void 0 : object.counterpartyVersions) ? object.counterpartyVersions.map((e) => connection_1.Version.fromJSON(e)) : [],
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          proofInit: isSet(object.proofInit) ? bytesFromBase64(object.proofInit) : new Uint8Array(),
          proofClient: isSet(object.proofClient) ? bytesFromBase64(object.proofClient) : new Uint8Array(),
          proofConsensus: isSet(object.proofConsensus) ? bytesFromBase64(object.proofConsensus) : new Uint8Array(),
          consensusHeight: isSet(object.consensusHeight) ? client_1.Height.fromJSON(object.consensusHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.previousConnectionId !== void 0 && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        if (message.counterpartyVersions) {
          obj.counterpartyVersions = message.counterpartyVersions.map((e) => e ? connection_1.Version.toJSON(e) : void 0);
        } else {
          obj.counterpartyVersions = [];
        }
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofInit !== void 0 && (obj.proofInit = base64FromBytes(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = base64FromBytes(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseMsgConnectionOpenTry();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.previousConnectionId = (_b = object.previousConnectionId) !== null && _b !== void 0 ? _b : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? connection_1.Counterparty.fromPartial(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        message.counterpartyVersions = ((_c = object.counterpartyVersions) === null || _c === void 0 ? void 0 : _c.map((e) => connection_1.Version.fromPartial(e))) || [];
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.proofInit = (_d = object.proofInit) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.proofClient = (_e = object.proofClient) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.proofConsensus = (_f = object.proofConsensus) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.consensusHeight = object.consensusHeight !== void 0 && object.consensusHeight !== null ? client_1.Height.fromPartial(object.consensusHeight) : void 0;
        message.signer = (_g = object.signer) !== null && _g !== void 0 ? _g : "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenTryResponse() {
      return {};
    }
    exports2.MsgConnectionOpenTryResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAck() {
      return {
        connectionId: "",
        counterpartyConnectionId: "",
        version: void 0,
        clientState: void 0,
        proofHeight: void 0,
        proofTry: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: void 0,
        signer: ""
      };
    }
    exports2.MsgConnectionOpenAck = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.counterpartyConnectionId !== "") {
          writer.uint32(18).string(message.counterpartyConnectionId);
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(50).bytes(message.proofTry);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(58).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(66).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(82).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.counterpartyConnectionId = reader.string();
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.proofTry = reader.bytes();
              break;
            case 7:
              message.proofClient = reader.bytes();
              break;
            case 8:
              message.proofConsensus = reader.bytes();
              break;
            case 9:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 10:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connectionId: isSet(object.connectionId) ? String(object.connectionId) : "",
          counterpartyConnectionId: isSet(object.counterpartyConnectionId) ? String(object.counterpartyConnectionId) : "",
          version: isSet(object.version) ? connection_1.Version.fromJSON(object.version) : void 0,
          clientState: isSet(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0,
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          proofTry: isSet(object.proofTry) ? bytesFromBase64(object.proofTry) : new Uint8Array(),
          proofClient: isSet(object.proofClient) ? bytesFromBase64(object.proofClient) : new Uint8Array(),
          proofConsensus: isSet(object.proofConsensus) ? bytesFromBase64(object.proofConsensus) : new Uint8Array(),
          consensusHeight: isSet(object.consensusHeight) ? client_1.Height.fromJSON(object.consensusHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== void 0 && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofTry !== void 0 && (obj.proofTry = base64FromBytes(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = base64FromBytes(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgConnectionOpenAck();
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.counterpartyConnectionId = (_b = object.counterpartyConnectionId) !== null && _b !== void 0 ? _b : "";
        message.version = object.version !== void 0 && object.version !== null ? connection_1.Version.fromPartial(object.version) : void 0;
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.proofTry = (_c = object.proofTry) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.proofClient = (_d = object.proofClient) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.proofConsensus = (_e = object.proofConsensus) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.consensusHeight = object.consensusHeight !== void 0 && object.consensusHeight !== null ? client_1.Height.fromPartial(object.consensusHeight) : void 0;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenAckResponse() {
      return {};
    }
    exports2.MsgConnectionOpenAckResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirm() {
      return { connectionId: "", proofAck: new Uint8Array(), proofHeight: void 0, signer: "" };
    }
    exports2.MsgConnectionOpenConfirm = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(18).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.proofAck = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connectionId: isSet(object.connectionId) ? String(object.connectionId) : "",
          proofAck: isSet(object.proofAck) ? bytesFromBase64(object.proofAck) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0,
          signer: isSet(object.signer) ? String(object.signer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.proofAck !== void 0 && (obj.proofAck = base64FromBytes(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConnectionOpenConfirm();
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.proofAck = (_b = object.proofAck) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirmResponse() {
      return {};
    }
    exports2.MsgConnectionOpenConfirmResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
      }
      ConnectionOpenInit(request) {
        const data = exports2.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data);
        return promise.then((data2) => exports2.MsgConnectionOpenInitResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionOpenTry(request) {
        const data = exports2.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data);
        return promise.then((data2) => exports2.MsgConnectionOpenTryResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionOpenAck(request) {
        const data = exports2.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data);
        return promise.then((data2) => exports2.MsgConnectionOpenAckResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionOpenConfirm(request) {
        const data = exports2.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data);
        return promise.then((data2) => exports2.MsgConnectionOpenConfirmResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages6 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgTransferEncodeObject = exports2.ibcTypes = void 0;
    var tx_1 = require_tx7();
    var tx_2 = require_tx8();
    var tx_3 = require_tx9();
    var tx_4 = require_tx10();
    exports2.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
    exports2.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
  }
});

// ../../node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js
var require_transfer = __commonJS({
  "../../node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.DenomTrace = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseDenomTrace() {
      return { path: "", baseDenom: "" };
    }
    exports2.DenomTrace = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.baseDenom !== "") {
          writer.uint32(18).string(message.baseDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.path = reader.string();
              break;
            case 2:
              message.baseDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          path: isSet(object.path) ? String(object.path) : "",
          baseDenom: isSet(object.baseDenom) ? String(object.baseDenom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.path !== void 0 && (obj.path = message.path);
        message.baseDenom !== void 0 && (obj.baseDenom = message.baseDenom);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDenomTrace();
        message.path = (_a = object.path) !== null && _a !== void 0 ? _a : "";
        message.baseDenom = (_b = object.baseDenom) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseParams() {
      return { sendEnabled: false, receiveEnabled: false };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sendEnabled === true) {
          writer.uint32(8).bool(message.sendEnabled);
        }
        if (message.receiveEnabled === true) {
          writer.uint32(16).bool(message.receiveEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled = reader.bool();
              break;
            case 2:
              message.receiveEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sendEnabled: isSet(object.sendEnabled) ? Boolean(object.sendEnabled) : false,
          receiveEnabled: isSet(object.receiveEnabled) ? Boolean(object.receiveEnabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.sendEnabled !== void 0 && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== void 0 && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseParams();
        message.sendEnabled = (_a = object.sendEnabled) !== null && _a !== void 0 ? _a : false;
        message.receiveEnabled = (_b = object.receiveEnabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js
var require_query7 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryDenomHashResponse = exports2.QueryDenomHashRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryDenomTracesResponse = exports2.QueryDenomTracesRequest = exports2.QueryDenomTraceResponse = exports2.QueryDenomTraceRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var transfer_1 = require_transfer();
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseQueryDenomTraceRequest() {
      return { hash: "" };
    }
    exports2.QueryDenomTraceRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { hash: isSet(object.hash) ? String(object.hash) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomTraceRequest();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDenomTraceResponse() {
      return { denomTrace: void 0 };
    }
    exports2.QueryDenomTraceResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denomTrace !== void 0) {
          transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { denomTrace: isSet(object.denomTrace) ? transfer_1.DenomTrace.fromJSON(object.denomTrace) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.denomTrace !== void 0 && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceResponse();
        message.denomTrace = object.denomTrace !== void 0 && object.denomTrace !== null ? transfer_1.DenomTrace.fromPartial(object.denomTrace) : void 0;
        return message;
      }
    };
    function createBaseQueryDenomTracesRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryDenomTracesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDenomTracesResponse() {
      return { denomTraces: [], pagination: void 0 };
    }
    exports2.QueryDenomTracesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.denomTraces) {
          transfer_1.DenomTrace.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denomTraces: Array.isArray(object === null || object === void 0 ? void 0 : object.denomTraces) ? object.denomTraces.map((e) => transfer_1.DenomTrace.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.denomTraces) {
          obj.denomTraces = message.denomTraces.map((e) => e ? transfer_1.DenomTrace.toJSON(e) : void 0);
        } else {
          obj.denomTraces = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomTracesResponse();
        message.denomTraces = ((_a = object.denomTraces) === null || _a === void 0 ? void 0 : _a.map((e) => transfer_1.DenomTrace.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = transfer_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? transfer_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? transfer_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQueryDenomHashRequest() {
      return { trace: "" };
    }
    exports2.QueryDenomHashRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.trace !== "") {
          writer.uint32(10).string(message.trace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.trace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { trace: isSet(object.trace) ? String(object.trace) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.trace !== void 0 && (obj.trace = message.trace);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomHashRequest();
        message.trace = (_a = object.trace) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryDenomHashResponse() {
      return { hash: "" };
    }
    exports2.QueryDenomHashResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { hash: isSet(object.hash) ? String(object.hash) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomHashResponse();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.DenomTrace = this.DenomTrace.bind(this);
        this.DenomTraces = this.DenomTraces.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomHash = this.DenomHash.bind(this);
      }
      DenomTrace(request) {
        const data = exports2.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data);
        return promise.then((data2) => exports2.QueryDenomTraceResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomTraces(request) {
        const data = exports2.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data);
        return promise.then((data2) => exports2.QueryDenomTracesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomHash(request) {
        const data = exports2.QueryDenomHashRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", data);
        return promise.then((data2) => exports2.QueryDenomHashResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/channel/v1/query.js
var require_query8 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/channel/v1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryNextSequenceReceiveResponse = exports2.QueryNextSequenceReceiveRequest = exports2.QueryUnreceivedAcksResponse = exports2.QueryUnreceivedAcksRequest = exports2.QueryUnreceivedPacketsResponse = exports2.QueryUnreceivedPacketsRequest = exports2.QueryPacketAcknowledgementsResponse = exports2.QueryPacketAcknowledgementsRequest = exports2.QueryPacketAcknowledgementResponse = exports2.QueryPacketAcknowledgementRequest = exports2.QueryPacketReceiptResponse = exports2.QueryPacketReceiptRequest = exports2.QueryPacketCommitmentsResponse = exports2.QueryPacketCommitmentsRequest = exports2.QueryPacketCommitmentResponse = exports2.QueryPacketCommitmentRequest = exports2.QueryChannelConsensusStateResponse = exports2.QueryChannelConsensusStateRequest = exports2.QueryChannelClientStateResponse = exports2.QueryChannelClientStateRequest = exports2.QueryConnectionChannelsResponse = exports2.QueryConnectionChannelsRequest = exports2.QueryChannelsResponse = exports2.QueryChannelsRequest = exports2.QueryChannelResponse = exports2.QueryChannelRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var client_1 = require_client();
    var channel_1 = require_channel();
    exports2.protobufPackage = "ibc.core.channel.v1";
    function createBaseQueryChannelRequest() {
      return { portId: "", channelId: "" };
    }
    exports2.QueryChannelRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryChannelRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryChannelResponse() {
      return { channel: void 0, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryChannelResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : void 0,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryChannelResponse();
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryChannelsRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryChannelsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryChannelsResponse() {
      return { channels: [], pagination: void 0, height: void 0 };
    }
    exports2.QueryChannelsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          channels: Array.isArray(object === null || object === void 0 ? void 0 : object.channels) ? object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0,
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryChannelsResponse();
        message.channels = ((_a = object.channels) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryConnectionChannelsRequest() {
      return { connection: "", pagination: void 0 };
    }
    exports2.QueryConnectionChannelsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connection !== "") {
          writer.uint32(10).string(message.connection);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connection: isSet(object.connection) ? String(object.connection) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionChannelsRequest();
        message.connection = (_a = object.connection) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryConnectionChannelsResponse() {
      return { channels: [], pagination: void 0, height: void 0 };
    }
    exports2.QueryConnectionChannelsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          channels: Array.isArray(object === null || object === void 0 ? void 0 : object.channels) ? object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0,
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionChannelsResponse();
        message.channels = ((_a = object.channels) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryChannelClientStateRequest() {
      return { portId: "", channelId: "" };
    }
    exports2.QueryChannelClientStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryChannelClientStateRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryChannelClientStateResponse() {
      return { identifiedClientState: void 0, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryChannelClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          identifiedClientState: isSet(object.identifiedClientState) ? client_1.IdentifiedClientState.fromJSON(object.identifiedClientState) : void 0,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryChannelClientStateResponse();
        message.identifiedClientState = object.identifiedClientState !== void 0 && object.identifiedClientState !== null ? client_1.IdentifiedClientState.fromPartial(object.identifiedClientState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateRequest() {
      return { portId: "", channelId: "", revisionNumber: long_1.default.UZERO, revisionHeight: long_1.default.UZERO };
    }
    exports2.QueryChannelConsensusStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.revisionNumber.isZero()) {
          writer.uint32(24).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(32).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.revisionNumber = reader.uint64();
              break;
            case 4:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          revisionNumber: isSet(object.revisionNumber) ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO,
          revisionHeight: isSet(object.revisionHeight) ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryChannelConsensusStateRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateResponse() {
      return { consensusState: void 0, clientId: "", proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryChannelConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          consensusState: isSet(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0,
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryChannelConsensusStateResponse();
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryPacketCommitmentRequest() {
      return { portId: "", channelId: "", sequence: long_1.default.UZERO };
    }
    exports2.QueryPacketCommitmentRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketCommitmentRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryPacketCommitmentResponse() {
      return { commitment: new Uint8Array(), proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryPacketCommitmentResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commitment.length !== 0) {
          writer.uint32(10).bytes(message.commitment);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitment = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(),
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.commitment !== void 0 && (obj.commitment = base64FromBytes(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketCommitmentResponse();
        message.commitment = (_a = object.commitment) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsRequest() {
      return { portId: "", channelId: "", pagination: void 0 };
    }
    exports2.QueryPacketCommitmentsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketCommitmentsRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsResponse() {
      return { commitments: [], pagination: void 0, height: void 0 };
    }
    exports2.QueryPacketCommitmentsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.commitments) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          commitments: Array.isArray(object === null || object === void 0 ? void 0 : object.commitments) ? object.commitments.map((e) => channel_1.PacketState.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0,
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.commitments) {
          obj.commitments = message.commitments.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.commitments = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPacketCommitmentsResponse();
        message.commitments = ((_a = object.commitments) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryPacketReceiptRequest() {
      return { portId: "", channelId: "", sequence: long_1.default.UZERO };
    }
    exports2.QueryPacketReceiptRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketReceiptRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryPacketReceiptResponse() {
      return { received: false, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryPacketReceiptResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.received === true) {
          writer.uint32(16).bool(message.received);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.received = reader.bool();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          received: isSet(object.received) ? Boolean(object.received) : false,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.received !== void 0 && (obj.received = message.received);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketReceiptResponse();
        message.received = (_a = object.received) !== null && _a !== void 0 ? _a : false;
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementRequest() {
      return { portId: "", channelId: "", sequence: long_1.default.UZERO };
    }
    exports2.QueryPacketAcknowledgementRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          sequence: isSet(object.sequence) ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketAcknowledgementRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementResponse() {
      return { acknowledgement: new Uint8Array(), proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryPacketAcknowledgementResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.acknowledgement.length !== 0) {
          writer.uint32(10).bytes(message.acknowledgement);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgement = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          acknowledgement: isSet(object.acknowledgement) ? bytesFromBase64(object.acknowledgement) : new Uint8Array(),
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.acknowledgement !== void 0 && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryPacketAcknowledgementResponse();
        message.acknowledgement = (_a = object.acknowledgement) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsRequest() {
      return { portId: "", channelId: "", pagination: void 0, packetCommitmentSequences: [] };
    }
    exports2.QueryPacketAcknowledgementsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0,
          packetCommitmentSequences: Array.isArray(object === null || object === void 0 ? void 0 : object.packetCommitmentSequences) ? object.packetCommitmentSequences.map((e) => long_1.default.fromValue(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        message.packetCommitmentSequences = ((_c = object.packetCommitmentSequences) === null || _c === void 0 ? void 0 : _c.map((e) => long_1.default.fromValue(e))) || [];
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsResponse() {
      return { acknowledgements: [], pagination: void 0, height: void 0 };
    }
    exports2.QueryPacketAcknowledgementsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.acknowledgements) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          acknowledgements: Array.isArray(object === null || object === void 0 ? void 0 : object.acknowledgements) ? object.acknowledgements.map((e) => channel_1.PacketState.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0,
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.acknowledgements) {
          obj.acknowledgements = message.acknowledgements.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.acknowledgements = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        message.acknowledgements = ((_a = object.acknowledgements) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsRequest() {
      return { portId: "", channelId: "", packetCommitmentSequences: [] };
    }
    exports2.QueryUnreceivedPacketsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          packetCommitmentSequences: Array.isArray(object === null || object === void 0 ? void 0 : object.packetCommitmentSequences) ? object.packetCommitmentSequences.map((e) => long_1.default.fromValue(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseQueryUnreceivedPacketsRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.packetCommitmentSequences = ((_c = object.packetCommitmentSequences) === null || _c === void 0 ? void 0 : _c.map((e) => long_1.default.fromValue(e))) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsResponse() {
      return { sequences: [], height: void 0 };
    }
    exports2.QueryUnreceivedPacketsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sequences: Array.isArray(object === null || object === void 0 ? void 0 : object.sequences) ? object.sequences.map((e) => long_1.default.fromValue(e)) : [],
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryUnreceivedPacketsResponse();
        message.sequences = ((_a = object.sequences) === null || _a === void 0 ? void 0 : _a.map((e) => long_1.default.fromValue(e))) || [];
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksRequest() {
      return { portId: "", channelId: "", packetAckSequences: [] };
    }
    exports2.QueryUnreceivedAcksRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetAckSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetAckSequences.push(reader.uint64());
                }
              } else {
                message.packetAckSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : "",
          packetAckSequences: Array.isArray(object === null || object === void 0 ? void 0 : object.packetAckSequences) ? object.packetAckSequences.map((e) => long_1.default.fromValue(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetAckSequences) {
          obj.packetAckSequences = message.packetAckSequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.packetAckSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseQueryUnreceivedAcksRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.packetAckSequences = ((_c = object.packetAckSequences) === null || _c === void 0 ? void 0 : _c.map((e) => long_1.default.fromValue(e))) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksResponse() {
      return { sequences: [], height: void 0 };
    }
    exports2.QueryUnreceivedAcksResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sequences: Array.isArray(object === null || object === void 0 ? void 0 : object.sequences) ? object.sequences.map((e) => long_1.default.fromValue(e)) : [],
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryUnreceivedAcksResponse();
        message.sequences = ((_a = object.sequences) === null || _a === void 0 ? void 0 : _a.map((e) => long_1.default.fromValue(e))) || [];
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveRequest() {
      return { portId: "", channelId: "" };
    }
    exports2.QueryNextSequenceReceiveRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet(object.portId) ? String(object.portId) : "",
          channelId: isSet(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryNextSequenceReceiveRequest();
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveResponse() {
      return { nextSequenceReceive: long_1.default.UZERO, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryNextSequenceReceiveResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.nextSequenceReceive.isZero()) {
          writer.uint32(8).uint64(message.nextSequenceReceive);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceReceive = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          nextSequenceReceive: isSet(object.nextSequenceReceive) ? long_1.default.fromValue(object.nextSequenceReceive) : long_1.default.UZERO,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceReceive !== void 0 && (obj.nextSequenceReceive = (message.nextSequenceReceive || long_1.default.UZERO).toString());
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryNextSequenceReceiveResponse();
        message.nextSequenceReceive = object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null ? long_1.default.fromValue(object.nextSequenceReceive) : long_1.default.UZERO;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
      }
      Channel(request) {
        const data = exports2.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data);
        return promise.then((data2) => exports2.QueryChannelResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Channels(request) {
        const data = exports2.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data);
        return promise.then((data2) => exports2.QueryChannelsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionChannels(request) {
        const data = exports2.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data);
        return promise.then((data2) => exports2.QueryConnectionChannelsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelClientState(request) {
        const data = exports2.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data);
        return promise.then((data2) => exports2.QueryChannelClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelConsensusState(request) {
        const data = exports2.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data);
        return promise.then((data2) => exports2.QueryChannelConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketCommitment(request) {
        const data = exports2.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data);
        return promise.then((data2) => exports2.QueryPacketCommitmentResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketCommitments(request) {
        const data = exports2.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data);
        return promise.then((data2) => exports2.QueryPacketCommitmentsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketReceipt(request) {
        const data = exports2.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data);
        return promise.then((data2) => exports2.QueryPacketReceiptResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketAcknowledgement(request) {
        const data = exports2.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data);
        return promise.then((data2) => exports2.QueryPacketAcknowledgementResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketAcknowledgements(request) {
        const data = exports2.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data);
        return promise.then((data2) => exports2.QueryPacketAcknowledgementsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UnreceivedPackets(request) {
        const data = exports2.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data);
        return promise.then((data2) => exports2.QueryUnreceivedPacketsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UnreceivedAcks(request) {
        const data = exports2.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data);
        return promise.then((data2) => exports2.QueryUnreceivedAcksResponse.decode(new minimal_1.default.Reader(data2)));
      }
      NextSequenceReceive(request) {
        const data = exports2.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data);
        return promise.then((data2) => exports2.QueryNextSequenceReceiveResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/client/v1/query.js
var require_query9 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/client/v1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryUpgradedConsensusStateResponse = exports2.QueryUpgradedConsensusStateRequest = exports2.QueryUpgradedClientStateResponse = exports2.QueryUpgradedClientStateRequest = exports2.QueryClientParamsResponse = exports2.QueryClientParamsRequest = exports2.QueryClientStatusResponse = exports2.QueryClientStatusRequest = exports2.QueryConsensusStatesResponse = exports2.QueryConsensusStatesRequest = exports2.QueryConsensusStateResponse = exports2.QueryConsensusStateRequest = exports2.QueryClientStatesResponse = exports2.QueryClientStatesRequest = exports2.QueryClientStateResponse = exports2.QueryClientStateRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var client_1 = require_client();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseQueryClientStateRequest() {
      return { clientId: "" };
    }
    exports2.QueryClientStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { clientId: isSet(object.clientId) ? String(object.clientId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientStateRequest();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryClientStateResponse() {
      return { clientState: void 0, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientState: isSet(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientStateResponse();
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryClientStatesRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryClientStatesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryClientStatesResponse() {
      return { clientStates: [], pagination: void 0 };
    }
    exports2.QueryClientStatesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.clientStates) {
          client_1.IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientStates: Array.isArray(object === null || object === void 0 ? void 0 : object.clientStates) ? object.clientStates.map((e) => client_1.IdentifiedClientState.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.clientStates) {
          obj.clientStates = message.clientStates.map((e) => e ? client_1.IdentifiedClientState.toJSON(e) : void 0);
        } else {
          obj.clientStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientStatesResponse();
        message.clientStates = ((_a = object.clientStates) === null || _a === void 0 ? void 0 : _a.map((e) => client_1.IdentifiedClientState.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryConsensusStateRequest() {
      return { clientId: "", revisionNumber: long_1.default.UZERO, revisionHeight: long_1.default.UZERO, latestHeight: false };
    }
    exports2.QueryConsensusStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (!message.revisionNumber.isZero()) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        if (message.latestHeight === true) {
          writer.uint32(32).bool(message.latestHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            case 4:
              message.latestHeight = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          revisionNumber: isSet(object.revisionNumber) ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO,
          revisionHeight: isSet(object.revisionHeight) ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO,
          latestHeight: isSet(object.latestHeight) ? Boolean(object.latestHeight) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryConsensusStateRequest();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        message.latestHeight = (_b = object.latestHeight) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseQueryConsensusStateResponse() {
      return { consensusState: void 0, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          consensusState: isSet(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConsensusStateResponse();
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryConsensusStatesRequest() {
      return { clientId: "", pagination: void 0 };
    }
    exports2.QueryConsensusStatesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConsensusStatesRequest();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryConsensusStatesResponse() {
      return { consensusStates: [], pagination: void 0 };
    }
    exports2.QueryConsensusStatesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.consensusStates) {
          client_1.ConsensusStateWithHeight.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          consensusStates: Array.isArray(object === null || object === void 0 ? void 0 : object.consensusStates) ? object.consensusStates.map((e) => client_1.ConsensusStateWithHeight.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? client_1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConsensusStatesResponse();
        message.consensusStates = ((_a = object.consensusStates) === null || _a === void 0 ? void 0 : _a.map((e) => client_1.ConsensusStateWithHeight.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryClientStatusRequest() {
      return { clientId: "" };
    }
    exports2.QueryClientStatusRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { clientId: isSet(object.clientId) ? String(object.clientId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientStatusRequest();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryClientStatusResponse() {
      return { status: "" };
    }
    exports2.QueryClientStatusResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { status: isSet(object.status) ? String(object.status) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientStatusResponse();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryClientParamsRequest() {
      return {};
    }
    exports2.QueryClientParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryClientParamsRequest();
        return message;
      }
    };
    function createBaseQueryClientParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryClientParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? client_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? client_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateRequest() {
      return {};
    }
    exports2.QueryUpgradedClientStateRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedClientStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateResponse() {
      return { upgradedClientState: void 0 };
    }
    exports2.QueryUpgradedClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          upgradedClientState: isSet(object.upgradedClientState) ? any_1.Any.fromJSON(object.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedClientStateResponse();
        message.upgradedClientState = object.upgradedClientState !== void 0 && object.upgradedClientState !== null ? any_1.Any.fromPartial(object.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateRequest() {
      return {};
    }
    exports2.QueryUpgradedConsensusStateRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedConsensusStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateResponse() {
      return { upgradedConsensusState: void 0 };
    }
    exports2.QueryUpgradedConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.upgradedConsensusState !== void 0) {
          any_1.Any.encode(message.upgradedConsensusState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedConsensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          upgradedConsensusState: isSet(object.upgradedConsensusState) ? any_1.Any.fromJSON(object.upgradedConsensusState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.upgradedConsensusState !== void 0 && (obj.upgradedConsensusState = message.upgradedConsensusState ? any_1.Any.toJSON(message.upgradedConsensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedConsensusStateResponse();
        message.upgradedConsensusState = object.upgradedConsensusState !== void 0 && object.upgradedConsensusState !== null ? any_1.Any.fromPartial(object.upgradedConsensusState) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ClientStatus = this.ClientStatus.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
        this.UpgradedClientState = this.UpgradedClientState.bind(this);
        this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
      }
      ClientState(request) {
        const data = exports2.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data);
        return promise.then((data2) => exports2.QueryClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientStates(request) {
        const data = exports2.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data);
        return promise.then((data2) => exports2.QueryClientStatesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConsensusState(request) {
        const data = exports2.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data);
        return promise.then((data2) => exports2.QueryConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConsensusStates(request) {
        const data = exports2.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data);
        return promise.then((data2) => exports2.QueryConsensusStatesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientStatus(request) {
        const data = exports2.QueryClientStatusRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", data);
        return promise.then((data2) => exports2.QueryClientStatusResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientParams(request) {
        const data = exports2.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data);
        return promise.then((data2) => exports2.QueryClientParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpgradedClientState(request) {
        const data = exports2.QueryUpgradedClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", data);
        return promise.then((data2) => exports2.QueryUpgradedClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpgradedConsensusState(request) {
        const data = exports2.QueryUpgradedConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", data);
        return promise.then((data2) => exports2.QueryUpgradedConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/core/connection/v1/query.js
var require_query10 = __commonJS({
  "../../node_modules/cosmjs-types/ibc/core/connection/v1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryConnectionConsensusStateResponse = exports2.QueryConnectionConsensusStateRequest = exports2.QueryConnectionClientStateResponse = exports2.QueryConnectionClientStateRequest = exports2.QueryClientConnectionsResponse = exports2.QueryClientConnectionsRequest = exports2.QueryConnectionsResponse = exports2.QueryConnectionsRequest = exports2.QueryConnectionResponse = exports2.QueryConnectionRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var client_1 = require_client();
    var connection_1 = require_connection();
    exports2.protobufPackage = "ibc.core.connection.v1";
    function createBaseQueryConnectionRequest() {
      return { connectionId: "" };
    }
    exports2.QueryConnectionRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { connectionId: isSet(object.connectionId) ? String(object.connectionId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionRequest();
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryConnectionResponse() {
      return { connection: void 0, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryConnectionResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connection !== void 0) {
          connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connection: isSet(object.connection) ? connection_1.ConnectionEnd.fromJSON(object.connection) : void 0,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionResponse();
        message.connection = object.connection !== void 0 && object.connection !== null ? connection_1.ConnectionEnd.fromPartial(object.connection) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryConnectionsRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryConnectionsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryConnectionsResponse() {
      return { connections: [], pagination: void 0, height: void 0 };
    }
    exports2.QueryConnectionsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.connections) {
          connection_1.IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connections: Array.isArray(object === null || object === void 0 ? void 0 : object.connections) ? object.connections.map((e) => connection_1.IdentifiedConnection.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0,
          height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.connections) {
          obj.connections = message.connections.map((e) => e ? connection_1.IdentifiedConnection.toJSON(e) : void 0);
        } else {
          obj.connections = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionsResponse();
        message.connections = ((_a = object.connections) === null || _a === void 0 ? void 0 : _a.map((e) => connection_1.IdentifiedConnection.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    function createBaseQueryClientConnectionsRequest() {
      return { clientId: "" };
    }
    exports2.QueryClientConnectionsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { clientId: isSet(object.clientId) ? String(object.clientId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientConnectionsRequest();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryClientConnectionsResponse() {
      return { connectionPaths: [], proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryClientConnectionsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.connectionPaths) {
          writer.uint32(10).string(v);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionPaths.push(reader.string());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connectionPaths: Array.isArray(object === null || object === void 0 ? void 0 : object.connectionPaths) ? object.connectionPaths.map((e) => String(e)) : [],
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.connectionPaths) {
          obj.connectionPaths = message.connectionPaths.map((e) => e);
        } else {
          obj.connectionPaths = [];
        }
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryClientConnectionsResponse();
        message.connectionPaths = ((_a = object.connectionPaths) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryConnectionClientStateRequest() {
      return { connectionId: "" };
    }
    exports2.QueryConnectionClientStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { connectionId: isSet(object.connectionId) ? String(object.connectionId) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionClientStateRequest();
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryConnectionClientStateResponse() {
      return { identifiedClientState: void 0, proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryConnectionClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          identifiedClientState: isSet(object.identifiedClientState) ? client_1.IdentifiedClientState.fromJSON(object.identifiedClientState) : void 0,
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionClientStateResponse();
        message.identifiedClientState = object.identifiedClientState !== void 0 && object.identifiedClientState !== null ? client_1.IdentifiedClientState.fromPartial(object.identifiedClientState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateRequest() {
      return { connectionId: "", revisionNumber: long_1.default.UZERO, revisionHeight: long_1.default.UZERO };
    }
    exports2.QueryConnectionConsensusStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (!message.revisionNumber.isZero()) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connectionId: isSet(object.connectionId) ? String(object.connectionId) : "",
          revisionNumber: isSet(object.revisionNumber) ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO,
          revisionHeight: isSet(object.revisionHeight) ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionConsensusStateRequest();
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateResponse() {
      return { consensusState: void 0, clientId: "", proof: new Uint8Array(), proofHeight: void 0 };
    }
    exports2.QueryConnectionConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          consensusState: isSet(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0,
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(),
          proofHeight: isSet(object.proofHeight) ? client_1.Height.fromJSON(object.proofHeight) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryConnectionConsensusStateResponse();
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
      }
      Connection(request) {
        const data = exports2.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data);
        return promise.then((data2) => exports2.QueryConnectionResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Connections(request) {
        const data = exports2.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data);
        return promise.then((data2) => exports2.QueryConnectionsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientConnections(request) {
        const data = exports2.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data);
        return promise.then((data2) => exports2.QueryClientConnectionsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionClientState(request) {
        const data = exports2.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data);
        return promise.then((data2) => exports2.QueryConnectionClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionConsensusState(request) {
        const data = exports2.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data);
        return promise.then((data2) => exports2.QueryConnectionConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/crypto/proof.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProofOps = exports2.ProofOp = exports2.DominoOp = exports2.ValueOp = exports2.Proof = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return { total: long_1.default.ZERO, index: long_1.default.ZERO, leafHash: new Uint8Array(), aunts: [] };
    }
    exports2.Proof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.total.isZero()) {
          writer.uint32(8).int64(message.total);
        }
        if (!message.index.isZero()) {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
          writer.uint32(34).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.int64();
              break;
            case 2:
              message.index = reader.int64();
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          total: isSet(object.total) ? long_1.default.fromValue(object.total) : long_1.default.ZERO,
          index: isSet(object.index) ? long_1.default.fromValue(object.index) : long_1.default.ZERO,
          leafHash: isSet(object.leafHash) ? bytesFromBase64(object.leafHash) : new Uint8Array(),
          aunts: Array.isArray(object === null || object === void 0 ? void 0 : object.aunts) ? object.aunts.map((e) => bytesFromBase64(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = (message.total || long_1.default.ZERO).toString());
        message.index !== void 0 && (obj.index = (message.index || long_1.default.ZERO).toString());
        message.leafHash !== void 0 && (obj.leafHash = base64FromBytes(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseProof();
        message.total = object.total !== void 0 && object.total !== null ? long_1.default.fromValue(object.total) : long_1.default.ZERO;
        message.index = object.index !== void 0 && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.ZERO;
        message.leafHash = (_a = object.leafHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.aunts = ((_b = object.aunts) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return { key: new Uint8Array(), proof: void 0 };
    }
    exports2.ValueOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports2.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports2.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          proof: isSet(object.proof) ? exports2.Proof.fromJSON(object.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports2.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValueOp();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? exports2.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    function createBaseDominoOp() {
      return { key: "", input: "", output: "" };
    }
    exports2.DominoOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? String(object.key) : "",
          input: isSet(object.input) ? String(object.input) : "",
          output: isSet(object.output) ? String(object.output) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseDominoOp();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.input = (_b = object.input) !== null && _b !== void 0 ? _b : "";
        message.output = (_c = object.output) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseProofOp() {
      return { type: "", key: new Uint8Array(), data: new Uint8Array() };
    }
    exports2.ProofOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet(object.type) ? String(object.type) : "",
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseProofOp();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.key = (_b = object.key) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps() {
      return { ops: [] };
    }
    exports2.ProofOps = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.ops) {
          exports2.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports2.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { ops: Array.isArray(object === null || object === void 0 ? void 0 : object.ops) ? object.ops.map((e) => exports2.ProofOp.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports2.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseProofOps();
        message.ops = ((_a = object.ops) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.ProofOp.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/version/types.js
var require_types = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/version/types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Consensus = exports2.App = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return { protocol: long_1.default.UZERO, software: "" };
    }
    exports2.App = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.protocol.isZero()) {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.uint64();
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          protocol: isSet(object.protocol) ? long_1.default.fromValue(object.protocol) : long_1.default.UZERO,
          software: isSet(object.software) ? String(object.software) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = (message.protocol || long_1.default.UZERO).toString());
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseApp();
        message.protocol = object.protocol !== void 0 && object.protocol !== null ? long_1.default.fromValue(object.protocol) : long_1.default.UZERO;
        message.software = (_a = object.software) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseConsensus() {
      return { block: long_1.default.UZERO, app: long_1.default.UZERO };
    }
    exports2.Consensus = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.block.isZero()) {
          writer.uint32(8).uint64(message.block);
        }
        if (!message.app.isZero()) {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = reader.uint64();
              break;
            case 2:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          block: isSet(object.block) ? long_1.default.fromValue(object.block) : long_1.default.UZERO,
          app: isSet(object.app) ? long_1.default.fromValue(object.app) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = (message.block || long_1.default.UZERO).toString());
        message.app !== void 0 && (obj.app = (message.app || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensus();
        message.block = object.block !== void 0 && object.block !== null ? long_1.default.fromValue(object.block) : long_1.default.UZERO;
        message.app = object.app !== void 0 && object.app !== null ? long_1.default.fromValue(object.app) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/crypto/keys.js
var require_keys4 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/crypto/keys.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "tendermint.crypto";
    function createBasePublicKey() {
      return { ed25519: void 0, secp256k1: void 0 };
    }
    exports2.PublicKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          ed25519: isSet(object.ed25519) ? bytesFromBase64(object.ed25519) : void 0,
          secp256k1: isSet(object.secp256k1) ? bytesFromBase64(object.secp256k1) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? base64FromBytes(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? base64FromBytes(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePublicKey();
        message.ed25519 = (_a = object.ed25519) !== null && _a !== void 0 ? _a : void 0;
        message.secp256k1 = (_b = object.secp256k1) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/validator.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleValidator = exports2.Validator = exports2.ValidatorSet = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var keys_1 = require_keys4();
    exports2.protobufPackage = "tendermint.types";
    function createBaseValidatorSet() {
      return { validators: [], proposer: void 0, totalVotingPower: long_1.default.ZERO };
    }
    exports2.ValidatorSet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          exports2.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports2.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (!message.totalVotingPower.isZero()) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports2.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => exports2.Validator.fromJSON(e)) : [],
          proposer: isSet(object.proposer) ? exports2.Validator.fromJSON(object.proposer) : void 0,
          totalVotingPower: isSet(object.totalVotingPower) ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports2.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorSet();
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Validator.fromPartial(e))) || [];
        message.proposer = object.proposer !== void 0 && object.proposer !== null ? exports2.Validator.fromPartial(object.proposer) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        pubKey: void 0,
        votingPower: long_1.default.ZERO,
        proposerPriority: long_1.default.ZERO
      };
    }
    exports2.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (!message.votingPower.isZero()) {
          writer.uint32(24).int64(message.votingPower);
        }
        if (!message.proposerPriority.isZero()) {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = reader.int64();
              break;
            case 4:
              message.proposerPriority = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(),
          pubKey: isSet(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0,
          votingPower: isSet(object.votingPower) ? long_1.default.fromValue(object.votingPower) : long_1.default.ZERO,
          proposerPriority: isSet(object.proposerPriority) ? long_1.default.fromValue(object.proposerPriority) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = base64FromBytes(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || long_1.default.ZERO).toString());
        message.proposerPriority !== void 0 && (obj.proposerPriority = (message.proposerPriority || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidator();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.votingPower = object.votingPower !== void 0 && object.votingPower !== null ? long_1.default.fromValue(object.votingPower) : long_1.default.ZERO;
        message.proposerPriority = object.proposerPriority !== void 0 && object.proposerPriority !== null ? long_1.default.fromValue(object.proposerPriority) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return { pubKey: void 0, votingPower: long_1.default.ZERO };
    }
    exports2.SimpleValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (!message.votingPower.isZero()) {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pubKey: isSet(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0,
          votingPower: isSet(object.votingPower) ? long_1.default.fromValue(object.votingPower) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimpleValidator();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.votingPower = object.votingPower !== void 0 && object.votingPower !== null ? long_1.default.fromValue(object.votingPower) : long_1.default.ZERO;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/types.js
var require_types2 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TxProof = exports2.BlockMeta = exports2.LightBlock = exports2.SignedHeader = exports2.Proposal = exports2.CommitSig = exports2.Commit = exports2.Vote = exports2.Data = exports2.Header = exports2.BlockID = exports2.Part = exports2.PartSetHeader = exports2.signedMsgTypeToJSON = exports2.signedMsgTypeFromJSON = exports2.SignedMsgType = exports2.blockIDFlagToJSON = exports2.blockIDFlagFromJSON = exports2.BlockIDFlag = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var timestamp_1 = require_timestamp();
    var proof_1 = require_proof();
    var types_1 = require_types();
    var validator_1 = require_validator();
    exports2.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag = exports2.BlockIDFlag || (exports2.BlockIDFlag = {}));
    function blockIDFlagFromJSON(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports2.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.blockIDFlagToJSON = blockIDFlagToJSON;
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType = exports2.SignedMsgType || (exports2.SignedMsgType = {}));
    function signedMsgTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports2.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.signedMsgTypeToJSON = signedMsgTypeToJSON;
    function createBasePartSetHeader() {
      return { total: 0, hash: new Uint8Array() };
    }
    exports2.PartSetHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          total: isSet(object.total) ? Number(object.total) : 0,
          hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePartSetHeader();
        message.total = (_a = object.total) !== null && _a !== void 0 ? _a : 0;
        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return { index: 0, bytes: new Uint8Array(), proof: void 0 };
    }
    exports2.Part = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          index: isSet(object.index) ? Number(object.index) : 0,
          bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(),
          proof: isSet(object.proof) ? proof_1.Proof.fromJSON(object.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = base64FromBytes(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePart();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.bytes = (_b = object.bytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    function createBaseBlockID() {
      return { hash: new Uint8Array(), partSetHeader: void 0 };
    }
    exports2.BlockID = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports2.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports2.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(),
          partSetHeader: isSet(object.partSetHeader) ? exports2.PartSetHeader.fromJSON(object.partSetHeader) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports2.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseBlockID();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.partSetHeader = object.partSetHeader !== void 0 && object.partSetHeader !== null ? exports2.PartSetHeader.fromPartial(object.partSetHeader) : void 0;
        return message;
      }
    };
    function createBaseHeader() {
      return {
        version: void 0,
        chainId: "",
        height: long_1.default.ZERO,
        time: void 0,
        lastBlockId: void 0,
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports2.Header = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports2.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.lastBlockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          version: isSet(object.version) ? types_1.Consensus.fromJSON(object.version) : void 0,
          chainId: isSet(object.chainId) ? String(object.chainId) : "",
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          time: isSet(object.time) ? fromJsonTimestamp(object.time) : void 0,
          lastBlockId: isSet(object.lastBlockId) ? exports2.BlockID.fromJSON(object.lastBlockId) : void 0,
          lastCommitHash: isSet(object.lastCommitHash) ? bytesFromBase64(object.lastCommitHash) : new Uint8Array(),
          dataHash: isSet(object.dataHash) ? bytesFromBase64(object.dataHash) : new Uint8Array(),
          validatorsHash: isSet(object.validatorsHash) ? bytesFromBase64(object.validatorsHash) : new Uint8Array(),
          nextValidatorsHash: isSet(object.nextValidatorsHash) ? bytesFromBase64(object.nextValidatorsHash) : new Uint8Array(),
          consensusHash: isSet(object.consensusHash) ? bytesFromBase64(object.consensusHash) : new Uint8Array(),
          appHash: isSet(object.appHash) ? bytesFromBase64(object.appHash) : new Uint8Array(),
          lastResultsHash: isSet(object.lastResultsHash) ? bytesFromBase64(object.lastResultsHash) : new Uint8Array(),
          evidenceHash: isSet(object.evidenceHash) ? bytesFromBase64(object.evidenceHash) : new Uint8Array(),
          proposerAddress: isSet(object.proposerAddress) ? bytesFromBase64(object.proposerAddress) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports2.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = base64FromBytes(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = base64FromBytes(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = base64FromBytes(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = base64FromBytes(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = base64FromBytes(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = base64FromBytes(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = base64FromBytes(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseHeader();
        message.version = object.version !== void 0 && object.version !== null ? types_1.Consensus.fromPartial(object.version) : void 0;
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.lastBlockId = object.lastBlockId !== void 0 && object.lastBlockId !== null ? exports2.BlockID.fromPartial(object.lastBlockId) : void 0;
        message.lastCommitHash = (_b = object.lastCommitHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.dataHash = (_c = object.dataHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.validatorsHash = (_d = object.validatorsHash) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.nextValidatorsHash = (_e = object.nextValidatorsHash) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.consensusHash = (_f = object.consensusHash) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.appHash = (_g = object.appHash) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.lastResultsHash = (_h = object.lastResultsHash) !== null && _h !== void 0 ? _h : new Uint8Array();
        message.evidenceHash = (_j = object.evidenceHash) !== null && _j !== void 0 ? _j : new Uint8Array();
        message.proposerAddress = (_k = object.proposerAddress) !== null && _k !== void 0 ? _k : new Uint8Array();
        return message;
      }
    };
    function createBaseData() {
      return { txs: [] };
    }
    exports2.Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs) ? object.txs.map((e) => bytesFromBase64(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseData();
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVote() {
      return {
        type: 0,
        height: long_1.default.ZERO,
        round: 0,
        blockId: void 0,
        timestamp: void 0,
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array()
      };
    }
    exports2.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (!message.height.isZero()) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          round: isSet(object.round) ? Number(object.round) : 0,
          blockId: isSet(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          validatorAddress: isSet(object.validatorAddress) ? bytesFromBase64(object.validatorAddress) : new Uint8Array(),
          validatorIndex: isSet(object.validatorIndex) ? Number(object.validatorIndex) : 0,
          signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseVote();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.validatorIndex = (_d = object.validatorIndex) !== null && _d !== void 0 ? _d : 0;
        message.signature = (_e = object.signature) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
      }
    };
    function createBaseCommit() {
      return { height: long_1.default.ZERO, round: 0, blockId: void 0, signatures: [] };
    }
    exports2.Commit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports2.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports2.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          round: isSet(object.round) ? Number(object.round) : 0,
          blockId: isSet(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => exports2.CommitSig.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCommit();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.round = (_a = object.round) !== null && _a !== void 0 ? _a : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.signatures = ((_b = object.signatures) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.CommitSig.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: void 0,
        signature: new Uint8Array()
      };
    }
    exports2.CommitSig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockIdFlag: isSet(object.blockIdFlag) ? blockIDFlagFromJSON(object.blockIdFlag) : 0,
          validatorAddress: isSet(object.validatorAddress) ? bytesFromBase64(object.validatorAddress) : new Uint8Array(),
          timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCommitSig();
        message.blockIdFlag = (_a = object.blockIdFlag) !== null && _a !== void 0 ? _a : 0;
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.signature = (_c = object.signature) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseProposal() {
      return {
        type: 0,
        height: long_1.default.ZERO,
        round: 0,
        polRound: 0,
        blockId: void 0,
        timestamp: void 0,
        signature: new Uint8Array()
      };
    }
    exports2.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (!message.height.isZero()) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          round: isSet(object.round) ? Number(object.round) : 0,
          polRound: isSet(object.polRound) ? Number(object.polRound) : 0,
          blockId: isSet(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseProposal();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : 0;
        message.polRound = (_c = object.polRound) !== null && _c !== void 0 ? _c : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.signature = (_d = object.signature) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader() {
      return { header: void 0, commit: void 0 };
    }
    exports2.SignedHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          exports2.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports2.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports2.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          header: isSet(object.header) ? exports2.Header.fromJSON(object.header) : void 0,
          commit: isSet(object.commit) ? exports2.Commit.fromJSON(object.commit) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports2.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignedHeader();
        message.header = object.header !== void 0 && object.header !== null ? exports2.Header.fromPartial(object.header) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports2.Commit.fromPartial(object.commit) : void 0;
        return message;
      }
    };
    function createBaseLightBlock() {
      return { signedHeader: void 0, validatorSet: void 0 };
    }
    exports2.LightBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedHeader !== void 0) {
          exports2.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports2.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signedHeader: isSet(object.signedHeader) ? exports2.SignedHeader.fromJSON(object.signedHeader) : void 0,
          validatorSet: isSet(object.validatorSet) ? validator_1.ValidatorSet.fromJSON(object.validatorSet) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports2.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightBlock();
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? exports2.SignedHeader.fromPartial(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object.validatorSet) : void 0;
        return message;
      }
    };
    function createBaseBlockMeta() {
      return { blockId: void 0, blockSize: long_1.default.ZERO, header: void 0, numTxs: long_1.default.ZERO };
    }
    exports2.BlockMeta = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (!message.blockSize.isZero()) {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports2.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (!message.numTxs.isZero()) {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = reader.int64();
              break;
            case 3:
              message.header = exports2.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockId: isSet(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          blockSize: isSet(object.blockSize) ? long_1.default.fromValue(object.blockSize) : long_1.default.ZERO,
          header: isSet(object.header) ? exports2.Header.fromJSON(object.header) : void 0,
          numTxs: isSet(object.numTxs) ? long_1.default.fromValue(object.numTxs) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = (message.blockSize || long_1.default.ZERO).toString());
        message.header !== void 0 && (obj.header = message.header ? exports2.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = (message.numTxs || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockMeta();
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.blockSize = object.blockSize !== void 0 && object.blockSize !== null ? long_1.default.fromValue(object.blockSize) : long_1.default.ZERO;
        message.header = object.header !== void 0 && object.header !== null ? exports2.Header.fromPartial(object.header) : void 0;
        message.numTxs = object.numTxs !== void 0 && object.numTxs !== null ? long_1.default.fromValue(object.numTxs) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseTxProof() {
      return { rootHash: new Uint8Array(), data: new Uint8Array(), proof: void 0 };
    }
    exports2.TxProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rootHash: isSet(object.rootHash) ? bytesFromBase64(object.rootHash) : new Uint8Array(),
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          proof: isSet(object.proof) ? proof_1.Proof.fromJSON(object.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = base64FromBytes(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTxProof();
        message.rootHash = (_a = object.rootHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js
var require_tendermint = __commonJS({
  "../../node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Fraction = exports2.Header = exports2.Misbehaviour = exports2.ConsensusState = exports2.ClientState = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var proofs_1 = require_proofs2();
    var duration_1 = require_duration();
    var timestamp_1 = require_timestamp();
    var types_1 = require_types2();
    var validator_1 = require_validator();
    var client_1 = require_client();
    var commitment_1 = require_commitment();
    exports2.protobufPackage = "ibc.lightclients.tendermint.v1";
    function createBaseClientState() {
      return {
        chainId: "",
        trustLevel: void 0,
        trustingPeriod: void 0,
        unbondingPeriod: void 0,
        maxClockDrift: void 0,
        frozenHeight: void 0,
        latestHeight: void 0,
        proofSpecs: [],
        upgradePath: [],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false
      };
    }
    exports2.ClientState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.trustLevel !== void 0) {
          exports2.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustingPeriod !== void 0) {
          duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.unbondingPeriod !== void 0) {
          duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        }
        if (message.maxClockDrift !== void 0) {
          duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        }
        if (message.frozenHeight !== void 0) {
          client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.latestHeight !== void 0) {
          client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.proofSpecs) {
          proofs_1.ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.upgradePath) {
          writer.uint32(74).string(v);
        }
        if (message.allowUpdateAfterExpiry === true) {
          writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        }
        if (message.allowUpdateAfterMisbehaviour === true) {
          writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.trustLevel = exports2.Fraction.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 5:
              message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 6:
              message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.latestHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
              break;
            case 9:
              message.upgradePath.push(reader.string());
              break;
            case 10:
              message.allowUpdateAfterExpiry = reader.bool();
              break;
            case 11:
              message.allowUpdateAfterMisbehaviour = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          chainId: isSet(object.chainId) ? String(object.chainId) : "",
          trustLevel: isSet(object.trustLevel) ? exports2.Fraction.fromJSON(object.trustLevel) : void 0,
          trustingPeriod: isSet(object.trustingPeriod) ? duration_1.Duration.fromJSON(object.trustingPeriod) : void 0,
          unbondingPeriod: isSet(object.unbondingPeriod) ? duration_1.Duration.fromJSON(object.unbondingPeriod) : void 0,
          maxClockDrift: isSet(object.maxClockDrift) ? duration_1.Duration.fromJSON(object.maxClockDrift) : void 0,
          frozenHeight: isSet(object.frozenHeight) ? client_1.Height.fromJSON(object.frozenHeight) : void 0,
          latestHeight: isSet(object.latestHeight) ? client_1.Height.fromJSON(object.latestHeight) : void 0,
          proofSpecs: Array.isArray(object === null || object === void 0 ? void 0 : object.proofSpecs) ? object.proofSpecs.map((e) => proofs_1.ProofSpec.fromJSON(e)) : [],
          upgradePath: Array.isArray(object === null || object === void 0 ? void 0 : object.upgradePath) ? object.upgradePath.map((e) => String(e)) : [],
          allowUpdateAfterExpiry: isSet(object.allowUpdateAfterExpiry) ? Boolean(object.allowUpdateAfterExpiry) : false,
          allowUpdateAfterMisbehaviour: isSet(object.allowUpdateAfterMisbehaviour) ? Boolean(object.allowUpdateAfterMisbehaviour) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? exports2.Fraction.toJSON(message.trustLevel) : void 0);
        message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : void 0);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : void 0);
        message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : void 0);
        message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : void 0);
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : void 0);
        if (message.proofSpecs) {
          obj.proofSpecs = message.proofSpecs.map((e) => e ? proofs_1.ProofSpec.toJSON(e) : void 0);
        } else {
          obj.proofSpecs = [];
        }
        if (message.upgradePath) {
          obj.upgradePath = message.upgradePath.map((e) => e);
        } else {
          obj.upgradePath = [];
        }
        message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseClientState();
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.trustLevel = object.trustLevel !== void 0 && object.trustLevel !== null ? exports2.Fraction.fromPartial(object.trustLevel) : void 0;
        message.trustingPeriod = object.trustingPeriod !== void 0 && object.trustingPeriod !== null ? duration_1.Duration.fromPartial(object.trustingPeriod) : void 0;
        message.unbondingPeriod = object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null ? duration_1.Duration.fromPartial(object.unbondingPeriod) : void 0;
        message.maxClockDrift = object.maxClockDrift !== void 0 && object.maxClockDrift !== null ? duration_1.Duration.fromPartial(object.maxClockDrift) : void 0;
        message.frozenHeight = object.frozenHeight !== void 0 && object.frozenHeight !== null ? client_1.Height.fromPartial(object.frozenHeight) : void 0;
        message.latestHeight = object.latestHeight !== void 0 && object.latestHeight !== null ? client_1.Height.fromPartial(object.latestHeight) : void 0;
        message.proofSpecs = ((_b = object.proofSpecs) === null || _b === void 0 ? void 0 : _b.map((e) => proofs_1.ProofSpec.fromPartial(e))) || [];
        message.upgradePath = ((_c = object.upgradePath) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.allowUpdateAfterExpiry = (_d = object.allowUpdateAfterExpiry) !== null && _d !== void 0 ? _d : false;
        message.allowUpdateAfterMisbehaviour = (_e = object.allowUpdateAfterMisbehaviour) !== null && _e !== void 0 ? _e : false;
        return message;
      }
    };
    function createBaseConsensusState() {
      return { timestamp: void 0, root: void 0, nextValidatorsHash: new Uint8Array() };
    }
    exports2.ConsensusState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        }
        if (message.root !== void 0) {
          commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(26).bytes(message.nextValidatorsHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextValidatorsHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          root: isSet(object.root) ? commitment_1.MerkleRoot.fromJSON(object.root) : void 0,
          nextValidatorsHash: isSet(object.nextValidatorsHash) ? bytesFromBase64(object.nextValidatorsHash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.root !== void 0 && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : void 0);
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseConsensusState();
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.root = object.root !== void 0 && object.root !== null ? commitment_1.MerkleRoot.fromPartial(object.root) : void 0;
        message.nextValidatorsHash = (_a = object.nextValidatorsHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseMisbehaviour() {
      return { clientId: "", header1: void 0, header2: void 0 };
    }
    exports2.Misbehaviour = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header1 !== void 0) {
          exports2.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        }
        if (message.header2 !== void 0) {
          exports2.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header1 = exports2.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.header2 = exports2.Header.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet(object.clientId) ? String(object.clientId) : "",
          header1: isSet(object.header1) ? exports2.Header.fromJSON(object.header1) : void 0,
          header2: isSet(object.header2) ? exports2.Header.fromJSON(object.header2) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header1 !== void 0 && (obj.header1 = message.header1 ? exports2.Header.toJSON(message.header1) : void 0);
        message.header2 !== void 0 && (obj.header2 = message.header2 ? exports2.Header.toJSON(message.header2) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMisbehaviour();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.header1 = object.header1 !== void 0 && object.header1 !== null ? exports2.Header.fromPartial(object.header1) : void 0;
        message.header2 = object.header2 !== void 0 && object.header2 !== null ? exports2.Header.fromPartial(object.header2) : void 0;
        return message;
      }
    };
    function createBaseHeader() {
      return {
        signedHeader: void 0,
        validatorSet: void 0,
        trustedHeight: void 0,
        trustedValidators: void 0
      };
    }
    exports2.Header = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedHeader !== void 0) {
          types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustedHeight !== void 0) {
          client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.trustedValidators !== void 0) {
          validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signedHeader: isSet(object.signedHeader) ? types_1.SignedHeader.fromJSON(object.signedHeader) : void 0,
          validatorSet: isSet(object.validatorSet) ? validator_1.ValidatorSet.fromJSON(object.validatorSet) : void 0,
          trustedHeight: isSet(object.trustedHeight) ? client_1.Height.fromJSON(object.trustedHeight) : void 0,
          trustedValidators: isSet(object.trustedValidators) ? validator_1.ValidatorSet.fromJSON(object.trustedValidators) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : void 0);
        message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? types_1.SignedHeader.fromPartial(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object.validatorSet) : void 0;
        message.trustedHeight = object.trustedHeight !== void 0 && object.trustedHeight !== null ? client_1.Height.fromPartial(object.trustedHeight) : void 0;
        message.trustedValidators = object.trustedValidators !== void 0 && object.trustedValidators !== null ? validator_1.ValidatorSet.fromPartial(object.trustedValidators) : void 0;
        return message;
      }
    };
    function createBaseFraction() {
      return { numerator: long_1.default.UZERO, denominator: long_1.default.UZERO };
    }
    exports2.Fraction = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.numerator.isZero()) {
          writer.uint32(8).uint64(message.numerator);
        }
        if (!message.denominator.isZero()) {
          writer.uint32(16).uint64(message.denominator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFraction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.numerator = reader.uint64();
              break;
            case 2:
              message.denominator = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          numerator: isSet(object.numerator) ? long_1.default.fromValue(object.numerator) : long_1.default.UZERO,
          denominator: isSet(object.denominator) ? long_1.default.fromValue(object.denominator) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.numerator !== void 0 && (obj.numerator = (message.numerator || long_1.default.UZERO).toString());
        message.denominator !== void 0 && (obj.denominator = (message.denominator || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFraction();
        message.numerator = object.numerator !== void 0 && object.numerator !== null ? long_1.default.fromValue(object.numerator) : long_1.default.UZERO;
        message.denominator = object.denominator !== void 0 && object.denominator !== null ? long_1.default.fromValue(object.denominator) : long_1.default.UZERO;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupIbcExtension = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var query_1 = require_query7();
    var channel_1 = require_channel();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var long_1 = __importDefault(require_long());
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                channels,
                height: response.height
              };
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                channels,
                height: response.height
              };
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: long_1.default.fromNumber(revisionNumber, true),
              revisionHeight: long_1.default.fromNumber(revisionHeight, true)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: long_1.default.fromNumber(sequence, true)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              var _a;
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                commitments,
                height: response.height
              };
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: long_1.default.fromNumber(sequence, true)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: long_1.default.fromNumber(sequence, true)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              var _a;
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                acknowledgements,
                height: response.height
              };
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => long_1.default.fromNumber(s, true))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => long_1.default.fromNumber(s, true))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                clientStates
              };
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? long_1.default.fromNumber(consensusHeight, true) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              var _a;
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                consensusStates
              };
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionHeight,
                revisionNumber: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              var _a;
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                connections,
                height: response.height
              };
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: long_1.default.fromNumber(revisionHeight, true)
            }))
          },
          transfer: {
            denomTrace: async (hash) => transferQueryService.DenomTrace({ hash }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              var _a;
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                denomTraces
              };
            },
            params: async () => transferQueryService.Params({})
          },
          verified: {
            channel: {
              channel: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`channelEnds/ports/${portId}/channels/${channelId}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value.length ? channel_1.Channel.decode(value) : null;
              },
              packetCommitment: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value;
              },
              packetAcknowledgement: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value;
              },
              nextSequenceReceive: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value.length ? math_1.Uint64.fromBytes(value).toNumber() : null;
              }
            }
          }
        }
      };
    }
    exports2.setupIbcExtension = setupIbcExtension;
  }
});

// ../../node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js
var require_mint = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Minter = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    exports2.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseMinter() {
      return { inflation: "", annualProvisions: "" };
    }
    exports2.Minter = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inflation !== "") {
          writer.uint32(10).string(message.inflation);
        }
        if (message.annualProvisions !== "") {
          writer.uint32(18).string(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMinter();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.string();
              break;
            case 2:
              message.annualProvisions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          inflation: isSet(object.inflation) ? String(object.inflation) : "",
          annualProvisions: isSet(object.annualProvisions) ? String(object.annualProvisions) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = message.inflation);
        message.annualProvisions !== void 0 && (obj.annualProvisions = message.annualProvisions);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMinter();
        message.inflation = (_a = object.inflation) !== null && _a !== void 0 ? _a : "";
        message.annualProvisions = (_b = object.annualProvisions) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        mintDenom: "",
        inflationRateChange: "",
        inflationMax: "",
        inflationMin: "",
        goalBonded: "",
        blocksPerYear: long_1.default.UZERO
      };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mintDenom !== "") {
          writer.uint32(10).string(message.mintDenom);
        }
        if (message.inflationRateChange !== "") {
          writer.uint32(18).string(message.inflationRateChange);
        }
        if (message.inflationMax !== "") {
          writer.uint32(26).string(message.inflationMax);
        }
        if (message.inflationMin !== "") {
          writer.uint32(34).string(message.inflationMin);
        }
        if (message.goalBonded !== "") {
          writer.uint32(42).string(message.goalBonded);
        }
        if (!message.blocksPerYear.isZero()) {
          writer.uint32(48).uint64(message.blocksPerYear);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mintDenom = reader.string();
              break;
            case 2:
              message.inflationRateChange = reader.string();
              break;
            case 3:
              message.inflationMax = reader.string();
              break;
            case 4:
              message.inflationMin = reader.string();
              break;
            case 5:
              message.goalBonded = reader.string();
              break;
            case 6:
              message.blocksPerYear = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mintDenom: isSet(object.mintDenom) ? String(object.mintDenom) : "",
          inflationRateChange: isSet(object.inflationRateChange) ? String(object.inflationRateChange) : "",
          inflationMax: isSet(object.inflationMax) ? String(object.inflationMax) : "",
          inflationMin: isSet(object.inflationMin) ? String(object.inflationMin) : "",
          goalBonded: isSet(object.goalBonded) ? String(object.goalBonded) : "",
          blocksPerYear: isSet(object.blocksPerYear) ? long_1.default.fromValue(object.blocksPerYear) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.mintDenom !== void 0 && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== void 0 && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== void 0 && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== void 0 && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== void 0 && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== void 0 && (obj.blocksPerYear = (message.blocksPerYear || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseParams();
        message.mintDenom = (_a = object.mintDenom) !== null && _a !== void 0 ? _a : "";
        message.inflationRateChange = (_b = object.inflationRateChange) !== null && _b !== void 0 ? _b : "";
        message.inflationMax = (_c = object.inflationMax) !== null && _c !== void 0 ? _c : "";
        message.inflationMin = (_d = object.inflationMin) !== null && _d !== void 0 ? _d : "";
        message.goalBonded = (_e = object.goalBonded) !== null && _e !== void 0 ? _e : "";
        message.blocksPerYear = object.blocksPerYear !== void 0 && object.blocksPerYear !== null ? long_1.default.fromValue(object.blocksPerYear) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js
var require_query11 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryAnnualProvisionsResponse = exports2.QueryAnnualProvisionsRequest = exports2.QueryInflationResponse = exports2.QueryInflationRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var mint_1 = require_mint();
    exports2.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = mint_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? mint_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? mint_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQueryInflationRequest() {
      return {};
    }
    exports2.QueryInflationRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryInflationRequest();
        return message;
      }
    };
    function createBaseQueryInflationResponse() {
      return { inflation: new Uint8Array() };
    }
    exports2.QueryInflationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inflation.length !== 0) {
          writer.uint32(10).bytes(message.inflation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { inflation: isSet(object.inflation) ? bytesFromBase64(object.inflation) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = base64FromBytes(message.inflation !== void 0 ? message.inflation : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryInflationResponse();
        message.inflation = (_a = object.inflation) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsRequest() {
      return {};
    }
    exports2.QueryAnnualProvisionsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryAnnualProvisionsRequest();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsResponse() {
      return { annualProvisions: new Uint8Array() };
    }
    exports2.QueryAnnualProvisionsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.annualProvisions.length !== 0) {
          writer.uint32(10).bytes(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.annualProvisions = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          annualProvisions: isSet(object.annualProvisions) ? bytesFromBase64(object.annualProvisions) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.annualProvisions !== void 0 && (obj.annualProvisions = base64FromBytes(message.annualProvisions !== void 0 ? message.annualProvisions : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAnnualProvisionsResponse();
        message.annualProvisions = (_a = object.annualProvisions) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Inflation(request) {
        const data = exports2.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data);
        return promise.then((data2) => exports2.QueryInflationResponse.decode(new minimal_1.default.Reader(data2)));
      }
      AnnualProvisions(request) {
        const data = exports2.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data);
        return promise.then((data2) => exports2.QueryAnnualProvisionsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupMintExtension = void 0;
    var utils_1 = require_build3();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
    exports2.setupMintExtension = setupMintExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages9 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSlashingAminoConverters = exports2.isAminoMsgUnjail = void 0;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    exports2.isAminoMsgUnjail = isAminoMsgUnjail;
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
    exports2.createSlashingAminoConverters = createSlashingAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js
var require_slashing = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.ValidatorSigningInfo = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var duration_1 = require_duration();
    var timestamp_1 = require_timestamp();
    exports2.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseValidatorSigningInfo() {
      return {
        address: "",
        startHeight: long_1.default.ZERO,
        indexOffset: long_1.default.ZERO,
        jailedUntil: void 0,
        tombstoned: false,
        missedBlocksCounter: long_1.default.ZERO
      };
    }
    exports2.ValidatorSigningInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (!message.startHeight.isZero()) {
          writer.uint32(16).int64(message.startHeight);
        }
        if (!message.indexOffset.isZero()) {
          writer.uint32(24).int64(message.indexOffset);
        }
        if (message.jailedUntil !== void 0) {
          timestamp_1.Timestamp.encode(message.jailedUntil, writer.uint32(34).fork()).ldelim();
        }
        if (message.tombstoned === true) {
          writer.uint32(40).bool(message.tombstoned);
        }
        if (!message.missedBlocksCounter.isZero()) {
          writer.uint32(48).int64(message.missedBlocksCounter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.startHeight = reader.int64();
              break;
            case 3:
              message.indexOffset = reader.int64();
              break;
            case 4:
              message.jailedUntil = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.tombstoned = reader.bool();
              break;
            case 6:
              message.missedBlocksCounter = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          startHeight: isSet(object.startHeight) ? long_1.default.fromValue(object.startHeight) : long_1.default.ZERO,
          indexOffset: isSet(object.indexOffset) ? long_1.default.fromValue(object.indexOffset) : long_1.default.ZERO,
          jailedUntil: isSet(object.jailedUntil) ? fromJsonTimestamp(object.jailedUntil) : void 0,
          tombstoned: isSet(object.tombstoned) ? Boolean(object.tombstoned) : false,
          missedBlocksCounter: isSet(object.missedBlocksCounter) ? long_1.default.fromValue(object.missedBlocksCounter) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.startHeight !== void 0 && (obj.startHeight = (message.startHeight || long_1.default.ZERO).toString());
        message.indexOffset !== void 0 && (obj.indexOffset = (message.indexOffset || long_1.default.ZERO).toString());
        message.jailedUntil !== void 0 && (obj.jailedUntil = fromTimestamp(message.jailedUntil).toISOString());
        message.tombstoned !== void 0 && (obj.tombstoned = message.tombstoned);
        message.missedBlocksCounter !== void 0 && (obj.missedBlocksCounter = (message.missedBlocksCounter || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseValidatorSigningInfo();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.startHeight = object.startHeight !== void 0 && object.startHeight !== null ? long_1.default.fromValue(object.startHeight) : long_1.default.ZERO;
        message.indexOffset = object.indexOffset !== void 0 && object.indexOffset !== null ? long_1.default.fromValue(object.indexOffset) : long_1.default.ZERO;
        message.jailedUntil = object.jailedUntil !== void 0 && object.jailedUntil !== null ? timestamp_1.Timestamp.fromPartial(object.jailedUntil) : void 0;
        message.tombstoned = (_b = object.tombstoned) !== null && _b !== void 0 ? _b : false;
        message.missedBlocksCounter = object.missedBlocksCounter !== void 0 && object.missedBlocksCounter !== null ? long_1.default.fromValue(object.missedBlocksCounter) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseParams() {
      return {
        signedBlocksWindow: long_1.default.ZERO,
        minSignedPerWindow: new Uint8Array(),
        downtimeJailDuration: void 0,
        slashFractionDoubleSign: new Uint8Array(),
        slashFractionDowntime: new Uint8Array()
      };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.signedBlocksWindow.isZero()) {
          writer.uint32(8).int64(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
          writer.uint32(18).bytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== void 0) {
          duration_1.Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.slashFractionDoubleSign.length !== 0) {
          writer.uint32(34).bytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
          writer.uint32(42).bytes(message.slashFractionDowntime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedBlocksWindow = reader.int64();
              break;
            case 2:
              message.minSignedPerWindow = reader.bytes();
              break;
            case 3:
              message.downtimeJailDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.slashFractionDoubleSign = reader.bytes();
              break;
            case 5:
              message.slashFractionDowntime = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signedBlocksWindow: isSet(object.signedBlocksWindow) ? long_1.default.fromValue(object.signedBlocksWindow) : long_1.default.ZERO,
          minSignedPerWindow: isSet(object.minSignedPerWindow) ? bytesFromBase64(object.minSignedPerWindow) : new Uint8Array(),
          downtimeJailDuration: isSet(object.downtimeJailDuration) ? duration_1.Duration.fromJSON(object.downtimeJailDuration) : void 0,
          slashFractionDoubleSign: isSet(object.slashFractionDoubleSign) ? bytesFromBase64(object.slashFractionDoubleSign) : new Uint8Array(),
          slashFractionDowntime: isSet(object.slashFractionDowntime) ? bytesFromBase64(object.slashFractionDowntime) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.signedBlocksWindow !== void 0 && (obj.signedBlocksWindow = (message.signedBlocksWindow || long_1.default.ZERO).toString());
        message.minSignedPerWindow !== void 0 && (obj.minSignedPerWindow = base64FromBytes(message.minSignedPerWindow !== void 0 ? message.minSignedPerWindow : new Uint8Array()));
        message.downtimeJailDuration !== void 0 && (obj.downtimeJailDuration = message.downtimeJailDuration ? duration_1.Duration.toJSON(message.downtimeJailDuration) : void 0);
        message.slashFractionDoubleSign !== void 0 && (obj.slashFractionDoubleSign = base64FromBytes(message.slashFractionDoubleSign !== void 0 ? message.slashFractionDoubleSign : new Uint8Array()));
        message.slashFractionDowntime !== void 0 && (obj.slashFractionDowntime = base64FromBytes(message.slashFractionDowntime !== void 0 ? message.slashFractionDowntime : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseParams();
        message.signedBlocksWindow = object.signedBlocksWindow !== void 0 && object.signedBlocksWindow !== null ? long_1.default.fromValue(object.signedBlocksWindow) : long_1.default.ZERO;
        message.minSignedPerWindow = (_a = object.minSignedPerWindow) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.downtimeJailDuration = object.downtimeJailDuration !== void 0 && object.downtimeJailDuration !== null ? duration_1.Duration.fromPartial(object.downtimeJailDuration) : void 0;
        message.slashFractionDoubleSign = (_b = object.slashFractionDoubleSign) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.slashFractionDowntime = (_c = object.slashFractionDowntime) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js
var require_query12 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QuerySigningInfosResponse = exports2.QuerySigningInfosRequest = exports2.QuerySigningInfoResponse = exports2.QuerySigningInfoRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var slashing_1 = require_slashing();
    exports2.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          slashing_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = slashing_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? slashing_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? slashing_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? slashing_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    function createBaseQuerySigningInfoRequest() {
      return { consAddress: "" };
    }
    exports2.QuerySigningInfoRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consAddress !== "") {
          writer.uint32(10).string(message.consAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { consAddress: isSet(object.consAddress) ? String(object.consAddress) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.consAddress !== void 0 && (obj.consAddress = message.consAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySigningInfoRequest();
        message.consAddress = (_a = object.consAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQuerySigningInfoResponse() {
      return { valSigningInfo: void 0 };
    }
    exports2.QuerySigningInfoResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.valSigningInfo !== void 0) {
          slashing_1.ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valSigningInfo = slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          valSigningInfo: isSet(object.valSigningInfo) ? slashing_1.ValidatorSigningInfo.fromJSON(object.valSigningInfo) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.valSigningInfo !== void 0 && (obj.valSigningInfo = message.valSigningInfo ? slashing_1.ValidatorSigningInfo.toJSON(message.valSigningInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoResponse();
        message.valSigningInfo = object.valSigningInfo !== void 0 && object.valSigningInfo !== null ? slashing_1.ValidatorSigningInfo.fromPartial(object.valSigningInfo) : void 0;
        return message;
      }
    };
    function createBaseQuerySigningInfosRequest() {
      return { pagination: void 0 };
    }
    exports2.QuerySigningInfosRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQuerySigningInfosResponse() {
      return { info: [], pagination: void 0 };
    }
    exports2.QuerySigningInfosResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.info) {
          slashing_1.ValidatorSigningInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info.push(slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          info: Array.isArray(object === null || object === void 0 ? void 0 : object.info) ? object.info.map((e) => slashing_1.ValidatorSigningInfo.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.info) {
          obj.info = message.info.map((e) => e ? slashing_1.ValidatorSigningInfo.toJSON(e) : void 0);
        } else {
          obj.info = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySigningInfosResponse();
        message.info = ((_a = object.info) === null || _a === void 0 ? void 0 : _a.map((e) => slashing_1.ValidatorSigningInfo.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SigningInfo(request) {
        const data = exports2.QuerySigningInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", data);
        return promise.then((data2) => exports2.QuerySigningInfoResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SigningInfos(request) {
        const data = exports2.QuerySigningInfosRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", data);
        return promise.then((data2) => exports2.QuerySigningInfosResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupSlashingExtension = void 0;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
    exports2.setupSlashingExtension = setupSlashingExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages10 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createStakingAminoConverters = exports2.isAminoMsgUndelegate = exports2.isAminoMsgBeginRedelegate = exports2.isAminoMsgDelegate = exports2.isAminoMsgEditValidator = exports2.isAminoMsgCreateValidator = exports2.protoDecimalToJson = void 0;
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional !== null && fractional !== void 0 ? fractional : "").padEnd(18, "0")}`;
    }
    exports2.protoDecimalToJson = protoDecimalToJson;
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    exports2.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    exports2.isAminoMsgEditValidator = isAminoMsgEditValidator;
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    exports2.isAminoMsgDelegate = isAminoMsgDelegate;
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    exports2.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    exports2.isAminoMsgUndelegate = isAminoMsgUndelegate;
    function createStakingAminoConverters(_prefix) {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.anyToSinglePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation !== null && min_self_delegation !== void 0 ? min_self_delegation : "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        }
      };
    }
    exports2.createStakingAminoConverters = createStakingAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pool = exports2.RedelegationResponse = exports2.RedelegationEntryResponse = exports2.DelegationResponse = exports2.Params = exports2.Redelegation = exports2.RedelegationEntry = exports2.UnbondingDelegationEntry = exports2.UnbondingDelegation = exports2.Delegation = exports2.DVVTriplets = exports2.DVVTriplet = exports2.DVPairs = exports2.DVPair = exports2.ValAddresses = exports2.Validator = exports2.Description = exports2.Commission = exports2.CommissionRates = exports2.HistoricalInfo = exports2.bondStatusToJSON = exports2.bondStatusFromJSON = exports2.BondStatus = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var duration_1 = require_duration();
    var timestamp_1 = require_timestamp();
    var types_1 = require_types2();
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus = exports2.BondStatus || (exports2.BondStatus = {}));
    function bondStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports2.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.bondStatusToJSON = bondStatusToJSON;
    function createBaseHistoricalInfo() {
      return { header: void 0, valset: [] };
    }
    exports2.HistoricalInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
          exports2.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports2.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          header: isSet(object.header) ? types_1.Header.fromJSON(object.header) : void 0,
          valset: Array.isArray(object === null || object === void 0 ? void 0 : object.valset) ? object.valset.map((e) => exports2.Validator.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports2.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseHistoricalInfo();
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromPartial(object.header) : void 0;
        message.valset = ((_a = object.valset) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Validator.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommissionRates() {
      return { rate: "", maxRate: "", maxChangeRate: "" };
    }
    exports2.CommissionRates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rate: isSet(object.rate) ? String(object.rate) : "",
          maxRate: isSet(object.maxRate) ? String(object.maxRate) : "",
          maxChangeRate: isSet(object.maxChangeRate) ? String(object.maxChangeRate) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCommissionRates();
        message.rate = (_a = object.rate) !== null && _a !== void 0 ? _a : "";
        message.maxRate = (_b = object.maxRate) !== null && _b !== void 0 ? _b : "";
        message.maxChangeRate = (_c = object.maxChangeRate) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseCommission() {
      return { commissionRates: void 0, updateTime: void 0 };
    }
    exports2.Commission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commissionRates !== void 0) {
          exports2.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports2.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          commissionRates: isSet(object.commissionRates) ? exports2.CommissionRates.fromJSON(object.commissionRates) : void 0,
          updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports2.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = fromTimestamp(message.updateTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommission();
        message.commissionRates = object.commissionRates !== void 0 && object.commissionRates !== null ? exports2.CommissionRates.fromPartial(object.commissionRates) : void 0;
        message.updateTime = object.updateTime !== void 0 && object.updateTime !== null ? timestamp_1.Timestamp.fromPartial(object.updateTime) : void 0;
        return message;
      }
    };
    function createBaseDescription() {
      return { moniker: "", identity: "", website: "", securityContact: "", details: "" };
    }
    exports2.Description = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          moniker: isSet(object.moniker) ? String(object.moniker) : "",
          identity: isSet(object.identity) ? String(object.identity) : "",
          website: isSet(object.website) ? String(object.website) : "",
          securityContact: isSet(object.securityContact) ? String(object.securityContact) : "",
          details: isSet(object.details) ? String(object.details) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseDescription();
        message.moniker = (_a = object.moniker) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.website = (_c = object.website) !== null && _c !== void 0 ? _c : "";
        message.securityContact = (_d = object.securityContact) !== null && _d !== void 0 ? _d : "";
        message.details = (_e = object.details) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: void 0,
        unbondingHeight: long_1.default.ZERO,
        unbondingTime: void 0,
        commission: void 0,
        minSelfDelegation: ""
      };
    }
    exports2.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports2.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (!message.unbondingHeight.isZero()) {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports2.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports2.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = reader.int64();
              break;
            case 9:
              message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.commission = exports2.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
          consensusPubkey: isSet(object.consensusPubkey) ? any_1.Any.fromJSON(object.consensusPubkey) : void 0,
          jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,
          status: isSet(object.status) ? bondStatusFromJSON(object.status) : 0,
          tokens: isSet(object.tokens) ? String(object.tokens) : "",
          delegatorShares: isSet(object.delegatorShares) ? String(object.delegatorShares) : "",
          description: isSet(object.description) ? exports2.Description.fromJSON(object.description) : void 0,
          unbondingHeight: isSet(object.unbondingHeight) ? long_1.default.fromValue(object.unbondingHeight) : long_1.default.ZERO,
          unbondingTime: isSet(object.unbondingTime) ? fromJsonTimestamp(object.unbondingTime) : void 0,
          commission: isSet(object.commission) ? exports2.Commission.fromJSON(object.commission) : void 0,
          minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports2.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = (message.unbondingHeight || long_1.default.ZERO).toString());
        message.unbondingTime !== void 0 && (obj.unbondingTime = fromTimestamp(message.unbondingTime).toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports2.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseValidator();
        message.operatorAddress = (_a = object.operatorAddress) !== null && _a !== void 0 ? _a : "";
        message.consensusPubkey = object.consensusPubkey !== void 0 && object.consensusPubkey !== null ? any_1.Any.fromPartial(object.consensusPubkey) : void 0;
        message.jailed = (_b = object.jailed) !== null && _b !== void 0 ? _b : false;
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.tokens = (_d = object.tokens) !== null && _d !== void 0 ? _d : "";
        message.delegatorShares = (_e = object.delegatorShares) !== null && _e !== void 0 ? _e : "";
        message.description = object.description !== void 0 && object.description !== null ? exports2.Description.fromPartial(object.description) : void 0;
        message.unbondingHeight = object.unbondingHeight !== void 0 && object.unbondingHeight !== null ? long_1.default.fromValue(object.unbondingHeight) : long_1.default.ZERO;
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? timestamp_1.Timestamp.fromPartial(object.unbondingTime) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? exports2.Commission.fromPartial(object.commission) : void 0;
        message.minSelfDelegation = (_f = object.minSelfDelegation) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseValAddresses() {
      return { addresses: [] };
    }
    exports2.ValAddresses = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.addresses) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { addresses: Array.isArray(object === null || object === void 0 ? void 0 : object.addresses) ? object.addresses.map((e) => String(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValAddresses();
        message.addresses = ((_a = object.addresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports2.DVPair = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseDVPair();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return { pairs: [] };
    }
    exports2.DVPairs = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pairs) {
          exports2.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports2.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pairs: Array.isArray(object === null || object === void 0 ? void 0 : object.pairs) ? object.pairs.map((e) => exports2.DVPair.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports2.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDVPairs();
        message.pairs = ((_a = object.pairs) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.DVPair.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "" };
    }
    exports2.DVVTriplet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorSrcAddress: isSet(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
          validatorDstAddress: isSet(object.validatorDstAddress) ? String(object.validatorDstAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseDVVTriplet();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return { triplets: [] };
    }
    exports2.DVVTriplets = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.triplets) {
          exports2.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports2.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          triplets: Array.isArray(object === null || object === void 0 ? void 0 : object.triplets) ? object.triplets.map((e) => exports2.DVVTriplet.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports2.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDVVTriplets();
        message.triplets = ((_a = object.triplets) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.DVVTriplet.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegation() {
      return { delegatorAddress: "", validatorAddress: "", shares: "" };
    }
    exports2.Delegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          shares: isSet(object.shares) ? String(object.shares) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseDelegation();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.shares = (_c = object.shares) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseUnbondingDelegation() {
      return { delegatorAddress: "", validatorAddress: "", entries: [] };
    }
    exports2.UnbondingDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
          exports2.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports2.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.UnbondingDelegationEntry.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.entries = ((_c = object.entries) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.UnbondingDelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry() {
      return { creationHeight: long_1.default.ZERO, completionTime: void 0, initialBalance: "", balance: "" };
    }
    exports2.UnbondingDelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.creationHeight.isZero()) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creationHeight: isSet(object.creationHeight) ? long_1.default.fromValue(object.creationHeight) : long_1.default.ZERO,
          completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0,
          initialBalance: isSet(object.initialBalance) ? String(object.initialBalance) : "",
          balance: isSet(object.balance) ? String(object.balance) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || long_1.default.ZERO).toString());
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseUnbondingDelegationEntry();
        message.creationHeight = object.creationHeight !== void 0 && object.creationHeight !== null ? long_1.default.fromValue(object.creationHeight) : long_1.default.ZERO;
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        message.initialBalance = (_a = object.initialBalance) !== null && _a !== void 0 ? _a : "";
        message.balance = (_b = object.balance) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseRedelegationEntry() {
      return { creationHeight: long_1.default.ZERO, completionTime: void 0, initialBalance: "", sharesDst: "" };
    }
    exports2.RedelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.creationHeight.isZero()) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creationHeight: isSet(object.creationHeight) ? long_1.default.fromValue(object.creationHeight) : long_1.default.ZERO,
          completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0,
          initialBalance: isSet(object.initialBalance) ? String(object.initialBalance) : "",
          sharesDst: isSet(object.sharesDst) ? String(object.sharesDst) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || long_1.default.ZERO).toString());
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRedelegationEntry();
        message.creationHeight = object.creationHeight !== void 0 && object.creationHeight !== null ? long_1.default.fromValue(object.creationHeight) : long_1.default.ZERO;
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        message.initialBalance = (_a = object.initialBalance) !== null && _a !== void 0 ? _a : "";
        message.sharesDst = (_b = object.sharesDst) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseRedelegation() {
      return { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "", entries: [] };
    }
    exports2.Redelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
          exports2.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports2.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorSrcAddress: isSet(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
          validatorDstAddress: isSet(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.RedelegationEntry.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseRedelegation();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.entries = ((_d = object.entries) === null || _d === void 0 ? void 0 : _d.map((e) => exports2.RedelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseParams() {
      return { unbondingTime: void 0, maxValidators: 0, maxEntries: 0, historicalEntries: 0, bondDenom: "" };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unbondingTime: isSet(object.unbondingTime) ? duration_1.Duration.fromJSON(object.unbondingTime) : void 0,
          maxValidators: isSet(object.maxValidators) ? Number(object.maxValidators) : 0,
          maxEntries: isSet(object.maxEntries) ? Number(object.maxEntries) : 0,
          historicalEntries: isSet(object.historicalEntries) ? Number(object.historicalEntries) : 0,
          bondDenom: isSet(object.bondDenom) ? String(object.bondDenom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseParams();
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? duration_1.Duration.fromPartial(object.unbondingTime) : void 0;
        message.maxValidators = (_a = object.maxValidators) !== null && _a !== void 0 ? _a : 0;
        message.maxEntries = (_b = object.maxEntries) !== null && _b !== void 0 ? _b : 0;
        message.historicalEntries = (_c = object.historicalEntries) !== null && _c !== void 0 ? _c : 0;
        message.bondDenom = (_d = object.bondDenom) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseDelegationResponse() {
      return { delegation: void 0, balance: void 0 };
    }
    exports2.DelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegation !== void 0) {
          exports2.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports2.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegation: isSet(object.delegation) ? exports2.Delegation.fromJSON(object.delegation) : void 0,
          balance: isSet(object.balance) ? coin_1.Coin.fromJSON(object.balance) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports2.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationResponse();
        message.delegation = object.delegation !== void 0 && object.delegation !== null ? exports2.Delegation.fromPartial(object.delegation) : void 0;
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : void 0;
        return message;
      }
    };
    function createBaseRedelegationEntryResponse() {
      return { redelegationEntry: void 0, balance: "" };
    }
    exports2.RedelegationEntryResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegationEntry !== void 0) {
          exports2.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports2.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redelegationEntry: isSet(object.redelegationEntry) ? exports2.RedelegationEntry.fromJSON(object.redelegationEntry) : void 0,
          balance: isSet(object.balance) ? String(object.balance) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports2.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRedelegationEntryResponse();
        message.redelegationEntry = object.redelegationEntry !== void 0 && object.redelegationEntry !== null ? exports2.RedelegationEntry.fromPartial(object.redelegationEntry) : void 0;
        message.balance = (_a = object.balance) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseRedelegationResponse() {
      return { redelegation: void 0, entries: [] };
    }
    exports2.RedelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegation !== void 0) {
          exports2.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
          exports2.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports2.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports2.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redelegation: isSet(object.redelegation) ? exports2.Redelegation.fromJSON(object.redelegation) : void 0,
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.RedelegationEntryResponse.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports2.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRedelegationResponse();
        message.redelegation = object.redelegation !== void 0 && object.redelegation !== null ? exports2.Redelegation.fromPartial(object.redelegation) : void 0;
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.RedelegationEntryResponse.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePool() {
      return { notBondedTokens: "", bondedTokens: "" };
    }
    exports2.Pool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          notBondedTokens: isSet(object.notBondedTokens) ? String(object.notBondedTokens) : "",
          bondedTokens: isSet(object.bondedTokens) ? String(object.bondedTokens) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePool();
        message.notBondedTokens = (_a = object.notBondedTokens) !== null && _a !== void 0 ? _a : "";
        message.bondedTokens = (_b = object.bondedTokens) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js
var require_tx11 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgUndelegateResponse = exports2.MsgUndelegate = exports2.MsgBeginRedelegateResponse = exports2.MsgBeginRedelegate = exports2.MsgDelegateResponse = exports2.MsgDelegate = exports2.MsgEditValidatorResponse = exports2.MsgEditValidator = exports2.MsgCreateValidatorResponse = exports2.MsgCreateValidator = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var coin_1 = require_coin();
    var staking_1 = require_staking();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator() {
      return {
        description: void 0,
        commission: void 0,
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: void 0
      };
    }
    exports2.MsgCreateValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          description: isSet(object.description) ? staking_1.Description.fromJSON(object.description) : void 0,
          commission: isSet(object.commission) ? staking_1.CommissionRates.fromJSON(object.commission) : void 0,
          minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : "",
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          pubkey: isSet(object.pubkey) ? any_1.Any.fromJSON(object.pubkey) : void 0,
          value: isSet(object.value) ? coin_1.Coin.fromJSON(object.value) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgCreateValidator();
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromPartial(object.description) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? staking_1.CommissionRates.fromPartial(object.commission) : void 0;
        message.minSelfDelegation = (_a = object.minSelfDelegation) !== null && _a !== void 0 ? _a : "";
        message.delegatorAddress = (_b = object.delegatorAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        message.pubkey = object.pubkey !== void 0 && object.pubkey !== null ? any_1.Any.fromPartial(object.pubkey) : void 0;
        message.value = object.value !== void 0 && object.value !== null ? coin_1.Coin.fromPartial(object.value) : void 0;
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse() {
      return {};
    }
    exports2.MsgCreateValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
      }
    };
    function createBaseMsgEditValidator() {
      return { description: void 0, validatorAddress: "", commissionRate: "", minSelfDelegation: "" };
    }
    exports2.MsgEditValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          description: isSet(object.description) ? staking_1.Description.fromJSON(object.description) : void 0,
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          commissionRate: isSet(object.commissionRate) ? String(object.commissionRate) : "",
          minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgEditValidator();
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromPartial(object.description) : void 0;
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        message.commissionRate = (_b = object.commissionRate) !== null && _b !== void 0 ? _b : "";
        message.minSelfDelegation = (_c = object.minSelfDelegation) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse() {
      return {};
    }
    exports2.MsgEditValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
      }
    };
    function createBaseMsgDelegate() {
      return { delegatorAddress: "", validatorAddress: "", amount: void 0 };
    }
    exports2.MsgDelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgDelegate();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgDelegateResponse() {
      return {};
    }
    exports2.MsgDelegateResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDelegateResponse();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate() {
      return { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "", amount: void 0 };
    }
    exports2.MsgBeginRedelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorSrcAddress: isSet(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
          validatorDstAddress: isSet(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
          amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse() {
      return { completionTime: void 0 };
    }
    exports2.MsgBeginRedelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegateResponse();
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        return message;
      }
    };
    function createBaseMsgUndelegate() {
      return { delegatorAddress: "", validatorAddress: "", amount: void 0 };
    }
    exports2.MsgUndelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
          amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgUndelegateResponse() {
      return { completionTime: void 0 };
    }
    exports2.MsgUndelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegateResponse();
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
      }
      CreateValidator(request) {
        const data = exports2.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data);
        return promise.then((data2) => exports2.MsgCreateValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      EditValidator(request) {
        const data = exports2.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data);
        return promise.then((data2) => exports2.MsgEditValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Delegate(request) {
        const data = exports2.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data);
        return promise.then((data2) => exports2.MsgDelegateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      BeginRedelegate(request) {
        const data = exports2.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data);
        return promise.then((data2) => exports2.MsgBeginRedelegateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Undelegate(request) {
        const data = exports2.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data);
        return promise.then((data2) => exports2.MsgUndelegateResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages7 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgUndelegateEncodeObject = exports2.isMsgEditValidatorEncodeObject = exports2.isMsgDelegateEncodeObject = exports2.isMsgCreateValidatorEncodeObject = exports2.isMsgBeginRedelegateEncodeObject = exports2.stakingTypes = void 0;
    var tx_1 = require_tx11();
    exports2.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate]
    ];
    function isMsgBeginRedelegateEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    exports2.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    function isMsgCreateValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    exports2.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    exports2.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    function isMsgEditValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    exports2.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    exports2.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
  }
});

// ../../node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js
var require_query13 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryPoolResponse = exports2.QueryPoolRequest = exports2.QueryHistoricalInfoResponse = exports2.QueryHistoricalInfoRequest = exports2.QueryDelegatorValidatorResponse = exports2.QueryDelegatorValidatorRequest = exports2.QueryDelegatorValidatorsResponse = exports2.QueryDelegatorValidatorsRequest = exports2.QueryRedelegationsResponse = exports2.QueryRedelegationsRequest = exports2.QueryDelegatorUnbondingDelegationsResponse = exports2.QueryDelegatorUnbondingDelegationsRequest = exports2.QueryDelegatorDelegationsResponse = exports2.QueryDelegatorDelegationsRequest = exports2.QueryUnbondingDelegationResponse = exports2.QueryUnbondingDelegationRequest = exports2.QueryDelegationResponse = exports2.QueryDelegationRequest = exports2.QueryValidatorUnbondingDelegationsResponse = exports2.QueryValidatorUnbondingDelegationsRequest = exports2.QueryValidatorDelegationsResponse = exports2.QueryValidatorDelegationsRequest = exports2.QueryValidatorResponse = exports2.QueryValidatorRequest = exports2.QueryValidatorsResponse = exports2.QueryValidatorsRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var staking_1 = require_staking();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseQueryValidatorsRequest() {
      return { status: "", pagination: void 0 };
    }
    exports2.QueryValidatorsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          status: isSet(object.status) ? String(object.status) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorsRequest();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorsResponse() {
      return { validators: [], pagination: void 0 };
    }
    exports2.QueryValidatorsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => staking_1.Validator.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorsResponse();
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.Validator.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorRequest() {
      return { validatorAddr: "" };
    }
    exports2.QueryValidatorRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { validatorAddr: isSet(object.validatorAddr) ? String(object.validatorAddr) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorRequest();
        message.validatorAddr = (_a = object.validatorAddr) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryValidatorResponse() {
      return { validator: void 0 };
    }
    exports2.QueryValidatorResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { validator: isSet(object.validator) ? staking_1.Validator.fromJSON(object.validator) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorResponse();
        message.validator = object.validator !== void 0 && object.validator !== null ? staking_1.Validator.fromPartial(object.validator) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsRequest() {
      return { validatorAddr: "", pagination: void 0 };
    }
    exports2.QueryValidatorDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorAddr: isSet(object.validatorAddr) ? String(object.validatorAddr) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorDelegationsRequest();
        message.validatorAddr = (_a = object.validatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsResponse() {
      return { delegationResponses: [], pagination: void 0 };
    }
    exports2.QueryValidatorDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegationResponses: Array.isArray(object === null || object === void 0 ? void 0 : object.delegationResponses) ? object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorDelegationsResponse();
        message.delegationResponses = ((_a = object.delegationResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsRequest() {
      return { validatorAddr: "", pagination: void 0 };
    }
    exports2.QueryValidatorUnbondingDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorAddr: isSet(object.validatorAddr) ? String(object.validatorAddr) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        message.validatorAddr = (_a = object.validatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsResponse() {
      return { unbondingResponses: [], pagination: void 0 };
    }
    exports2.QueryValidatorUnbondingDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unbondingResponses: Array.isArray(object === null || object === void 0 ? void 0 : object.unbondingResponses) ? object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        message.unbondingResponses = ((_a = object.unbondingResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegationRequest() {
      return { delegatorAddr: "", validatorAddr: "" };
    }
    exports2.QueryDelegationRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          validatorAddr: isSet(object.validatorAddr) ? String(object.validatorAddr) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryDelegationRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.validatorAddr = (_b = object.validatorAddr) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryDelegationResponse() {
      return { delegationResponse: void 0 };
    }
    exports2.QueryDelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegationResponse !== void 0) {
          staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegationResponse: isSet(object.delegationResponse) ? staking_1.DelegationResponse.fromJSON(object.delegationResponse) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegationResponse !== void 0 && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationResponse();
        message.delegationResponse = object.delegationResponse !== void 0 && object.delegationResponse !== null ? staking_1.DelegationResponse.fromPartial(object.delegationResponse) : void 0;
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationRequest() {
      return { delegatorAddr: "", validatorAddr: "" };
    }
    exports2.QueryUnbondingDelegationRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          validatorAddr: isSet(object.validatorAddr) ? String(object.validatorAddr) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryUnbondingDelegationRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.validatorAddr = (_b = object.validatorAddr) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationResponse() {
      return { unbond: void 0 };
    }
    exports2.QueryUnbondingDelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbond !== void 0) {
          staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { unbond: isSet(object.unbond) ? staking_1.UnbondingDelegation.fromJSON(object.unbond) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.unbond !== void 0 && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationResponse();
        message.unbond = object.unbond !== void 0 && object.unbond !== null ? staking_1.UnbondingDelegation.fromPartial(object.unbond) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsRequest() {
      return { delegatorAddr: "", pagination: void 0 };
    }
    exports2.QueryDelegatorDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorDelegationsRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsResponse() {
      return { delegationResponses: [], pagination: void 0 };
    }
    exports2.QueryDelegatorDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegationResponses: Array.isArray(object === null || object === void 0 ? void 0 : object.delegationResponses) ? object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorDelegationsResponse();
        message.delegationResponses = ((_a = object.delegationResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsRequest() {
      return { delegatorAddr: "", pagination: void 0 };
    }
    exports2.QueryDelegatorUnbondingDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsResponse() {
      return { unbondingResponses: [], pagination: void 0 };
    }
    exports2.QueryDelegatorUnbondingDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unbondingResponses: Array.isArray(object === null || object === void 0 ? void 0 : object.unbondingResponses) ? object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        message.unbondingResponses = ((_a = object.unbondingResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryRedelegationsRequest() {
      return { delegatorAddr: "", srcValidatorAddr: "", dstValidatorAddr: "", pagination: void 0 };
    }
    exports2.QueryRedelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
          writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
          writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.srcValidatorAddr = reader.string();
              break;
            case 3:
              message.dstValidatorAddr = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          srcValidatorAddr: isSet(object.srcValidatorAddr) ? String(object.srcValidatorAddr) : "",
          dstValidatorAddr: isSet(object.dstValidatorAddr) ? String(object.dstValidatorAddr) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== void 0 && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== void 0 && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseQueryRedelegationsRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.srcValidatorAddr = (_b = object.srcValidatorAddr) !== null && _b !== void 0 ? _b : "";
        message.dstValidatorAddr = (_c = object.dstValidatorAddr) !== null && _c !== void 0 ? _c : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryRedelegationsResponse() {
      return { redelegationResponses: [], pagination: void 0 };
    }
    exports2.QueryRedelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.redelegationResponses) {
          staking_1.RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redelegationResponses: Array.isArray(object === null || object === void 0 ? void 0 : object.redelegationResponses) ? object.redelegationResponses.map((e) => staking_1.RedelegationResponse.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.redelegationResponses) {
          obj.redelegationResponses = message.redelegationResponses.map((e) => e ? staking_1.RedelegationResponse.toJSON(e) : void 0);
        } else {
          obj.redelegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryRedelegationsResponse();
        message.redelegationResponses = ((_a = object.redelegationResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.RedelegationResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return { delegatorAddr: "", pagination: void 0 };
    }
    exports2.QueryDelegatorValidatorsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return { validators: [], pagination: void 0 };
    }
    exports2.QueryDelegatorValidatorsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => staking_1.Validator.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.Validator.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorRequest() {
      return { delegatorAddr: "", validatorAddr: "" };
    }
    exports2.QueryDelegatorValidatorRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddr: isSet(object.delegatorAddr) ? String(object.delegatorAddr) : "",
          validatorAddr: isSet(object.validatorAddr) ? String(object.validatorAddr) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryDelegatorValidatorRequest();
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.validatorAddr = (_b = object.validatorAddr) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorResponse() {
      return { validator: void 0 };
    }
    exports2.QueryDelegatorValidatorResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { validator: isSet(object.validator) ? staking_1.Validator.fromJSON(object.validator) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorResponse();
        message.validator = object.validator !== void 0 && object.validator !== null ? staking_1.Validator.fromPartial(object.validator) : void 0;
        return message;
      }
    };
    function createBaseQueryHistoricalInfoRequest() {
      return { height: long_1.default.ZERO };
    }
    exports2.QueryHistoricalInfoRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoRequest();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseQueryHistoricalInfoResponse() {
      return { hist: void 0 };
    }
    exports2.QueryHistoricalInfoResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hist !== void 0) {
          staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { hist: isSet(object.hist) ? staking_1.HistoricalInfo.fromJSON(object.hist) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.hist !== void 0 && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoResponse();
        message.hist = object.hist !== void 0 && object.hist !== null ? staking_1.HistoricalInfo.fromPartial(object.hist) : void 0;
        return message;
      }
    };
    function createBaseQueryPoolRequest() {
      return {};
    }
    exports2.QueryPoolRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryPoolRequest();
        return message;
      }
    };
    function createBaseQueryPoolResponse() {
      return { pool: void 0 };
    }
    exports2.QueryPoolResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pool !== void 0) {
          staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool = staking_1.Pool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pool: isSet(object.pool) ? staking_1.Pool.fromJSON(object.pool) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pool !== void 0 && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPoolResponse();
        message.pool = object.pool !== void 0 && object.pool !== null ? staking_1.Pool.fromPartial(object.pool) : void 0;
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return { params: void 0 };
    }
    exports2.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { params: isSet(object.params) ? staking_1.Params.fromJSON(object.params) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = object.params !== void 0 && object.params !== null ? staking_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
      }
      Validators(request) {
        const data = exports2.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data);
        return promise.then((data2) => exports2.QueryValidatorsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Validator(request) {
        const data = exports2.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data);
        return promise.then((data2) => exports2.QueryValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorDelegations(request) {
        const data = exports2.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data);
        return promise.then((data2) => exports2.QueryValidatorDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorUnbondingDelegations(request) {
        const data = exports2.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data);
        return promise.then((data2) => exports2.QueryValidatorUnbondingDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Delegation(request) {
        const data = exports2.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data);
        return promise.then((data2) => exports2.QueryDelegationResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UnbondingDelegation(request) {
        const data = exports2.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data);
        return promise.then((data2) => exports2.QueryUnbondingDelegationResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorDelegations(request) {
        const data = exports2.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data);
        return promise.then((data2) => exports2.QueryDelegatorDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorUnbondingDelegations(request) {
        const data = exports2.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data);
        return promise.then((data2) => exports2.QueryDelegatorUnbondingDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Redelegations(request) {
        const data = exports2.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data);
        return promise.then((data2) => exports2.QueryRedelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorValidators(request) {
        const data = exports2.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data2) => exports2.QueryDelegatorValidatorsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorValidator(request) {
        const data = exports2.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data);
        return promise.then((data2) => exports2.QueryDelegatorValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      HistoricalInfo(request) {
        const data = exports2.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data);
        return promise.then((data2) => exports2.QueryHistoricalInfoResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Pool(request) {
        const data = exports2.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data);
        return promise.then((data2) => exports2.QueryPoolResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupStakingExtension = void 0;
    var query_1 = require_query13();
    var long_1 = __importDefault(require_long());
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: long_1.default.fromNumber(height, true)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupStakingExtension = setupStakingExtension;
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/evidence.js
var require_evidence = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/evidence.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EvidenceList = exports2.LightClientAttackEvidence = exports2.DuplicateVoteEvidence = exports2.Evidence = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var timestamp_1 = require_timestamp();
    var types_1 = require_types2();
    var validator_1 = require_validator();
    exports2.protobufPackage = "tendermint.types";
    function createBaseEvidence() {
      return { duplicateVoteEvidence: void 0, lightClientAttackEvidence: void 0 };
    }
    exports2.Evidence = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.duplicateVoteEvidence !== void 0) {
          exports2.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
        }
        if (message.lightClientAttackEvidence !== void 0) {
          exports2.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.duplicateVoteEvidence = exports2.DuplicateVoteEvidence.decode(reader, reader.uint32());
              break;
            case 2:
              message.lightClientAttackEvidence = exports2.LightClientAttackEvidence.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          duplicateVoteEvidence: isSet(object.duplicateVoteEvidence) ? exports2.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence) : void 0,
          lightClientAttackEvidence: isSet(object.lightClientAttackEvidence) ? exports2.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.duplicateVoteEvidence !== void 0 && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports2.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : void 0);
        message.lightClientAttackEvidence !== void 0 && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports2.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidence();
        message.duplicateVoteEvidence = object.duplicateVoteEvidence !== void 0 && object.duplicateVoteEvidence !== null ? exports2.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence) : void 0;
        message.lightClientAttackEvidence = object.lightClientAttackEvidence !== void 0 && object.lightClientAttackEvidence !== null ? exports2.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence) : void 0;
        return message;
      }
    };
    function createBaseDuplicateVoteEvidence() {
      return {
        voteA: void 0,
        voteB: void 0,
        totalVotingPower: long_1.default.ZERO,
        validatorPower: long_1.default.ZERO,
        timestamp: void 0
      };
    }
    exports2.DuplicateVoteEvidence = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.voteA !== void 0) {
          types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteB !== void 0) {
          types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
        }
        if (!message.totalVotingPower.isZero()) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        if (!message.validatorPower.isZero()) {
          writer.uint32(32).int64(message.validatorPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuplicateVoteEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteA = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 2:
              message.voteB = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            case 4:
              message.validatorPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          voteA: isSet(object.voteA) ? types_1.Vote.fromJSON(object.voteA) : void 0,
          voteB: isSet(object.voteB) ? types_1.Vote.fromJSON(object.voteB) : void 0,
          totalVotingPower: isSet(object.totalVotingPower) ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO,
          validatorPower: isSet(object.validatorPower) ? long_1.default.fromValue(object.validatorPower) : long_1.default.ZERO,
          timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.voteA !== void 0 && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : void 0);
        message.voteB !== void 0 && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());
        message.validatorPower !== void 0 && (obj.validatorPower = (message.validatorPower || long_1.default.ZERO).toString());
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuplicateVoteEvidence();
        message.voteA = object.voteA !== void 0 && object.voteA !== null ? types_1.Vote.fromPartial(object.voteA) : void 0;
        message.voteB = object.voteB !== void 0 && object.voteB !== null ? types_1.Vote.fromPartial(object.voteB) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO;
        message.validatorPower = object.validatorPower !== void 0 && object.validatorPower !== null ? long_1.default.fromValue(object.validatorPower) : long_1.default.ZERO;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        return message;
      }
    };
    function createBaseLightClientAttackEvidence() {
      return {
        conflictingBlock: void 0,
        commonHeight: long_1.default.ZERO,
        byzantineValidators: [],
        totalVotingPower: long_1.default.ZERO,
        timestamp: void 0
      };
    }
    exports2.LightClientAttackEvidence = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.conflictingBlock !== void 0) {
          types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
        }
        if (!message.commonHeight.isZero()) {
          writer.uint32(16).int64(message.commonHeight);
        }
        for (const v of message.byzantineValidators) {
          validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (!message.totalVotingPower.isZero()) {
          writer.uint32(32).int64(message.totalVotingPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightClientAttackEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
              break;
            case 2:
              message.commonHeight = reader.int64();
              break;
            case 3:
              message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
              break;
            case 4:
              message.totalVotingPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          conflictingBlock: isSet(object.conflictingBlock) ? types_1.LightBlock.fromJSON(object.conflictingBlock) : void 0,
          commonHeight: isSet(object.commonHeight) ? long_1.default.fromValue(object.commonHeight) : long_1.default.ZERO,
          byzantineValidators: Array.isArray(object === null || object === void 0 ? void 0 : object.byzantineValidators) ? object.byzantineValidators.map((e) => validator_1.Validator.fromJSON(e)) : [],
          totalVotingPower: isSet(object.totalVotingPower) ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO,
          timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.conflictingBlock !== void 0 && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : void 0);
        message.commonHeight !== void 0 && (obj.commonHeight = (message.commonHeight || long_1.default.ZERO).toString());
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? validator_1.Validator.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseLightClientAttackEvidence();
        message.conflictingBlock = object.conflictingBlock !== void 0 && object.conflictingBlock !== null ? types_1.LightBlock.fromPartial(object.conflictingBlock) : void 0;
        message.commonHeight = object.commonHeight !== void 0 && object.commonHeight !== null ? long_1.default.fromValue(object.commonHeight) : long_1.default.ZERO;
        message.byzantineValidators = ((_a = object.byzantineValidators) === null || _a === void 0 ? void 0 : _a.map((e) => validator_1.Validator.fromPartial(e))) || [];
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        return message;
      }
    };
    function createBaseEvidenceList() {
      return { evidence: [] };
    }
    exports2.EvidenceList = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.evidence) {
          exports2.Evidence.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.evidence.push(exports2.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          evidence: Array.isArray(object === null || object === void 0 ? void 0 : object.evidence) ? object.evidence.map((e) => exports2.Evidence.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.evidence) {
          obj.evidence = message.evidence.map((e) => e ? exports2.Evidence.toJSON(e) : void 0);
        } else {
          obj.evidence = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseEvidenceList();
        message.evidence = ((_a = object.evidence) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Evidence.fromPartial(e))) || [];
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/block.js
var require_block = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/block.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Block = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var evidence_1 = require_evidence();
    var types_1 = require_types2();
    exports2.protobufPackage = "tendermint.types";
    function createBaseBlock() {
      return { header: void 0, data: void 0, evidence: void 0, lastCommit: void 0 };
    }
    exports2.Block = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        }
        if (message.lastCommit !== void 0) {
          types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = types_1.Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
              break;
            case 4:
              message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          header: isSet(object.header) ? types_1.Header.fromJSON(object.header) : void 0,
          data: isSet(object.data) ? types_1.Data.fromJSON(object.data) : void 0,
          evidence: isSet(object.evidence) ? evidence_1.EvidenceList.fromJSON(object.evidence) : void 0,
          lastCommit: isSet(object.lastCommit) ? types_1.Commit.fromJSON(object.lastCommit) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.data !== void 0 && (obj.data = message.data ? types_1.Data.toJSON(message.data) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : void 0);
        message.lastCommit !== void 0 && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlock();
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromPartial(object.header) : void 0;
        message.data = object.data !== void 0 && object.data !== null ? types_1.Data.fromPartial(object.data) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? evidence_1.EvidenceList.fromPartial(object.evidence) : void 0;
        message.lastCommit = object.lastCommit !== void 0 && object.lastCommit !== null ? types_1.Commit.fromPartial(object.lastCommit) : void 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/types/params.js
var require_params = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/types/params.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashedParams = exports2.VersionParams = exports2.ValidatorParams = exports2.EvidenceParams = exports2.BlockParams = exports2.ConsensusParams = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var duration_1 = require_duration();
    exports2.protobufPackage = "tendermint.types";
    function createBaseConsensusParams() {
      return { block: void 0, evidence: void 0, validator: void 0, version: void 0 };
    }
    exports2.ConsensusParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.block !== void 0) {
          exports2.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          exports2.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          exports2.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          exports2.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports2.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = exports2.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = exports2.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = exports2.VersionParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          block: isSet(object.block) ? exports2.BlockParams.fromJSON(object.block) : void 0,
          evidence: isSet(object.evidence) ? exports2.EvidenceParams.fromJSON(object.evidence) : void 0,
          validator: isSet(object.validator) ? exports2.ValidatorParams.fromJSON(object.validator) : void 0,
          version: isSet(object.version) ? exports2.VersionParams.fromJSON(object.version) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports2.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? exports2.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? exports2.VersionParams.toJSON(message.version) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusParams();
        message.block = object.block !== void 0 && object.block !== null ? exports2.BlockParams.fromPartial(object.block) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? exports2.EvidenceParams.fromPartial(object.evidence) : void 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? exports2.ValidatorParams.fromPartial(object.validator) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? exports2.VersionParams.fromPartial(object.version) : void 0;
        return message;
      }
    };
    function createBaseBlockParams() {
      return { maxBytes: long_1.default.ZERO, maxGas: long_1.default.ZERO, timeIotaMs: long_1.default.ZERO };
    }
    exports2.BlockParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxBytes.isZero()) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (!message.maxGas.isZero()) {
          writer.uint32(16).int64(message.maxGas);
        }
        if (!message.timeIotaMs.isZero()) {
          writer.uint32(24).int64(message.timeIotaMs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            case 3:
              message.timeIotaMs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          maxBytes: isSet(object.maxBytes) ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO,
          maxGas: isSet(object.maxGas) ? long_1.default.fromValue(object.maxGas) : long_1.default.ZERO,
          timeIotaMs: isSet(object.timeIotaMs) ? long_1.default.fromValue(object.timeIotaMs) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || long_1.default.ZERO).toString());
        message.timeIotaMs !== void 0 && (obj.timeIotaMs = (message.timeIotaMs || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockParams();
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO;
        message.maxGas = object.maxGas !== void 0 && object.maxGas !== null ? long_1.default.fromValue(object.maxGas) : long_1.default.ZERO;
        message.timeIotaMs = object.timeIotaMs !== void 0 && object.timeIotaMs !== null ? long_1.default.fromValue(object.timeIotaMs) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseEvidenceParams() {
      return { maxAgeNumBlocks: long_1.default.ZERO, maxAgeDuration: void 0, maxBytes: long_1.default.ZERO };
    }
    exports2.EvidenceParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxAgeNumBlocks.isZero()) {
          writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== void 0) {
          duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (!message.maxBytes.isZero()) {
          writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxAgeNumBlocks = reader.int64();
              break;
            case 2:
              message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxBytes = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          maxAgeNumBlocks: isSet(object.maxAgeNumBlocks) ? long_1.default.fromValue(object.maxAgeNumBlocks) : long_1.default.ZERO,
          maxAgeDuration: isSet(object.maxAgeDuration) ? duration_1.Duration.fromJSON(object.maxAgeDuration) : void 0,
          maxBytes: isSet(object.maxBytes) ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxAgeNumBlocks !== void 0 && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || long_1.default.ZERO).toString());
        message.maxAgeDuration !== void 0 && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : void 0);
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceParams();
        message.maxAgeNumBlocks = object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null ? long_1.default.fromValue(object.maxAgeNumBlocks) : long_1.default.ZERO;
        message.maxAgeDuration = object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null ? duration_1.Duration.fromPartial(object.maxAgeDuration) : void 0;
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseValidatorParams() {
      return { pubKeyTypes: [] };
    }
    exports2.ValidatorParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pubKeyTypes) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKeyTypes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pubKeyTypes: Array.isArray(object === null || object === void 0 ? void 0 : object.pubKeyTypes) ? object.pubKeyTypes.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes) {
          obj.pubKeyTypes = message.pubKeyTypes.map((e) => e);
        } else {
          obj.pubKeyTypes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorParams();
        message.pubKeyTypes = ((_a = object.pubKeyTypes) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVersionParams() {
      return { appVersion: long_1.default.UZERO };
    }
    exports2.VersionParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.appVersion.isZero()) {
          writer.uint32(8).uint64(message.appVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersionParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.appVersion = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { appVersion: isSet(object.appVersion) ? long_1.default.fromValue(object.appVersion) : long_1.default.UZERO };
      },
      toJSON(message) {
        const obj = {};
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersionParams();
        message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? long_1.default.fromValue(object.appVersion) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseHashedParams() {
      return { blockMaxBytes: long_1.default.ZERO, blockMaxGas: long_1.default.ZERO };
    }
    exports2.HashedParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.blockMaxBytes.isZero()) {
          writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (!message.blockMaxGas.isZero()) {
          writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockMaxBytes = reader.int64();
              break;
            case 2:
              message.blockMaxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockMaxBytes: isSet(object.blockMaxBytes) ? long_1.default.fromValue(object.blockMaxBytes) : long_1.default.ZERO,
          blockMaxGas: isSet(object.blockMaxGas) ? long_1.default.fromValue(object.blockMaxGas) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockMaxBytes !== void 0 && (obj.blockMaxBytes = (message.blockMaxBytes || long_1.default.ZERO).toString());
        message.blockMaxGas !== void 0 && (obj.blockMaxGas = (message.blockMaxGas || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHashedParams();
        message.blockMaxBytes = object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null ? long_1.default.fromValue(object.blockMaxBytes) : long_1.default.ZERO;
        message.blockMaxGas = object.blockMaxGas !== void 0 && object.blockMaxGas !== null ? long_1.default.fromValue(object.blockMaxGas) : long_1.default.ZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/tendermint/abci/types.js
var require_types3 = __commonJS({
  "../../node_modules/cosmjs-types/tendermint/abci/types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Event = exports2.LastCommitInfo = exports2.BlockParams = exports2.ConsensusParams = exports2.ResponseApplySnapshotChunk = exports2.ResponseLoadSnapshotChunk = exports2.ResponseOfferSnapshot = exports2.ResponseListSnapshots = exports2.ResponseCommit = exports2.ResponseEndBlock = exports2.ResponseDeliverTx = exports2.ResponseCheckTx = exports2.ResponseBeginBlock = exports2.ResponseQuery = exports2.ResponseInitChain = exports2.ResponseSetOption = exports2.ResponseInfo = exports2.ResponseFlush = exports2.ResponseEcho = exports2.ResponseException = exports2.Response = exports2.RequestApplySnapshotChunk = exports2.RequestLoadSnapshotChunk = exports2.RequestOfferSnapshot = exports2.RequestListSnapshots = exports2.RequestCommit = exports2.RequestEndBlock = exports2.RequestDeliverTx = exports2.RequestCheckTx = exports2.RequestBeginBlock = exports2.RequestQuery = exports2.RequestInitChain = exports2.RequestSetOption = exports2.RequestInfo = exports2.RequestFlush = exports2.RequestEcho = exports2.Request = exports2.responseApplySnapshotChunk_ResultToJSON = exports2.responseApplySnapshotChunk_ResultFromJSON = exports2.ResponseApplySnapshotChunk_Result = exports2.responseOfferSnapshot_ResultToJSON = exports2.responseOfferSnapshot_ResultFromJSON = exports2.ResponseOfferSnapshot_Result = exports2.evidenceTypeToJSON = exports2.evidenceTypeFromJSON = exports2.EvidenceType = exports2.checkTxTypeToJSON = exports2.checkTxTypeFromJSON = exports2.CheckTxType = exports2.protobufPackage = void 0;
    exports2.ABCIApplicationClientImpl = exports2.Snapshot = exports2.Evidence = exports2.VoteInfo = exports2.ValidatorUpdate = exports2.Validator = exports2.TxResult = exports2.EventAttribute = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var timestamp_1 = require_timestamp();
    var keys_1 = require_keys4();
    var proof_1 = require_proof();
    var params_1 = require_params();
    var types_1 = require_types2();
    exports2.protobufPackage = "tendermint.abci";
    var CheckTxType;
    (function(CheckTxType2) {
      CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
      CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
      CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CheckTxType = exports2.CheckTxType || (exports2.CheckTxType = {}));
    function checkTxTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "NEW":
          return CheckTxType.NEW;
        case 1:
        case "RECHECK":
          return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return CheckTxType.UNRECOGNIZED;
      }
    }
    exports2.checkTxTypeFromJSON = checkTxTypeFromJSON;
    function checkTxTypeToJSON(object) {
      switch (object) {
        case CheckTxType.NEW:
          return "NEW";
        case CheckTxType.RECHECK:
          return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.checkTxTypeToJSON = checkTxTypeToJSON;
    var EvidenceType;
    (function(EvidenceType2) {
      EvidenceType2[EvidenceType2["UNKNOWN"] = 0] = "UNKNOWN";
      EvidenceType2[EvidenceType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
      EvidenceType2[EvidenceType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
      EvidenceType2[EvidenceType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EvidenceType = exports2.EvidenceType || (exports2.EvidenceType = {}));
    function evidenceTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return EvidenceType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
          return EvidenceType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
          return EvidenceType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return EvidenceType.UNRECOGNIZED;
      }
    }
    exports2.evidenceTypeFromJSON = evidenceTypeFromJSON;
    function evidenceTypeToJSON(object) {
      switch (object) {
        case EvidenceType.UNKNOWN:
          return "UNKNOWN";
        case EvidenceType.DUPLICATE_VOTE:
          return "DUPLICATE_VOTE";
        case EvidenceType.LIGHT_CLIENT_ATTACK:
          return "LIGHT_CLIENT_ATTACK";
        case EvidenceType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.evidenceTypeToJSON = evidenceTypeToJSON;
    var ResponseOfferSnapshot_Result;
    (function(ResponseOfferSnapshot_Result2) {
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseOfferSnapshot_Result = exports2.ResponseOfferSnapshot_Result || (exports2.ResponseOfferSnapshot_Result = {}));
    function responseOfferSnapshot_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
          return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
          return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
          return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseOfferSnapshot_Result.UNRECOGNIZED;
      }
    }
    exports2.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
    function responseOfferSnapshot_ResultToJSON(object) {
      switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
          return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
          return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
          return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
          return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
          return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
    var ResponseApplySnapshotChunk_Result;
    (function(ResponseApplySnapshotChunk_Result2) {
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseApplySnapshotChunk_Result = exports2.ResponseApplySnapshotChunk_Result || (exports2.ResponseApplySnapshotChunk_Result = {}));
    function responseApplySnapshotChunk_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
          return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
      }
    }
    exports2.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
    function responseApplySnapshotChunk_ResultToJSON(object) {
      switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
          return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
          return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
          return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
          return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
          return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
    function createBaseRequest() {
      return {
        echo: void 0,
        flush: void 0,
        info: void 0,
        setOption: void 0,
        initChain: void 0,
        query: void 0,
        beginBlock: void 0,
        checkTx: void 0,
        deliverTx: void 0,
        endBlock: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0
      };
    }
    exports2.Request = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.echo !== void 0) {
          exports2.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports2.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports2.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.setOption !== void 0) {
          exports2.RequestSetOption.encode(message.setOption, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports2.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports2.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.beginBlock !== void 0) {
          exports2.RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports2.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.deliverTx !== void 0) {
          exports2.RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.endBlock !== void 0) {
          exports2.RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports2.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports2.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports2.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports2.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.echo = exports2.RequestEcho.decode(reader, reader.uint32());
              break;
            case 2:
              message.flush = exports2.RequestFlush.decode(reader, reader.uint32());
              break;
            case 3:
              message.info = exports2.RequestInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.setOption = exports2.RequestSetOption.decode(reader, reader.uint32());
              break;
            case 5:
              message.initChain = exports2.RequestInitChain.decode(reader, reader.uint32());
              break;
            case 6:
              message.query = exports2.RequestQuery.decode(reader, reader.uint32());
              break;
            case 7:
              message.beginBlock = exports2.RequestBeginBlock.decode(reader, reader.uint32());
              break;
            case 8:
              message.checkTx = exports2.RequestCheckTx.decode(reader, reader.uint32());
              break;
            case 9:
              message.deliverTx = exports2.RequestDeliverTx.decode(reader, reader.uint32());
              break;
            case 10:
              message.endBlock = exports2.RequestEndBlock.decode(reader, reader.uint32());
              break;
            case 11:
              message.commit = exports2.RequestCommit.decode(reader, reader.uint32());
              break;
            case 12:
              message.listSnapshots = exports2.RequestListSnapshots.decode(reader, reader.uint32());
              break;
            case 13:
              message.offerSnapshot = exports2.RequestOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 14:
              message.loadSnapshotChunk = exports2.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 15:
              message.applySnapshotChunk = exports2.RequestApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          echo: isSet(object.echo) ? exports2.RequestEcho.fromJSON(object.echo) : void 0,
          flush: isSet(object.flush) ? exports2.RequestFlush.fromJSON(object.flush) : void 0,
          info: isSet(object.info) ? exports2.RequestInfo.fromJSON(object.info) : void 0,
          setOption: isSet(object.setOption) ? exports2.RequestSetOption.fromJSON(object.setOption) : void 0,
          initChain: isSet(object.initChain) ? exports2.RequestInitChain.fromJSON(object.initChain) : void 0,
          query: isSet(object.query) ? exports2.RequestQuery.fromJSON(object.query) : void 0,
          beginBlock: isSet(object.beginBlock) ? exports2.RequestBeginBlock.fromJSON(object.beginBlock) : void 0,
          checkTx: isSet(object.checkTx) ? exports2.RequestCheckTx.fromJSON(object.checkTx) : void 0,
          deliverTx: isSet(object.deliverTx) ? exports2.RequestDeliverTx.fromJSON(object.deliverTx) : void 0,
          endBlock: isSet(object.endBlock) ? exports2.RequestEndBlock.fromJSON(object.endBlock) : void 0,
          commit: isSet(object.commit) ? exports2.RequestCommit.fromJSON(object.commit) : void 0,
          listSnapshots: isSet(object.listSnapshots) ? exports2.RequestListSnapshots.fromJSON(object.listSnapshots) : void 0,
          offerSnapshot: isSet(object.offerSnapshot) ? exports2.RequestOfferSnapshot.fromJSON(object.offerSnapshot) : void 0,
          loadSnapshotChunk: isSet(object.loadSnapshotChunk) ? exports2.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk) : void 0,
          applySnapshotChunk: isSet(object.applySnapshotChunk) ? exports2.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.echo !== void 0 && (obj.echo = message.echo ? exports2.RequestEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports2.RequestFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports2.RequestInfo.toJSON(message.info) : void 0);
        message.setOption !== void 0 && (obj.setOption = message.setOption ? exports2.RequestSetOption.toJSON(message.setOption) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports2.RequestInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports2.RequestQuery.toJSON(message.query) : void 0);
        message.beginBlock !== void 0 && (obj.beginBlock = message.beginBlock ? exports2.RequestBeginBlock.toJSON(message.beginBlock) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports2.RequestCheckTx.toJSON(message.checkTx) : void 0);
        message.deliverTx !== void 0 && (obj.deliverTx = message.deliverTx ? exports2.RequestDeliverTx.toJSON(message.deliverTx) : void 0);
        message.endBlock !== void 0 && (obj.endBlock = message.endBlock ? exports2.RequestEndBlock.toJSON(message.endBlock) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.RequestCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports2.RequestListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports2.RequestOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports2.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports2.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequest();
        message.echo = object.echo !== void 0 && object.echo !== null ? exports2.RequestEcho.fromPartial(object.echo) : void 0;
        message.flush = object.flush !== void 0 && object.flush !== null ? exports2.RequestFlush.fromPartial(object.flush) : void 0;
        message.info = object.info !== void 0 && object.info !== null ? exports2.RequestInfo.fromPartial(object.info) : void 0;
        message.setOption = object.setOption !== void 0 && object.setOption !== null ? exports2.RequestSetOption.fromPartial(object.setOption) : void 0;
        message.initChain = object.initChain !== void 0 && object.initChain !== null ? exports2.RequestInitChain.fromPartial(object.initChain) : void 0;
        message.query = object.query !== void 0 && object.query !== null ? exports2.RequestQuery.fromPartial(object.query) : void 0;
        message.beginBlock = object.beginBlock !== void 0 && object.beginBlock !== null ? exports2.RequestBeginBlock.fromPartial(object.beginBlock) : void 0;
        message.checkTx = object.checkTx !== void 0 && object.checkTx !== null ? exports2.RequestCheckTx.fromPartial(object.checkTx) : void 0;
        message.deliverTx = object.deliverTx !== void 0 && object.deliverTx !== null ? exports2.RequestDeliverTx.fromPartial(object.deliverTx) : void 0;
        message.endBlock = object.endBlock !== void 0 && object.endBlock !== null ? exports2.RequestEndBlock.fromPartial(object.endBlock) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports2.RequestCommit.fromPartial(object.commit) : void 0;
        message.listSnapshots = object.listSnapshots !== void 0 && object.listSnapshots !== null ? exports2.RequestListSnapshots.fromPartial(object.listSnapshots) : void 0;
        message.offerSnapshot = object.offerSnapshot !== void 0 && object.offerSnapshot !== null ? exports2.RequestOfferSnapshot.fromPartial(object.offerSnapshot) : void 0;
        message.loadSnapshotChunk = object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null ? exports2.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : void 0;
        message.applySnapshotChunk = object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null ? exports2.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : void 0;
        return message;
      }
    };
    function createBaseRequestEcho() {
      return { message: "" };
    }
    exports2.RequestEcho = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { message: isSet(object.message) ? String(object.message) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRequestEcho();
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseRequestFlush() {
      return {};
    }
    exports2.RequestFlush = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestFlush();
        return message;
      }
    };
    function createBaseRequestInfo() {
      return { version: "", blockVersion: long_1.default.UZERO, p2pVersion: long_1.default.UZERO };
    }
    exports2.RequestInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (!message.blockVersion.isZero()) {
          writer.uint32(16).uint64(message.blockVersion);
        }
        if (!message.p2pVersion.isZero()) {
          writer.uint32(24).uint64(message.p2pVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.blockVersion = reader.uint64();
              break;
            case 3:
              message.p2pVersion = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          version: isSet(object.version) ? String(object.version) : "",
          blockVersion: isSet(object.blockVersion) ? long_1.default.fromValue(object.blockVersion) : long_1.default.UZERO,
          p2pVersion: isSet(object.p2pVersion) ? long_1.default.fromValue(object.p2pVersion) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.blockVersion !== void 0 && (obj.blockVersion = (message.blockVersion || long_1.default.UZERO).toString());
        message.p2pVersion !== void 0 && (obj.p2pVersion = (message.p2pVersion || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRequestInfo();
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : "";
        message.blockVersion = object.blockVersion !== void 0 && object.blockVersion !== null ? long_1.default.fromValue(object.blockVersion) : long_1.default.UZERO;
        message.p2pVersion = object.p2pVersion !== void 0 && object.p2pVersion !== null ? long_1.default.fromValue(object.p2pVersion) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseRequestSetOption() {
      return { key: "", value: "" };
    }
    exports2.RequestSetOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestSetOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? String(object.key) : "",
          value: isSet(object.value) ? String(object.value) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRequestSetOption();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseRequestInitChain() {
      return {
        time: void 0,
        chainId: "",
        consensusParams: void 0,
        validators: [],
        appStateBytes: new Uint8Array(),
        initialHeight: long_1.default.ZERO
      };
    }
    exports2.RequestInitChain = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== void 0) {
          exports2.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports2.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
          writer.uint32(42).bytes(message.appStateBytes);
        }
        if (!message.initialHeight.isZero()) {
          writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.consensusParams = exports2.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.validators.push(exports2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 5:
              message.appStateBytes = reader.bytes();
              break;
            case 6:
              message.initialHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          time: isSet(object.time) ? fromJsonTimestamp(object.time) : void 0,
          chainId: isSet(object.chainId) ? String(object.chainId) : "",
          consensusParams: isSet(object.consensusParams) ? exports2.ConsensusParams.fromJSON(object.consensusParams) : void 0,
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => exports2.ValidatorUpdate.fromJSON(e)) : [],
          appStateBytes: isSet(object.appStateBytes) ? bytesFromBase64(object.appStateBytes) : new Uint8Array(),
          initialHeight: isSet(object.initialHeight) ? long_1.default.fromValue(object.initialHeight) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? exports2.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appStateBytes !== void 0 && (obj.appStateBytes = base64FromBytes(message.appStateBytes !== void 0 ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== void 0 && (obj.initialHeight = (message.initialHeight || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRequestInitChain();
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.consensusParams = object.consensusParams !== void 0 && object.consensusParams !== null ? exports2.ConsensusParams.fromPartial(object.consensusParams) : void 0;
        message.validators = ((_b = object.validators) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.ValidatorUpdate.fromPartial(e))) || [];
        message.appStateBytes = (_c = object.appStateBytes) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.initialHeight = object.initialHeight !== void 0 && object.initialHeight !== null ? long_1.default.fromValue(object.initialHeight) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseRequestQuery() {
      return { data: new Uint8Array(), path: "", height: long_1.default.ZERO, prove: false };
    }
    exports2.RequestQuery = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
          writer.uint32(18).string(message.path);
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
          writer.uint32(32).bool(message.prove);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.path = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.prove = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          path: isSet(object.path) ? String(object.path) : "",
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          prove: isSet(object.prove) ? Boolean(object.prove) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.path !== void 0 && (obj.path = message.path);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.prove !== void 0 && (obj.prove = message.prove);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRequestQuery();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.path = (_b = object.path) !== null && _b !== void 0 ? _b : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.prove = (_c = object.prove) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    function createBaseRequestBeginBlock() {
      return { hash: new Uint8Array(), header: void 0, lastCommitInfo: void 0, byzantineValidators: [] };
    }
    exports2.RequestBeginBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(18).fork()).ldelim();
        }
        if (message.lastCommitInfo !== void 0) {
          exports2.LastCommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.byzantineValidators) {
          exports2.Evidence.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestBeginBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.lastCommitInfo = exports2.LastCommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.byzantineValidators.push(exports2.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(),
          header: isSet(object.header) ? types_1.Header.fromJSON(object.header) : void 0,
          lastCommitInfo: isSet(object.lastCommitInfo) ? exports2.LastCommitInfo.fromJSON(object.lastCommitInfo) : void 0,
          byzantineValidators: Array.isArray(object === null || object === void 0 ? void 0 : object.byzantineValidators) ? object.byzantineValidators.map((e) => exports2.Evidence.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.lastCommitInfo !== void 0 && (obj.lastCommitInfo = message.lastCommitInfo ? exports2.LastCommitInfo.toJSON(message.lastCommitInfo) : void 0);
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? exports2.Evidence.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRequestBeginBlock();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromPartial(object.header) : void 0;
        message.lastCommitInfo = object.lastCommitInfo !== void 0 && object.lastCommitInfo !== null ? exports2.LastCommitInfo.fromPartial(object.lastCommitInfo) : void 0;
        message.byzantineValidators = ((_b = object.byzantineValidators) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.Evidence.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseRequestCheckTx() {
      return { tx: new Uint8Array(), type: 0 };
    }
    exports2.RequestCheckTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            case 2:
              message.type = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array(),
          type: isSet(object.type) ? checkTxTypeFromJSON(object.type) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = base64FromBytes(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.type !== void 0 && (obj.type = checkTxTypeToJSON(message.type));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRequestCheckTx();
        message.tx = (_a = object.tx) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseRequestDeliverTx() {
      return { tx: new Uint8Array() };
    }
    exports2.RequestDeliverTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestDeliverTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = base64FromBytes(message.tx !== void 0 ? message.tx : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRequestDeliverTx();
        message.tx = (_a = object.tx) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseRequestEndBlock() {
      return { height: long_1.default.ZERO };
    }
    exports2.RequestEndBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEndBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestEndBlock();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseRequestCommit() {
      return {};
    }
    exports2.RequestCommit = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestCommit();
        return message;
      }
    };
    function createBaseRequestListSnapshots() {
      return {};
    }
    exports2.RequestListSnapshots = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestListSnapshots();
        return message;
      }
    };
    function createBaseRequestOfferSnapshot() {
      return { snapshot: void 0, appHash: new Uint8Array() };
    }
    exports2.RequestOfferSnapshot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.snapshot !== void 0) {
          exports2.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(18).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshot = exports2.Snapshot.decode(reader, reader.uint32());
              break;
            case 2:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          snapshot: isSet(object.snapshot) ? exports2.Snapshot.fromJSON(object.snapshot) : void 0,
          appHash: isSet(object.appHash) ? bytesFromBase64(object.appHash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.snapshot !== void 0 && (obj.snapshot = message.snapshot ? exports2.Snapshot.toJSON(message.snapshot) : void 0);
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRequestOfferSnapshot();
        message.snapshot = object.snapshot !== void 0 && object.snapshot !== null ? exports2.Snapshot.fromPartial(object.snapshot) : void 0;
        message.appHash = (_a = object.appHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseRequestLoadSnapshotChunk() {
      return { height: long_1.default.UZERO, format: 0, chunk: 0 };
    }
    exports2.RequestLoadSnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
          writer.uint32(24).uint32(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunk = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.UZERO,
          format: isSet(object.format) ? Number(object.format) : 0,
          chunk: isSet(object.chunk) ? Number(object.chunk) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.UZERO).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunk !== void 0 && (obj.chunk = Math.round(message.chunk));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRequestLoadSnapshotChunk();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.UZERO;
        message.format = (_a = object.format) !== null && _a !== void 0 ? _a : 0;
        message.chunk = (_b = object.chunk) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseRequestApplySnapshotChunk() {
      return { index: 0, chunk: new Uint8Array(), sender: "" };
    }
    exports2.RequestApplySnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
          writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.chunk = reader.bytes();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          index: isSet(object.index) ? Number(object.index) : 0,
          chunk: isSet(object.chunk) ? bytesFromBase64(object.chunk) : new Uint8Array(),
          sender: isSet(object.sender) ? String(object.sender) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.chunk !== void 0 && (obj.chunk = base64FromBytes(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRequestApplySnapshotChunk();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.chunk = (_b = object.chunk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseResponse() {
      return {
        exception: void 0,
        echo: void 0,
        flush: void 0,
        info: void 0,
        setOption: void 0,
        initChain: void 0,
        query: void 0,
        beginBlock: void 0,
        checkTx: void 0,
        deliverTx: void 0,
        endBlock: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0
      };
    }
    exports2.Response = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exception !== void 0) {
          exports2.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== void 0) {
          exports2.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports2.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports2.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.setOption !== void 0) {
          exports2.ResponseSetOption.encode(message.setOption, writer.uint32(42).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports2.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports2.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.beginBlock !== void 0) {
          exports2.ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports2.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.deliverTx !== void 0) {
          exports2.ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();
        }
        if (message.endBlock !== void 0) {
          exports2.ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports2.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports2.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports2.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports2.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exception = exports2.ResponseException.decode(reader, reader.uint32());
              break;
            case 2:
              message.echo = exports2.ResponseEcho.decode(reader, reader.uint32());
              break;
            case 3:
              message.flush = exports2.ResponseFlush.decode(reader, reader.uint32());
              break;
            case 4:
              message.info = exports2.ResponseInfo.decode(reader, reader.uint32());
              break;
            case 5:
              message.setOption = exports2.ResponseSetOption.decode(reader, reader.uint32());
              break;
            case 6:
              message.initChain = exports2.ResponseInitChain.decode(reader, reader.uint32());
              break;
            case 7:
              message.query = exports2.ResponseQuery.decode(reader, reader.uint32());
              break;
            case 8:
              message.beginBlock = exports2.ResponseBeginBlock.decode(reader, reader.uint32());
              break;
            case 9:
              message.checkTx = exports2.ResponseCheckTx.decode(reader, reader.uint32());
              break;
            case 10:
              message.deliverTx = exports2.ResponseDeliverTx.decode(reader, reader.uint32());
              break;
            case 11:
              message.endBlock = exports2.ResponseEndBlock.decode(reader, reader.uint32());
              break;
            case 12:
              message.commit = exports2.ResponseCommit.decode(reader, reader.uint32());
              break;
            case 13:
              message.listSnapshots = exports2.ResponseListSnapshots.decode(reader, reader.uint32());
              break;
            case 14:
              message.offerSnapshot = exports2.ResponseOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 15:
              message.loadSnapshotChunk = exports2.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.applySnapshotChunk = exports2.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          exception: isSet(object.exception) ? exports2.ResponseException.fromJSON(object.exception) : void 0,
          echo: isSet(object.echo) ? exports2.ResponseEcho.fromJSON(object.echo) : void 0,
          flush: isSet(object.flush) ? exports2.ResponseFlush.fromJSON(object.flush) : void 0,
          info: isSet(object.info) ? exports2.ResponseInfo.fromJSON(object.info) : void 0,
          setOption: isSet(object.setOption) ? exports2.ResponseSetOption.fromJSON(object.setOption) : void 0,
          initChain: isSet(object.initChain) ? exports2.ResponseInitChain.fromJSON(object.initChain) : void 0,
          query: isSet(object.query) ? exports2.ResponseQuery.fromJSON(object.query) : void 0,
          beginBlock: isSet(object.beginBlock) ? exports2.ResponseBeginBlock.fromJSON(object.beginBlock) : void 0,
          checkTx: isSet(object.checkTx) ? exports2.ResponseCheckTx.fromJSON(object.checkTx) : void 0,
          deliverTx: isSet(object.deliverTx) ? exports2.ResponseDeliverTx.fromJSON(object.deliverTx) : void 0,
          endBlock: isSet(object.endBlock) ? exports2.ResponseEndBlock.fromJSON(object.endBlock) : void 0,
          commit: isSet(object.commit) ? exports2.ResponseCommit.fromJSON(object.commit) : void 0,
          listSnapshots: isSet(object.listSnapshots) ? exports2.ResponseListSnapshots.fromJSON(object.listSnapshots) : void 0,
          offerSnapshot: isSet(object.offerSnapshot) ? exports2.ResponseOfferSnapshot.fromJSON(object.offerSnapshot) : void 0,
          loadSnapshotChunk: isSet(object.loadSnapshotChunk) ? exports2.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk) : void 0,
          applySnapshotChunk: isSet(object.applySnapshotChunk) ? exports2.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.exception !== void 0 && (obj.exception = message.exception ? exports2.ResponseException.toJSON(message.exception) : void 0);
        message.echo !== void 0 && (obj.echo = message.echo ? exports2.ResponseEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports2.ResponseFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports2.ResponseInfo.toJSON(message.info) : void 0);
        message.setOption !== void 0 && (obj.setOption = message.setOption ? exports2.ResponseSetOption.toJSON(message.setOption) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports2.ResponseInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports2.ResponseQuery.toJSON(message.query) : void 0);
        message.beginBlock !== void 0 && (obj.beginBlock = message.beginBlock ? exports2.ResponseBeginBlock.toJSON(message.beginBlock) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports2.ResponseCheckTx.toJSON(message.checkTx) : void 0);
        message.deliverTx !== void 0 && (obj.deliverTx = message.deliverTx ? exports2.ResponseDeliverTx.toJSON(message.deliverTx) : void 0);
        message.endBlock !== void 0 && (obj.endBlock = message.endBlock ? exports2.ResponseEndBlock.toJSON(message.endBlock) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.ResponseCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports2.ResponseListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports2.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports2.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports2.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponse();
        message.exception = object.exception !== void 0 && object.exception !== null ? exports2.ResponseException.fromPartial(object.exception) : void 0;
        message.echo = object.echo !== void 0 && object.echo !== null ? exports2.ResponseEcho.fromPartial(object.echo) : void 0;
        message.flush = object.flush !== void 0 && object.flush !== null ? exports2.ResponseFlush.fromPartial(object.flush) : void 0;
        message.info = object.info !== void 0 && object.info !== null ? exports2.ResponseInfo.fromPartial(object.info) : void 0;
        message.setOption = object.setOption !== void 0 && object.setOption !== null ? exports2.ResponseSetOption.fromPartial(object.setOption) : void 0;
        message.initChain = object.initChain !== void 0 && object.initChain !== null ? exports2.ResponseInitChain.fromPartial(object.initChain) : void 0;
        message.query = object.query !== void 0 && object.query !== null ? exports2.ResponseQuery.fromPartial(object.query) : void 0;
        message.beginBlock = object.beginBlock !== void 0 && object.beginBlock !== null ? exports2.ResponseBeginBlock.fromPartial(object.beginBlock) : void 0;
        message.checkTx = object.checkTx !== void 0 && object.checkTx !== null ? exports2.ResponseCheckTx.fromPartial(object.checkTx) : void 0;
        message.deliverTx = object.deliverTx !== void 0 && object.deliverTx !== null ? exports2.ResponseDeliverTx.fromPartial(object.deliverTx) : void 0;
        message.endBlock = object.endBlock !== void 0 && object.endBlock !== null ? exports2.ResponseEndBlock.fromPartial(object.endBlock) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports2.ResponseCommit.fromPartial(object.commit) : void 0;
        message.listSnapshots = object.listSnapshots !== void 0 && object.listSnapshots !== null ? exports2.ResponseListSnapshots.fromPartial(object.listSnapshots) : void 0;
        message.offerSnapshot = object.offerSnapshot !== void 0 && object.offerSnapshot !== null ? exports2.ResponseOfferSnapshot.fromPartial(object.offerSnapshot) : void 0;
        message.loadSnapshotChunk = object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null ? exports2.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : void 0;
        message.applySnapshotChunk = object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null ? exports2.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : void 0;
        return message;
      }
    };
    function createBaseResponseException() {
      return { error: "" };
    }
    exports2.ResponseException = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.error !== "") {
          writer.uint32(10).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { error: isSet(object.error) ? String(object.error) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseException();
        message.error = (_a = object.error) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseResponseEcho() {
      return { message: "" };
    }
    exports2.ResponseEcho = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { message: isSet(object.message) ? String(object.message) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseEcho();
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseResponseFlush() {
      return {};
    }
    exports2.ResponseFlush = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseResponseFlush();
        return message;
      }
    };
    function createBaseResponseInfo() {
      return {
        data: "",
        version: "",
        appVersion: long_1.default.UZERO,
        lastBlockHeight: long_1.default.ZERO,
        lastBlockAppHash: new Uint8Array()
      };
    }
    exports2.ResponseInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data !== "") {
          writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (!message.appVersion.isZero()) {
          writer.uint32(24).uint64(message.appVersion);
        }
        if (!message.lastBlockHeight.isZero()) {
          writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
          writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.appVersion = reader.uint64();
              break;
            case 4:
              message.lastBlockHeight = reader.int64();
              break;
            case 5:
              message.lastBlockAppHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: isSet(object.data) ? String(object.data) : "",
          version: isSet(object.version) ? String(object.version) : "",
          appVersion: isSet(object.appVersion) ? long_1.default.fromValue(object.appVersion) : long_1.default.UZERO,
          lastBlockHeight: isSet(object.lastBlockHeight) ? long_1.default.fromValue(object.lastBlockHeight) : long_1.default.ZERO,
          lastBlockAppHash: isSet(object.lastBlockAppHash) ? bytesFromBase64(object.lastBlockAppHash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = message.data);
        message.version !== void 0 && (obj.version = message.version);
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || long_1.default.UZERO).toString());
        message.lastBlockHeight !== void 0 && (obj.lastBlockHeight = (message.lastBlockHeight || long_1.default.ZERO).toString());
        message.lastBlockAppHash !== void 0 && (obj.lastBlockAppHash = base64FromBytes(message.lastBlockAppHash !== void 0 ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseResponseInfo();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : "";
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? long_1.default.fromValue(object.appVersion) : long_1.default.UZERO;
        message.lastBlockHeight = object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null ? long_1.default.fromValue(object.lastBlockHeight) : long_1.default.ZERO;
        message.lastBlockAppHash = (_c = object.lastBlockAppHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseResponseSetOption() {
      return { code: 0, log: "", info: "" };
    }
    exports2.ResponseSetOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseSetOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          code: isSet(object.code) ? Number(object.code) : 0,
          log: isSet(object.log) ? String(object.log) : "",
          info: isSet(object.info) ? String(object.info) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseResponseSetOption();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.info = (_c = object.info) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseResponseInitChain() {
      return { consensusParams: void 0, validators: [], appHash: new Uint8Array() };
    }
    exports2.ResponseInitChain = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusParams !== void 0) {
          exports2.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports2.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(26).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusParams = exports2.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.validators.push(exports2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 3:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          consensusParams: isSet(object.consensusParams) ? exports2.ConsensusParams.fromJSON(object.consensusParams) : void 0,
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => exports2.ValidatorUpdate.fromJSON(e)) : [],
          appHash: isSet(object.appHash) ? bytesFromBase64(object.appHash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? exports2.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseResponseInitChain();
        message.consensusParams = object.consensusParams !== void 0 && object.consensusParams !== null ? exports2.ConsensusParams.fromPartial(object.consensusParams) : void 0;
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.ValidatorUpdate.fromPartial(e))) || [];
        message.appHash = (_b = object.appHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseResponseQuery() {
      return {
        code: 0,
        log: "",
        info: "",
        index: long_1.default.ZERO,
        key: new Uint8Array(),
        value: new Uint8Array(),
        proofOps: void 0,
        height: long_1.default.ZERO,
        codespace: ""
      };
    }
    exports2.ResponseQuery = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (!message.index.isZero()) {
          writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
          writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== void 0) {
          proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (!message.height.isZero()) {
          writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
          writer.uint32(82).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.index = reader.int64();
              break;
            case 6:
              message.key = reader.bytes();
              break;
            case 7:
              message.value = reader.bytes();
              break;
            case 8:
              message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
              break;
            case 9:
              message.height = reader.int64();
              break;
            case 10:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          code: isSet(object.code) ? Number(object.code) : 0,
          log: isSet(object.log) ? String(object.log) : "",
          info: isSet(object.info) ? String(object.info) : "",
          index: isSet(object.index) ? long_1.default.fromValue(object.index) : long_1.default.ZERO,
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),
          proofOps: isSet(object.proofOps) ? proof_1.ProofOps.fromJSON(object.proofOps) : void 0,
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          codespace: isSet(object.codespace) ? String(object.codespace) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.index !== void 0 && (obj.index = (message.index || long_1.default.ZERO).toString());
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.proofOps !== void 0 && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : void 0);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseResponseQuery();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.info = (_c = object.info) !== null && _c !== void 0 ? _c : "";
        message.index = object.index !== void 0 && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.ZERO;
        message.key = (_d = object.key) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.value = (_e = object.value) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.proofOps = object.proofOps !== void 0 && object.proofOps !== null ? proof_1.ProofOps.fromPartial(object.proofOps) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.codespace = (_f = object.codespace) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseResponseBeginBlock() {
      return { events: [] };
    }
    exports2.ResponseBeginBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseBeginBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => exports2.Event.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseBeginBlock();
        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseCheckTx() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: long_1.default.ZERO,
        gasUsed: long_1.default.ZERO,
        events: [],
        codespace: ""
      };
    }
    exports2.ResponseCheckTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (!message.gasWanted.isZero()) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          code: isSet(object.code) ? Number(object.code) : 0,
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          log: isSet(object.log) ? String(object.log) : "",
          info: isSet(object.info) ? String(object.info) : "",
          gasWanted: isSet(object.gas_wanted) ? long_1.default.fromValue(object.gas_wanted) : long_1.default.ZERO,
          gasUsed: isSet(object.gas_used) ? long_1.default.fromValue(object.gas_used) : long_1.default.ZERO,
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => exports2.Event.fromJSON(e)) : [],
          codespace: isSet(object.codespace) ? String(object.codespace) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || long_1.default.ZERO).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || long_1.default.ZERO).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseResponseCheckTx();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.log = (_c = object.log) !== null && _c !== void 0 ? _c : "";
        message.info = (_d = object.info) !== null && _d !== void 0 ? _d : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO;
        message.events = ((_e = object.events) === null || _e === void 0 ? void 0 : _e.map((e) => exports2.Event.fromPartial(e))) || [];
        message.codespace = (_f = object.codespace) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseResponseDeliverTx() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: long_1.default.ZERO,
        gasUsed: long_1.default.ZERO,
        events: [],
        codespace: ""
      };
    }
    exports2.ResponseDeliverTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (!message.gasWanted.isZero()) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseDeliverTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          code: isSet(object.code) ? Number(object.code) : 0,
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          log: isSet(object.log) ? String(object.log) : "",
          info: isSet(object.info) ? String(object.info) : "",
          gasWanted: isSet(object.gas_wanted) ? long_1.default.fromValue(object.gas_wanted) : long_1.default.ZERO,
          gasUsed: isSet(object.gas_used) ? long_1.default.fromValue(object.gas_used) : long_1.default.ZERO,
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => exports2.Event.fromJSON(e)) : [],
          codespace: isSet(object.codespace) ? String(object.codespace) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || long_1.default.ZERO).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || long_1.default.ZERO).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseResponseDeliverTx();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.log = (_c = object.log) !== null && _c !== void 0 ? _c : "";
        message.info = (_d = object.info) !== null && _d !== void 0 ? _d : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO;
        message.events = ((_e = object.events) === null || _e === void 0 ? void 0 : _e.map((e) => exports2.Event.fromPartial(e))) || [];
        message.codespace = (_f = object.codespace) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseResponseEndBlock() {
      return { validatorUpdates: [], consensusParamUpdates: void 0, events: [] };
    }
    exports2.ResponseEndBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validatorUpdates) {
          exports2.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== void 0) {
          exports2.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEndBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorUpdates.push(exports2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 2:
              message.consensusParamUpdates = exports2.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.validatorUpdates) ? object.validatorUpdates.map((e) => exports2.ValidatorUpdate.fromJSON(e)) : [],
          consensusParamUpdates: isSet(object.consensusParamUpdates) ? exports2.ConsensusParams.fromJSON(object.consensusParamUpdates) : void 0,
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => exports2.Event.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorUpdates) {
          obj.validatorUpdates = message.validatorUpdates.map((e) => e ? exports2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validatorUpdates = [];
        }
        message.consensusParamUpdates !== void 0 && (obj.consensusParamUpdates = message.consensusParamUpdates ? exports2.ConsensusParams.toJSON(message.consensusParamUpdates) : void 0);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseResponseEndBlock();
        message.validatorUpdates = ((_a = object.validatorUpdates) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.ValidatorUpdate.fromPartial(e))) || [];
        message.consensusParamUpdates = object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null ? exports2.ConsensusParams.fromPartial(object.consensusParamUpdates) : void 0;
        message.events = ((_b = object.events) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseCommit() {
      return { data: new Uint8Array(), retainHeight: long_1.default.ZERO };
    }
    exports2.ResponseCommit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (!message.retainHeight.isZero()) {
          writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.retainHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          retainHeight: isSet(object.retainHeight) ? long_1.default.fromValue(object.retainHeight) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.retainHeight !== void 0 && (obj.retainHeight = (message.retainHeight || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseCommit();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.retainHeight = object.retainHeight !== void 0 && object.retainHeight !== null ? long_1.default.fromValue(object.retainHeight) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseResponseListSnapshots() {
      return { snapshots: [] };
    }
    exports2.ResponseListSnapshots = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.snapshots) {
          exports2.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshots.push(exports2.Snapshot.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          snapshots: Array.isArray(object === null || object === void 0 ? void 0 : object.snapshots) ? object.snapshots.map((e) => exports2.Snapshot.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.snapshots) {
          obj.snapshots = message.snapshots.map((e) => e ? exports2.Snapshot.toJSON(e) : void 0);
        } else {
          obj.snapshots = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseListSnapshots();
        message.snapshots = ((_a = object.snapshots) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.Snapshot.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseOfferSnapshot() {
      return { result: 0 };
    }
    exports2.ResponseOfferSnapshot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { result: isSet(object.result) ? responseOfferSnapshot_ResultFromJSON(object.result) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseOfferSnapshot();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseResponseLoadSnapshotChunk() {
      return { chunk: new Uint8Array() };
    }
    exports2.ResponseLoadSnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chunk.length !== 0) {
          writer.uint32(10).bytes(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chunk = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { chunk: isSet(object.chunk) ? bytesFromBase64(object.chunk) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.chunk !== void 0 && (obj.chunk = base64FromBytes(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseLoadSnapshotChunk();
        message.chunk = (_a = object.chunk) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseResponseApplySnapshotChunk() {
      return { result: 0, refetchChunks: [], rejectSenders: [] };
    }
    exports2.ResponseApplySnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v of message.refetchChunks) {
          writer.uint32(v);
        }
        writer.ldelim();
        for (const v of message.rejectSenders) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.refetchChunks.push(reader.uint32());
                }
              } else {
                message.refetchChunks.push(reader.uint32());
              }
              break;
            case 3:
              message.rejectSenders.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          result: isSet(object.result) ? responseApplySnapshotChunk_ResultFromJSON(object.result) : 0,
          refetchChunks: Array.isArray(object === null || object === void 0 ? void 0 : object.refetchChunks) ? object.refetchChunks.map((e) => Number(e)) : [],
          rejectSenders: Array.isArray(object === null || object === void 0 ? void 0 : object.rejectSenders) ? object.rejectSenders.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
        if (message.refetchChunks) {
          obj.refetchChunks = message.refetchChunks.map((e) => Math.round(e));
        } else {
          obj.refetchChunks = [];
        }
        if (message.rejectSenders) {
          obj.rejectSenders = message.rejectSenders.map((e) => e);
        } else {
          obj.rejectSenders = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseResponseApplySnapshotChunk();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        message.refetchChunks = ((_b = object.refetchChunks) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.rejectSenders = ((_c = object.rejectSenders) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseConsensusParams() {
      return { block: void 0, evidence: void 0, validator: void 0, version: void 0 };
    }
    exports2.ConsensusParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.block !== void 0) {
          exports2.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          params_1.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          params_1.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          params_1.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports2.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = params_1.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = params_1.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = params_1.VersionParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          block: isSet(object.block) ? exports2.BlockParams.fromJSON(object.block) : void 0,
          evidence: isSet(object.evidence) ? params_1.EvidenceParams.fromJSON(object.evidence) : void 0,
          validator: isSet(object.validator) ? params_1.ValidatorParams.fromJSON(object.validator) : void 0,
          version: isSet(object.version) ? params_1.VersionParams.fromJSON(object.version) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports2.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? params_1.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? params_1.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? params_1.VersionParams.toJSON(message.version) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusParams();
        message.block = object.block !== void 0 && object.block !== null ? exports2.BlockParams.fromPartial(object.block) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? params_1.EvidenceParams.fromPartial(object.evidence) : void 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? params_1.ValidatorParams.fromPartial(object.validator) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? params_1.VersionParams.fromPartial(object.version) : void 0;
        return message;
      }
    };
    function createBaseBlockParams() {
      return { maxBytes: long_1.default.ZERO, maxGas: long_1.default.ZERO };
    }
    exports2.BlockParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxBytes.isZero()) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (!message.maxGas.isZero()) {
          writer.uint32(16).int64(message.maxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          maxBytes: isSet(object.maxBytes) ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO,
          maxGas: isSet(object.maxGas) ? long_1.default.fromValue(object.maxGas) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockParams();
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO;
        message.maxGas = object.maxGas !== void 0 && object.maxGas !== null ? long_1.default.fromValue(object.maxGas) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseLastCommitInfo() {
      return { round: 0, votes: [] };
    }
    exports2.LastCommitInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports2.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLastCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports2.VoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          round: isSet(object.round) ? Number(object.round) : 0,
          votes: Array.isArray(object === null || object === void 0 ? void 0 : object.votes) ? object.votes.map((e) => exports2.VoteInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports2.VoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseLastCommitInfo();
        message.round = (_a = object.round) !== null && _a !== void 0 ? _a : 0;
        message.votes = ((_b = object.votes) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.VoteInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseEvent() {
      return { type: "", attributes: [] };
    }
    exports2.Event = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports2.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports2.EventAttribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet(object.type) ? String(object.type) : "",
          attributes: Array.isArray(object === null || object === void 0 ? void 0 : object.attributes) ? object.attributes.map((e) => exports2.EventAttribute.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports2.EventAttribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseEvent();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.attributes = ((_b = object.attributes) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.EventAttribute.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseEventAttribute() {
      return { key: new Uint8Array(), value: new Uint8Array(), index: false };
    }
    exports2.EventAttribute = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.index === true) {
          writer.uint32(24).bool(message.index);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.index = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),
          index: isSet(object.index) ? Boolean(object.index) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.index !== void 0 && (obj.index = message.index);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseEventAttribute();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.index = (_c = object.index) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    function createBaseTxResult() {
      return { height: long_1.default.ZERO, index: 0, tx: new Uint8Array(), result: void 0 };
    }
    exports2.TxResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
          writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
          writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== void 0) {
          exports2.ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.index = reader.uint32();
              break;
            case 3:
              message.tx = reader.bytes();
              break;
            case 4:
              message.result = exports2.ResponseDeliverTx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          index: isSet(object.index) ? Number(object.index) : 0,
          tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array(),
          result: isSet(object.result) ? exports2.ResponseDeliverTx.fromJSON(object.result) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.tx !== void 0 && (obj.tx = base64FromBytes(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.result !== void 0 && (obj.result = message.result ? exports2.ResponseDeliverTx.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTxResult();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.tx = (_b = object.tx) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.result = object.result !== void 0 && object.result !== null ? exports2.ResponseDeliverTx.fromPartial(object.result) : void 0;
        return message;
      }
    };
    function createBaseValidator() {
      return { address: new Uint8Array(), power: long_1.default.ZERO };
    }
    exports2.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (!message.power.isZero()) {
          writer.uint32(24).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 3:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(),
          power: isSet(object.power) ? long_1.default.fromValue(object.power) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = base64FromBytes(message.address !== void 0 ? message.address : new Uint8Array()));
        message.power !== void 0 && (obj.power = (message.power || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidator();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.power = object.power !== void 0 && object.power !== null ? long_1.default.fromValue(object.power) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseValidatorUpdate() {
      return { pubKey: void 0, power: long_1.default.ZERO };
    }
    exports2.ValidatorUpdate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (!message.power.isZero()) {
          writer.uint32(16).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pubKey: isSet(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0,
          power: isSet(object.power) ? long_1.default.fromValue(object.power) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.power !== void 0 && (obj.power = (message.power || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdate();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.power = object.power !== void 0 && object.power !== null ? long_1.default.fromValue(object.power) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseVoteInfo() {
      return { validator: void 0, signedLastBlock: false };
    }
    exports2.VoteInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== void 0) {
          exports2.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.signedLastBlock === true) {
          writer.uint32(16).bool(message.signedLastBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 2:
              message.signedLastBlock = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validator: isSet(object.validator) ? exports2.Validator.fromJSON(object.validator) : void 0,
          signedLastBlock: isSet(object.signedLastBlock) ? Boolean(object.signedLastBlock) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.Validator.toJSON(message.validator) : void 0);
        message.signedLastBlock !== void 0 && (obj.signedLastBlock = message.signedLastBlock);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseVoteInfo();
        message.validator = object.validator !== void 0 && object.validator !== null ? exports2.Validator.fromPartial(object.validator) : void 0;
        message.signedLastBlock = (_a = object.signedLastBlock) !== null && _a !== void 0 ? _a : false;
        return message;
      }
    };
    function createBaseEvidence() {
      return { type: 0, validator: void 0, height: long_1.default.ZERO, time: void 0, totalVotingPower: long_1.default.ZERO };
    }
    exports2.Evidence = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.validator !== void 0) {
          exports2.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (!message.totalVotingPower.isZero()) {
          writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.validator = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet(object.type) ? evidenceTypeFromJSON(object.type) : 0,
          validator: isSet(object.validator) ? exports2.Validator.fromJSON(object.validator) : void 0,
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          time: isSet(object.time) ? fromJsonTimestamp(object.time) : void 0,
          totalVotingPower: isSet(object.totalVotingPower) ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = evidenceTypeToJSON(message.type));
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.Validator.toJSON(message.validator) : void 0);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseEvidence();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? exports2.Validator.fromPartial(object.validator) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO;
        return message;
      }
    };
    function createBaseSnapshot() {
      return { height: long_1.default.UZERO, format: 0, chunks: 0, hash: new Uint8Array(), metadata: new Uint8Array() };
    }
    exports2.Snapshot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
          writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
          writer.uint32(42).bytes(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunks = reader.uint32();
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.metadata = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.UZERO,
          format: isSet(object.format) ? Number(object.format) : 0,
          chunks: isSet(object.chunks) ? Number(object.chunks) : 0,
          hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(),
          metadata: isSet(object.metadata) ? bytesFromBase64(object.metadata) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.UZERO).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunks !== void 0 && (obj.chunks = Math.round(message.chunks));
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.metadata !== void 0 && (obj.metadata = base64FromBytes(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSnapshot();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.UZERO;
        message.format = (_a = object.format) !== null && _a !== void 0 ? _a : 0;
        message.chunks = (_b = object.chunks) !== null && _b !== void 0 ? _b : 0;
        message.hash = (_c = object.hash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    var ABCIApplicationClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Echo = this.Echo.bind(this);
        this.Flush = this.Flush.bind(this);
        this.Info = this.Info.bind(this);
        this.SetOption = this.SetOption.bind(this);
        this.DeliverTx = this.DeliverTx.bind(this);
        this.CheckTx = this.CheckTx.bind(this);
        this.Query = this.Query.bind(this);
        this.Commit = this.Commit.bind(this);
        this.InitChain = this.InitChain.bind(this);
        this.BeginBlock = this.BeginBlock.bind(this);
        this.EndBlock = this.EndBlock.bind(this);
        this.ListSnapshots = this.ListSnapshots.bind(this);
        this.OfferSnapshot = this.OfferSnapshot.bind(this);
        this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this);
        this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this);
      }
      Echo(request) {
        const data = exports2.RequestEcho.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Echo", data);
        return promise.then((data2) => exports2.ResponseEcho.decode(new minimal_1.default.Reader(data2)));
      }
      Flush(request) {
        const data = exports2.RequestFlush.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Flush", data);
        return promise.then((data2) => exports2.ResponseFlush.decode(new minimal_1.default.Reader(data2)));
      }
      Info(request) {
        const data = exports2.RequestInfo.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Info", data);
        return promise.then((data2) => exports2.ResponseInfo.decode(new minimal_1.default.Reader(data2)));
      }
      SetOption(request) {
        const data = exports2.RequestSetOption.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "SetOption", data);
        return promise.then((data2) => exports2.ResponseSetOption.decode(new minimal_1.default.Reader(data2)));
      }
      DeliverTx(request) {
        const data = exports2.RequestDeliverTx.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", data);
        return promise.then((data2) => exports2.ResponseDeliverTx.decode(new minimal_1.default.Reader(data2)));
      }
      CheckTx(request) {
        const data = exports2.RequestCheckTx.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", data);
        return promise.then((data2) => exports2.ResponseCheckTx.decode(new minimal_1.default.Reader(data2)));
      }
      Query(request) {
        const data = exports2.RequestQuery.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Query", data);
        return promise.then((data2) => exports2.ResponseQuery.decode(new minimal_1.default.Reader(data2)));
      }
      Commit(request) {
        const data = exports2.RequestCommit.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Commit", data);
        return promise.then((data2) => exports2.ResponseCommit.decode(new minimal_1.default.Reader(data2)));
      }
      InitChain(request) {
        const data = exports2.RequestInitChain.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", data);
        return promise.then((data2) => exports2.ResponseInitChain.decode(new minimal_1.default.Reader(data2)));
      }
      BeginBlock(request) {
        const data = exports2.RequestBeginBlock.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", data);
        return promise.then((data2) => exports2.ResponseBeginBlock.decode(new minimal_1.default.Reader(data2)));
      }
      EndBlock(request) {
        const data = exports2.RequestEndBlock.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", data);
        return promise.then((data2) => exports2.ResponseEndBlock.decode(new minimal_1.default.Reader(data2)));
      }
      ListSnapshots(request) {
        const data = exports2.RequestListSnapshots.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", data);
        return promise.then((data2) => exports2.ResponseListSnapshots.decode(new minimal_1.default.Reader(data2)));
      }
      OfferSnapshot(request) {
        const data = exports2.RequestOfferSnapshot.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", data);
        return promise.then((data2) => exports2.ResponseOfferSnapshot.decode(new minimal_1.default.Reader(data2)));
      }
      LoadSnapshotChunk(request) {
        const data = exports2.RequestLoadSnapshotChunk.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", data);
        return promise.then((data2) => exports2.ResponseLoadSnapshotChunk.decode(new minimal_1.default.Reader(data2)));
      }
      ApplySnapshotChunk(request) {
        const data = exports2.RequestApplySnapshotChunk.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", data);
        return promise.then((data2) => exports2.ResponseApplySnapshotChunk.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.ABCIApplicationClientImpl = ABCIApplicationClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js
var require_abci = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SearchTxsResult = exports2.TxMsgData = exports2.MsgData = exports2.SimulationResponse = exports2.Result = exports2.GasInfo = exports2.Attribute = exports2.StringEvent = exports2.ABCIMessageLog = exports2.TxResponse = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    var types_1 = require_types3();
    exports2.protobufPackage = "cosmos.base.abci.v1beta1";
    function createBaseTxResponse() {
      return {
        height: long_1.default.ZERO,
        txhash: "",
        codespace: "",
        code: 0,
        data: "",
        rawLog: "",
        logs: [],
        info: "",
        gasWanted: long_1.default.ZERO,
        gasUsed: long_1.default.ZERO,
        tx: void 0,
        timestamp: "",
        events: []
      };
    }
    exports2.TxResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.txhash !== "") {
          writer.uint32(18).string(message.txhash);
        }
        if (message.codespace !== "") {
          writer.uint32(26).string(message.codespace);
        }
        if (message.code !== 0) {
          writer.uint32(32).uint32(message.code);
        }
        if (message.data !== "") {
          writer.uint32(42).string(message.data);
        }
        if (message.rawLog !== "") {
          writer.uint32(50).string(message.rawLog);
        }
        for (const v of message.logs) {
          exports2.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.info !== "") {
          writer.uint32(66).string(message.info);
        }
        if (!message.gasWanted.isZero()) {
          writer.uint32(72).int64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(80).int64(message.gasUsed);
        }
        if (message.tx !== void 0) {
          any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        }
        if (message.timestamp !== "") {
          writer.uint32(98).string(message.timestamp);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.txhash = reader.string();
              break;
            case 3:
              message.codespace = reader.string();
              break;
            case 4:
              message.code = reader.uint32();
              break;
            case 5:
              message.data = reader.string();
              break;
            case 6:
              message.rawLog = reader.string();
              break;
            case 7:
              message.logs.push(exports2.ABCIMessageLog.decode(reader, reader.uint32()));
              break;
            case 8:
              message.info = reader.string();
              break;
            case 9:
              message.gasWanted = reader.int64();
              break;
            case 10:
              message.gasUsed = reader.int64();
              break;
            case 11:
              message.tx = any_1.Any.decode(reader, reader.uint32());
              break;
            case 12:
              message.timestamp = reader.string();
              break;
            case 13:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          txhash: isSet(object.txhash) ? String(object.txhash) : "",
          codespace: isSet(object.codespace) ? String(object.codespace) : "",
          code: isSet(object.code) ? Number(object.code) : 0,
          data: isSet(object.data) ? String(object.data) : "",
          rawLog: isSet(object.rawLog) ? String(object.rawLog) : "",
          logs: Array.isArray(object === null || object === void 0 ? void 0 : object.logs) ? object.logs.map((e) => exports2.ABCIMessageLog.fromJSON(e)) : [],
          info: isSet(object.info) ? String(object.info) : "",
          gasWanted: isSet(object.gasWanted) ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO,
          gasUsed: isSet(object.gasUsed) ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO,
          tx: isSet(object.tx) ? any_1.Any.fromJSON(object.tx) : void 0,
          timestamp: isSet(object.timestamp) ? String(object.timestamp) : "",
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => types_1.Event.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.txhash !== void 0 && (obj.txhash = message.txhash);
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = message.data);
        message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
        if (message.logs) {
          obj.logs = message.logs.map((e) => e ? exports2.ABCIMessageLog.toJSON(e) : void 0);
        } else {
          obj.logs = [];
        }
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || long_1.default.ZERO).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || long_1.default.ZERO).toString());
        message.tx !== void 0 && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseTxResponse();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.txhash = (_a = object.txhash) !== null && _a !== void 0 ? _a : "";
        message.codespace = (_b = object.codespace) !== null && _b !== void 0 ? _b : "";
        message.code = (_c = object.code) !== null && _c !== void 0 ? _c : 0;
        message.data = (_d = object.data) !== null && _d !== void 0 ? _d : "";
        message.rawLog = (_e = object.rawLog) !== null && _e !== void 0 ? _e : "";
        message.logs = ((_f = object.logs) === null || _f === void 0 ? void 0 : _f.map((e) => exports2.ABCIMessageLog.fromPartial(e))) || [];
        message.info = (_g = object.info) !== null && _g !== void 0 ? _g : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO;
        message.tx = object.tx !== void 0 && object.tx !== null ? any_1.Any.fromPartial(object.tx) : void 0;
        message.timestamp = (_h = object.timestamp) !== null && _h !== void 0 ? _h : "";
        message.events = ((_j = object.events) === null || _j === void 0 ? void 0 : _j.map((e) => types_1.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseABCIMessageLog() {
      return { msgIndex: 0, log: "", events: [] };
    }
    exports2.ABCIMessageLog = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msgIndex !== 0) {
          writer.uint32(8).uint32(message.msgIndex);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          exports2.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIMessageLog();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgIndex = reader.uint32();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(exports2.StringEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          msgIndex: isSet(object.msgIndex) ? Number(object.msgIndex) : 0,
          log: isSet(object.log) ? String(object.log) : "",
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => exports2.StringEvent.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.msgIndex !== void 0 && (obj.msgIndex = Math.round(message.msgIndex));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.StringEvent.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseABCIMessageLog();
        message.msgIndex = (_a = object.msgIndex) !== null && _a !== void 0 ? _a : 0;
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.events = ((_c = object.events) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.StringEvent.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseStringEvent() {
      return { type: "", attributes: [] };
    }
    exports2.StringEvent = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports2.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStringEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports2.Attribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet(object.type) ? String(object.type) : "",
          attributes: Array.isArray(object === null || object === void 0 ? void 0 : object.attributes) ? object.attributes.map((e) => exports2.Attribute.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports2.Attribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseStringEvent();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.attributes = ((_b = object.attributes) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.Attribute.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAttribute() {
      return { key: "", value: "" };
    }
    exports2.Attribute = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? String(object.key) : "",
          value: isSet(object.value) ? String(object.value) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseAttribute();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseGasInfo() {
      return { gasWanted: long_1.default.UZERO, gasUsed: long_1.default.UZERO };
    }
    exports2.GasInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.gasWanted.isZero()) {
          writer.uint32(8).uint64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(16).uint64(message.gasUsed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGasInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasWanted = reader.uint64();
              break;
            case 2:
              message.gasUsed = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          gasWanted: isSet(object.gasWanted) ? long_1.default.fromValue(object.gasWanted) : long_1.default.UZERO,
          gasUsed: isSet(object.gasUsed) ? long_1.default.fromValue(object.gasUsed) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || long_1.default.UZERO).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGasInfo();
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.UZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseResult() {
      return { data: new Uint8Array(), log: "", events: [] };
    }
    exports2.Result = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
          log: isSet(object.log) ? String(object.log) : "",
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => types_1.Event.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseResult();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.events = ((_c = object.events) === null || _c === void 0 ? void 0 : _c.map((e) => types_1.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSimulationResponse() {
      return { gasInfo: void 0, result: void 0 };
    }
    exports2.SimulationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.gasInfo !== void 0) {
          exports2.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          exports2.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = exports2.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = exports2.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          gasInfo: isSet(object.gasInfo) ? exports2.GasInfo.fromJSON(object.gasInfo) : void 0,
          result: isSet(object.result) ? exports2.Result.fromJSON(object.result) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? exports2.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? exports2.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulationResponse();
        message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? exports2.GasInfo.fromPartial(object.gasInfo) : void 0;
        message.result = object.result !== void 0 && object.result !== null ? exports2.Result.fromPartial(object.result) : void 0;
        return message;
      }
    };
    function createBaseMsgData() {
      return { msgType: "", data: new Uint8Array() };
    }
    exports2.MsgData = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msgType !== "") {
          writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgType = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          msgType: isSet(object.msgType) ? String(object.msgType) : "",
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.msgType !== void 0 && (obj.msgType = message.msgType);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgData();
        message.msgType = (_a = object.msgType) !== null && _a !== void 0 ? _a : "";
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseTxMsgData() {
      return { data: [] };
    }
    exports2.TxMsgData = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.data) {
          exports2.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data.push(exports2.MsgData.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { data: Array.isArray(object === null || object === void 0 ? void 0 : object.data) ? object.data.map((e) => exports2.MsgData.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.data) {
          obj.data = message.data.map((e) => e ? exports2.MsgData.toJSON(e) : void 0);
        } else {
          obj.data = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseTxMsgData();
        message.data = ((_a = object.data) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.MsgData.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSearchTxsResult() {
      return {
        totalCount: long_1.default.UZERO,
        count: long_1.default.UZERO,
        pageNumber: long_1.default.UZERO,
        pageTotal: long_1.default.UZERO,
        limit: long_1.default.UZERO,
        txs: []
      };
    }
    exports2.SearchTxsResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.totalCount.isZero()) {
          writer.uint32(8).uint64(message.totalCount);
        }
        if (!message.count.isZero()) {
          writer.uint32(16).uint64(message.count);
        }
        if (!message.pageNumber.isZero()) {
          writer.uint32(24).uint64(message.pageNumber);
        }
        if (!message.pageTotal.isZero()) {
          writer.uint32(32).uint64(message.pageTotal);
        }
        if (!message.limit.isZero()) {
          writer.uint32(40).uint64(message.limit);
        }
        for (const v of message.txs) {
          exports2.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchTxsResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.uint64();
              break;
            case 2:
              message.count = reader.uint64();
              break;
            case 3:
              message.pageNumber = reader.uint64();
              break;
            case 4:
              message.pageTotal = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.txs.push(exports2.TxResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          totalCount: isSet(object.totalCount) ? long_1.default.fromValue(object.totalCount) : long_1.default.UZERO,
          count: isSet(object.count) ? long_1.default.fromValue(object.count) : long_1.default.UZERO,
          pageNumber: isSet(object.pageNumber) ? long_1.default.fromValue(object.pageNumber) : long_1.default.UZERO,
          pageTotal: isSet(object.pageTotal) ? long_1.default.fromValue(object.pageTotal) : long_1.default.UZERO,
          limit: isSet(object.limit) ? long_1.default.fromValue(object.limit) : long_1.default.UZERO,
          txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs) ? object.txs.map((e) => exports2.TxResponse.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || long_1.default.UZERO).toString());
        message.count !== void 0 && (obj.count = (message.count || long_1.default.UZERO).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || long_1.default.UZERO).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || long_1.default.UZERO).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || long_1.default.UZERO).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? exports2.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSearchTxsResult();
        message.totalCount = object.totalCount !== void 0 && object.totalCount !== null ? long_1.default.fromValue(object.totalCount) : long_1.default.UZERO;
        message.count = object.count !== void 0 && object.count !== null ? long_1.default.fromValue(object.count) : long_1.default.UZERO;
        message.pageNumber = object.pageNumber !== void 0 && object.pageNumber !== null ? long_1.default.fromValue(object.pageNumber) : long_1.default.UZERO;
        message.pageTotal = object.pageTotal !== void 0 && object.pageTotal !== null ? long_1.default.fromValue(object.pageTotal) : long_1.default.UZERO;
        message.limit = object.limit !== void 0 && object.limit !== null ? long_1.default.fromValue(object.limit) : long_1.default.UZERO;
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.TxResponse.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js
var require_service2 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceClientImpl = exports2.GetBlockWithTxsResponse = exports2.GetBlockWithTxsRequest = exports2.GetTxResponse = exports2.GetTxRequest = exports2.SimulateResponse = exports2.SimulateRequest = exports2.BroadcastTxResponse = exports2.BroadcastTxRequest = exports2.GetTxsEventResponse = exports2.GetTxsEventRequest = exports2.broadcastModeToJSON = exports2.broadcastModeFromJSON = exports2.BroadcastMode = exports2.orderByToJSON = exports2.orderByFromJSON = exports2.OrderBy = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var block_1 = require_block();
    var types_1 = require_types2();
    var abci_1 = require_abci();
    var pagination_1 = require_pagination();
    var tx_1 = require_tx();
    exports2.protobufPackage = "cosmos.tx.v1beta1";
    var OrderBy;
    (function(OrderBy2) {
      OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
      OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
      OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
      OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OrderBy = exports2.OrderBy || (exports2.OrderBy = {}));
    function orderByFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_BY_UNSPECIFIED":
          return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
          return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
          return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OrderBy.UNRECOGNIZED;
      }
    }
    exports2.orderByFromJSON = orderByFromJSON;
    function orderByToJSON(object) {
      switch (object) {
        case OrderBy.ORDER_BY_UNSPECIFIED:
          return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
          return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
          return "ORDER_BY_DESC";
        case OrderBy.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.orderByToJSON = orderByToJSON;
    var BroadcastMode;
    (function(BroadcastMode2) {
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
      BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BroadcastMode = exports2.BroadcastMode || (exports2.BroadcastMode = {}));
    function broadcastModeFromJSON(object) {
      switch (object) {
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
          return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
          return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
          return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
          return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BroadcastMode.UNRECOGNIZED;
      }
    }
    exports2.broadcastModeFromJSON = broadcastModeFromJSON;
    function broadcastModeToJSON(object) {
      switch (object) {
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
          return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
          return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
          return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
          return "BROADCAST_MODE_ASYNC";
        case BroadcastMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.broadcastModeToJSON = broadcastModeToJSON;
    function createBaseGetTxsEventRequest() {
      return { events: [], pagination: void 0, orderBy: 0 };
    }
    exports2.GetTxsEventRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
          writer.uint32(24).int32(message.orderBy);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.orderBy = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => String(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0,
          orderBy: isSet(object.orderBy) ? orderByFromJSON(object.orderBy) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e);
        } else {
          obj.events = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseGetTxsEventRequest();
        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        message.orderBy = (_b = object.orderBy) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseGetTxsEventResponse() {
      return { txs: [], txResponses: [], pagination: void 0 };
    }
    exports2.GetTxsEventResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResponses) {
          abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs) ? object.txs.map((e) => tx_1.Tx.fromJSON(e)) : [],
          txResponses: Array.isArray(object === null || object === void 0 ? void 0 : object.txResponses) ? object.txResponses.map((e) => abci_1.TxResponse.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        if (message.txResponses) {
          obj.txResponses = message.txResponses.map((e) => e ? abci_1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseGetTxsEventResponse();
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => tx_1.Tx.fromPartial(e))) || [];
        message.txResponses = ((_b = object.txResponses) === null || _b === void 0 ? void 0 : _b.map((e) => abci_1.TxResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseBroadcastTxRequest() {
      return { txBytes: new Uint8Array(), mode: 0 };
    }
    exports2.BroadcastTxRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        if (message.mode !== 0) {
          writer.uint32(16).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            case 2:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          txBytes: isSet(object.txBytes) ? bytesFromBase64(object.txBytes) : new Uint8Array(),
          mode: isSet(object.mode) ? broadcastModeFromJSON(object.mode) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = base64FromBytes(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        message.mode !== void 0 && (obj.mode = broadcastModeToJSON(message.mode));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseBroadcastTxRequest();
        message.txBytes = (_a = object.txBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.mode = (_b = object.mode) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function createBaseBroadcastTxResponse() {
      return { txResponse: void 0 };
    }
    exports2.BroadcastTxResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { txResponse: isSet(object.txResponse) ? abci_1.TxResponse.fromJSON(object.txResponse) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxResponse();
        message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? abci_1.TxResponse.fromPartial(object.txResponse) : void 0;
        return message;
      }
    };
    function createBaseSimulateRequest() {
      return { tx: void 0, txBytes: new Uint8Array() };
    }
    exports2.SimulateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txBytes.length !== 0) {
          writer.uint32(18).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          tx: isSet(object.tx) ? tx_1.Tx.fromJSON(object.tx) : void 0,
          txBytes: isSet(object.txBytes) ? bytesFromBase64(object.txBytes) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txBytes !== void 0 && (obj.txBytes = base64FromBytes(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSimulateRequest();
        message.tx = object.tx !== void 0 && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : void 0;
        message.txBytes = (_a = object.txBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseSimulateResponse() {
      return { gasInfo: void 0, result: void 0 };
    }
    exports2.SimulateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.gasInfo !== void 0) {
          abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = abci_1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          gasInfo: isSet(object.gasInfo) ? abci_1.GasInfo.fromJSON(object.gasInfo) : void 0,
          result: isSet(object.result) ? abci_1.Result.fromJSON(object.result) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateResponse();
        message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? abci_1.GasInfo.fromPartial(object.gasInfo) : void 0;
        message.result = object.result !== void 0 && object.result !== null ? abci_1.Result.fromPartial(object.result) : void 0;
        return message;
      }
    };
    function createBaseGetTxRequest() {
      return { hash: "" };
    }
    exports2.GetTxRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { hash: isSet(object.hash) ? String(object.hash) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseGetTxRequest();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseGetTxResponse() {
      return { tx: void 0, txResponse: void 0 };
    }
    exports2.GetTxResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          tx: isSet(object.tx) ? tx_1.Tx.fromJSON(object.tx) : void 0,
          txResponse: isSet(object.txResponse) ? abci_1.TxResponse.fromJSON(object.txResponse) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxResponse();
        message.tx = object.tx !== void 0 && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : void 0;
        message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? abci_1.TxResponse.fromPartial(object.txResponse) : void 0;
        return message;
      }
    };
    function createBaseGetBlockWithTxsRequest() {
      return { height: long_1.default.ZERO, pagination: void 0 };
    }
    exports2.GetBlockWithTxsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsRequest();
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseGetBlockWithTxsResponse() {
      return { txs: [], blockId: void 0, block: void 0, pagination: void 0 };
    }
    exports2.GetBlockWithTxsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockId !== void 0) {
          types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
        }
        if (message.block !== void 0) {
          block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.blockId = types_1.BlockID.decode(reader, reader.uint32());
              break;
            case 3:
              message.block = block_1.Block.decode(reader, reader.uint32());
              break;
            case 4:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs) ? object.txs.map((e) => tx_1.Tx.fromJSON(e)) : [],
          blockId: isSet(object.blockId) ? types_1.BlockID.fromJSON(object.blockId) : void 0,
          block: isSet(object.block) ? block_1.Block.fromJSON(object.block) : void 0,
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        message.blockId !== void 0 && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : void 0);
        message.block !== void 0 && (obj.block = message.block ? block_1.Block.toJSON(message.block) : void 0);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseGetBlockWithTxsResponse();
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => tx_1.Tx.fromPartial(e))) || [];
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? types_1.BlockID.fromPartial(object.blockId) : void 0;
        message.block = object.block !== void 0 && object.block !== null ? block_1.Block.fromPartial(object.block) : void 0;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var ServiceClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
      }
      Simulate(request) {
        const data = exports2.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data);
        return promise.then((data2) => exports2.SimulateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GetTx(request) {
        const data = exports2.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data);
        return promise.then((data2) => exports2.GetTxResponse.decode(new minimal_1.default.Reader(data2)));
      }
      BroadcastTx(request) {
        const data = exports2.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data);
        return promise.then((data2) => exports2.BroadcastTxResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GetTxsEvent(request) {
        const data = exports2.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data);
        return promise.then((data2) => exports2.GetTxsEventResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GetBlockWithTxs(request) {
        const data = exports2.GetBlockWithTxsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data);
        return promise.then((data2) => exports2.GetBlockWithTxsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.ServiceClientImpl = ServiceClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupTxExtension = void 0;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service2();
    var tx_1 = require_tx();
    var long_1 = __importDefault(require_long());
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: long_1.default.fromNumber(sequence, true),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
    exports2.setupTxExtension = setupTxExtension;
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages11 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVestingAminoConverters = exports2.isAminoMsgCreateVestingAccount = void 0;
    var long_1 = __importDefault(require_long());
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    exports2.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: long_1.default.fromString(end_time),
            delayed
          })
        }
      };
    }
    exports2.createVestingAminoConverters = createVestingAminoConverters;
  }
});

// ../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js
var require_tx12 = __commonJS({
  "../../node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgCreateVestingAccountResponse = exports2.MsgCreateVestingAccount = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    exports2.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseMsgCreateVestingAccount() {
      return { fromAddress: "", toAddress: "", amount: [], endTime: long_1.default.ZERO, delayed: false };
    }
    exports2.MsgCreateVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (!message.endTime.isZero()) {
          writer.uint32(32).int64(message.endTime);
        }
        if (message.delayed === true) {
          writer.uint32(40).bool(message.delayed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.endTime = reader.int64();
              break;
            case 5:
              message.delayed = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : "",
          toAddress: isSet(object.toAddress) ? String(object.toAddress) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
          endTime: isSet(object.endTime) ? long_1.default.fromValue(object.endTime) : long_1.default.ZERO,
          delayed: isSet(object.delayed) ? Boolean(object.delayed) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || long_1.default.ZERO).toString());
        message.delayed !== void 0 && (obj.delayed = message.delayed);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgCreateVestingAccount();
        message.fromAddress = (_a = object.fromAddress) !== null && _a !== void 0 ? _a : "";
        message.toAddress = (_b = object.toAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.endTime = object.endTime !== void 0 && object.endTime !== null ? long_1.default.fromValue(object.endTime) : long_1.default.ZERO;
        message.delayed = (_d = object.delayed) !== null && _d !== void 0 ? _d : false;
        return message;
      }
    };
    function createBaseMsgCreateVestingAccountResponse() {
      return {};
    }
    exports2.MsgCreateVestingAccountResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateVestingAccountResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateVestingAccount = this.CreateVestingAccount.bind(this);
      }
      CreateVestingAccount(request) {
        const data = exports2.MsgCreateVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", data);
        return promise.then((data2) => exports2.MsgCreateVestingAccountResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages8 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.vestingTypes = void 0;
    var tx_1 = require_tx12();
    exports2.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// ../../node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/modules/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAminoMsgEditValidator = exports2.isAminoMsgDelegate = exports2.isAminoMsgCreateValidator = exports2.isAminoMsgBeginRedelegate = exports2.createStakingAminoConverters = exports2.setupSlashingExtension = exports2.isAminoMsgUnjail = exports2.createSlashingAminoConverters = exports2.setupMintExtension = exports2.setupIbcExtension = exports2.isMsgTransferEncodeObject = exports2.ibcTypes = exports2.isAminoMsgTransfer = exports2.createIbcAminoConverters = exports2.setupGovExtension = exports2.isMsgVoteWeightedEncodeObject = exports2.isMsgVoteEncodeObject = exports2.isMsgSubmitProposalEncodeObject = exports2.isMsgDepositEncodeObject = exports2.govTypes = exports2.isAminoMsgVoteWeighted = exports2.isAminoMsgVote = exports2.isAminoMsgSubmitProposal = exports2.isAminoMsgDeposit = exports2.createGovAminoConverters = exports2.setupFeegrantExtension = exports2.feegrantTypes = exports2.createFeegrantAminoConverters = exports2.isAminoMsgSubmitEvidence = exports2.createEvidenceAminoConverters = exports2.setupDistributionExtension = exports2.isMsgWithdrawDelegatorRewardEncodeObject = exports2.distributionTypes = exports2.isAminoMsgWithdrawValidatorCommission = exports2.isAminoMsgWithdrawDelegatorReward = exports2.isAminoMsgSetWithdrawAddress = exports2.isAminoMsgFundCommunityPool = exports2.createDistributionAminoConverters = exports2.isAminoMsgVerifyInvariant = exports2.createCrysisAminoConverters = exports2.setupBankExtension = exports2.isMsgSendEncodeObject = exports2.bankTypes = exports2.isAminoMsgSend = exports2.isAminoMsgMultiSend = exports2.createBankAminoConverters = exports2.setupAuthzExtension = exports2.authzTypes = exports2.createAuthzAminoConverters = exports2.setupAuthExtension = void 0;
    exports2.vestingTypes = exports2.isAminoMsgCreateVestingAccount = exports2.createVestingAminoConverters = exports2.setupTxExtension = exports2.setupStakingExtension = exports2.stakingTypes = exports2.isMsgUndelegateEncodeObject = exports2.isMsgEditValidatorEncodeObject = exports2.isMsgDelegateEncodeObject = exports2.isMsgCreateValidatorEncodeObject = exports2.isMsgBeginRedelegateEncodeObject = exports2.isAminoMsgUndelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports2, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports2, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports2, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports2, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports2, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports2, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports2, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports2, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports2, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports2, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports2, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports2, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports2, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports2, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports2, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports2, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports2, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports2, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports2, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports2, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports2, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports2, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports2, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports2, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports2, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createIbcAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_8.isAminoMsgTransfer;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports2, "ibcTypes", { enumerable: true, get: function() {
      return messages_6.ibcTypes;
    } });
    Object.defineProperty(exports2, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_6.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports2, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports2, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports2, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports2, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports2, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createStakingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUndelegate;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports2, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "stakingTypes", { enumerable: true, get: function() {
      return messages_7.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports2, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports2, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports2, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createVestingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateVestingAccount;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports2, "vestingTypes", { enumerable: true, get: function() {
      return messages_8.vestingTypes;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/multisignature.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeMultisignedTxBytes = exports2.makeMultisignedTx = exports2.makeCompactBitArray = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    var tx_2 = require_tx();
    var long_1 = __importDefault(require_long());
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    exports2.makeCompactBitArray = makeCompactBitArray;
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: long_1.default.fromNumber(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: long_1.default.fromString(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_2.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    exports2.makeMultisignedTx = makeMultisignedTx;
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_2.TxRaw.encode(signedTx).finish());
    }
    exports2.makeMultisignedTxBytes = makeMultisignedTxBytes;
  }
});

// ../../node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/search.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSearchByTagsQuery = exports2.isSearchBySentFromOrToQuery = exports2.isSearchByHeightQuery = void 0;
    function isSearchByHeightQuery(query) {
      return query.height !== void 0;
    }
    exports2.isSearchByHeightQuery = isSearchByHeightQuery;
    function isSearchBySentFromOrToQuery(query) {
      return query.sentFromOrTo !== void 0;
    }
    exports2.isSearchBySentFromOrToQuery = isSearchBySentFromOrToQuery;
    function isSearchByTagsQuery(query) {
      return query.tags !== void 0;
    }
    exports2.isSearchByTagsQuery = isSearchByTagsQuery;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pubkeyToAddress = exports2.pubkeyToRawAddress = exports2.rawSecp256k1PubkeyToRawAddress = exports2.rawEd25519PubkeyToRawAddress = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    exports2.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    exports2.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    function pubkeyToRawAddress(type, data) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    exports2.pubkeyToRawAddress = pubkeyToRawAddress;
    function pubkeyToAddress(type, data) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
    }
    exports2.pubkeyToAddress = pubkeyToAddress;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DateTime = exports2.toSeconds = exports2.fromSeconds = exports2.toRfc3339WithNanoseconds = exports2.fromRfc3339WithNanoseconds = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    exports2.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    function toRfc3339WithNanoseconds(dateTime) {
      var _a, _b;
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = (_b = (_a = dateTime.nanoseconds) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    exports2.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    exports2.fromSeconds = fromSeconds;
    function toSeconds(date) {
      var _a;
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + ((_a = date.nanoseconds) !== null && _a !== void 0 ? _a : 0)
      };
    }
    exports2.toSeconds = toSeconds;
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports2.DateTime = DateTime;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeJsonRpcId = void 0;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
    exports2.makeJsonRpcId = makeJsonRpcId;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/types.js
var require_types4 = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jsonRpcCode = exports2.isJsonRpcSuccessResponse = exports2.isJsonRpcErrorResponse = void 0;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    exports2.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports2.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    exports2.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonRpcClient = void 0;
    var stream_1 = require_build8();
    var types_1 = require_types4();
    var JsonRpcClient = class {
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports2.JsonRpcClient = JsonRpcClient;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isJsonCompatibleDictionary = exports2.isJsonCompatibleArray = exports2.isJsonCompatibleValue = void 0;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    exports2.isJsonCompatibleValue = isJsonCompatibleValue;
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    exports2.isJsonCompatibleArray = isJsonCompatibleArray;
    function isJsonCompatibleDictionary(data) {
      if (typeof data !== "object" || data === null) {
        return false;
      }
      if (Object.prototype.toString.call(data) !== "[object Object]") {
        return false;
      }
      return Object.values(data).every(isJsonCompatibleValue);
    }
    exports2.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseJsonRpcResponse = exports2.parseJsonRpcSuccessResponse = exports2.parseJsonRpcErrorResponse = exports2.parseJsonRpcRequest = exports2.parseJsonRpcId = void 0;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    exports2.parseJsonRpcId = parseJsonRpcId;
    function parseJsonRpcRequest(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);
      }
      const id = parseJsonRpcId(data);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data.method;
      if (typeof method !== "string") {
        throw new Error("Invalid method field");
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data.params
      };
    }
    exports2.parseJsonRpcRequest = parseJsonRpcRequest;
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data.error)
      };
    }
    exports2.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    function parseJsonRpcSuccessResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    exports2.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    function parseJsonRpcResponse(data) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data);
      }
      return response;
    }
    exports2.parseJsonRpcResponse = parseJsonRpcResponse;
  }
});

// ../../node_modules/@cosmjs/json-rpc/build/index.js
var require_build9 = __commonJS({
  "../../node_modules/@cosmjs/json-rpc/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jsonRpcCode = exports2.isJsonRpcSuccessResponse = exports2.isJsonRpcErrorResponse = exports2.parseJsonRpcSuccessResponse = exports2.parseJsonRpcResponse = exports2.parseJsonRpcRequest = exports2.parseJsonRpcId = exports2.parseJsonRpcErrorResponse = exports2.JsonRpcClient = exports2.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports2, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports2, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports2, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports2, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports2, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports2, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports2, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types4();
    Object.defineProperty(exports2, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports2, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports2, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/utils.js
var require_utils7 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve, reject, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../../node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "../../node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL2(input));
            } catch (err) {
              parsed = url.parse(input);
            }
            if (!isString(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/package.json
var require_package2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/package.json"(exports2, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.4",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://axios-http.com",
      devDependencies: {
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.3.0",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^23.0.0",
        "grunt-karma": "^4.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^4.0.2",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^6.3.2",
        "karma-chrome-launcher": "^3.1.0",
        "karma-firefox-launcher": "^2.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^4.3.6",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.8",
        "karma-webpack": "^4.0.2",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^8.2.1",
        sinon: "^4.5.0",
        "terser-webpack-plugin": "^4.2.3",
        typescript: "^4.0.5",
        "url-search-params": "^0.10.0",
        webpack: "^4.44.2",
        "webpack-dev-server": "^3.11.0"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.14.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var pkg = require_package2();
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var resolve = function resolve2(value) {
          resolvePromise(value);
        };
        var reject = function reject2(value) {
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        if ("User-Agent" in headers || "user-agent" in headers) {
          if (!headers["User-Agent"] && !headers["user-agent"]) {
            delete headers["User-Agent"];
            delete headers["user-agent"];
          }
        } else {
          headers["User-Agent"] = "axios/" + pkg.version;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config
            ));
          }
          headers["Content-Length"] = data.length;
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth) {
          delete headers.Authorization;
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                stream.destroy();
                reject(createError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  config,
                  null,
                  lastRequest
                ));
              }
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError(
              "error trying to parse `config.timeout` to int",
              config,
              "ERR_PARSE_TIMEOUT",
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            reject(createError(
              "timeout of " + timeout + "ms exceeded",
              config,
              config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ));
          });
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(cancel);
          });
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/validator.js
var require_validator2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var pkg = require_package2();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      isOlderVersion,
      assertOptions,
      validators
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator2();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils7();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.http = void 0;
    var axios_1 = __importDefault(require_axios2());
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, headers, request) {
      if (typeof fetch !== "undefined") {
        const settings = {
          method,
          body: request ? JSON.stringify(request) : void 0,
          headers: {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            "Content-Type": "application/json",
            ...headers
          }
        };
        return fetch(url, settings).then(filterBadStatus).then((res) => res.json());
      } else {
        return axios_1.default.request({ url, method, data: request, headers }).then((res) => res.data);
      }
    }
    exports2.http = http;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasProtocol = exports2.instanceOfRpcStreamingClient = void 0;
    function instanceOfRpcStreamingClient(client) {
      return typeof client.listen === "function";
    }
    exports2.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
    exports2.hasProtocol = hasProtocol;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpBatchClient = void 0;
    var json_rpc_1 = require_build9();
    var http_1 = require_http2();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      constructor(endpoint, options = {}) {
        var _a, _b;
        this.queue = [];
        this.options = {
          batchSizeLimit: (_a = options.batchSizeLimit) !== null && _a !== void 0 ? _a : defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: (_b = options.dispatchInterval) !== null && _b !== void 0 ? _b : defaultHttpBatchClientOptions.dispatchInterval
        };
        if (typeof endpoint === "string") {
          this.url = (0, rpcclient_1.hasProtocol)(endpoint) ? endpoint : "http://" + endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => this.tick(), options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        this.timer && clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s) => s.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s) => s.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s) => s.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports2.HttpBatchClient = HttpBatchClient;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = void 0;
    var json_rpc_1 = require_build9();
    var http_1 = require_http2();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      constructor(endpoint) {
        if (typeof endpoint === "string") {
          this.url = (0, rpcclient_1.hasProtocol)(endpoint) ? endpoint : "http://" + endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports2.HttpClient = HttpClient;
  }
});

// ../../node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "../../node_modules/node-gyp-build/node-gyp-build.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../../node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "../../node_modules/node-gyp-build/index.js"(exports2, module2) {
    if (typeof process.addon === "function") {
      module2.exports = process.addon.bind(process);
    } else {
      module2.exports = require_node_gyp_build();
    }
  }
});

// ../../node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "../../node_modules/bufferutil/fallback.js"(exports2, module2) {
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask2[i & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// ../../node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "../../node_modules/bufferutil/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module2.exports = require_fallback();
    }
  }
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require_bufferutil();
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "../../node_modules/utf-8-validate/fallback.js"(exports2, module2) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// ../../node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "../../node_modules/utf-8-validate/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module2.exports = require_fallback2();
    }
  }
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require_utf_8_validate();
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {String} [binaryType=nodebuffer] The type for binary data
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Boolean} [isServer=false] Specifies whether to operate in client or
       *     server mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       */
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {Buffer} data The data to frame
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {Buffer[]} The framed data as a list of `Buffer` instances
       * @public
       */
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {String} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      /**
       * Frames and sends a close message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @private
       */
      doClose(data, mask2, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a ping message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a pong message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a data message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @param {Object} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {Number} code The status code explaining why the connection is being
       *     closed
       * @param {String} reason A human-readable string explaining why the
       *     connection is closing
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      /**
       * Create a new `OpenEvent`.
       *
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {Object} error The error that generated this event
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} listener The listener to remove
       * @public
       */
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return void 0;
      }
      /* istanbul ignore next */
      set onclose(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return void 0;
      }
      /* istanbul ignore next */
      set onerror(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return void 0;
      }
      /* istanbul ignore next */
      set onopen(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return void 0;
      }
      /* istanbul ignore next */
      set onmessage(listener) {
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Number} [maxPayload=0] The maximum allowed message size
       * @private
       */
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {String} [data] A string explaining why the connection is closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalUnixSocket = isUnixSocket;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else {
          const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = /* @__PURE__ */ new Set();
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Close the server.
       *
       * @param {Function} [cb] Callback
       * @public
       */
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Object} extensions The accepted extensions
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// ../../node_modules/ws/index.js
var require_ws = __commonJS({
  "../../node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// ../../node_modules/isomorphic-ws/node.js
var require_node2 = __commonJS({
  "../../node_modules/isomorphic-ws/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// ../../node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "../../node_modules/@cosmjs/socket/build/socketwrapper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_node2());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.closed = false;
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data, (err) => err ? reject(err) : resolve());
          } else {
            this.socket.send(data);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports2.SocketWrapper = SocketWrapper;
  }
});

// ../../node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "../../node_modules/@cosmjs/socket/build/streamingsocket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data) {
        return this.socket.send(data);
      }
    };
    exports2.StreamingSocket = StreamingSocket;
  }
});

// ../../node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "../../node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueingStreamingSocket = exports2.ConnectionStatus = void 0;
    var stream_1 = require_build8();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus = exports2.ConnectionStatus || (exports2.ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.queue = [];
        this.isProcessingQueue = false;
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports2.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// ../../node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "../../node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.unconnected = true;
        this.disconnected = false;
        this.timeoutIndex = 0;
        this.reconnectTimeout = null;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports2.ReconnectingSocket = ReconnectingSocket;
  }
});

// ../../node_modules/@cosmjs/socket/build/index.js
var require_build10 = __commonJS({
  "../../node_modules/@cosmjs/socket/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamingSocket = exports2.SocketWrapper = exports2.ReconnectingSocket = exports2.QueueingStreamingSocket = exports2.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports2, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports2, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports2, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports2, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports2, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebsocketClient = void 0;
    var json_rpc_1 = require_build9();
    var socket_1 = require_build10();
    var stream_1 = require_build8();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexcepted message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      constructor(request, socket) {
        this.running = false;
        this.subscriptions = [];
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      constructor(baseUrl, onError = defaultErrorHandler) {
        this.subscriptionStreams = /* @__PURE__ */ new Map();
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        const cleanBaseUrl = (0, rpcclient_1.hasProtocol)(baseUrl) ? baseUrl : "ws://" + baseUrl;
        this.url = cleanBaseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports2.WebsocketClient = WebsocketClient;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebsocketClient = exports2.instanceOfRpcStreamingClient = exports2.HttpClient = exports2.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports2, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports2, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports2, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports2, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildQuery = exports2.SubscriptionEventType = exports2.Method = void 0;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method = exports2.Method || (exports2.Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType = exports2.SubscriptionEventType || (exports2.SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
    exports2.buildQuery = buildQuery;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VoteType = exports2.broadcastTxCommitSuccess = exports2.broadcastTxSyncSuccess = void 0;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    exports2.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    exports2.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType = exports2.VoteType || (exports2.VoteType = {}));
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createJsonRpcRequest = void 0;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
    exports2.createJsonRpcRequest = createJsonRpcRequest;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBlockId = exports2.encodeVersion = exports2.encodeBytes = exports2.encodeTime = exports2.encodeUvarint = exports2.encodeString = exports2.dictionaryToStringMap = exports2.may = exports2.assertNotEmpty = exports2.assertObject = exports2.assertArray = exports2.assertNumber = exports2.assertString = exports2.assertBoolean = exports2.assertSet = void 0;
    var encoding_1 = require_build();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    exports2.assertSet = assertSet;
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    exports2.assertBoolean = assertBoolean;
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    exports2.assertString = assertString;
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    exports2.assertNumber = assertNumber;
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    exports2.assertArray = assertArray;
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    exports2.assertObject = assertObject;
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    exports2.assertNotEmpty = assertNotEmpty;
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    exports2.may = may;
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    exports2.dictionaryToStringMap = dictionaryToStringMap;
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    exports2.encodeString = encodeString;
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    exports2.encodeUvarint = encodeUvarint;
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    exports2.encodeTime = encodeTime;
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    exports2.encodeBytes = encodeBytes;
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    exports2.encodeVersion = encodeVersion;
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
    exports2.encodeBlockId = encodeBlockId;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashBlock = exports2.hashTx = void 0;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    exports2.hashTx = hashTx;
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
    exports2.hashBlock = hashBlock;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.smallIntToApi = exports2.apiToBigInt = exports2.apiToSmallInt = void 0;
    var math_1 = require_build2();
    var encodings_1 = require_encodings();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    exports2.apiToSmallInt = apiToSmallInt;
    function apiToBigInt(input) {
      (0, encodings_1.assertString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    exports2.apiToBigInt = apiToBigInt;
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
    exports2.smallIntToApi = smallIntToApi;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = void 0;
    var encoding_1 = require_build();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports2.Params = Params;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types5 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag = exports2.BlockIdFlag || (exports2.BlockIdFlag = {}));
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses2 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Responses = exports2.decodeValidatorInfo = exports2.decodeValidatorGenesis = exports2.decodeValidatorUpdate = exports2.decodeEvent = void 0;
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types5();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      var _a, _b, _c, _d;
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)((_a = data.key) !== null && _a !== void 0 ? _a : "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)((_b = data.value) !== null && _b !== void 0 ? _b : "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)((_c = data.codespace) !== null && _c !== void 0 ? _c : ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)((_d = data.info) !== null && _d !== void 0 ? _d : "")
      };
    }
    function decodeAttribute(attribute) {
      var _a;
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)((_a = attribute.value) !== null && _a !== void 0 ? _a : ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    exports2.decodeEvent = decodeEvent;
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      var _a, _b, _c;
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)((_a = data.code) !== null && _a !== void 0 ? _a : 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToSmallInt)((_b = data.gas_wanted) !== null && _b !== void 0 ? _b : "0"),
        gasUsed: (0, inthelpers_1.apiToSmallInt)((_c = data.gas_used) !== null && _c !== void 0 ? _c : "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      var _a;
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((_a = data.power) !== null && _a !== void 0 ? _a : "0")
      };
    }
    exports2.decodeValidatorUpdate = decodeValidatorUpdate;
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      var _a;
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)((_a = data.app) !== null && _a !== void 0 ? _a : 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeOptionalTime(timestamp) {
      const nonZeroTime = timestamp && !timestamp.startsWith("0001-01-01");
      return nonZeroTime ? (0, dates_1.fromRfc3339WithNanoseconds)(timestamp) : void 0;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: decodeOptionalTime(data.timestamp),
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    exports2.decodeValidatorGenesis = decodeValidatorGenesis;
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    exports2.decodeValidatorInfo = decodeValidatorInfo;
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertNotEmpty)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      return {
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index)
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a, _b;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: (_b = (_a = data.evidence) === null || _a === void 0 ? void 0 : _a.evidence) !== null && _b !== void 0 ? _b : []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports2.Responses = Responses;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.adaptor34 = void 0;
    var hasher_1 = require_hasher();
    var requests_1 = require_requests2();
    var responses_1 = require_responses2();
    exports2.adaptor34 = {
      params: requests_1.Params,
      responses: responses_1.Responses,
      hashTx: hasher_1.hashTx,
      hashBlock: hasher_1.hashBlock
    };
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tendermint34Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Tendermint34Client = class {
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
        this.p = adaptor_1.adaptor34.params;
        this.r = adaptor_1.adaptor34.responses;
      }
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        if (typeof endpoint === "object") {
          return Tendermint34Client.create(new rpcclients_1.HttpClient(endpoint));
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          const rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
          return Tendermint34Client.create(rpcClient);
        }
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        const _version = await this.detectVersion(rpcClient);
        return new Tendermint34Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, this.p.encodeAbciInfo, this.r.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, this.p.encodeAbciQuery, this.r.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, this.p.encodeBlock, this.r.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, this.p.encodeBlockResults, this.r.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, this.p.encodeBlockSearch, this.r.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, this.p.encodeBlockchain, this.r.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, this.p.encodeCommit, this.r.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, this.p.encodeGenesis, this.r.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, this.p.encodeHealth, this.r.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, this.p.encodeNumUnconfirmedTxs, this.r.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, this.p.encodeStatus, this.r.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, this.r.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, this.r.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, this.r.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, this.p.encodeTx, this.r.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, this.p.encodeTxSearch, this.r.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, this.p.encodeValidators, this.r.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight !== null && blockHeight !== void 0 ? blockHeight : 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = this.p.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports2.Tendermint34Client = Tendermint34Client;
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tendermint34Client = exports2.VoteType = exports2.broadcastTxSyncSuccess = exports2.broadcastTxCommitSuccess = exports2.SubscriptionEventType = exports2.Method = void 0;
    var requests_1 = require_requests();
    Object.defineProperty(exports2, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports2, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports2, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports2, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports2, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports2, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// ../../node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build11 = __commonJS({
  "../../node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BlockIdFlag = exports2.Tendermint34Client = exports2.tendermint34 = exports2.VoteType = exports2.SubscriptionEventType = exports2.Method = exports2.broadcastTxSyncSuccess = exports2.broadcastTxCommitSuccess = exports2.WebsocketClient = exports2.HttpClient = exports2.HttpBatchClient = exports2.toSeconds = exports2.toRfc3339WithNanoseconds = exports2.fromSeconds = exports2.fromRfc3339WithNanoseconds = exports2.DateTime = exports2.rawSecp256k1PubkeyToRawAddress = exports2.rawEd25519PubkeyToRawAddress = exports2.pubkeyToRawAddress = exports2.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses2();
    Object.defineProperty(exports2, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports2, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports2, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports2, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports2, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports2, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports2, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports2, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports2, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports2, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports2, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports2, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports2, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports2, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports2, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports2, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports2, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports2.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports2, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    var types_1 = require_types5();
    Object.defineProperty(exports2, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// ../../node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/stargateclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StargateClient = exports2.BroadcastTxError = exports2.assertIsDeliverTxFailure = exports2.assertIsDeliverTxSuccess = exports2.isDeliverTxSuccess = exports2.isDeliverTxFailure = exports2.TimeoutError = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build3();
    var accounts_1 = require_accounts();
    var events_1 = require_events();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      constructor(message, txId) {
        super(message);
        this.txId = txId;
      }
    };
    exports2.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    exports2.isDeliverTxFailure = isDeliverTxFailure;
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    exports2.isDeliverTxSuccess = isDeliverTxSuccess;
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports2.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports2.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var BroadcastTxError = class extends Error {
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports2.BroadcastTxError = BroadcastTxError;
    var StargateClient = class {
      constructor(tmClient, options) {
        if (tmClient) {
          this.tmClient = tmClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(tmClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      static async connect(endpoint, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new StargateClient(tmClient, options);
      }
      getTmClient() {
        return this.tmClient;
      }
      forceGetTmClient() {
        if (!this.tmClient) {
          throw new Error("Tendermint client not available. You cannot use online functionality in offline mode.");
        }
        return this.tmClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetTmClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetTmClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetTmClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination === null || pagination === void 0 ? void 0 : pagination.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        var _a;
        let delegatedAmount;
        try {
          delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) === null || _a === void 0 ? void 0 : _a.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        var _a;
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;
      }
      async searchTx(query, filter = {}) {
        const minHeight = filter.minHeight || 0;
        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;
        if (maxHeight < minHeight)
          return [];
        function withFilters(originalQuery) {
          return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;
        }
        let txs;
        if ((0, search_1.isSearchByHeightQuery)(query)) {
          txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];
        } else if ((0, search_1.isSearchBySentFromOrToQuery)(query)) {
          const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);
          const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);
          const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));
          const sentHashes = sent.map((t) => t.hash);
          txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];
        } else if ((0, search_1.isSearchByTagsQuery)(query)) {
          const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(" AND "));
          txs = await this.txsQuery(rawQuery);
        } else {
          throw new Error("Unknown query type");
        }
        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);
        return filtered;
      }
      disconnect() {
        if (this.tmClient)
          this.tmClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        var _a;
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            events: result.events,
            rawLog: result.rawLog,
            transactionHash: txId,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, (_a = broadcasted.codespace) !== null && _a !== void 0 ? _a : "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      async txsQuery(query) {
        const results = await this.forceGetTmClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          return {
            height: tx.height,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermint34Event),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports2.StargateClient = StargateClient;
  }
});

// ../../node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SigningStargateClient = exports2.defaultRegistryTypes = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build3();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx11();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx7();
    var long_1 = __importDefault(require_long());
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var modules_2 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports2.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultRegistry() {
      return new proto_signing_1.Registry(exports2.defaultRegistryTypes);
    }
    function createDefaultTypes(prefix) {
      return {
        ...(0, modules_2.createAuthzAminoConverters)(),
        ...(0, modules_2.createBankAminoConverters)(),
        ...(0, modules_2.createDistributionAminoConverters)(),
        ...(0, modules_2.createGovAminoConverters)(),
        ...(0, modules_2.createStakingAminoConverters)(prefix),
        ...(0, modules_2.createIbcAminoConverters)(),
        ...(0, modules_2.createFeegrantAminoConverters)(),
        ...(0, modules_2.createVestingAminoConverters)()
      };
    }
    var SigningStargateClient = class extends stargateclient_1.StargateClient {
      constructor(tmClient, signer, options) {
        var _a;
        super(tmClient, options);
        const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : "cosmos";
        const { registry = createDefaultRegistry(), aminoTypes = new aminotypes_1.AminoTypes(createDefaultTypes(prefix)) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      static async connectWithSigner(endpoint, signer, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new SigningStargateClient(tmClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new SigningStargateClient(void 0, signer, options);
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? long_1.default.fromNumber(timeoutTimestamp).multiply(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : 1.3;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports2.SigningStargateClient = SigningStargateClient;
  }
});

// ../../node_modules/@cosmjs/stargate/build/index.js
var require_build12 = __commonJS({
  "../../node_modules/@cosmjs/stargate/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupAuthExtension = exports2.isMsgWithdrawDelegatorRewardEncodeObject = exports2.isMsgVoteWeightedEncodeObject = exports2.isMsgVoteEncodeObject = exports2.isMsgUndelegateEncodeObject = exports2.isMsgTransferEncodeObject = exports2.isMsgSubmitProposalEncodeObject = exports2.isMsgSendEncodeObject = exports2.isMsgEditValidatorEncodeObject = exports2.isMsgDepositEncodeObject = exports2.isMsgDelegateEncodeObject = exports2.isMsgCreateValidatorEncodeObject = exports2.isMsgBeginRedelegateEncodeObject = exports2.isAminoMsgWithdrawValidatorCommission = exports2.isAminoMsgWithdrawDelegatorReward = exports2.isAminoMsgVoteWeighted = exports2.isAminoMsgVote = exports2.isAminoMsgVerifyInvariant = exports2.isAminoMsgUnjail = exports2.isAminoMsgUndelegate = exports2.isAminoMsgTransfer = exports2.isAminoMsgSubmitProposal = exports2.isAminoMsgSubmitEvidence = exports2.isAminoMsgSetWithdrawAddress = exports2.isAminoMsgSend = exports2.isAminoMsgMultiSend = exports2.isAminoMsgFundCommunityPool = exports2.isAminoMsgEditValidator = exports2.isAminoMsgDeposit = exports2.isAminoMsgDelegate = exports2.isAminoMsgCreateVestingAccount = exports2.isAminoMsgCreateValidator = exports2.isAminoMsgBeginRedelegate = exports2.createVestingAminoConverters = exports2.createStakingAminoConverters = exports2.createSlashingAminoConverters = exports2.createIbcAminoConverters = exports2.createGovAminoConverters = exports2.createFeegrantAminoConverters = exports2.createEvidenceAminoConverters = exports2.createDistributionAminoConverters = exports2.createCrysisAminoConverters = exports2.createBankAminoConverters = exports2.createAuthzAminoConverters = exports2.logs = exports2.GasPrice = exports2.calculateFee = exports2.fromTendermint34Event = exports2.AminoTypes = exports2.accountFromAny = void 0;
    exports2.parseCoins = exports2.makeCosmoshubPath = exports2.coins = exports2.coin = exports2.TimeoutError = exports2.StargateClient = exports2.isDeliverTxSuccess = exports2.isDeliverTxFailure = exports2.BroadcastTxError = exports2.assertIsDeliverTxSuccess = exports2.assertIsDeliverTxFailure = exports2.SigningStargateClient = exports2.defaultRegistryTypes = exports2.isSearchByTagsQuery = exports2.isSearchBySentFromOrToQuery = exports2.isSearchByHeightQuery = exports2.QueryClient = exports2.decodeCosmosSdkDecFromProto = exports2.createProtobufRpcClient = exports2.createPagination = exports2.makeMultisignedTxBytes = exports2.makeMultisignedTx = exports2.setupTxExtension = exports2.setupStakingExtension = exports2.setupSlashingExtension = exports2.setupMintExtension = exports2.setupIbcExtension = exports2.setupGovExtension = exports2.setupFeegrantExtension = exports2.setupDistributionExtension = exports2.setupBankExtension = exports2.setupAuthzExtension = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports2, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports2, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "fromTendermint34Event", { enumerable: true, get: function() {
      return events_1.fromTendermint34Event;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports2, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports2, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports2.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports2, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports2, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports2, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports2, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports2, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports2, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports2, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports2, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports2, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports2, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports2, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports2, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports2, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports2, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports2, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports2, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports2, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports2, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports2, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports2, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports2, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports2, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports2, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports2, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports2, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports2, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports2, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports2, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports2, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports2, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports2, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports2, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports2, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports2, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports2, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports2, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports2, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports2, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports2, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports2, "isSearchByHeightQuery", { enumerable: true, get: function() {
      return search_1.isSearchByHeightQuery;
    } });
    Object.defineProperty(exports2, "isSearchBySentFromOrToQuery", { enumerable: true, get: function() {
      return search_1.isSearchBySentFromOrToQuery;
    } });
    Object.defineProperty(exports2, "isSearchByTagsQuery", { enumerable: true, get: function() {
      return search_1.isSearchByTagsQuery;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports2, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports2, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports2, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports2, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports2, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports2, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports2, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports2, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports2, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports2, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports2, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports2, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

// ../../node_modules/cosmjs-types/cosmwasm/wasm/v1/types.js
var require_types6 = __commonJS({
  "../../node_modules/cosmjs-types/cosmwasm/wasm/v1/types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Model = exports2.AbsoluteTxPosition = exports2.ContractCodeHistoryEntry = exports2.ContractInfo = exports2.CodeInfo = exports2.Params = exports2.AccessConfig = exports2.AccessTypeParam = exports2.contractCodeHistoryOperationTypeToJSON = exports2.contractCodeHistoryOperationTypeFromJSON = exports2.ContractCodeHistoryOperationType = exports2.accessTypeToJSON = exports2.accessTypeFromJSON = exports2.AccessType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var any_1 = require_any();
    exports2.protobufPackage = "cosmwasm.wasm.v1";
    var AccessType;
    (function(AccessType2) {
      AccessType2[AccessType2["ACCESS_TYPE_UNSPECIFIED"] = 0] = "ACCESS_TYPE_UNSPECIFIED";
      AccessType2[AccessType2["ACCESS_TYPE_NOBODY"] = 1] = "ACCESS_TYPE_NOBODY";
      AccessType2[AccessType2["ACCESS_TYPE_ONLY_ADDRESS"] = 2] = "ACCESS_TYPE_ONLY_ADDRESS";
      AccessType2[AccessType2["ACCESS_TYPE_EVERYBODY"] = 3] = "ACCESS_TYPE_EVERYBODY";
      AccessType2[AccessType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AccessType = exports2.AccessType || (exports2.AccessType = {}));
    function accessTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "ACCESS_TYPE_UNSPECIFIED":
          return AccessType.ACCESS_TYPE_UNSPECIFIED;
        case 1:
        case "ACCESS_TYPE_NOBODY":
          return AccessType.ACCESS_TYPE_NOBODY;
        case 2:
        case "ACCESS_TYPE_ONLY_ADDRESS":
          return AccessType.ACCESS_TYPE_ONLY_ADDRESS;
        case 3:
        case "ACCESS_TYPE_EVERYBODY":
          return AccessType.ACCESS_TYPE_EVERYBODY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AccessType.UNRECOGNIZED;
      }
    }
    exports2.accessTypeFromJSON = accessTypeFromJSON;
    function accessTypeToJSON(object) {
      switch (object) {
        case AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "ACCESS_TYPE_UNSPECIFIED";
        case AccessType.ACCESS_TYPE_NOBODY:
          return "ACCESS_TYPE_NOBODY";
        case AccessType.ACCESS_TYPE_ONLY_ADDRESS:
          return "ACCESS_TYPE_ONLY_ADDRESS";
        case AccessType.ACCESS_TYPE_EVERYBODY:
          return "ACCESS_TYPE_EVERYBODY";
        case AccessType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.accessTypeToJSON = accessTypeToJSON;
    var ContractCodeHistoryOperationType;
    (function(ContractCodeHistoryOperationType2) {
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"] = 0] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"] = 1] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"] = 2] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS"] = 3] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContractCodeHistoryOperationType = exports2.ContractCodeHistoryOperationType || (exports2.ContractCodeHistoryOperationType = {}));
    function contractCodeHistoryOperationTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;
        case 1:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;
        case 2:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;
        case 3:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ContractCodeHistoryOperationType.UNRECOGNIZED;
      }
    }
    exports2.contractCodeHistoryOperationTypeFromJSON = contractCodeHistoryOperationTypeFromJSON;
    function contractCodeHistoryOperationTypeToJSON(object) {
      switch (object) {
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
        case ContractCodeHistoryOperationType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.contractCodeHistoryOperationTypeToJSON = contractCodeHistoryOperationTypeToJSON;
    function createBaseAccessTypeParam() {
      return { value: 0 };
    }
    exports2.AccessTypeParam = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.value !== 0) {
          writer.uint32(8).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessTypeParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.value = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { value: isSet(object.value) ? accessTypeFromJSON(object.value) : 0 };
      },
      toJSON(message) {
        const obj = {};
        message.value !== void 0 && (obj.value = accessTypeToJSON(message.value));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseAccessTypeParam();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseAccessConfig() {
      return { permission: 0, address: "" };
    }
    exports2.AccessConfig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.permission !== 0) {
          writer.uint32(8).int32(message.permission);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.permission = reader.int32();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          permission: isSet(object.permission) ? accessTypeFromJSON(object.permission) : 0,
          address: isSet(object.address) ? String(object.address) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.permission !== void 0 && (obj.permission = accessTypeToJSON(message.permission));
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseAccessConfig();
        message.permission = (_a = object.permission) !== null && _a !== void 0 ? _a : 0;
        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseParams() {
      return { codeUploadAccess: void 0, instantiateDefaultPermission: 0 };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeUploadAccess !== void 0) {
          exports2.AccessConfig.encode(message.codeUploadAccess, writer.uint32(10).fork()).ldelim();
        }
        if (message.instantiateDefaultPermission !== 0) {
          writer.uint32(16).int32(message.instantiateDefaultPermission);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeUploadAccess = exports2.AccessConfig.decode(reader, reader.uint32());
              break;
            case 2:
              message.instantiateDefaultPermission = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeUploadAccess: isSet(object.codeUploadAccess) ? exports2.AccessConfig.fromJSON(object.codeUploadAccess) : void 0,
          instantiateDefaultPermission: isSet(object.instantiateDefaultPermission) ? accessTypeFromJSON(object.instantiateDefaultPermission) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeUploadAccess !== void 0 && (obj.codeUploadAccess = message.codeUploadAccess ? exports2.AccessConfig.toJSON(message.codeUploadAccess) : void 0);
        message.instantiateDefaultPermission !== void 0 && (obj.instantiateDefaultPermission = accessTypeToJSON(message.instantiateDefaultPermission));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseParams();
        message.codeUploadAccess = object.codeUploadAccess !== void 0 && object.codeUploadAccess !== null ? exports2.AccessConfig.fromPartial(object.codeUploadAccess) : void 0;
        message.instantiateDefaultPermission = (_a = object.instantiateDefaultPermission) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    function createBaseCodeInfo() {
      return { codeHash: new Uint8Array(), creator: "", instantiateConfig: void 0 };
    }
    exports2.CodeInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeHash.length !== 0) {
          writer.uint32(10).bytes(message.codeHash);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.instantiateConfig !== void 0) {
          exports2.AccessConfig.encode(message.instantiateConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeHash = reader.bytes();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 5:
              message.instantiateConfig = exports2.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeHash: isSet(object.codeHash) ? bytesFromBase64(object.codeHash) : new Uint8Array(),
          creator: isSet(object.creator) ? String(object.creator) : "",
          instantiateConfig: isSet(object.instantiateConfig) ? exports2.AccessConfig.fromJSON(object.instantiateConfig) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeHash !== void 0 && (obj.codeHash = base64FromBytes(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
        message.creator !== void 0 && (obj.creator = message.creator);
        message.instantiateConfig !== void 0 && (obj.instantiateConfig = message.instantiateConfig ? exports2.AccessConfig.toJSON(message.instantiateConfig) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCodeInfo();
        message.codeHash = (_a = object.codeHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.creator = (_b = object.creator) !== null && _b !== void 0 ? _b : "";
        message.instantiateConfig = object.instantiateConfig !== void 0 && object.instantiateConfig !== null ? exports2.AccessConfig.fromPartial(object.instantiateConfig) : void 0;
        return message;
      }
    };
    function createBaseContractInfo() {
      return {
        codeId: long_1.default.UZERO,
        creator: "",
        admin: "",
        label: "",
        created: void 0,
        ibcPortId: "",
        extension: void 0
      };
    }
    exports2.ContractInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.created !== void 0) {
          exports2.AbsoluteTxPosition.encode(message.created, writer.uint32(42).fork()).ldelim();
        }
        if (message.ibcPortId !== "") {
          writer.uint32(50).string(message.ibcPortId);
        }
        if (message.extension !== void 0) {
          any_1.Any.encode(message.extension, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.created = exports2.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 6:
              message.ibcPortId = reader.string();
              break;
            case 7:
              message.extension = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO,
          creator: isSet(object.creator) ? String(object.creator) : "",
          admin: isSet(object.admin) ? String(object.admin) : "",
          label: isSet(object.label) ? String(object.label) : "",
          created: isSet(object.created) ? exports2.AbsoluteTxPosition.fromJSON(object.created) : void 0,
          ibcPortId: isSet(object.ibcPortId) ? String(object.ibcPortId) : "",
          extension: isSet(object.extension) ? any_1.Any.fromJSON(object.extension) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.label !== void 0 && (obj.label = message.label);
        message.created !== void 0 && (obj.created = message.created ? exports2.AbsoluteTxPosition.toJSON(message.created) : void 0);
        message.ibcPortId !== void 0 && (obj.ibcPortId = message.ibcPortId);
        message.extension !== void 0 && (obj.extension = message.extension ? any_1.Any.toJSON(message.extension) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseContractInfo();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.admin = (_b = object.admin) !== null && _b !== void 0 ? _b : "";
        message.label = (_c = object.label) !== null && _c !== void 0 ? _c : "";
        message.created = object.created !== void 0 && object.created !== null ? exports2.AbsoluteTxPosition.fromPartial(object.created) : void 0;
        message.ibcPortId = (_d = object.ibcPortId) !== null && _d !== void 0 ? _d : "";
        message.extension = object.extension !== void 0 && object.extension !== null ? any_1.Any.fromPartial(object.extension) : void 0;
        return message;
      }
    };
    function createBaseContractCodeHistoryEntry() {
      return { operation: 0, codeId: long_1.default.UZERO, updated: void 0, msg: new Uint8Array() };
    }
    exports2.ContractCodeHistoryEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operation !== 0) {
          writer.uint32(8).int32(message.operation);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.updated !== void 0) {
          exports2.AbsoluteTxPosition.encode(message.updated, writer.uint32(26).fork()).ldelim();
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractCodeHistoryEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operation = reader.int32();
              break;
            case 2:
              message.codeId = reader.uint64();
              break;
            case 3:
              message.updated = exports2.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operation: isSet(object.operation) ? contractCodeHistoryOperationTypeFromJSON(object.operation) : 0,
          codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO,
          updated: isSet(object.updated) ? exports2.AbsoluteTxPosition.fromJSON(object.updated) : void 0,
          msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.operation !== void 0 && (obj.operation = contractCodeHistoryOperationTypeToJSON(message.operation));
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        message.updated !== void 0 && (obj.updated = message.updated ? exports2.AbsoluteTxPosition.toJSON(message.updated) : void 0);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseContractCodeHistoryEntry();
        message.operation = (_a = object.operation) !== null && _a !== void 0 ? _a : 0;
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        message.updated = object.updated !== void 0 && object.updated !== null ? exports2.AbsoluteTxPosition.fromPartial(object.updated) : void 0;
        message.msg = (_b = object.msg) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseAbsoluteTxPosition() {
      return { blockHeight: long_1.default.UZERO, txIndex: long_1.default.UZERO };
    }
    exports2.AbsoluteTxPosition = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.blockHeight.isZero()) {
          writer.uint32(8).uint64(message.blockHeight);
        }
        if (!message.txIndex.isZero()) {
          writer.uint32(16).uint64(message.txIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAbsoluteTxPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockHeight = reader.uint64();
              break;
            case 2:
              message.txIndex = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockHeight: isSet(object.blockHeight) ? long_1.default.fromValue(object.blockHeight) : long_1.default.UZERO,
          txIndex: isSet(object.txIndex) ? long_1.default.fromValue(object.txIndex) : long_1.default.UZERO
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockHeight !== void 0 && (obj.blockHeight = (message.blockHeight || long_1.default.UZERO).toString());
        message.txIndex !== void 0 && (obj.txIndex = (message.txIndex || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAbsoluteTxPosition();
        message.blockHeight = object.blockHeight !== void 0 && object.blockHeight !== null ? long_1.default.fromValue(object.blockHeight) : long_1.default.UZERO;
        message.txIndex = object.txIndex !== void 0 && object.txIndex !== null ? long_1.default.fromValue(object.txIndex) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseModel() {
      return { key: new Uint8Array(), value: new Uint8Array() };
    }
    exports2.Model = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),
          value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseModel();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js
var require_aminomessages12 = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cosmWasmTypes = exports2.createWasmAminoConverters = void 0;
    var encoding_1 = require_build();
    var long_1 = __importDefault(require_long());
    function createWasmAminoConverters() {
      return {
        "/cosmwasm.wasm.v1.MsgStoreCode": {
          aminoType: "wasm/MsgStoreCode",
          toAmino: ({ sender, wasmByteCode }) => ({
            sender,
            wasm_byte_code: (0, encoding_1.toBase64)(wasmByteCode)
          }),
          fromAmino: ({ sender, wasm_byte_code }) => ({
            sender,
            wasmByteCode: (0, encoding_1.fromBase64)(wasm_byte_code),
            instantiatePermission: void 0
          })
        },
        "/cosmwasm.wasm.v1.MsgInstantiateContract": {
          aminoType: "wasm/MsgInstantiateContract",
          toAmino: ({ sender, codeId, label, msg, funds, admin }) => ({
            sender,
            code_id: codeId.toString(),
            label,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds,
            admin: admin || void 0
          }),
          fromAmino: ({ sender, code_id, label, msg, funds, admin }) => ({
            sender,
            codeId: long_1.default.fromString(code_id),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds],
            admin: admin !== null && admin !== void 0 ? admin : ""
          })
        },
        "/cosmwasm.wasm.v1.MsgUpdateAdmin": {
          aminoType: "wasm/MsgUpdateAdmin",
          toAmino: ({ sender, newAdmin, contract }) => ({
            sender,
            new_admin: newAdmin,
            contract
          }),
          fromAmino: ({ sender, new_admin, contract }) => ({
            sender,
            newAdmin: new_admin,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgClearAdmin": {
          aminoType: "wasm/MsgClearAdmin",
          toAmino: ({ sender, contract }) => ({
            sender,
            contract
          }),
          fromAmino: ({ sender, contract }) => ({
            sender,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgExecuteContract": {
          aminoType: "wasm/MsgExecuteContract",
          toAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds
          }),
          fromAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds]
          })
        },
        "/cosmwasm.wasm.v1.MsgMigrateContract": {
          aminoType: "wasm/MsgMigrateContract",
          toAmino: ({ sender, contract, codeId, msg }) => ({
            sender,
            contract,
            code_id: codeId.toString(),
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg))
          }),
          fromAmino: ({ sender, contract, code_id, msg }) => ({
            sender,
            contract,
            codeId: long_1.default.fromString(code_id),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg))
          })
        }
      };
    }
    exports2.createWasmAminoConverters = createWasmAminoConverters;
    exports2.cosmWasmTypes = createWasmAminoConverters();
  }
});

// ../../node_modules/cosmjs-types/cosmwasm/wasm/v1/tx.js
var require_tx13 = __commonJS({
  "../../node_modules/cosmjs-types/cosmwasm/wasm/v1/tx.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgClearAdminResponse = exports2.MsgClearAdmin = exports2.MsgUpdateAdminResponse = exports2.MsgUpdateAdmin = exports2.MsgMigrateContractResponse = exports2.MsgMigrateContract = exports2.MsgExecuteContractResponse = exports2.MsgExecuteContract = exports2.MsgInstantiateContractResponse = exports2.MsgInstantiateContract = exports2.MsgStoreCodeResponse = exports2.MsgStoreCode = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var coin_1 = require_coin();
    var types_1 = require_types6();
    exports2.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseMsgStoreCode() {
      return { sender: "", wasmByteCode: new Uint8Array(), instantiatePermission: void 0 };
    }
    exports2.MsgStoreCode = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(18).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCode();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.wasmByteCode = reader.bytes();
              break;
            case 5:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet(object.sender) ? String(object.sender) : "",
          wasmByteCode: isSet(object.wasmByteCode) ? bytesFromBase64(object.wasmByteCode) : new Uint8Array(),
          instantiatePermission: isSet(object.instantiatePermission) ? types_1.AccessConfig.fromJSON(object.instantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgStoreCode();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.wasmByteCode = (_b = object.wasmByteCode) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? types_1.AccessConfig.fromPartial(object.instantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseMsgStoreCodeResponse() {
      return { codeId: long_1.default.UZERO };
    }
    exports2.MsgStoreCodeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreCodeResponse();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseMsgInstantiateContract() {
      return { sender: "", admin: "", codeId: long_1.default.UZERO, label: "", msg: new Uint8Array(), funds: [] };
    }
    exports2.MsgInstantiateContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet(object.sender) ? String(object.sender) : "",
          admin: isSet(object.admin) ? String(object.admin) : "",
          codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO,
          label: isSet(object.label) ? String(object.label) : "",
          msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),
          funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgInstantiateContract();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.admin = (_b = object.admin) !== null && _b !== void 0 ? _b : "";
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        message.label = (_c = object.label) !== null && _c !== void 0 ? _c : "";
        message.msg = (_d = object.msg) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.funds = ((_e = object.funds) === null || _e === void 0 ? void 0 : _e.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgInstantiateContractResponse() {
      return { address: "", data: new Uint8Array() };
    }
    exports2.MsgInstantiateContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgInstantiateContractResponse();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgExecuteContract() {
      return { sender: "", contract: "", msg: new Uint8Array(), funds: [] };
    }
    exports2.MsgExecuteContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(26).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.msg = reader.bytes();
              break;
            case 5:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet(object.sender) ? String(object.sender) : "",
          contract: isSet(object.contract) ? String(object.contract) : "",
          msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),
          funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgExecuteContract();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : "";
        message.msg = (_c = object.msg) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.funds = ((_d = object.funds) === null || _d === void 0 ? void 0 : _d.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgExecuteContractResponse() {
      return { data: new Uint8Array() };
    }
    exports2.MsgExecuteContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgExecuteContractResponse();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContract() {
      return { sender: "", contract: "", codeId: long_1.default.UZERO, msg: new Uint8Array() };
    }
    exports2.MsgMigrateContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (!message.codeId.isZero()) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet(object.sender) ? String(object.sender) : "",
          contract: isSet(object.contract) ? String(object.contract) : "",
          codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO,
          msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgMigrateContract();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : "";
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        message.msg = (_c = object.msg) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContractResponse() {
      return { data: new Uint8Array() };
    }
    exports2.MsgMigrateContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgMigrateContractResponse();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgUpdateAdmin() {
      return { sender: "", newAdmin: "", contract: "" };
    }
    exports2.MsgUpdateAdmin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.newAdmin !== "") {
          writer.uint32(18).string(message.newAdmin);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.newAdmin = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet(object.sender) ? String(object.sender) : "",
          newAdmin: isSet(object.newAdmin) ? String(object.newAdmin) : "",
          contract: isSet(object.contract) ? String(object.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgUpdateAdmin();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.newAdmin = (_b = object.newAdmin) !== null && _b !== void 0 ? _b : "";
        message.contract = (_c = object.contract) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgUpdateAdminResponse() {
      return {};
    }
    exports2.MsgUpdateAdminResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateAdminResponse();
        return message;
      }
    };
    function createBaseMsgClearAdmin() {
      return { sender: "", contract: "" };
    }
    exports2.MsgClearAdmin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet(object.sender) ? String(object.sender) : "",
          contract: isSet(object.contract) ? String(object.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgClearAdmin();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgClearAdminResponse() {
      return {};
    }
    exports2.MsgClearAdminResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgClearAdminResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.StoreCode = this.StoreCode.bind(this);
        this.InstantiateContract = this.InstantiateContract.bind(this);
        this.ExecuteContract = this.ExecuteContract.bind(this);
        this.MigrateContract = this.MigrateContract.bind(this);
        this.UpdateAdmin = this.UpdateAdmin.bind(this);
        this.ClearAdmin = this.ClearAdmin.bind(this);
      }
      StoreCode(request) {
        const data = exports2.MsgStoreCode.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "StoreCode", data);
        return promise.then((data2) => exports2.MsgStoreCodeResponse.decode(new minimal_1.default.Reader(data2)));
      }
      InstantiateContract(request) {
        const data = exports2.MsgInstantiateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract", data);
        return promise.then((data2) => exports2.MsgInstantiateContractResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ExecuteContract(request) {
        const data = exports2.MsgExecuteContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "ExecuteContract", data);
        return promise.then((data2) => exports2.MsgExecuteContractResponse.decode(new minimal_1.default.Reader(data2)));
      }
      MigrateContract(request) {
        const data = exports2.MsgMigrateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "MigrateContract", data);
        return promise.then((data2) => exports2.MsgMigrateContractResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpdateAdmin(request) {
        const data = exports2.MsgUpdateAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateAdmin", data);
        return promise.then((data2) => exports2.MsgUpdateAdminResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClearAdmin(request) {
        const data = exports2.MsgClearAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "ClearAdmin", data);
        return promise.then((data2) => exports2.MsgClearAdminResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js
var require_messages9 = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgExecuteEncodeObject = exports2.isMsgMigrateEncodeObject = exports2.isMsgClearAdminEncodeObject = exports2.isMsgUpdateAdminEncodeObject = exports2.isMsgInstantiateContractEncodeObject = exports2.isMsgStoreCodeEncodeObject = exports2.wasmTypes = void 0;
    var tx_1 = require_tx13();
    exports2.wasmTypes = [
      ["/cosmwasm.wasm.v1.MsgClearAdmin", tx_1.MsgClearAdmin],
      ["/cosmwasm.wasm.v1.MsgExecuteContract", tx_1.MsgExecuteContract],
      ["/cosmwasm.wasm.v1.MsgMigrateContract", tx_1.MsgMigrateContract],
      ["/cosmwasm.wasm.v1.MsgStoreCode", tx_1.MsgStoreCode],
      ["/cosmwasm.wasm.v1.MsgInstantiateContract", tx_1.MsgInstantiateContract],
      ["/cosmwasm.wasm.v1.MsgUpdateAdmin", tx_1.MsgUpdateAdmin]
    ];
    function isMsgStoreCodeEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgStoreCode";
    }
    exports2.isMsgStoreCodeEncodeObject = isMsgStoreCodeEncodeObject;
    function isMsgInstantiateContractEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgInstantiateContract";
    }
    exports2.isMsgInstantiateContractEncodeObject = isMsgInstantiateContractEncodeObject;
    function isMsgUpdateAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgUpdateAdmin";
    }
    exports2.isMsgUpdateAdminEncodeObject = isMsgUpdateAdminEncodeObject;
    function isMsgClearAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgClearAdmin";
    }
    exports2.isMsgClearAdminEncodeObject = isMsgClearAdminEncodeObject;
    function isMsgMigrateEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgMigrateContract";
    }
    exports2.isMsgMigrateEncodeObject = isMsgMigrateEncodeObject;
    function isMsgExecuteEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgExecuteContract";
    }
    exports2.isMsgExecuteEncodeObject = isMsgExecuteEncodeObject;
  }
});

// ../../node_modules/cosmjs-types/cosmwasm/wasm/v1/query.js
var require_query14 = __commonJS({
  "../../node_modules/cosmjs-types/cosmwasm/wasm/v1/query.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryPinnedCodesResponse = exports2.QueryPinnedCodesRequest = exports2.QueryCodesResponse = exports2.QueryCodesRequest = exports2.QueryCodeResponse = exports2.CodeInfoResponse = exports2.QueryCodeRequest = exports2.QuerySmartContractStateResponse = exports2.QuerySmartContractStateRequest = exports2.QueryRawContractStateResponse = exports2.QueryRawContractStateRequest = exports2.QueryAllContractStateResponse = exports2.QueryAllContractStateRequest = exports2.QueryContractsByCodeResponse = exports2.QueryContractsByCodeRequest = exports2.QueryContractHistoryResponse = exports2.QueryContractHistoryRequest = exports2.QueryContractInfoResponse = exports2.QueryContractInfoRequest = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal2());
    var pagination_1 = require_pagination();
    var types_1 = require_types6();
    exports2.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseQueryContractInfoRequest() {
      return { address: "" };
    }
    exports2.QueryContractInfoRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { address: isSet(object.address) ? String(object.address) : "" };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractInfoRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    function createBaseQueryContractInfoResponse() {
      return { address: "", contractInfo: void 0 };
    }
    exports2.QueryContractInfoResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.contractInfo !== void 0) {
          types_1.ContractInfo.encode(message.contractInfo, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.contractInfo = types_1.ContractInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          contractInfo: isSet(object.contractInfo) ? types_1.ContractInfo.fromJSON(object.contractInfo) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.contractInfo !== void 0 && (obj.contractInfo = message.contractInfo ? types_1.ContractInfo.toJSON(message.contractInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractInfoResponse();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.contractInfo = object.contractInfo !== void 0 && object.contractInfo !== null ? types_1.ContractInfo.fromPartial(object.contractInfo) : void 0;
        return message;
      }
    };
    function createBaseQueryContractHistoryRequest() {
      return { address: "", pagination: void 0 };
    }
    exports2.QueryContractHistoryRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractHistoryRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractHistoryRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractHistoryResponse() {
      return { entries: [], pagination: void 0 };
    }
    exports2.QueryContractHistoryResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
          types_1.ContractCodeHistoryEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractHistoryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(types_1.ContractCodeHistoryEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => types_1.ContractCodeHistoryEntry.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? types_1.ContractCodeHistoryEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractHistoryResponse();
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => types_1.ContractCodeHistoryEntry.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractsByCodeRequest() {
      return { codeId: long_1.default.UZERO, pagination: void 0 };
    }
    exports2.QueryContractsByCodeRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO,
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCodeRequest();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryContractsByCodeResponse() {
      return { contracts: [], pagination: void 0 };
    }
    exports2.QueryContractsByCodeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.contracts) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.contracts.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          contracts: Array.isArray(object === null || object === void 0 ? void 0 : object.contracts) ? object.contracts.map((e) => String(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.contracts) {
          obj.contracts = message.contracts.map((e) => e);
        } else {
          obj.contracts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryContractsByCodeResponse();
        message.contracts = ((_a = object.contracts) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllContractStateRequest() {
      return { address: "", pagination: void 0 };
    }
    exports2.QueryAllContractStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllContractStateRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryAllContractStateResponse() {
      return { models: [], pagination: void 0 };
    }
    exports2.QueryAllContractStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.models) {
          types_1.Model.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.models.push(types_1.Model.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          models: Array.isArray(object === null || object === void 0 ? void 0 : object.models) ? object.models.map((e) => types_1.Model.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.models) {
          obj.models = message.models.map((e) => e ? types_1.Model.toJSON(e) : void 0);
        } else {
          obj.models = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllContractStateResponse();
        message.models = ((_a = object.models) === null || _a === void 0 ? void 0 : _a.map((e) => types_1.Model.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryRawContractStateRequest() {
      return { address: "", queryData: new Uint8Array() };
    }
    exports2.QueryRawContractStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.queryData.length !== 0) {
          writer.uint32(18).bytes(message.queryData);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRawContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.queryData = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          queryData: isSet(object.queryData) ? bytesFromBase64(object.queryData) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.queryData !== void 0 && (obj.queryData = base64FromBytes(message.queryData !== void 0 ? message.queryData : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryRawContractStateRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.queryData = (_b = object.queryData) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseQueryRawContractStateResponse() {
      return { data: new Uint8Array() };
    }
    exports2.QueryRawContractStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRawContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryRawContractStateResponse();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseQuerySmartContractStateRequest() {
      return { address: "", queryData: new Uint8Array() };
    }
    exports2.QuerySmartContractStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.queryData.length !== 0) {
          writer.uint32(18).bytes(message.queryData);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySmartContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.queryData = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet(object.address) ? String(object.address) : "",
          queryData: isSet(object.queryData) ? bytesFromBase64(object.queryData) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.queryData !== void 0 && (obj.queryData = base64FromBytes(message.queryData !== void 0 ? message.queryData : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQuerySmartContractStateRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.queryData = (_b = object.queryData) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseQuerySmartContractStateResponse() {
      return { data: new Uint8Array() };
    }
    exports2.QuerySmartContractStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySmartContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array() };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySmartContractStateResponse();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseQueryCodeRequest() {
      return { codeId: long_1.default.UZERO };
    }
    exports2.QueryCodeRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeRequest();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        return message;
      }
    };
    function createBaseCodeInfoResponse() {
      return { codeId: long_1.default.UZERO, creator: "", dataHash: new Uint8Array(), instantiatePermission: void 0 };
    }
    exports2.CodeInfoResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.codeId.isZero()) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(26).bytes(message.dataHash);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.dataHash = reader.bytes();
              break;
            case 6:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: isSet(object.codeId) ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO,
          creator: isSet(object.creator) ? String(object.creator) : "",
          dataHash: isSet(object.dataHash) ? bytesFromBase64(object.dataHash) : new Uint8Array(),
          instantiatePermission: isSet(object.instantiatePermission) ? types_1.AccessConfig.fromJSON(object.instantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.dataHash !== void 0 && (obj.dataHash = base64FromBytes(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCodeInfoResponse();
        message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_1.default.fromValue(object.codeId) : long_1.default.UZERO;
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.dataHash = (_b = object.dataHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? types_1.AccessConfig.fromPartial(object.instantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseQueryCodeResponse() {
      return { codeInfo: void 0, data: new Uint8Array() };
    }
    exports2.QueryCodeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeInfo !== void 0) {
          exports2.CodeInfoResponse.encode(message.codeInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeInfo = exports2.CodeInfoResponse.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeInfo: isSet(object.codeInfo) ? exports2.CodeInfoResponse.fromJSON(object.codeInfo) : void 0,
          data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeInfo !== void 0 && (obj.codeInfo = message.codeInfo ? exports2.CodeInfoResponse.toJSON(message.codeInfo) : void 0);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryCodeResponse();
        message.codeInfo = object.codeInfo !== void 0 && object.codeInfo !== null ? exports2.CodeInfoResponse.fromPartial(object.codeInfo) : void 0;
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    function createBaseQueryCodesRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryCodesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodesRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryCodesResponse() {
      return { codeInfos: [], pagination: void 0 };
    }
    exports2.QueryCodesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.codeInfos) {
          exports2.CodeInfoResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeInfos.push(exports2.CodeInfoResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.codeInfos) ? object.codeInfos.map((e) => exports2.CodeInfoResponse.fromJSON(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.codeInfos) {
          obj.codeInfos = message.codeInfos.map((e) => e ? exports2.CodeInfoResponse.toJSON(e) : void 0);
        } else {
          obj.codeInfos = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryCodesResponse();
        message.codeInfos = ((_a = object.codeInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports2.CodeInfoResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryPinnedCodesRequest() {
      return { pagination: void 0 };
    }
    exports2.QueryPinnedCodesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPinnedCodesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPinnedCodesRequest();
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    function createBaseQueryPinnedCodesResponse() {
      return { codeIds: [], pagination: void 0 };
    }
    exports2.QueryPinnedCodesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.codeIds) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPinnedCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.codeIds.push(reader.uint64());
                }
              } else {
                message.codeIds.push(reader.uint64());
              }
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeIds: Array.isArray(object === null || object === void 0 ? void 0 : object.codeIds) ? object.codeIds.map((e) => long_1.default.fromValue(e)) : [],
          pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.codeIds) {
          obj.codeIds = message.codeIds.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.codeIds = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPinnedCodesResponse();
        message.codeIds = ((_a = object.codeIds) === null || _a === void 0 ? void 0 : _a.map((e) => long_1.default.fromValue(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ContractInfo = this.ContractInfo.bind(this);
        this.ContractHistory = this.ContractHistory.bind(this);
        this.ContractsByCode = this.ContractsByCode.bind(this);
        this.AllContractState = this.AllContractState.bind(this);
        this.RawContractState = this.RawContractState.bind(this);
        this.SmartContractState = this.SmartContractState.bind(this);
        this.Code = this.Code.bind(this);
        this.Codes = this.Codes.bind(this);
        this.PinnedCodes = this.PinnedCodes.bind(this);
      }
      ContractInfo(request) {
        const data = exports2.QueryContractInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractInfo", data);
        return promise.then((data2) => exports2.QueryContractInfoResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ContractHistory(request) {
        const data = exports2.QueryContractHistoryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractHistory", data);
        return promise.then((data2) => exports2.QueryContractHistoryResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ContractsByCode(request) {
        const data = exports2.QueryContractsByCodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCode", data);
        return promise.then((data2) => exports2.QueryContractsByCodeResponse.decode(new minimal_1.default.Reader(data2)));
      }
      AllContractState(request) {
        const data = exports2.QueryAllContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "AllContractState", data);
        return promise.then((data2) => exports2.QueryAllContractStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      RawContractState(request) {
        const data = exports2.QueryRawContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "RawContractState", data);
        return promise.then((data2) => exports2.QueryRawContractStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SmartContractState(request) {
        const data = exports2.QuerySmartContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "SmartContractState", data);
        return promise.then((data2) => exports2.QuerySmartContractStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Code(request) {
        const data = exports2.QueryCodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Code", data);
        return promise.then((data2) => exports2.QueryCodeResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Codes(request) {
        const data = exports2.QueryCodesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Codes", data);
        return promise.then((data2) => exports2.QueryCodesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PinnedCodes(request) {
        const data = exports2.QueryPinnedCodesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "PinnedCodes", data);
        return promise.then((data2) => exports2.QueryPinnedCodesResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined") {
        return globalThis2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw "Unable to locate global object";
    })();
    function bytesFromBase64(b64) {
      if (globalThis2.Buffer) {
        return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
      } else {
        const bin = globalThis2.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
          arr[i] = bin.charCodeAt(i);
        }
        return arr;
      }
    }
    function base64FromBytes(arr) {
      if (globalThis2.Buffer) {
        return globalThis2.Buffer.from(arr).toString("base64");
      } else {
        const bin = [];
        arr.forEach((byte) => {
          bin.push(String.fromCharCode(byte));
        });
        return globalThis2.btoa(bin.join(""));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js
var require_queries12 = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupWasmExtension = void 0;
    var encoding_1 = require_build();
    var stargate_1 = require_build12();
    var query_1 = require_query14();
    var long_1 = __importDefault(require_long());
    function setupWasmExtension(base) {
      const rpc = (0, stargate_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        wasm: {
          listCodeInfo: async (paginationKey) => {
            const request = {
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.Codes(request);
          },
          getCode: async (id) => {
            const request = { codeId: long_1.default.fromNumber(id) };
            return queryService.Code(request);
          },
          listContractsByCodeId: async (id, paginationKey) => {
            const request = {
              codeId: long_1.default.fromNumber(id),
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractsByCode(request);
          },
          getContractInfo: async (address) => {
            const request = { address };
            return queryService.ContractInfo(request);
          },
          getContractCodeHistory: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractHistory(request);
          },
          getAllContractState: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.AllContractState(request);
          },
          queryContractRaw: async (address, key) => {
            const request = { address, queryData: key };
            return queryService.RawContractState(request);
          },
          queryContractSmart: async (address, query) => {
            const request = { address, queryData: (0, encoding_1.toUtf8)(JSON.stringify(query)) };
            const { data } = await queryService.SmartContractState(request);
            let responseText;
            try {
              responseText = (0, encoding_1.fromUtf8)(data);
            } catch (error) {
              throw new Error(`Could not UTF-8 decode smart query response from contract: ${error}`);
            }
            try {
              return JSON.parse(responseText);
            } catch (error) {
              throw new Error(`Could not JSON parse smart query response from contract: ${error}`);
            }
          }
        }
      };
    }
    exports2.setupWasmExtension = setupWasmExtension;
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js
var require_modules2 = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupWasmExtension = exports2.wasmTypes = exports2.isMsgUpdateAdminEncodeObject = exports2.isMsgStoreCodeEncodeObject = exports2.isMsgMigrateEncodeObject = exports2.isMsgInstantiateContractEncodeObject = exports2.isMsgExecuteEncodeObject = exports2.isMsgClearAdminEncodeObject = exports2.createWasmAminoConverters = exports2.cosmWasmTypes = void 0;
    var aminomessages_1 = require_aminomessages12();
    Object.defineProperty(exports2, "cosmWasmTypes", { enumerable: true, get: function() {
      return aminomessages_1.cosmWasmTypes;
    } });
    Object.defineProperty(exports2, "createWasmAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createWasmAminoConverters;
    } });
    var messages_1 = require_messages9();
    Object.defineProperty(exports2, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports2, "wasmTypes", { enumerable: true, get: function() {
      return messages_1.wasmTypes;
    } });
    var queries_1 = require_queries12();
    Object.defineProperty(exports2, "setupWasmExtension", { enumerable: true, get: function() {
      return queries_1.setupWasmExtension;
    } });
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js
var require_cosmwasmclient = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CosmWasmClient = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var stargate_1 = require_build12();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build3();
    var types_1 = require_types6();
    var modules_1 = require_modules2();
    var CosmWasmClient2 = class {
      constructor(tmClient) {
        this.codesCache = /* @__PURE__ */ new Map();
        if (tmClient) {
          this.tmClient = tmClient;
          this.queryClient = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, modules_1.setupWasmExtension, stargate_1.setupTxExtension);
        }
      }
      static async connect(endpoint) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new CosmWasmClient2(tmClient);
      }
      getTmClient() {
        return this.tmClient;
      }
      forceGetTmClient() {
        if (!this.tmClient) {
          throw new Error("Tendermint client not available. You cannot use online functionality in offline mode.");
        }
        return this.tmClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetTmClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetTmClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? (0, stargate_1.accountFromAny)(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error("Account does not exist on chain. Send some tokens there before trying to query sequence.");
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetTmClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      async getTx(id) {
        var _a;
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;
      }
      async searchTx(query, filter = {}) {
        const minHeight = filter.minHeight || 0;
        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;
        if (maxHeight < minHeight)
          return [];
        function withFilters(originalQuery) {
          return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;
        }
        let txs;
        if ((0, stargate_1.isSearchByHeightQuery)(query)) {
          txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];
        } else if ((0, stargate_1.isSearchBySentFromOrToQuery)(query)) {
          const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);
          const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);
          const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));
          const sentHashes = sent.map((t) => t.hash);
          txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];
        } else if ((0, stargate_1.isSearchByTagsQuery)(query)) {
          const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(" AND "));
          txs = await this.txsQuery(rawQuery);
        } else {
          throw new Error("Unknown query type");
        }
        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);
        return filtered;
      }
      disconnect() {
        if (this.tmClient)
          this.tmClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      // NOTE: This method is tested against slow chains and timeouts in the @cosmjs/stargate package.
      // Make sure it is kept in sync!
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        var _a;
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new stargate_1.TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            rawLog: result.rawLog,
            transactionHash: txId,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new stargate_1.BroadcastTxError(broadcasted.code, (_a = broadcasted.codespace) !== null && _a !== void 0 ? _a : "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * getCodes() returns all codes and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getCodes() {
        const allCodes = [];
        let startAtKey = void 0;
        do {
          const { codeInfos, pagination } = await this.forceGetQueryClient().wasm.listCodeInfo(startAtKey);
          const loadedCodes = codeInfos || [];
          allCodes.push(...loadedCodes);
          startAtKey = pagination === null || pagination === void 0 ? void 0 : pagination.nextKey;
        } while ((startAtKey === null || startAtKey === void 0 ? void 0 : startAtKey.length) !== 0);
        return allCodes.map((entry) => {
          (0, utils_1.assert)(entry.creator && entry.codeId && entry.dataHash, "entry incomplete");
          return {
            id: entry.codeId.toNumber(),
            creator: entry.creator,
            checksum: (0, encoding_1.toHex)(entry.dataHash)
          };
        });
      }
      async getCodeDetails(codeId) {
        const cached = this.codesCache.get(codeId);
        if (cached)
          return cached;
        const { codeInfo, data } = await this.forceGetQueryClient().wasm.getCode(codeId);
        (0, utils_1.assert)(codeInfo && codeInfo.codeId && codeInfo.creator && codeInfo.dataHash && data, "codeInfo missing or incomplete");
        const codeDetails = {
          id: codeInfo.codeId.toNumber(),
          creator: codeInfo.creator,
          checksum: (0, encoding_1.toHex)(codeInfo.dataHash),
          data
        };
        this.codesCache.set(codeId, codeDetails);
        return codeDetails;
      }
      /**
       * getContracts() returns all contract instances for one code and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getContracts(codeId) {
        const allContracts = [];
        let startAtKey = void 0;
        do {
          const { contracts, pagination } = await this.forceGetQueryClient().wasm.listContractsByCodeId(codeId, startAtKey);
          const loadedContracts = contracts || [];
          allContracts.push(...loadedContracts);
          startAtKey = pagination === null || pagination === void 0 ? void 0 : pagination.nextKey;
        } while ((startAtKey === null || startAtKey === void 0 ? void 0 : startAtKey.length) !== 0 && startAtKey !== void 0);
        return allContracts;
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContract(address) {
        const { address: retrievedAddress, contractInfo } = await this.forceGetQueryClient().wasm.getContractInfo(address);
        if (!contractInfo)
          throw new Error(`No contract found at address "${address}"`);
        (0, utils_1.assert)(retrievedAddress, "address missing");
        (0, utils_1.assert)(contractInfo.codeId && contractInfo.creator && contractInfo.label, "contractInfo incomplete");
        return {
          address: retrievedAddress,
          codeId: contractInfo.codeId.toNumber(),
          creator: contractInfo.creator,
          admin: contractInfo.admin || void 0,
          label: contractInfo.label,
          ibcPortId: contractInfo.ibcPortId || void 0
        };
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContractCodeHistory(address) {
        const result = await this.forceGetQueryClient().wasm.getContractCodeHistory(address);
        if (!result)
          throw new Error(`No contract history found for address "${address}"`);
        const operations = {
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: "Init",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: "Genesis",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: "Migrate"
        };
        return (result.entries || []).map((entry) => {
          (0, utils_1.assert)(entry.operation && entry.codeId && entry.msg);
          return {
            operation: operations[entry.operation],
            codeId: entry.codeId.toNumber(),
            msg: JSON.parse((0, encoding_1.fromAscii)(entry.msg))
          };
        });
      }
      /**
       * Returns the data at the key if present (raw contract dependent storage data)
       * or null if no data at this key.
       *
       * Promise is rejected when contract does not exist.
       */
      async queryContractRaw(address, key) {
        await this.getContract(address);
        const { data } = await this.forceGetQueryClient().wasm.queryContractRaw(address, key);
        return data !== null && data !== void 0 ? data : null;
      }
      /**
       * Makes a smart query on the contract, returns the parsed JSON document.
       *
       * Promise is rejected when contract does not exist.
       * Promise is rejected for invalid query format.
       * Promise is rejected for invalid response format.
       */
      async queryContractSmart(address, queryMsg) {
        try {
          return await this.forceGetQueryClient().wasm.queryContractSmart(address, queryMsg);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.startsWith("not found: contract")) {
              throw new Error(`No contract found at address "${address}"`);
            } else {
              throw error;
            }
          } else {
            throw error;
          }
        }
      }
      async txsQuery(query) {
        const results = await this.forceGetTmClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          return {
            height: tx.height,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            rawLog: tx.result.log || "",
            tx: tx.tx,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports2.CosmWasmClient = CosmWasmClient2;
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js
var require_encoding2 = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBinary = exports2.toBinary = void 0;
    var encoding_1 = require_build();
    function toBinary(obj) {
      return (0, encoding_1.toBase64)((0, encoding_1.toUtf8)(JSON.stringify(obj)));
    }
    exports2.toBinary = toBinary;
    function fromBinary(base64) {
      return JSON.parse((0, encoding_1.fromUtf8)((0, encoding_1.fromBase64)(base64)));
    }
    exports2.fromBinary = fromBinary;
  }
});

// ../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/pako/lib/zlib/trees.js"(exports2, module2) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module2.exports._tr_init = _tr_init;
    module2.exports._tr_stored_block = _tr_stored_block;
    module2.exports._tr_flush_block = _tr_flush_block;
    module2.exports._tr_tally = _tr_tally;
    module2.exports._tr_align = _tr_align;
  }
});

// ../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module2.exports = adler32;
  }
});

// ../../node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module2.exports = crc32;
  }
});

// ../../node_modules/pako/lib/zlib/messages.js
var require_messages10 = __commonJS({
  "../../node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/pako/lib/zlib/deflate.js"(exports2, module2) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages10();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants2();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module2.exports.deflateInit = deflateInit;
    module2.exports.deflateInit2 = deflateInit2;
    module2.exports.deflateReset = deflateReset;
    module2.exports.deflateResetKeep = deflateResetKeep;
    module2.exports.deflateSetHeader = deflateSetHeader;
    module2.exports.deflate = deflate;
    module2.exports.deflateEnd = deflateEnd;
    module2.exports.deflateSetDictionary = deflateSetDictionary;
    module2.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/utils/common.js
var require_common4 = __commonJS({
  "../../node_modules/pako/lib/utils/common.js"(exports2, module2) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module2.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module2.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// ../../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../node_modules/pako/lib/utils/strings.js"(exports2, module2) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module2.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module2.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module2.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// ../../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../node_modules/pako/lib/deflate.js"(exports2, module2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common4();
    var strings = require_strings();
    var msg = require_messages10();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants2();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module2.exports.Deflate = Deflate;
    module2.exports.deflate = deflate;
    module2.exports.deflateRaw = deflateRaw;
    module2.exports.gzip = gzip;
    module2.exports.constants = require_constants2();
  }
});

// ../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module2.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module2.exports = inflate_table;
  }
});

// ../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/pako/lib/zlib/inflate.js"(exports2, module2) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants2();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module2.exports.inflateReset = inflateReset;
    module2.exports.inflateReset2 = inflateReset2;
    module2.exports.inflateResetKeep = inflateResetKeep;
    module2.exports.inflateInit = inflateInit;
    module2.exports.inflateInit2 = inflateInit2;
    module2.exports.inflate = inflate;
    module2.exports.inflateEnd = inflateEnd;
    module2.exports.inflateGetHeader = inflateGetHeader;
    module2.exports.inflateSetDictionary = inflateSetDictionary;
    module2.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// ../../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../node_modules/pako/lib/inflate.js"(exports2, module2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common4();
    var strings = require_strings();
    var msg = require_messages10();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants2();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module2.exports.Inflate = Inflate;
    module2.exports.inflate = inflate;
    module2.exports.inflateRaw = inflateRaw;
    module2.exports.ungzip = inflate;
    module2.exports.constants = require_constants2();
  }
});

// ../../node_modules/pako/index.js
var require_pako = __commonJS({
  "../../node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants2();
    module2.exports.Deflate = Deflate;
    module2.exports.deflate = deflate;
    module2.exports.deflateRaw = deflateRaw;
    module2.exports.gzip = gzip;
    module2.exports.Inflate = Inflate;
    module2.exports.inflate = inflate;
    module2.exports.inflateRaw = inflateRaw;
    module2.exports.ungzip = ungzip;
    module2.exports.constants = constants;
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js
var require_signingcosmwasmclient = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SigningCosmWasmClient = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var stargate_1 = require_build12();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build3();
    var tx_1 = require_tx4();
    var tx_2 = require_tx11();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx13();
    var long_1 = __importDefault(require_long());
    var pako_1 = __importDefault(require_pako());
    var cosmwasmclient_1 = require_cosmwasmclient();
    var modules_1 = require_modules2();
    function createDeliverTxResponseErrorMessage(result) {
      return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
    }
    function createDefaultRegistry() {
      return new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes, ...modules_1.wasmTypes]);
    }
    var SigningCosmWasmClient = class extends cosmwasmclient_1.CosmWasmClient {
      constructor(tmClient, signer, options) {
        super(tmClient);
        const { registry = createDefaultRegistry(), aminoTypes = new stargate_1.AminoTypes({ ...(0, modules_1.createWasmAminoConverters)(), ...(0, stargate_1.createBankAminoConverters)() }) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      static async connectWithSigner(endpoint, signer, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new SigningCosmWasmClient(tmClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new SigningCosmWasmClient(void 0, signer, options);
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      /** Uploads code and returns a receipt, including the code ID */
      async upload(senderAddress, wasmCode, fee, memo = "") {
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
          value: tx_4.MsgStoreCode.fromPartial({
            sender: senderAddress,
            wasmByteCode: compressed
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
        const codeIdAttr = stargate_1.logs.findAttribute(parsedLogs, "store_code", "code_id");
        return {
          originalSize: wasmCode.length,
          originalChecksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(wasmCode)),
          compressedSize: compressed.length,
          compressedChecksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(compressed)),
          codeId: Number.parseInt(codeIdAttr.value, 10),
          logs: parsedLogs,
          height: result.height,
          transactionHash: result.transactionHash,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async instantiate(senderAddress, codeId, msg, label, fee, options = {}) {
        const instantiateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
          value: tx_4.MsgInstantiateContract.fromPartial({
            sender: senderAddress,
            codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...options.funds || []],
            admin: options.admin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], fee, options.memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
        const contractAddressAttr = stargate_1.logs.findAttribute(parsedLogs, "instantiate", "_contract_address");
        return {
          contractAddress: contractAddressAttr.value,
          logs: parsedLogs,
          height: result.height,
          transactionHash: result.transactionHash,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async updateAdmin(senderAddress, contractAddress, newAdmin, fee, memo = "") {
        const updateAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
          value: tx_4.MsgUpdateAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            newAdmin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async clearAdmin(senderAddress, contractAddress, fee, memo = "") {
        const clearAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
          value: tx_4.MsgClearAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async migrate(senderAddress, contractAddress, codeId, migrateMsg, fee, memo = "") {
        const migrateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
          value: tx_4.MsgMigrateContract.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(migrateMsg))
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async execute(senderAddress, contractAddress, msg, fee, memo = "", funds) {
        const instruction = {
          contractAddress,
          msg,
          funds
        };
        return this.executeMultiple(senderAddress, [instruction], fee, memo);
      }
      /**
       * Like `execute` but allows executing multiple messages in one transaction.
       */
      async executeMultiple(senderAddress, instructions, fee, memo = "") {
        const msgs = instructions.map((i) => ({
          typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
          value: tx_4.MsgExecuteContract.fromPartial({
            sender: senderAddress,
            contract: i.contractAddress,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(i.msg)),
            funds: [...i.funds || []]
          })
        }));
        const result = await this.signAndBroadcast(senderAddress, msgs, fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawDelegatorRewardMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({ delegatorAddress, validatorAddress })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], fee, memo);
      }
      /**
       * Creates a transaction with the given messages, fee and memo. Then signs and broadcasts the transaction.
       *
       * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
       * @param messages
       * @param fee
       * @param memo
       */
      async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : 1.3;
          usedFee = (0, stargate_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      async sign(signerAddress, messages, fee, memo, explicitSignerData) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
            memo: signed.memo
          }
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBody);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo
          }
        };
        const txBodyBytes = this.registry.encode(txBody);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports2.SigningCosmWasmClient = SigningCosmWasmClient;
  }
});

// ../../node_modules/@cosmjs/cosmwasm-stargate/build/index.js
var require_build13 = __commonJS({
  "../../node_modules/@cosmjs/cosmwasm-stargate/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SigningCosmWasmClient = exports2.setupWasmExtension = exports2.isMsgUpdateAdminEncodeObject = exports2.isMsgStoreCodeEncodeObject = exports2.isMsgMigrateEncodeObject = exports2.isMsgInstantiateContractEncodeObject = exports2.isMsgExecuteEncodeObject = exports2.isMsgClearAdminEncodeObject = exports2.createWasmAminoConverters = exports2.cosmWasmTypes = exports2.toBinary = exports2.fromBinary = exports2.CosmWasmClient = void 0;
    var cosmwasmclient_1 = require_cosmwasmclient();
    Object.defineProperty(exports2, "CosmWasmClient", { enumerable: true, get: function() {
      return cosmwasmclient_1.CosmWasmClient;
    } });
    var encoding_1 = require_encoding2();
    Object.defineProperty(exports2, "fromBinary", { enumerable: true, get: function() {
      return encoding_1.fromBinary;
    } });
    Object.defineProperty(exports2, "toBinary", { enumerable: true, get: function() {
      return encoding_1.toBinary;
    } });
    var modules_1 = require_modules2();
    Object.defineProperty(exports2, "cosmWasmTypes", { enumerable: true, get: function() {
      return modules_1.cosmWasmTypes;
    } });
    Object.defineProperty(exports2, "createWasmAminoConverters", { enumerable: true, get: function() {
      return modules_1.createWasmAminoConverters;
    } });
    Object.defineProperty(exports2, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports2, "setupWasmExtension", { enumerable: true, get: function() {
      return modules_1.setupWasmExtension;
    } });
    var signingcosmwasmclient_1 = require_signingcosmwasmclient();
    Object.defineProperty(exports2, "SigningCosmWasmClient", { enumerable: true, get: function() {
      return signingcosmwasmclient_1.SigningCosmWasmClient;
    } });
  }
});

// src/name-service.ts
var name_service_exports = {};
__export(name_service_exports, {
  INS: () => INS,
  parseINSName: () => parseINSName
});
module.exports = __toCommonJS(name_service_exports);
var import_cosmwasm_stargate = __toESM(require_build13());
var parseINSName = (name) => {
  const insRegEx = /(?<name>[a-z0-9]+)@(?<resolver>[a-z]+)\.(?<nameservice>[a-z]{2,})/;
  return name.match(insRegEx)?.groups;
};
var INS = class {
  /**
   * This class is used to resolve names and addresses.
   */
  constructor(chains, ins_registry) {
    this.chains = chains;
    this.ins_registry = ins_registry;
  }
  /**
   * Resolve a name to an address using a specific nameservice.
   *
   * @param {string} address The address to resolve a name for.
   */
  async resolveInsName(address, nameservice) {
    const registry = this.ins_registry.find(
      (item) => item.name === nameservice
    );
    if (!registry)
      throw new Error("Nameservice not found");
    const chain = this.chains.find(
      (item) => item.chain_name === registry.chainName
    );
    let client;
    for (let i = 0; i < chain.apis.rpc.length; i++) {
      try {
        client = await import_cosmwasm_stargate.CosmWasmClient.connect(chain.apis.rpc[i]?.address);
        break;
      } catch (e) {
        continue;
      }
    }
    const { contract, getNameQueryMsg, normalizeNameResponse } = registry;
    const result = await client.queryContractSmart(
      contract,
      getNameQueryMsg(address)
    );
    return normalizeNameResponse(result);
  }
  /**
   * Resolve a full INS name to an address.
   *
   * The format is [name]@[chain_prefix].[resolver], similar to an email address.
   * For example, `jake@juno.sns` would resolve the address using the Stargaze
   *
   * @param {String} name A fully compliant INS name.
   **/
  async resolveINSAddress(insName) {
    const { name, resolver, nameservice } = parseINSName(insName);
    const registry = this.ins_registry.find(
      (item) => item.name === nameservice
    );
    if (!registry)
      throw new Error("Nameservice not found");
    const chain = this.chains.find(
      (item) => item.chain_name === registry.chainName
    );
    let client;
    for (let i = 0; i < chain.apis.rpc.length; i++) {
      try {
        client = await import_cosmwasm_stargate.CosmWasmClient.connect(chain.apis.rpc[i]?.address);
        break;
      } catch (e) {
        continue;
      }
    }
    const { contract, getAddressQueryMsg, normalizeAddressResponse } = registry;
    const result = await client.queryContractSmart(
      contract,
      getAddressQueryMsg(name, resolver)
    );
    return normalizeAddressResponse(result);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  INS,
  parseINSName
});
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=name-service.js.map
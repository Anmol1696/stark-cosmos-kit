{"version":3,"sources":["../../src/extension/types.ts"],"sourcesContent":["import {\n  AminoSignResponse,\n  OfflineAminoSigner,\n  StdSignature,\n  StdSignDoc,\n} from '@cosmjs/amino';\nimport { OfflineDirectSigner, OfflineSigner } from '@cosmjs/proto-signing';\nimport { DirectSignResponse } from '@cosmjs/proto-signing';\nimport { BroadcastMode } from '@cosmos-kit/core';\nimport type { ChainInfo } from '@keplr-wallet/types';\n\nexport interface Key {\n  readonly name: string;\n  readonly algo: string;\n  readonly pubKey: Uint8Array;\n  readonly address: Uint8Array;\n  readonly bech32Address: string;\n  readonly isNanoLedger: boolean;\n}\nexport interface CompassSignOptions {\n  readonly preferNoSetFee?: boolean;\n  readonly preferNoSetMemo?: boolean;\n  readonly disableBalanceCheck?: boolean;\n}\n\nexport interface Compass {\n  disconnect(): Promise<void>;\n  enable(chainIds: string | string[]): Promise<void>;\n  suggestToken(chainId: string, contractAddress: string): Promise<void>;\n  mode: 'extension';\n  getKey(chainId: string): Promise<Key>;\n  getOfflineSigner(chainId: string): OfflineAminoSigner & OfflineDirectSigner;\n  getOfflineSignerOnlyAmino(chainId: string): OfflineAminoSigner;\n  getOfflineSignerAuto(chainId: string): Promise<OfflineSigner>;\n  signAmino(\n    chainId: string,\n    signer: string,\n    signDoc: StdSignDoc,\n    signOptions?: CompassSignOptions\n  ): Promise<AminoSignResponse>;\n  signDirect(\n    chainId: string,\n    signer: string,\n    signDoc: {\n      /** SignDoc bodyBytes */\n      bodyBytes?: Uint8Array | null;\n      /** SignDoc authInfoBytes */\n      authInfoBytes?: Uint8Array | null;\n      /** SignDoc chainId */\n      chainId?: string | null;\n      /** SignDoc accountNumber */\n      accountNumber?: Long | null;\n    },\n    signOptions?: CompassSignOptions\n  ): Promise<DirectSignResponse>;\n  signArbitrary(\n    chainId: string,\n    signer: string,\n    data: string | Uint8Array\n  ): Promise<StdSignature>;\n  getEnigmaPubKey(chainId: string): Promise<Uint8Array>;\n  getEnigmaTxEncryptionKey(\n    chainId: string,\n    nonce: Uint8Array\n  ): Promise<Uint8Array>;\n  enigmaEncrypt(\n    chainId: string,\n    contractCodeHash: string,\n    msg: object\n  ): Promise<Uint8Array>;\n  enigmaDecrypt(\n    chainId: string,\n    ciphertext: Uint8Array,\n    nonce: Uint8Array\n  ): Promise<Uint8Array>;\n  sendTx(\n    chainId: string,\n    tx: Uint8Array,\n    mode: BroadcastMode\n  ): Promise<Uint8Array>;\n  experimentalSuggestChain(chainInfo: ChainInfo): Promise<void>;\n}\n"],"mappings":";;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}